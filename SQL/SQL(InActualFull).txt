

code with mosh sql:
===================

Let's start with a quick overview of Databases, what they are and how we use them. A database is a collection of data stored in a format that can easily be accessed. In order to manage our Databases, we use a software application called Database Management System or DBMS. We connect to a DBMS and give it instructions for querying or modifying data. The DBMS will execute our instructions and send results back. 

Now, we have several database management systems out there, and these are classified into two categories. 
Relational and non-relational, also called NoSQL. In Relational Databases, we store data in tables that are linked to each other using relationships. That's why we call these databases Relational Databases. Each table stores data about a specific type of object, like customer, product, order, and so on. 
SQL is the language that we use to work with these Relational Database Management Systems. It looks like this. 

SELECT *
FROM products
WHERE category = 'food'
ORDER BY price


We use SQL to query or modify our data. In this course, you're going to learn everything about this powerful language. Now, there are many different Relational database management systems out there. Some of the most popular ones are MySQL, SQL Server by Microsoft, and Oracle. But of course, there are plenty more. Each Database management system has a different flavor of SQL, But all these implementations are very similar and are based on the standard SQL specification. So most of the SQL code that you will learn in this course will work with any Database Management system. In this course, we'll be using MySQL, which is the most popular open source Database in the world. 

Alright, Now, What about Non-relational databases? In Non-relational databases, we don't have tables or relationships. These databases are very different from Relational databases, but that's a topic for an entirely different course. What you need to know is that Non-relational Database Management Systems don't understand SQL. They have their own query language. So we use SQL to work with Relational Database Management Systems. 

Now, before we jump in and install MySQL, let me clarify something quickly. As you talk to different people, you will hear two different pronunciations of SQL, SQL or Sequel. What is the correct way? Well, it depends on who you ask. And of course, everybody thinks their way of pronouncing this word is the right way. But here's a little history about this language. 
SQL was originally developed at IBM in the 70s, and back then it was initially called SeQuEL, short for Structured English Query Language. But they changed the acronym to SQL because Sequel was the trademark of an airplane company. So to this date, there's been an argument about what is the right way to pronounce this language. Generally speaking, people in non-English speaking countries call it SQL. I'm used to calling it SQL because it's shorter and sweeter than SQL. But if you prefer to call it SQL, that's totally fine with me. I'm not going to get mad at you. So that's the history behind this language. But what about MySQL as a software product? Developers of this product prefer to call it MySQL rather than MySQL, but they don't mind if we call it MySQL. 
In this course, I'll be teaching you SQL with MySQL.
 
 
 
 
What is SQL:
------------

🚀 Introduction to Databases:
A database is a structured collection of data that allows for easy access, management, and modification. To interact with databases, we use Database Management Systems (DBMS), which handle storing, retrieving, updating, and deleting data efficiently.




📌 Types of Database Management Systems:
1. Relational Databases (SQL-Based)
✔ Data is stored in tables that are linked using relationships. 
✔ Each table represents a specific entity (e.g., customers, orders, products). 
✔ SQL (Structured Query Language) is used to query and modify data. 
✔ Examples of Relational Database Management Systems (RDBMS):
MySQL (Open-source, widely used)
Microsoft SQL Server
PostgreSQL
Oracle Database
SQLite

📌 Example SQL Query to Retrieve Data:
sql
SELECT * 
FROM products 
WHERE category = 'food' 
ORDER BY price;

🚀 Effect: ✔ Retrieves all food products, ordered by price.




2. Non-Relational Databases (NoSQL)
✔ Data is stored in flexible formats such as key-value pairs, documents, graphs, or columns. 
✔ Does not use SQL—each system has its own query language. 
✔ Ideal for handling large, unstructured, or rapidly changing data. 
✔ Examples of NoSQL Databases:
MongoDB (Document-based)
Redis (Key-value store)
Cassandra (Column-based)
Neo4j (Graph-based)

🚀 Effect: ✔ NoSQL databases offer flexibility, making them suitable for big data, real-time analytics, and large-scale applications.




📌 Understanding SQL vs NoSQL
Feature	SQL         (Relational)	                     NoSQL (Non-Relational)
Data Structure	    Tables (rows & columns)	             Flexible (JSON, key-value, graphs)
Relationships	    Uses Foreign Keys	                 No predefined relationships
Scalability	        Vertical (powerful server)	         Horizontal (distributed servers)
Query Language	    SQL	                                 NoSQL-specific syntax
Examples	        MySQL, PostgreSQL, SQL Server	     MongoDB, Redis, Cassandra

🚀 Effect: ✔ SQL is structured, best for transactions; NoSQL is flexible, ideal for handling large-scale dynamic data.





📌 History & Pronunciation of SQL
✔ Originally called "SeQuEL" (Structured English Query Language). 
✔ The name was changed to SQL after legal issues with an airplane company. 
✔ Pronounced both "SQL" and "Sequel"—preferences vary globally.

🚀 Effect: ✔ Both pronunciations are widely accepted, though MySQL developers prefer "MySQL" over "MySequel."




📌 Why MySQL?
✔ MySQL is the most popular open-source database. 
✔ Used by Facebook, Twitter, YouTube, and countless websites. 
✔ Lightweight, fast, and reliable for handling structured data.

🚀 Effect: ✔ In this course, we'll use MySQL to learn SQL and database management.




📌 Visual Representation of Database Structure
Relational Database Example (SQL)

┌──────────┬───────────┬───────────────┐
│ Customer │ Product   │ Order         │
├──────────┼───────────┼───────────────┤
│ ID       │ ID        │ ID            │
│ Name     │ Name      │ Customer_ID   │
│ Email    │ Category  │ Product_ID    │
│ Phone    │ Price     │ Quantity      │
└──────────┴───────────┴───────────────┘
🚀 Effect: ✔ Each table stores specific information, linked together using Foreign Keys.




📌 Summary
✔ Databases store and manage structured/unstructured data. 
✔ RDBMS (SQL) uses tables & relationships; NoSQL offers flexible storage formats. 
✔ SQL is widely used; NoSQL is best for scalability & flexibility. 
✔ MySQL is the most popular open-source RDBMS, ideal for learning SQL. 
✔ Both "SQL" and "Sequel" are acceptable pronunciations. 














🚀 Installing MySQL on Mac & Windows:
-------------------------------------
This guide provides step-by-step instructions for installing MySQL on both Mac and Windows, setting up MySQL Workbench, and creating a connection to the MySQL database server.

📌 Installing MySQL on Mac
1. Download MySQL
✔ Open your browser and go to MySQL Downloads. 
✔ Scroll down and click on MySQL Community Edition (free version). 
✔ Click MySQL Community Server → Select MacOS DMG Archive. 
✔ Click on "No thanks, just start my download" to download the file.



2. Install MySQL
✔ Open the downloaded .dmg file. 
✔ Double-click the package and follow the installation wizard:
Accept the license agreement.
Enter your Mac password (system login password).
Set a password for the MySQL root user. ✔ Click Finish, and MySQL is now installed.



3. Install MySQL Workbench
✔ Go to MySQL Community Edition → Find MySQL Workbench. 
✔ Download the MacOS DMG Archive version. 
✔ Open the .dmg file and drag MySQL Workbench into Applications.

🚀 Effect: ✔ You now have MySQL and MySQL Workbench installed!




📌 Setting Up MySQL Workbench on Mac:
1. Open MySQL Workbench
✔ Press Command + Space → Search MySQL Workbench → Open it. 
✔ If prompted, click "Open" to confirm security settings.



2. Create a Connection
✔ If a default connection is available, use it. 
✔ Otherwise, click on the + (plus) icon to create a new connection.

✔ Fill in the following details:
Connection Name: Local Instance
Method: TCP/IP
Host: 127.0.0.1 (Local Machine)
Port: 3306 (Default MySQL Port)
Username: root

✔ Click "Store in Keychain" → Enter the root password set during installation. 
✔ Click Test Connection → Should show "Successful Connection".

🚀 Effect: ✔ MySQL Workbench is now connected to your database server.




📌 Installing MySQL on Windows
1. Download MySQL
✔ Open MySQL Downloads → Select MySQL Community Edition. 
✔ Click MySQL Community Server → Download MySQL Installer for Windows. 
✔ Click on "No thanks, just start my download" to download the installer.



2. Install MySQL
✔ Open the MySQL Installer file. 
✔ Select Developer Default Setup and click Next. 
✔ Follow the installation wizard and click Next:
If prompted, ignore the Python 3.7 warning (not required for MySQL). 
✔ Click Execute → Wait for installation (5-10 minutes). 
✔ Click Next until prompted to set a password for the root user. 
✔ Enter a secure password and proceed. 
✔ Click Finish, and MySQL is installed!




3. Install MySQL Workbench
✔ After installing MySQL Server, MySQL Workbench should be installed automatically. 
✔ Open MySQL Workbench → Create a new connection (similar to Mac setup):
Connection Name: Local Instance
Host: 127.0.0.1
Port: 3306
Username: root
✔ Store the root password, test the connection, and click OK.

🚀 Effect: ✔ You have now successfully installed MySQL on Windows.

📌 Exploring MySQL Workbench
✔ The navigator panel (left) lists all databases. 
✔ The query editor (middle) is where we write SQL queries. 
✔ The right panel contains snippets and SQL history.

🚀 Effect: ✔ You can now start writing SQL queries and managing databases!




📌 Summary
✔ Installed MySQL on Mac & Windows. 
✔ Set up MySQL Workbench to connect to the database server. 
✔ Created a local connection to MySQL. 
✔ Next steps: Creating databases and executing SQL queries!
















🚀 Creating Databases in MySQL Workbench:
-----------------------------------------
In this guide, we will: 
✔ Set up databases using MySQL Workbench. 
✔ Understand MySQL Workbench's interface and navigation. 
✔ Execute SQL scripts to create multiple databases. 
✔ Explore tables, views, relationships, and stored procedures.



📌 Understanding MySQL Workbench Interface
1. Interface Overview:
✔ Toolbar (Top): Buttons for writing SQL, creating databases/tables. 
✔ Navigator Panel (Left):
Administration Tab: Server management (start/stop, import/export).
Schemas Tab: Shows available databases. ✔ Query Editor (Middle): Where we write SQL queries. ✔ Context Help & Snippets Panel (Right): Provides SQL references.


2. Cleaning Up the Interface:
✔ Hide right-side snippets panel and bottom output panel for clarity.
🚀 Effect: ✔ A clean workspace for writing SQL queries efficiently.

📌 Executing the Database Setup Script
1. Download the SQL Script
✔ Locate and open create-databases.sql in MySQL Workbench.

2. Running the Script
✔ Click the yellow thunder icon to execute the SQL code. 
✔ If a single command needs execution, highlight it before clicking the thunder icon. 
✔ Verify execution in the output window.

3. Refreshing the Database View
✔ Click Refresh in the Schemas tab to see the newly created databases.
🚀 Effect: ✔ All databases are created successfully!

📌 Understanding Relational Databases
A relational database stores information in multiple related tables using Foreign Key relationships.

Example Database Structure (sql_store)
┌──────────┬──────────┬───────────────┐
│Customers │ Orders   │ Products      │
├──────────┼──────────┼───────────────┤
│ ID       │ ID       │ ID            │
│ Name     │ Customer │ Name          │
│ Phone    │ OrderDate│ Price         │
│ Address  │ Status   │ Stock         │
└──────────┴──────────┴───────────────┘
🚀 Effect: ✔ Data is stored across multiple related tables, ensuring efficient storage.




📌 Exploring Tables & Relationships:
1. Viewing Customer Data
✔ Open sql_store > Customers and click table lightning icon to see records. 
✔ Example Customer Data:
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ Name      │ Phone Number  │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John Doe  │ 123-456-7890  │ New York  │
│ 2          │ Alice     │ 987-654-3210  │ London    │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Each row represents a customer, storing all relevant details.


2. Understanding Foreign Key Relationships
✔ Open Orders table—notice CustomerID as a Foreign Key:

┌─────────┬───────────┬──────────────┐
│ OrderID │ CustomerID│ Order Date   │
├─────────┼───────────┼──────────────┤
│ 101     │ 1         │ 2025-04-01   │
│ 102     │ 2         │ 2025-04-05   │
└─────────┴───────────┴──────────────┘
🚀 Effect: ✔ Orders are linked to customers using Foreign Keys, ensuring data integrity.




📌 Benefits of Relational Databases:
✔ Avoids redundant data (Customer details stored once, referenced in Orders). 
✔ Prevents inconsistencies (Updating customer details in one place). 
✔ Efficient queries (Retrieve customer orders efficiently using JOIN).

🚀 Effect: ✔ Ensures data accuracy, consistency, and optimized storage.



📌 Summary
✔ Installed MySQL on Mac & Windows. 
✔ Set up MySQL Workbench and executed SQL scripts. 
✔ Created databases with multiple relational tables. 
✔ Explored data structure, relationships, and foreign keys. 
✔ Next steps: Running SQL queries to retrieve data efficiently!










🚀 Course Overview: What You'll Learn in SQL:
---------------------------------------------
This course is designed to teach you everything you need to know about SQL, covering essential database operations, advanced querying techniques, and performance optimization.

📌 Course Breakdown:
1. SQL Fundamentals
✔ Learn how to retrieve, insert, update, and delete data from a database. 
✔ Understand SQL syntax and structure applicable to any database management system (MySQL, PostgreSQL, SQL Server, Oracle).
🚀 Effect: ✔ These skills allow you to work with any relational database, making you a versatile SQL professional.


2. Summarizing & Reporting Data
✔ Aggregate functions for data analysis (SUM, AVG, COUNT). 
✔ Learn to write complex queries using subqueries for deeper insights. 
✔ Work with dates, numbers, and textual data using built-in SQL functions.
🚀 Effect: ✔ Master data summarization, enabling report generation and business analysis.


3. Optimizing Queries Using Views & Stored Procedures
✔ Views: Create reusable virtual tables to simplify complex queries. 
✔ Stored Procedures & Functions: Store and reuse SQL queries to increase productivity.
🚀 Effect: ✔ Avoid repetitive queries, enhancing efficiency in database operations.


4. Advanced Topics: Triggers, Events & Transactions
✔ Triggers: Automate actions based on database changes (e.g., logging updates). 
✔ Scheduled Events: Perform automated tasks at specific times. 
✔ Transactions & Concurrency: Manage database updates safely to prevent inconsistencies.
🚀 Effect: ✔ Implement real-world database automation and consistency mechanisms.


5. Database Design
✔ Learn how to design scalable databases. 
✔ Follow a systematic approach for creating optimized database structures.
🚀 Effect: ✔ Develop efficient, high-performance databases used in real-world applications.


6. Indexing for High Performance
✔ Understand how indexes work. 
✔ Learn to speed up queries when handling millions or billions of records.
🚀 Effect: ✔ Optimize database performance by reducing query execution time.


7. Securing Databases
✔ User accounts & privileges: Control access to sensitive data. 
✔ Prevent unauthorized modifications and secure database transactions.
🚀 Effect: ✔ Protect databases from misuse and ensure data integrity.


📌 Course Benefits
✔ Master SQL for job interviews and real-world projects. 
✔ Gain transferable database management skills across multiple platforms. 
✔ Build high-performance databases and optimize data processing. ✔ Ensure security and reliability in large-scale applications.

🚀 Next steps: Start learning SQL and practice each concept with hands-on exercises!











Retrieving Data From a Single Table: 
------------------------------------

The SELECT Statement: 
---------------------
🚀 Understanding the SELECT Statement in SQL:
In this tutorial, we will: 
✔ Learn how to retrieve data from a single table using SQL's SELECT statement.
✔ Understand how to filter (WHERE clause) and sort (ORDER BY clause) data. 
✔ Explore SQL syntax rules and best practices.

📌 1. Selecting a Database for Querying
Before executing SQL queries, we must select the database we want to query.

📌 Syntax:

USE sql_store;

🚀 Effect: ✔ The sql_store database is now the active database for our queries.




📌 2. Retrieving All Data From a Table:

📌 Syntax to retrieve all records from customers table:

SELECT * 
FROM customers;

🚀 Effect: ✔ Fetches all columns and rows from the customers table.

📌 Table Structure Example (customers):
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John      │ Doe           │ NY, USA   │
│ 2          │ Alice     │ Johnson       │ London, UK│
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Returns all customers stored in the database.




📌 3. Filtering Data Using the WHERE Clause

📌 Retrieve a specific customer by ID:

SELECT * 
FROM customers
WHERE customer_id = 1;

🚀 Effect: ✔ Returns only the customer whose customer_id = 1.

📌 Example Output:
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John      │ Doe           │ NY, USA   │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Filters only relevant data instead of retrieving everything.




📌 4. Sorting Data Using the ORDER BY Clause
📌 Sort customers by first name:

SELECT * 
FROM customers
ORDER BY first_name;

🚀 Effect: ✔ Customers are sorted alphabetically based on the first_name column.

📌 Example Output (Sorted by First Name):
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 3          │ Alice     │ Johnson       │ London, UK│
│ 1          │ John      │ Doe           │ NY, USA   │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ The result is ordered based on first names.


📌 Sorting in Descending Order:

SELECT * FROM customers ORDER BY first_name DESC;

🚀 Effect: ✔ Sorts results in reverse (Z-A) order.




📌 5. Commenting Out SQL Code (--):
✔ Use -- to disable a line of SQL code without deleting it.

📌 Example (Commenting Out WHERE Clause):

SELECT * 
FROM customers
-- WHERE customer_id = 1
ORDER BY first_name;

🚀 Effect: ✔ The query executes without filtering, showing all customers. ✔ Useful for temporary testing/debugging.




📌 6. Selecting Custom Values (Without a Table):
📌 Retrieving static values:

SELECT 1, 2;

🚀 Effect: ✔ Returns two columns named 1 and 2, each containing static values.

📌 Example Output:
┌───┬───┐
│ 1 │ 2 │
├───┼───┤
│ 1 │ 2 │
└───┴───┘

🚀 Effect: ✔ Used for testing query execution without fetching from a table.




📌 7. SQL Syntax Rules & Best Practices:
✔ SQL is not case-sensitive, but use uppercase for keywords (SELECT, WHERE). 
✔ Terminate statements with a semicolon (;) for clarity. 
✔ Place each clause on a new line to improve readability:

SELECT * 
FROM customers
WHERE customer_id = 1
ORDER BY first_name;

🚀 Effect: ✔ Clear and structured queries for easier debugging.




📌 8. Understanding Clause Order in SQL
✔ The order of SQL clauses must follow a strict sequence:

SELECT → FROM → WHERE → ORDER BY

🚀 Effect: ✔ Ensures queries are properly structured to avoid errors.

📌 Example of Incorrect Clause Order (Throws Syntax Error):

sql
FROM customers 
SELECT *;

🚀 Effect: ✔ This will fail because SELECT must come before FROM.





Queries used in this lesson: 
Use sql_store;

SELECT * 
FROM customers;


SELECT * 
FROM customers
WHERE customer_id = 1;

SELECT * 
FROM customers
-- WHERE customer_id = 1
ORDER BY first_name;


SELECT 1, 2
-- FROM customers
-- WHERE customer_id = 1
-- ORDER BY first_name;


SELECT * FROM customers WHERE customer_id = 1 ORDER BY first_name;




📌 Summary
✔ SELECT retrieves data from a database table. 
✔ WHERE filters records based on conditions. 
✔ ORDER BY sorts results alphabetically or numerically. 
✔ SQL queries must follow a specific order (SELECT → FROM → WHERE → ORDER BY). 
✔ Next steps: Exploring the SELECT clause in more detail.

🚀 Master these SQL basics to retrieve, filter, and sort data effectively!















The SELECT Clause: 
------------------

🚀 Understanding the SELECT Clause in SQL
The SELECT clause is one of the most fundamental parts of SQL, used for retrieving data from a table. This tutorial explores how to use it efficiently, apply arithmetic operations, use aliases, and remove duplicate values.

📌 1. Retrieving Specific Columns vs. All Columns:
✔ The simplest way to retrieve all data from a table is using an asterisk (*):

SELECT * 
FROM customers;
🚀 Effect: ✔ Returns all columns in the customers table.

📌 Retrieving Specific Columns ✔ Instead of fetching all data, we can select only the necessary columns:
SELECT first_name, last_name 
FROM customers;
🚀 Effect: ✔ Displays only the first_name and last_name columns, reducing load on the database.

📌 Changing Column Order ✔ Columns can be retrieved in any order:
SELECT last_name, first_name 
FROM customers;
🚀 Effect: ✔ The order of columns in the output matches the order of selection.




📌 2. Using Arithmetic Expressions in Queries:
✔ SQL allows performing mathematical operations directly in queries.
📌 Example: Modifying Points Based on Customer Shopping
SELECT last_name, first_name, points + 10 
FROM customers;
🚀 Effect: ✔ Adds 10 to each customer's points, useful for calculating discounts.

📌 Complex Arithmetic Expression ✔ SQL supports multiple operators (+, -, *, /, %):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100
FROM customers;

🚀 Effect: ✔ Multiplies points by 10, then adds 100 for a new discount calculation.




📌 3. Understanding Operator Precedence in SQL
✔ Just like in math, multiplication (*) and division (/) are processed before addition (+) and subtraction (-).

📌 Example Without Parentheses:
SELECT 
    last_name,
    first_name, 
    points + 10 * 100
FROM customers;

🚀 Effect: ✔ First multiplies 10 * 100, then adds the result to points. ✔ If this is not what we want, use parentheses.

📌 Example With Parentheses (Changing the Order)

SELECT 
    last_name,
    first_name, 
    (points + 10) * 100 AS discount_factor
FROM customers;

🚀 Effect: ✔ First adds 10 to points, then multiplies the result by 100.

📌 Visualization of Operator Precedence:
Without Parentheses:   points + (10 * 100)
With Parentheses:     (points + 10) * 100
🚀 Effect: ✔ Parentheses ensure clarity and correct execution of calculations.




📌 4. Using Aliases (AS) to Rename Columns
✔ Column names in SQL output are based on expressions used in queries. ✔ We can make names more readable using AS.

📌 Assigning a Custom Name (Alias):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100 AS discount_factor
FROM customers;

🚀 Effect: ✔ Renames the calculated column for better readability.

📌 Adding Spaces in Aliases (Using Quotes):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100 AS 'Discount Factor'
FROM customers;

🚀 Effect: ✔ If column names require spaces, use single or double quotes.




📌 5. Removing Duplicate Values Using DISTINCT
✔ The DISTINCT keyword removes duplicate entries from the result set.

📌 Example: Get Unique States from customers Table
SELECT DISTINCT state 
FROM customers;
🚀 Effect: ✔ Retrieves only unique states, eliminating duplicate entries.

📌 Why Use DISTINCT? ✔ Prevents redundancy when analyzing categorical data (e.g., unique cities, job titles).




📌 6. SQL Exercise: Product Price Calculation
🚀 Task: 
✔ Retrieve product names and prices. 
✔ Apply a 10% price increase. 
✔ Use an alias (new_price) for better clarity.

📌 Expected Query Solution:
SELECT name, unit_price, unit_price * 1.1 AS new_price 
FROM products;
🚀 Effect: ✔ The result includes:

┌───────────┬───────────┬───────────┐
│ Name      │ UnitPrice │ NewPrice  │
├───────────┼───────────┼───────────┤
│ Lettuce   │ 3.35      │ 3.69      │
│ Broccoli  │ 4.53      │ 4.98      │
└───────────┴───────────┴───────────┘
✔ New price is calculated using unit_price * 1.1.






Queries used in this lesson: 

SELECT first_name, last_name 
FROM customers;


SELECT last_name, first_name 
FROM customers;

SELECT last_name, first_name, points 
FROM customers;

SELECT last_name, first_name, points + 10 
FROM customers;

SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100
FROM customers;

SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100 AS discount_factor
FROM customers;


SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100 AS 'discount factor'
FROM customers;


SELECT DISTINCT state
FROM customers;


Exercise: 
-- Return all the products
-- name
-- unit price
-- new price (unit price * 1.1)


SELECT name, unit_price, unit_price * 1.1 AS new_price FROM products;



📌 Summary
✔ SELECT retrieves specific columns or all columns (*). 
✔ Arithmetic expressions allow calculations within queries. 
✔ Operator precedence determines the order of execution—use parentheses for clarity. 
✔ Aliases (AS) rename columns, improving readability. 
✔ DISTINCT removes duplicate values from results. 
✔ SQL syntax must follow structured ordering (SELECT → FROM → WHERE → ORDER BY).










The WHERE Clause: 
-----------------
🚀 Understanding the WHERE Clause in SQL:
The WHERE clause in SQL allows us to filter data based on conditions, ensuring we retrieve only relevant records. This tutorial covers comparison operators, filtering string, numeric, and date values, and an exercise to solidify understanding.

📌 1. Using the WHERE Clause to Filter Data:
Retrieve Customers With Points Greater Than 3000

SELECT * 
FROM Customers
WHERE points > 3000;

🚀 Effect: ✔ Filters records, returning only customers who have more than 3000 points.

📌 Example Output:
┌────────────┬───────────┬───────────┬─────────────┐
│ CustomerID │ Name      │ State     │ Points      │
├────────────┼───────────┼───────────┼─────────────┤
│ 5          │ Clemmie   │ TX        │ 3675        │
│ 6          │ Elka      │ IL        │ 3073        │
└────────────┴───────────┴───────────┴─────────────┘
✔ The query execution engine checks each customer, evaluates the condition, and returns matching records.




📌 2. Understanding Comparison Operators:
SQL provides several comparison operators for filtering data:

>, >=, <, <=, =, !=, <>

📌 Examples Using Comparison Operators 
✔ Retrieve customers born after January 1st, 1990:

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01';

✔ Retrieve customers from Virginia (VA):

SELECT * 
FROM Customers
WHERE state = 'VA';

✔ Retrieve customers NOT from Virginia (VA):

SELECT * 
FROM Customers
WHERE state != 'VA';

✔ Alternative syntax for NOT EQUAL (<>):

SELECT * 
FROM Customers
WHERE state <> 'VA';

🚀 Effect: ✔ All comparison operators work with numbers, text, and dates.




📌 3. Working With String Filtering
✔ Strings in SQL must be enclosed in quotes ('single' or "double"). 
✔ SQL is not case-sensitive, so both queries below return the same result:

SELECT * 
FROM Customers
WHERE state = 'VA';

SELECT * 
FROM Customers
WHERE state = 'va';

🚀 Effect: ✔ Retrieves all customers located in Virginia, regardless of uppercase/lowercase.




📌 4. Filtering Data Using Date Values
✔ SQL stores dates in the format YYYY-MM-DD. ✔ We can compare dates using comparison operators.

📌 Example Query: Customers Born After 1990:

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01';

🚀 Effect: ✔ Retrieves only customers born after January 1, 1990.

📌 Example Output
┌────────────┬───────────┬───────────┬─────────────┐
│ CustomerID │ Name      │ BirthDate │ Points      │
├────────────┼───────────┼───────────┼─────────────┤
│ 6          │ Elka      │ 1991-09-04│ 3073        │
│ 8          │ Thacher   │ 1993-07-17│ 205         │
│ 9          │ Romola    │ 1992-05-23│ 1486        │
└────────────┴───────────┴───────────┴─────────────┘
✔ Even though dates are not strings, we must enclose them in quotes ('YYYY-MM-DD') in SQL queries.




📌 5. Exercise: Retrieving Orders Placed in the Current Year
🚀 Task: ✔ Retrieve all orders placed in 2019 using the order_date column.

📌 Expected Query Solution:
SELECT * 
FROM orders
WHERE order_date >= '2019-01-01';
🚀 Effect: ✔ Returns all orders placed on or after January 1st, 2019.

📌 Example Output:
┌─────────┬───────────┬───────────────┬───────────┐
│ OrderID │ CustomerID│ OrderDate     │ Status    │
├─────────┼───────────┼───────────────┼───────────┤
│ 1       │ 6         │ 2019-01-30    │ Processed │
└─────────┴───────────┴───────────────┴───────────┘
✔ Currently, only one order matches the filter.

📌 Future Consideration 
✔ Since we manually set 2019, next year the query won't be accurate. 
✔ Later in the course, we will explore dynamic queries to get the current year automatically.





Queries used in this lesson: 

SELECT *
FROM Customers
WHERE points > 3000;


>, >=, <, <=, =, !=, <>


SELECT *
FROM Customers
WHERE state = 'VA';

SELECT *
FROM Customers
WHERE state = 'va';

SELECT *
FROM Customers
WHERE state != 'va';

SELECT *
FROM Customers
WHERE state <> 'va';

SELECT *
FROM Customers
WHERE birth_date > '1990-01-01';


Exercise:

-- Get the orders placed this year

SELECT *
FROM orders
WHERE order_date >= '2019-01-01';




📌 Summary:
✔ WHERE filters data based on conditions. 
✔ Comparison operators (>, <, >=, <=, =, !=, <>) allow precise data filtering. 
✔ Strings must be enclosed in quotes ('VA', 'New York'). 
✔ Dates follow the format YYYY-MM-DD and must be enclosed in quotes. 
✔ SQL is case-insensitive for string comparisons (VA = va). 
✔ Next steps: Learning how to combine multiple conditions using logical operators (AND, OR).











The AND, OR and NOT Operators:
------------------------------
Combining Conditions in SQL Using AND, OR, and NOT Operators:
In this tutorial, we will learn how to filter data using multiple conditions, understand operator precedence, and apply logical operators (AND, OR, NOT) in SQL queries.

📌 1. Using AND to Combine Conditions
The AND operator returns rows where all specified conditions are true.

📌 Example: Get Customers Born After 1990 & With More Than 1000 Points

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' AND points > 1000;

🚀 Effect: ✔ Retrieves only customers who satisfy both conditions.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ 1991-09-04│ 3675      │
│ 6         │ Elka      │ 1992-05-23│ 3073      │
└───────────┴───────────┴───────────┴───────────┘
✔ This query only returns customers who satisfy both conditions.




📌 2. Using OR for Flexible Filtering:
The OR operator returns rows where at least one condition is true.

📌 Example: Get Customers Born After 1990 OR With More Than 1000 Points

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000;

🚀 Effect: ✔ Expands the result set, returning customers who satisfy at least one condition.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 1986-04-13│  947      │ ❌ Older than 1990, Less than 1000 points
│ 5         │ Clemmie   │ 1991-09-04│ 3675      │ ✅ Born after 1990, More than 1000 points
│ 6         │ Elka      │ 1992-05-23│ 3073      │ ✅ Born after 1990, More than 1000 points
└───────────┴───────────┴───────────┴───────────┘
✔ Customers are retrieved if at least one condition matches.




📌 3. Combining AND & OR With Parentheses:
When combining multiple logical operators, order matters — use parentheses to control execution.

📌 Example: Customers Born After 1990 OR (Have 1000+ Points & Live in Virginia)

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' OR 
      (points > 1000 AND state = 'VA');

🚀 Effect: ✔ Customers who were born after 1990 OR who live in Virginia AND have over 1000 points.

📌 Understanding Precedence 
✔ AND is evaluated first, then OR. 
✔ Parentheses override default precedence and group conditions.


📌 Correct Precedence Order:
1. (points > 1000 AND state = 'VA') → Evaluated first
2. birth_date > '1990-01-01' → Evaluated after OR condition
🚀 Effect: ✔ Ensures logical grouping and correct evaluation.




📌 4. Using NOT to Negate Conditions:
The NOT operator reverses a condition, excluding matching rows.

📌 Example: Get Customers NOT Born After 1990 OR Who Don't Have More Than 1000 Points

SELECT * 
FROM Customers
WHERE NOT (birth_date > '1990-01-01' OR points > 1000);

🚀 Effect: ✔ Retrieves customers born before 1990 & with 1000 or fewer points.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 1986-04-13│  947      │ ❌ Born Before 1990, Less than 1000 points
│ 4         │ Ambur     │ 1974-04-14│  457      │ ❌ Born Before 1990, Less than 1000 points
│ 10        │ Levy      │ 1969-10-13│  796      │ ❌ Born Before 1990, Less than 1000 points
└───────────┴───────────┴───────────┴───────────┘
✔ All results do not match the original condition.


📌 Simplifying NOT Expressions: 
✔ Instead of using NOT, we rewrite the condition using inverse operators:

SELECT * 
FROM Customers
WHERE birth_date <= '1990-01-01' AND points <= 1000;

🚀 Effect: ✔ Cleaner, easier-to-read query with same logical meaning.





📌 5. Exercise: Filtering Order Items
🚀 Task: ✔ Retrieve order items from order #6 where the total price (quantity × unit price) is greater than 30.

📌 Expected Query Solution

SELECT * 
FROM order_items
WHERE order_id = 6 AND unit_price * quantity > 30;
🚀 Effect: ✔ Retrieves only order items where total price exceeds $30.

📌 Understanding Condition: 
✔ We calculate total price using unit_price * quantity. 
✔ The result is filtered to exclude values ≤ 30.

📌 Example Output:
┌─────────┬───────────┬───────────────┬───────────┐
│ OrderID │ ProductID │ Quantity      │ UnitPrice │
├─────────┼───────────┼───────────────┼───────────┤
│ 6       │ 1         │  4            │  8.65     │ ✅ $34.60 (Matches Condition)
└─────────┴───────────┴───────────────┴───────────┘
✔ Only one product matches the criteria.






Queries used in this lesson: 
SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' AND points > 1000;


SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000;


SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000 AND state = 'VA';


Order of precedence in Arithmetic Operations:
()
*/
+-

SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR 
	 (points > 1000 AND state = 'VA');
	 
	 
SELECT *
FROM Customers
WHERE NOT (birth_date > '1990-01-01' OR points > 1000);	 

Simplifying the NOT like this: 
SELECT *
FROM Customers
WHERE (birth_date <= '1990-01-01' AND points <= 1000);	



Exercise: 
-- From the order_items table, get the items
--  for order #6
--  where the total price is greater than 30


SELECT *
FROM order_items
WHERE order_id = 6 AND unit_price  * quantity > 30; 





📌 Summary
✔ AND ensures both conditions must be true. 
✔ OR ensures at least one condition must be true. 
✔ Operator precedence (AND before OR) affects execution—use parentheses for clarity. 
✔ NOT reverses a condition to exclude matching rows. 
✔ Next steps: Learning how to filter data using IN, BETWEEN, and LIKE conditions.











The IN Operator:
----------------
🚀 Using the IN Operator in SQL:
The IN operator allows us to simplify multiple OR conditions, making SQL queries more concise and readable.


📌 1. Understanding the Need for the IN Operator:
Using OR for Filtering Multiple Values
📌 Example: Retrieve Customers Located in Virginia, Georgia, or Florida

SELECT * 
FROM Customers
WHERE state = 'VA' OR state = 'GA' OR state = 'FL';

🚀 Effect: ✔ Checks each row individually, leading to a long and repetitive query.

📌 Incorrect Syntax Attempt (What Doesn’t Work)

SELECT * 
FROM Customers
WHERE state = 'VA' OR 'GA' OR 'FL';  -- ❌ Incorrect syntax

🚀 Why Doesn't This Work? 
✔ SQL requires explicit conditions for each comparison. 
✔ Strings cannot be combined with boolean expressions.




📌 2. Simplifying with the IN Operator
Using IN for Cleaner Filtering

SELECT * 
FROM Customers
WHERE state IN ('VA', 'GA', 'FL');

🚀 Effect: ✔ Retrieves customers from Virginia, Georgia, or Florida. ✔ Shorter and easier to understand compared to using multiple OR conditions.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ VA        │
│ 2         │ Alice     │ GA        │
│ 5         │ Clemmie   │ FL        │
└───────────┴───────────┴───────────┘
🚀 Effect: ✔ Efficient data retrieval, avoiding redundant OR conditions.




📌 3. Using NOT IN to Exclude Values
📌 Retrieve Customers NOT in Virginia, Georgia, or Florida

SELECT * 
FROM Customers
WHERE state NOT IN ('VA', 'GA', 'FL');

🚀 Effect: ✔ Retrieves customers outside of these states (e.g., Texas, Colorado).

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 3         │ Elka      │ TX        │
│ 4         │ Ambur     │ CO        │
└───────────┴───────────┴───────────┘
🚀 Effect: ✔ Filters out unwanted values efficiently.




📌 4. Exercise: Filtering Products Based on Quantity in Stock
🚀 Task: ✔ Retrieve products where quantity_in_stock is 49, 38, or 72.

📌 Expected Query Solution
SELECT * 
FROM products
WHERE quantity_in_stock IN (49, 38, 72);

🚀 Effect: ✔ Filters only products matching the specified stock quantities.

📌 Example Output:
┌───────────┬───────────┬───────────────┐
│ ProductID │ Name      │ QuantityStock │
├───────────┼───────────┼───────────────┤
│ 2         │ Bacon     │ 49            │
│ 3         │ Lettuce   │ 38            │
└───────────┴───────────┴───────────────┘
✔ Since no product has quantity_in_stock = 72, only two records match.









Queries used in this lesson: 
SELECT *
FROM Customers
WHERE state = 'VA' OR state = 'GA' OR state = 'FL';

SELECT *
FROM Customers
WHERE state = 'VA' OR 'GA' OR 'FL';

SELECT *
FROM Customers
WHERE state IN ('VA', 'GA', 'FL');

SELECT *
FROM Customers
WHERE state NOT IN ('VA', 'GA', 'FL');


Exercise: 

-- Return products with 
--     quantity in stock equal to 49, 38, 72


SELECT * 
FROM products
WHERE quantity_in_stock IN (49, 38, 72);





📌 Summary
✔ IN replaces multiple OR conditions, making queries cleaner. 
✔ NOT IN excludes specific values, filtering out unwanted data. 
✔ SQL requires explicit comparisons (OR for multiple conditions vs IN for lists). 
✔ Next steps: Learning BETWEEN for range filtering.













The BETWEEN Operator: 
---------------------

🚀 Understanding the BETWEEN Operator in SQL:
The BETWEEN operator simplifies range-based filtering, making SQL queries more efficient and readable.

📌 1. Filtering Data Using BETWEEN:
Using Comparison Operators to Retrieve Customers With Points Between 1000 and 3000

SELECT * 
FROM customers
WHERE points >= 1000 AND points <= 3000;

🚀 Effect: ✔ Retrieves customers whose points fall within the range of 1000 to 3000.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Points    │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 3         │ Freddi    │ 2967      │ CO        │
│ 6         │ Elka      │ 3073      │ IL        │
└───────────┴───────────┴───────────┴───────────┘
✔ The query execution engine evaluates each row, returning matching records.




📌 2. Simplifying Queries Using the BETWEEN Operator
✔ Instead of using multiple comparison operators (>=, <=), BETWEEN provides a cleaner syntax.

📌 Equivalent Query Using BETWEEN:

SELECT * 
FROM customers
WHERE points BETWEEN 1000 AND 3000;

🚀 Effect: ✔ The result is identical to using >= and <=, but the query is shorter and more readable.

📌 Understanding BETWEEN Behavior 

✔ BETWEEN includes boundary values, meaning:

BETWEEN 1000 AND 3000 → Equivalent to ≥ 1000 AND ≤ 3000
🚀 Effect: ✔ Both the lower (1000) and upper (3000) limits are included.





📌 3. Using BETWEEN With Date Values
✔ The BETWEEN operator works with both numbers and dates.

📌 Example: Retrieve Customers Born Between 1990 and 2000:

SELECT * 
FROM customers
WHERE birth_date BETWEEN '1990-01-01' AND '2000-01-01';

🚀 Effect: ✔ Retrieves customers born in the date range, including January 1, 1990 and January 1, 2000.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 6         │ Elka      │ 1991-09-04│ 3073      │
│ 8         │ Thacher   │ 1993-07-17│ 205       │
│ 9         │ Romola    │ 1992-05-23│ 1486      │
└───────────┴───────────┴───────────┴───────────┘
✔ Since dates are not strings, they still need to be enclosed in quotes ('YYYY-MM-DD').

📌 Breaking Down SQL Date Formatting

'YYYY-MM-DD' → Standard SQL Date Format
'1990-01-01' → January 1, 1990
'2000-01-01' → January 1, 2000

🚀 Effect: ✔ BETWEEN handles date filtering efficiently, avoiding multiple conditions.




Queries used in this lesson: 
SELECT  * 
FROM customers
WHERE points >= 1000 AND points <= 3000;

SELECT  * 
FROM customers
WHERE points BETWEEN 1000 AND 3000;


Exercise:

--Return customers born 
			between 1/1/1990 and 1/1/2000
			
			
SELECT *
FROM customers
WHERE birth_date BETWEEN '1990-01-01' AND '2000-01-01'; 




📌 Summary
✔ BETWEEN simplifies range filtering, replacing multiple comparison operators (>=, <=). 
✔ Works with both numbers and dates, ensuring clean queries. 
✔ BETWEEN is inclusive, meaning both lower and upper values are included. 
✔ SQL date format follows 'YYYY-MM-DD', ensuring consistency. 
✔ Next steps: Learning how to filter textual data using the LIKE operator.












The LIKE Operator:
------------------
🚀 Understanding the LIKE Operator in SQL:
The LIKE operator allows us to filter textual data based on patterns, enabling flexible searching in SQL queries.

📌 1. Using LIKE for Pattern Matching
Example: Retrieve Customers Whose Last Name Starts With "B":

SELECT * 
FROM customers
WHERE last_name LIKE 'b%';

🚀 Effect: ✔ Returns customers whose last name begins with "B", regardless of the number of following characters. ✔ Not case-sensitive—"B" matches both uppercase and lowercase.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ LastName  │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ Barbara   │ Banks     │ VA        │
│ 3         │ Freddi    │ Boagey    │ CO        │
│ 5         │ Clemmie   │ Betchley  │ FL        │
└───────────┴───────────┴───────────┴───────────┘
🚀 Effect: ✔ Matches all last names beginning with "B".




📌 2. Using Wildcards for Flexible Searching:
Wildcard Characters:
Wildcard	Function
%	        Matches any number of characters (including none)
_	        Matches exactly one character

📌 Example Queries: 
✔ Retrieve last names that start with "Brush":
SELECT * 
FROM customers
WHERE last_name LIKE 'brush%';

✔ Retrieve last names that contain "B" anywhere:
SELECT * 
FROM customers
WHERE last_name LIKE '%b%';

✔ Retrieve last names ending with "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '%y';
🚀 Effect: ✔ % ensures matches can be anywhere in the string.




📌 3. Using _ (Underscore) for Exact Character Matching

✔ Match last names that are exactly two characters long, ending with "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '_y';
🚀 Effect: ✔ Matches one-character last names followed by "Y" (if any exist).

✔ Match last names with exactly five characters before "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '_____y';
🚀 Effect: ✔ Retrieves last names with exactly six characters, ending with "Y".

✔ Match last names starting with "B" and having exactly four more characters before "Y":
SELECT * 
FROM customers
WHERE last_name LIKE 'b____y';
🚀 Effect: ✔ Returns specific patterns with strict character matching.




📌 4. Using LIKE With NOT for Excluding Patterns:
✔ Retrieve customers whose phone numbers DO NOT end with "9":

SELECT * 
FROM customers
WHERE phone NOT LIKE '%9';
🚀 Effect: ✔ Matches all phone numbers except those ending in "9".




📌 5. Exercise: Filtering Customers Based on Address & Phone Number
🚀 Task: 
✔ Retrieve customers whose addresses contain "Trail" or "Avenue". 
✔ Retrieve customers whose phone numbers end with "9".

📌 Expected Query Solution

SELECT * 
FROM customers
WHERE address LIKE '%trail%' OR
      address LIKE '%avenue%';
🚀 Effect: ✔ Filters addresses containing "Trail" or "Avenue", regardless of location.

📌 Example Output:                  
┌───────────┬───────────┬───────────────────────┬──────────────┐
│ CustomerID│ Name      │ Address               │ Phone        │
├───────────┼───────────┼───────────────────────┼──────────────┤
│ 2         │ Ines      │ 14187 Commercial Trail│ 804-427-9456 │
│ 9         │ Romola    │ 3520 Ohio Trail       │ 559-181-3744 │
│ 10        │ Levy      │ 68 Lawn Avenue        │ 404-246-3370 │
└───────────┴───────────┴───────────────────────┴──────────────┘
🚀 Effect: ✔ Matches all relevant addresses.

📌 Query to Retrieve Phone Numbers Ending With "9"

SELECT * 
FROM customers
WHERE phone LIKE '%9';
🚀 Effect: ✔ Filters customers whose phone numbers end with "9".






Queries used in this discussion:
SELECT * 
FROM customers
WHERE last_name LIKE 'b%';

SELECT * 
FROM customers
WHERE last_name LIKE 'brush%';

SELECT * 
FROM customers
WHERE last_name LIKE '%b%';

SELECT * 
FROM customers
WHERE last_name LIKE '%y';

SELECT * 
FROM customers
WHERE last_name LIKE '_y';

SELECT * 
FROM customers
WHERE last_name LIKE '_____y';

SELECT * 
FROM customers
WHERE last_name LIKE 'b____y';


Exercise: 
-- Get the customers whose 
-- 	  addresses contain TRAIL or AVENUE
--    phone numbers end with 9

Solution: 
SELECT * 
FROM customers
WHERE address LIKE '%trail%' OR
	  address LIKE '%avenue%';
	  

SELECT * 
FROM customers
WHERE phone LIKE '%9';

SELECT * 
FROM customers
WHERE phone NOT LIKE '%9';
	  




📌 Summary
✔ LIKE filters string patterns using % and _. 
✔ % matches any number of characters, while _ matches exactly one character. 
✔ NOT LIKE excludes specific patterns from results. 
✔ SQL is case-insensitive, making searches flexible. 
✔ Next steps: Learning how to filter data efficiently using REGEXP for advanced text matching.
















The REGEXP Operator: 
--------------------

🚀 Using the REGEXP Operator in SQL:
The REGEXP operator allows for advanced text pattern matching in SQL, making searches more flexible and powerful than the LIKE operator.

📌 1. Understanding Basic REGEXP Usage:
Using LIKE vs. REGEXP
📌 Using LIKE to Find Customers With "Field" in Last Name

SELECT * 
FROM customers
WHERE last_name LIKE '%field%';

📌 Using REGEXP for the Same Query

SELECT * 
FROM customers
WHERE last_name REGEXP 'field';

🚀 Effect: ✔ The results are identical, but REGEXP allows more advanced pattern matching.




📌 2. Special Characters in REGEXP
Caret (^): Matches the Beginning of a String
✔ Find customers whose last name starts with "Field":

SELECT * 
FROM customers
WHERE last_name REGEXP '^field';

🚀 Effect: ✔ Retrieves records only where "Field" appears at the beginning.

Dollar Sign ($): Matches the End of a String
✔ Find customers whose last name ends with "Field":

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$';
🚀 Effect: ✔ Matches records where "Field" appears at the end.

Pipe (|): OR Condition for Multiple Patterns
✔ Find customers whose last name contains "Field", "Mac", or "Rose":

SELECT * 
FROM customers
WHERE last_name REGEXP 'field|mac|rose';
🚀 Effect: ✔ Retrieves records matching any of the given patterns.

Combining Special Characters
✔ Find customers whose last name starts with "Field" OR contains "Mac" OR "Rose":

SELECT * 
FROM customers
WHERE last_name REGEXP '^field|mac|rose';
🚀 Effect: ✔ Ensures "Field" must be at the beginning, while "Mac" or "Rose" can be anywhere.




📌 3. Using Square Brackets [ ] for Character Matching
✔ Find customers whose last name contains "E", preceded by G, I, or M:

SELECT * 
FROM customers
WHERE last_name REGEXP '[gim]e';
🚀 Effect: ✔ Ensures "E" is preceded by either "G", "I", or "M".

✔ Find customers whose last name contains "E", followed by F, M, or Q:

SELECT * 
FROM customers
WHERE last_name REGEXP 'e[fmq]';
🚀 Effect: ✔ Ensures "E" is followed by "F", "M", or "Q".




📌 4. Using Ranges in Character Matching
✔ Find customers whose last name contains "E", preceded by any letter from A to H:

SELECT * 
FROM customers
WHERE last_name REGEXP '[a-h]e';
🚀 Effect: ✔ Searches for a last name containing "E", preceded by letters A-H.




📌 5. Exercise: Using REGEXP for Advanced Searches
🚀 Task: ✔ Retrieve customers based on the following conditions: 
1.First names should be Elka or Ambur. 
2.Last names should end with "EY" or "ON". 
3.Last names should start with "MY" or contain "SE". 
4.Last names should contain "B" followed by "R" or "U".

📌 Expected Query Solutions:

SELECT * 
FROM customers
WHERE first_name REGEXP 'elka|ambur';
🚀 Effect: ✔ Matches Elka and Ambur.


SELECT * 
FROM customers
WHERE last_name REGEXP 'ey$|on$';
🚀 Effect: ✔ Retrieves last names ending with "EY" or "ON".


SELECT * 
FROM customers
WHERE last_name REGEXP '^my|se';
🚀 Effect: ✔ Retrieves last names starting with "MY" or containing "SE".


SELECT * 
FROM customers
WHERE last_name REGEXP 'b[ru]';
🚀 Effect: ✔ Ensures "B" is followed by "R" or "U".

✔ Alternative query using OR condition:


SELECT * 
FROM customers
WHERE last_name REGEXP 'br|bu';
🚀 Effect: ✔ Matches exact phrases "BR" or "BU" following "B".





Queries in this lesson: 

SELECT * 
FROM customers
WHERE last_name REGEXP 'field'

SELECT * 
FROM customers
WHERE last_name REGEXP '^field'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field|mac|rose'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$|mac|rose'

SELECT * 
FROM customers
WHERE last_name REGEXP '[gim]e'

SELECT * 
FROM customers
WHERE last_name REGEXP '[a-h]e';


Exercise: 

-- Get the customers whose
-- 	 first names are ELKA or AMBUR
--   last names end with EY or ON
--   last names start with MY or contains SE
--   last names contain B followed by R or U


Solution: 

SELECT * 
FROM customers
WHERE first_name REGEXP 'elka|ambur';


SELECT * 
FROM customers
WHERE first_name REGEXP 'ey$|on$';

SELECT * 
FROM customers
WHERE first_name REGEXP '^my|se';


SELECT * 
FROM customers
WHERE first_name REGEXP 'b[ru]';

SELECT * 
FROM customers
WHERE first_name REGEXP 'br|bu';



📌 Summary
✔ REGEXP allows flexible pattern matching beyond LIKE. 
✔ Special characters (^, $, |, [ ]) enhance text filtering precision. 
✔ Ranges ([a-h]) provide a powerful way to search multiple characters efficiently. 
✔ SQL regular expressions simplify complex searches, making queries concise. 
✔ Next steps: Learning how to handle NULL values and missing data in SQL queries.











The IS NULL Operator: 
---------------------
🚀 Understanding the IS NULL Operator in SQL:
The IS NULL operator is used to identify missing values in a database, allowing us to filter records where certain attributes are absent.

📌 1. Identifying NULL Values in a Table:
✔ NULL represents missing or unknown data. 
✔ If a column contains NULL, it means no value has been assigned.

📌 Example: Retrieve Customers Without a Phone Number

SELECT * 
FROM customers
WHERE phone IS NULL;

🚀 Effect: ✔ Filters customers who do not have a phone number.

📌 Example Output
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Phone     │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ NULL      │ TX        │
└───────────┴───────────┴───────────┴───────────┘
✔ Customer 5 has no phone number.

📌 Real-World Use Case ✔ If a customer has missing contact details, businesses can send an email prompting them to update their information.




📌 2. Excluding NULL Values Using IS NOT NULL
✔ The IS NOT NULL operator retrieves only rows where values exist.

📌 Example: Retrieve Customers Who Have a Phone Number

SELECT * 
FROM customers
WHERE phone IS NOT NULL;
🚀 Effect: ✔ Filters customers who have valid phone numbers.

📌 Example Output
┌───────────┬───────────┬───────────────┬────────┐
│ CustomerID│ Name      │ Phone         │ State  │
├───────────┼───────────┼───────────────┼────────┤
│ 1         │ Barbara   │ 781-932-9754  │ VA     │
│ 2         │ Ines      │ 804-427-9456  │ GA     │
│ 3         │ Freddi    │ 719-724-7869  │ CO     │
└───────────┴───────────┴───────────────┴────────┘
✔ Only customers with phone numbers are included.





📌 3. Exercise: Retrieve Orders That Are Not Shipped
🚀 Task: ✔ Retrieve orders that have not been shipped (missing shipper details).

📌 Expected Query Solution:

SELECT * 
FROM orders
WHERE shipper_id IS NULL;
🚀 Effect: ✔ Filters orders that have NOT been assigned to a shipping provider.

📌 Example Output:
┌───────────┬───────────┬────────────┬───────────┐
│ OrderID   │ CustomerID│ ShippedDate│ ShipperID │
├───────────┼───────────┼────────────┼───────────┤
│ 1         │ 6         │ NULL       │ NULL      │
│ 3         │ 8         │ NULL       │ NULL      │
│ 4         │ 2         │ NULL       │ NULL      │
│ 6         │ 10        │ NULL       │ NULL      │
│ 8         │ 5         │ NULL       │ NULL      │
└───────────┴───────────┴────────────┴───────────┘
✔ Only unshipped orders are retrieved.

📌 Alternative Query Using shipped_date Instead

SELECT * 
FROM orders
WHERE shipped_date IS NULL;
🚀 Effect: ✔ Retrieves orders without a shipping date, indicating they haven’t been processed yet.

📌 Real-World Use Case ✔ E-commerce platforms frequently use this query to track pending shipments.




Queries used in this discussion: 

SELECT * 
FROM customers
WHERE phone IS NULL;


SELECT * 
FROM customers
WHERE phone IS NOT NULL;


Exercise: 

-- Get the orders that are not shipped 

SELECT * 
FROM orders
WHERE shipper_id IS NULL;




📌 Summary
✔ NULL represents missing values in a table. 
✔ IS NULL retrieves missing values, while IS NOT NULL excludes them. 
✔ Businesses use NULL filtering to track missing customer details and pending orders. 
✔ Next steps: Learning how to handle duplicate records and optimize data integrity using DISTINCT.









The ORDER BY Clause:
--------------------

🚀 Understanding the ORDER BY Clause in SQL:
The ORDER BY clause in SQL allows us to sort query results based on one or more columns in ascending or descending order.

📌 1. Default Sorting Behavior
✔ By default, MySQL orders query results based on the primary key column (typically id). 
✔ When we select all customers, they appear sorted by customer_id:

SELECT * 
FROM customers;

📌 Example Output:
┌───────────┬───────────┬───────────────┐
│ CustomerID│ Name      │ State         │
├───────────┼───────────┼───────────────┤
│ 1         │ Barbara   │ VA            │
│ 2         │ Ines      │ GA            │
│ 3         │ Freddi    │ CO            │
└───────────┴───────────┴───────────────┘
✔ The sorting is based on customer_id, as indicated by the primary key.




📌 2. Sorting Data Using ORDER BY
✔ We can change the sorting order using the ORDER BY clause.

📌 Example: Sorting Customers by First Name

SELECT * 
FROM customers 
ORDER BY first_name;
🚀 Effect: ✔ Customers are sorted alphabetically by first name in ascending order.

📌 Sorting in Descending Order ✔ To reverse the order, use DESC:

sql
SELECT * 
FROM customers 
ORDER BY first_name DESC;
🚀 Effect: ✔ Customers are sorted in reverse alphabetical order (Z-A).




📌 3. Sorting By Multiple Columns
✔ We can sort by multiple attributes, ensuring nested ordering.

📌 Example: First Sort By State, Then By First Name

SELECT * 
FROM customers 
ORDER BY state, first_name;
🚀 Effect: ✔ Customers are sorted alphabetically by state, and then by first name within each state.

📌 Mixing ASC & DESC for Multi-Level Sorting ✔ First sort by state in descending order, then by first name in ascending order:

SELECT * 
FROM customers 
ORDER BY state DESC, first_name ASC;
🚀 Effect: ✔ Data appears in reverse alphabetical order by state, but names remain in ascending order within each state.




📌 4. Ordering Data by Non-Selected Columns
✔ Unlike some database systems, MySQL allows sorting by columns not included in the SELECT clause.

📌 Example: Selecting Only Names, But Sorting By Birth Date

SELECT first_name, last_name 
FROM customers 
ORDER BY birth_date;

🚀 Effect: ✔ Only first_name and last_name are shown, but data is sorted by birth_date.




📌 5. Sorting Using Aliases
✔ We can sort by expressions or aliases.

📌 Example: Sorting By an Alias (points)

SELECT first_name, last_name, 10 AS points 
FROM customers 
ORDER BY points, first_name;

🚀 Effect: ✔ Even though points is not a real column, MySQL still allows sorting by its alias.




📌 6. Avoiding Sorting By Column Positions
✔ Some tutorials suggest sorting by column positions (ORDER BY 1, 2), but this is unreliable.

📌 Example: Sorting By Column Positions (Avoid This)

SELECT first_name, last_name, 10 AS points 
FROM customers 
ORDER BY 1, 2;

🚀 Why Avoid This? 
✔ If a new column is added before first_name, sorting behavior changes unexpectedly. 
✔ Always sort by column names instead.




📌 7. Exercise: Sorting Order Items By Total Price
🚀 Task: ✔ Retrieve items for order #2, sorted by total price (quantity × unit_price) in descending order.

📌 Expected Query Solution

SELECT *, quantity * unit_price AS total_price 
FROM order_items 
WHERE order_id = 2 
ORDER BY total_price DESC;

🚀 Effect: ✔ Sorts items in order #2 by their total price, highest first.

📌 Example Output
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ TotalPrice│
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ 1         │  2        │ 18.20     │ ✅ Highest Total Price
│ 2         │ 4         │  4        │  6.64     │
│ 2         │ 6         │  2        │  5.88     │ ✅ Lowest Total Price
└───────────┴───────────┴───────────┴───────────┘
✔ Orders are correctly sorted by total price.


📌 Alternative Query Using Alias for Sorting

SELECT *, quantity * unit_price AS total_price 
FROM order_items 
WHERE order_id = 2 
ORDER BY total_price DESC;

🚀 Effect: ✔ Avoids redundancy by using total_price alias instead of recalculating.






Queries used in this discussion: 

SELECT *
FROM customers 
ORDER BY first_name; 

SELECT *
FROM customers 
ORDER BY first_name DESC; 

SELECT *
FROM customers 
ORDER BY state, first_name; 

SELECT *
FROM customers 
ORDER BY state DESC, first_name DESC; 


valid query: 
SELECT first_name, last_name
FROM customers 
ORDER BY birth_date; 


SELECT first_name, last_name, 10 AS points
FROM customers 
ORDER BY points, first_name; 


Avoid: 
SELECT first_name, last_name, 10 AS points
FROM customers 
ORDER BY 1, 2; 


Exercise: 
SELECT *, quantity * unit_price AS total_price
FROM order_items
WHERE order_id = 2
ORDER BY total_price DESC




📌 Summary
✔ ORDER BY sorts query results in ascending (ASC) or descending (DESC) order. 
✔ Sorting can be applied to multiple columns, allowing nested ordering. 
✔ MySQL allows sorting by columns not included in SELECT. 
✔ Sorting by column positions (ORDER BY 1, 2) is risky—use explicit column names. 
✔ SQL supports ordering by expressions and aliases (ORDER BY total_price). 
✔ Next steps: Learning how to limit query results using LIMIT for pagination and optimization.


















The LIMIT Clause: 
-----------------
🚀 Understanding the LIMIT Clause in SQL:
The LIMIT clause allows us to control the number of records returned in a SQL query. It is especially useful for pagination and retrieving top results.

📌 1. Limiting Query Results
By default, when we execute a query like:

SELECT * 
FROM customers;
🚀 Effect: ✔ It retrieves all records in the customers table. ✔ If the table contains 10 customers, the result will show all 10.

📌 Using LIMIT to Return Only the First 3 Customers:

SELECT * 
FROM customers
LIMIT 3;
🚀 Effect: ✔ Retrieves only the first 3 rows from the table.

📌 If LIMIT Exceeds Available Records:

SELECT * 
FROM customers
LIMIT 300;
🚀 Effect: ✔ Since there are only 10 customers, this query will return all 10 records. ✔ LIMIT will never exceed available data.




📌 2. Using LIMIT With OFFSET for Pagination
✔ The LIMIT clause allows us to skip records using OFFSET, ensuring efficient pagination.

📌 Example: Displaying Customers in Pages of 3

Page 1 → Customers 1, 2, 3
Page 2 → Customers 4, 5, 6
Page 3 → Customers 7, 8, 9

📌 Retrieving Customers for Page 3

SELECT * 
FROM customers
LIMIT 6, 3;
🚀 Effect: ✔ Skips the first 6 records and retrieves the next 3 customers.

✔ Alternative Syntax Using OFFSET

SELECT * 
FROM customers
LIMIT 3 OFFSET 6;
🚀 Effect: ✔ Ensures data is retrieved efficiently, helping websites paginate content properly.




📌 3. Exercise: Retrieving the Top 3 Loyal Customers
🚀 Task: ✔ Retrieve the top 3 customers with the highest points.

📌 Expected Query Solution:

SELECT * 
FROM customers
ORDER BY points DESC
LIMIT 3;
🚀 Effect: ✔ Customers are first sorted by points in descending order (DESC). ✔ Then, only the top 3 records are retrieved.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Points    │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ 3675      │ TX        │ ✅ Highest Loyalty
│ 6         │ Elka      │ 3073      │ IL        │
│ 3         │ Freddi    │ 2967      │ CO        │ ✅ Third Highest Loyalty
└───────────┴───────────┴───────────┴───────────┘
✔ The most loyal customers appear first.

📌 Important SQL Clause Order ✔ The LIMIT clause must always come at the end of a query.

SELECT → FROM → WHERE → ORDER BY → LIMIT
✔ Changing this order causes errors.





Queries used in this discussion: 

SELECT * 
FROM customers
LIMIT 3


SELECT * 
FROM customers
LIMIT 300 -- produces all the rows 


-- page 1: 1 - 3
-- page 2: 4 - 6
-- page 3: 7 - 9

SELECT * 
FROM customers
LIMIT 6, 3

SELECT * 
FROM customers
LIMIT 6 OFFSET 3;


Exercise: 
--Get the top three loyal customers

Solution: 
SELECT * 
FROM customers
ORDER BY points DESC
LIMIT 3;



📌 Summary
✔ LIMIT controls the number of records returned. 
✔ LIMIT with OFFSET enables pagination, helping display data in pages. 
✔ Sorting must happen before limiting records, ensuring accurate results. 
✔ SQL follows strict query structure (SELECT → FROM → WHERE → ORDER BY → LIMIT). 










Retrieving Data From Multiple Tables: 
-------------------------------------


Inner Joins:
------------
🚀 Understanding INNER JOINS in SQL:
In real-world applications, data is spread across multiple tables, and JOIN operations allow us to retrieve related data efficiently. This tutorial covers INNER JOINS, their syntax, usage, and best practices.

📌 1. Why Do We Need Joins?
✔ Tables are structured to avoid redundancy and store related data separately. 
✔ For example:
The orders table stores order details, but not customer information.
The customers table stores customer details, but not order details.

📌 Example: Orders Table:
┌───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │
├───────────┼───────────┼───────────┤
│ 1         │ 3         │ 2025-05-17│
│ 2         │ 7         │ 2025-05-16│
└───────────┴───────────┴───────────┘
✔ The customer_id column links orders to customers.

📌 Example: Customers Table:
┌───────────┬───────────┬───────────┬─────────────────┐
│ CustomerID│ FirstName │ LastName  │ Email           │
├───────────┼───────────┼───────────┼─────────────────┤
│ 3         │ Alex      │ Smith     │ alex@email.com  │
│ 7         │ Maria     │ Johnson   │ maria@email.com │
└───────────┴───────────┴───────────┴─────────────────┘
✔ To retrieve an order with customer details, we join both tables.




📌 2. Using INNER JOIN to Merge Data:
✔ INNER JOIN matches records between two tables based on a common key (e.g., customer_id).

📌 Retrieve Orders Along With Customer Names:

SELECT order_id, first_name, last_name
FROM orders
JOIN customers 
ON orders.customer_id = customers.customer_id;

🚀 Effect: ✔ Merges both tables, ensuring only matching records appear.

📌 Example Output
┌───────────┬───────────┬───────────┐
│ OrderID   │ FirstName │ LastName  │
├───────────┼───────────┼───────────┤
│ 1         │ Alex      │ Smith     │
│ 2         │ Maria     │ Johnson   │
└───────────┴───────────┴───────────┘
✔ Now we see customer names instead of just IDs.




📌 3. Handling Column Name Ambiguity:
✔ If both tables contain a column with the same name (customer_id), MySQL requires explicit table prefixes.

📌 Example Query That Causes an Error:

SELECT order_id, customer_id, first_name, last_name
FROM orders
JOIN customers 
ON customer_id = customer_id;  -- ❌ Ambiguous!

🚀 Effect: ✔ This throws an error—MySQL doesn't know which customer_id to use.

📌 Correct Query Using Table Prefixes

SELECT order_id, orders.customer_id, first_name, last_name
FROM orders
JOIN customers 
ON orders.customer_id = customers.customer_id;

🚀 Effect: ✔ Explicit table names resolve ambiguity, making the query valid.




📌 4. Using Table Aliases for Simplicity
✔ To avoid repetition, use short aliases for tables.

📌 Assigning Aliases (o for orders, c for customers)

SELECT order_id, o.customer_id, first_name, last_name
FROM orders o
JOIN customers c
ON o.customer_id = c.customer_id;

🚀 Effect: ✔ Query remains clear, but avoids redundant table names.




📌 5. Exercise: Joining Order Items with Products
🚀 Task: ✔ Retrieve product details for each order item from order_items and products.

📌 Expected Query Solution:

SELECT order_id, oi.product_id, quantity, oi.unit_price
FROM order_items oi
JOIN products p 
ON oi.product_id = p.product_id;

🚀 Effect: ✔ Displays product details alongside order quantities.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 10        │  3        │  4.99     │
│ 1         │ 22        │  2        │  8.25     │
│ 2         │ 10        │  5        │  4.99     │
└───────────┴───────────┴───────────┴───────────┘
✔ The product_id is retrieved along with quantity and unit price.




📌 6. Understanding Price Data Storage:
✔ The unit_price column exists in both order_items and products tables.

📌 Why Does unit_price Exist Twice? 
✔ Products Table (products.unit_price) → Stores current price. 
✔ Order Items Table (order_items.unit_price) → Stores historical price at time of order.

🚀 Effect: ✔ Ensures accurate historical pricing, allowing proper sales calculations.






Queries in this discussion: 

SELECT *
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	

SELECT order_id, customer_id, first_name, last_name
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	
SELECT order_id, orders.customer_id, first_name, last_name
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	
SELECT order_id, o.customer_id, first_name, last_name
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;	
	
	
Exercise:

SELECT order_id, oi. product_id, quantity, oi.unit_price
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id






📌 Summary:
✔ INNER JOIN merges records from multiple tables, linking related data. 
✔ Ambiguous columns require explicit table prefixes (orders.customer_id). 
✔ Aliases (o, c) simplify queries, making them easier to read. 
✔ Product pricing is stored both historically (order_items) and currently (products). 
✔ Next steps: Learning how to use OUTER JOINS to retrieve unmatched data from related tables.










Joining Across Databases: 
-------------------------

🚀 Joining Across Databases in SQL:
In real-world applications, developers and database administrators often work with multiple databases. This tutorial demonstrates how to join tables across different databases, ensuring proper data integration.

📌 1. Why Join Tables Across Databases?
✔ Large applications may store data in separate databases for organization and security. 
✔ Sometimes, identical tables exist in multiple databases, but queries require combining them.

📌 Example Scenario: 
✔ The sql_store database contains customer orders (order_items). 
✔ The sql_inventory database contains product details (products). 
✔ We need to retrieve order items from sql_store, along with product details from sql_inventory.




📌 2. Writing Queries to Join Tables Across Databases
✔ When a table exists in another database, it must be prefixed with the database name.

📌 Joining order_items (from sql_store) With products (from sql_inventory):

SELECT * 
FROM order_items oi
JOIN sql_inventory.products p 
ON oi.product_id = p.product_id;
🚀 Effect: ✔ Joins order items from sql_store with product details from sql_inventory.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬─────────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │ ProductName │
├───────────┼───────────┼───────────┼───────────┼─────────────┤
│ 1         │ 10        │  3        │  4.99     │ Foam Plate  │
│ 2         │ 22        │  2        │  8.25     │ Bacon       │
└───────────┴───────────┴───────────┴───────────┴─────────────┘
✔ Ensures data from both databases is integrated.




📌 3. Selecting a Different Database for Querying
✔ The current database determines which tables need prefixing. ✔ The USE statement sets the active database.

📌 Changing the Active Database to sql_inventory:

USE sql_inventory;
🚀 Effect: ✔ Sets sql_inventory as the current database, affecting queries.

📌 Joining order_items (From sql_store) When sql_inventory Is Active:
SELECT * 
FROM sql_store.order_items oi
JOIN products p 
ON oi.product_id = p.product_id;
🚀 Effect: ✔ Since sql_inventory is active, only order_items needs database prefixing.




Queries in this discussion: 

SELECT *
FROM order_items oi
JOIN sql_inventory.products p
	ON oi.product_id = p.product_id;
	
	
	
USE sql_inventory;
	
SELECT *
FROM sql_store.order_items oi
JOIN products p
	ON oi.product_id = p.product_id;	



📌 Key Takeaways
✔ Tables from other databases must be prefixed with the database name (sql_inventory.products). 
✔ If the table exists in the current database, no prefix is required. 
✔ Changing the active database (USE database_name;) alters query requirements. 
✔ Next steps: Exploring different types of joins (LEFT, RIGHT, FULL OUTER) for handling unmatched records.

🚀 Use cross-database joins to retrieve data seamlessly across systems!












Self Joins:
-----------
🚀 Understanding Self Joins in SQL:
A self-join occurs when a table is joined with itself, often used to compare rows within the same table.

📌 1. Why Use Self Joins?
✔ Some tables reference themselves, such as hierarchical structures. 
✔ In the sql_hr database, employees report to other employees, making a self-referencing relationship.

📌 Example: Employees Table:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Job Title │ Salary    │ ReportsTo │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 37270     │ John      │ CEO       │ 120000    │ NULL      │
│ 33391     │ Sarah     │ Manager   │ 75000     │ 37270     │
│ 37851     │ Alex      │ Engineer  │ 65000     │ 33391     │
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ The ReportsTo column references EmployeeID within the same table.




📌 2. Performing a Self Join:
✔ To retrieve employees along with their managers, we join the employees table with itself.

📌 Joining Employees With Their Managers:

USE sql_hr;

SELECT * 
FROM employees e
JOIN employees m 
ON e.reports_to = m.employee_id;
🚀 Effect: ✔ Links each employee with their manager, forming a hierarchical structure.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Job Title │ Salary    │ ReportsTo │ Manager   │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ 33391     │ Sarah     │ Manager   │ 75000     │ 37270     │ John      │
│ 37851     │ Alex      │ Engineer  │ 65000     │ 33391     │ Sarah     │
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Each row shows an employee and their manager.




📌 3. Selecting Specific Columns for Clarity
✔ Instead of selecting all columns, we focus on employee name & manager name.

📌 Query Selecting Only Employee & Manager Names:

SELECT 
    e.employee_id,
    e.first_name,
    m.first_name AS manager
FROM employees e
JOIN employees m 
ON e.reports_to = m.employee_id;
🚀 Effect: ✔ Improves readability by focusing on essential columns.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Manager   │
├───────────┼───────────┼───────────┤
│ 33391     │ Sarah     │ John      │
│ 37851     │ Alex      │ Sarah     │
└───────────┴───────────┴───────────┘
✔ The Manager column is renamed for clarity.




Queries in this discussion:

USE sql_hr;


SELECT *
FROM employees e
JOIN employees m
 ON e.reports_to = m.employee_id;


SELECT 
	e.employee_id,
	e.first_name,
	m.first_name AS manager
FROM employees e
JOIN employees m
	ON e.reports_to = m.employee_id;  




📌 Key Takeaways:
✔ Self-joins allow referencing rows within the same table, commonly used for hierarchical structures. 
✔ Aliases (e, m) simplify the query, making it easier to read. 
✔ Explicit table prefixes are required, as all columns belong to the same table. 
✔ Next steps: Learning how to join multiple tables together for complex queries.

🚀 Use self joins to retrieve hierarchical relationships efficiently!










Joining Multiple Tables:
------------------------

🚀 Joining Multiple Tables in SQL:
In SQL, joining multiple tables allows us to combine related data from different sources into a single query result. This tutorial covers joining three tables, its practical use, and an exercise to reinforce learning.

📌 1. Understanding Multi-Table Joins
✔ The orders table contains order details but does not store customer or status names. 
✔ The customers table contains customer details. 
✔ The order_statuses table contains order status names.

📌 Example: Orders Table:
┌───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ Status    │
├───────────┼───────────┼───────────┤
│ 1         │ 6         │ 1         │
│ 2         │ 3         │ 2         │
└───────────┴───────────┴───────────┘
✔ The status column stores an order status ID, not a name.

📌 Example: Order Statuses Table:
┌───────────────┬───────────┐
│ OrderStatusID │ Name      │
├───────────────┼───────────┤
│ 1             │ Processed │
│ 2             │ Shipped   │
└───────────────┴───────────┘
✔ This table provides readable status names.





📌 2. Writing a Multi-Table Join Query
📌 Retrieving Orders With Customer Names and Status:

USE sql_store;

SELECT 
    o.order_id, 
    o.order_date,
    c.first_name, 
    c.last_name,
    os.name AS status
FROM orders o
JOIN customers c 
    ON o.customer_id = c.customer_id
JOIN order_statuses os 
    ON o.status = os.order_status_id;
🚀 Effect: ✔ Retrieves order details along with customer names and order statuses.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ FirstName │ LastName  │ Status    │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ 2025-05-17│ Alex      │ Smith     │ Processed │
│ 2         │ 2025-05-16│ Maria     │ Johnson   │ Shipped   │
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Orders now display full customer names and status names.




📌 3. How Multi-Table Joins Work
✔ SQL executes joins sequentially, first linking orders → customers, then orders → order_statuses. 
✔ Queries can join multiple tables in a single statement using additional JOIN clauses. 
✔ Aliases (o, c, os) simplify queries for better readability.

📌 Query Breakdown:
JOIN customers connects orders with customers, matching customer IDs.
JOIN order_statuses connects orders with statuses, mapping the status ID.





📌 4. Exercise: Joining Payments With Clients and Payment Methods:
🚀 Task: ✔ Retrieve payment details along with client names and payment methods.

📌 Expected Query Solution:

SELECT 
    p.date, 
    p.invoice_id,
    p.amount, 
    c.name,
    pm.name
FROM payments p
JOIN clients c 
    ON p.client_id = c.client_id
JOIN payment_methods pm 
    ON p.payment_method = pm.payment_method_id;
	
🚀 Effect: ✔ Displays detailed payment information.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────────┐
│ Date      │ InvoiceID │ Amount    │ Client    │ Method        │
├───────────┼───────────┼───────────┼───────────┼───────────────┤
│ 2025-05-01│ 112       │ 250.00    │ Vinte     │ Credit Card   │
│ 2025-04-30│ 113       │ 175.50    │ MyWorks   │ Wire Transfer │
└───────────┴───────────┴───────────┴───────────┴───────────────┘
✔ Clients and payment methods are clearly displayed.





Queries in this discussion: 

USE sql_store; 


SELECT 
	o.order_id, 
	o.order_date,
	c.first_name, 
	c.last_name,
	os.name AS status
FROM order o
JOIN customers c
	ON o.customer_id = c.customer_id
JOIN order_statuses os
	ON o.status = os.order_status_id;



Exercise: 

SELECT 
	p.date, 
	p.invoice_id,
	p.amount, 
	c.name,
	pm.name
FROM payments p
JOIN clients c
	ON p.client_id = c.client_id
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id;




📌 Summary
✔ Joining multiple tables allows for complex data retrieval. 
✔ Aliases (o, c, os) reduce redundancy. 
✔ SQL executes joins sequentially, ensuring efficient data mapping. 
✔ Next steps: Learning different join types (LEFT, RIGHT, FULL OUTER) for handling unmatched records.














Compound Join Conditions:
-------------------------

🚀 Understanding Compound Join Conditions in SQL:
While many tables use a single column to uniquely identify rows (customer_id in customers), some require multiple columns for uniqueness. This tutorial covers composite primary keys and joining tables using multiple conditions.

📌 1. Identifying Composite Keys in Tables:
✔ Some tables cannot use a single column for unique identification. 
✔ Example: order_items table contains repeated values in order_id and product_id.

📌 Example: order_items Table:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ 1         │  2        │  9.10     │
│ 2         │ 4         │  4        │  1.66     │
│ 2         │ 6         │  2        │  2.94     │
│ 6         │ 1         │  4        │  8.65     │
└───────────┴───────────┴───────────┴───────────┘
✔ Neither order_id nor product_id alone can uniquely identify records. 
✔ The combination of order_id and product_id creates a unique identifier.

📌 Understanding Composite Primary Keys 
✔ The primary key (PK) is a combination of multiple columns (order_id & product_id). 
✔ This ensures each order item is uniquely tracked.




📌 2. Joining Tables With a Composite Key:
✔ When joining a table with a composite key, both key columns must be included in the join condition.

📌 Example: Joining order_items With order_item_notes:

SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	ON oi.order_id = oin.order_id 
	AND oi.product_id = oin.product_id;
🚀 Effect: ✔ Matches order items with their corresponding notes, ensuring precise record association.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬────────────┐
│ OrderID   │ ProductID │ Quantity  │ NoteID    │ Note       │
├───────────┼───────────┼───────────┼───────────┼────────────┤
│ 2         │ 1         │  2        │ 1         │ First note │
│ 2         │ 1         │  2        │ 2         │ Second note│
└───────────┴───────────┴───────────┴───────────┴────────────┘
✔ Each order item is correctly linked with its notes.




Queries in this discussion:

SELECT *
FROM order_items oi
JOIN order_item_notes oin
	ON oi.order_id = oin.order_id
	AND oi.product_id = oin.product_id




📌 Key Takeaways
✔ Some tables require composite keys (multiple columns) for unique identification. 
✔ Joining tables with composite keys requires multiple conditions (ON order_id AND product_id). 
✔ Ensures precise data retrieval and accurate joins. 












Implicit Join Syntax:
---------------------

🚀 Understanding Implicit Join Syntax in SQL:
MySQL allows two methods for joining tables: 
Explicit Join Syntax (Recommended ✅) 
Implicit Join Syntax (Not Recommended ⚠️)



📌 1. Explicit vs. Implicit Joins:
✔ Explicit joins use the JOIN keyword, ensuring clarity and structure. 
✔ Implicit joins place multiple tables in the FROM clause and define join conditions in WHERE.

📌 Explicit Join (Recommended):

SELECT * 
FROM orders o
JOIN customers c 
ON o.customer_id = c.customer_id;

🚀 Effect: ✔ Directly links orders with customers, ensuring structured queries.


📌 Implicit Join (Not Recommended):
SELECT * 
FROM orders o, customers c 
WHERE o.customer_id = c.customer_id;

🚀 Effect: ✔ Produces the same result, but poses risks if the WHERE clause is omitted.




📌 2. Risks of Implicit Join Syntax:
✔ If the WHERE clause is mistakenly omitted, MySQL performs a CROSS JOIN, multiplying data unexpectedly.

📌 Example of Missing WHERE Clause (Cross Join):

SELECT * 
FROM orders o, customers c;  -- ⚠️ No Join Condition!

🚀 Effect: 
✔ Every order combines with every customer, creating unexpected results. 
✔ If the orders table contains 10 records and customers contains 10 records, the result produces 100 rows instead of 10.

📌 Example Output of a Cross Join:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │ Customer  │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 1         │ 2025-05-17│ Alice     │
│ 1         │ 2         │ 2025-05-17│ Bob       │
│ 1         │ 3         │ 2025-05-17│ Charlie   │
│ 2         │ 1         │ 2025-05-16│ Alice     │
│ 2         │ 2         │ 2025-05-16│ Bob       │
│ 2         │ 3         │ 2025-05-16│ Charlie   │
└───────────┴───────────┴───────────┴───────────┘
✔ Orders incorrectly combine with all customers, leading to data inconsistency.




📌 3. Why Explicit Joins Are Safer
✔ Explicit syntax forces the join condition, preventing unintended CROSS JOINS. 
✔ If the join condition is missing, MySQL throws an error instead of generating incorrect results.

📌 Explicit Join Preventing Cross Join:

SELECT * 
FROM orders o
JOIN customers c;  -- ❌ ERROR (Join condition required)

🚀 Effect: ✔ Ensures correctness by enforcing required conditions.





Queries in this discussion: 

SELECT *
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;
	
	
--Implicit Join Syntax
SELECT *
FROM orders o, customers c
WHERE o.customer_id = c.customer_id;




📌 Summary
✔ Explicit joins (JOIN ON) ensure structured queries and prevent errors. 
✔ Implicit joins (FROM table1, table2 WHERE) allow mistakes if the WHERE condition is forgotten. 
✔ Avoid implicit joins to prevent accidental cross joins. 












Outer Joins: 
------------
🚀 Understanding Outer Joins in SQL:
SQL joins allow us to combine data from multiple tables. So far, we've explored inner joins, which return only matching records between tables. However, outer joins retrieve all records from one table, even if there is no match in the other.

📌 1. Difference Between Inner and Outer Joins
✔ Inner Join: Returns only records that match in both tables. 
✔ Outer Join: Returns all records from one table, even if there is no match in the second table.

📌 Inner Join Example:
SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ Only customers who have placed orders are retrieved.

📌 Example Output (Inner Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 4         │
│ 2         │ Ines      │ 7         │
│ 5         │ Clemmie   │ 12        │
└───────────┴───────────┴───────────┘
✔ Customers without orders are missing.




📌 2. Using LEFT JOIN to Retrieve All Customers
✔ LEFT JOIN returns all records from the left table, even if no match exists in the right table.

📌 Retrieve All Customers, Including Those Without Orders:

SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
LEFT JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;
🚀 Effect: ✔ All customers appear in the result, whether or not they have orders.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ ✅ Has orders
│ 2         │ Ines      │ 7         │ ✅ Has orders
│ 3         │ Freddi    │ NULL      │ ❌ No orders
└───────────┴───────────┴───────────┘
✔ Customers without orders display NULL values for order_id.





📌 3. Using RIGHT JOIN to Retrieve All Orders
✔ RIGHT JOIN returns all records from the right table, ensuring all orders appear, even if no matching customer exists.

📌 Retrieve All Orders, Including Those Without Customers:

SELECT c.customer_id, c.first_name, o.order_id
FROM orders o
RIGHT JOIN customers c 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ All orders appear, even if no customer exists.

📌 Example Output (Right Join)

┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ ✅ Has orders
│ 2         │ Ines      │ 7         │ ✅ Has orders
│ NULL      │ NULL      │ 10        │ ❌ No matching customer
└───────────┴───────────┴───────────┘
✔ Orders without customers display NULL values for customer_id.

📌 Understanding Table Order ✔ LEFT JOIN → Ensures all customers appear. ✔ RIGHT JOIN → Ensures all orders appear. ✔ Swapping tables affects results.




📌 4. Exercise: Retrieve Products, Including Those Never Ordered
🚀 Task: ✔ Retrieve all products, even those never ordered.

📌 Expected Query Solution:

SELECT p.product_id, p.name, oi.quantity 
FROM products p
LEFT JOIN order_items oi 
ON p.product_id = oi.product_id;

🚀 Effect: ✔ All products appear, even if not ordered.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Quantity  │
├───────────┼───────────┼───────────┤
│ 1         │ Laptop    │ 5         │ ✅ Ordered
│ 2         │ Mouse     │ 12        │ ✅ Ordered
│ 3         │ Keyboard  │ NULL      │ ❌ Never ordered
└───────────┴───────────┴───────────┘
✔ Products with no orders display NULL values in quantity.





Queries used in this discussion: 

SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
JOIN orders o
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM orders o
RIGHT JOIN customers c
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	


Exercise:

SELECT 
	p.product_id, 
	p.name, 
	oi.quantity
FROM products p
LEFT JOIN order_items oi
	ON p.product_id = oi.product_id;






📌 Summary
✔ INNER JOIN → Only matching records from both tables. 
✔ LEFT JOIN → All records from left table, even if no match in right. 
✔ RIGHT JOIN → All records from right table, even if no match in left. 
✔ OUTER keyword is optional (LEFT JOIN = LEFT OUTER JOIN). 













Outer Joins Between Multiple Tables: 
------------------------------------

🚀 Using Outer Joins Between Multiple Tables in SQL
Just like inner joins, outer joins can be used to combine multiple tables, ensuring all records from one table appear, even if no match exists in another table.

📌 1. Why Use Multiple Outer Joins?
✔ Some tables contain missing values that can affect query results. 
✔ Outer joins ensure all records from the primary table remain, even if some fields are NULL.

📌 Example Scenario 
✔ The customers table contains customer details. 
✔ The orders table contains customer orders, but not all customers have placed orders. 
✔ The shippers table contains shipping companies, but not all orders have been shipped.

📌 2. Combining Customers and Orders With a LEFT JOIN
✔ If we join customers with orders using an INNER JOIN, only customers with orders appear.

📌 Inner Join (Excludes Customers Without Orders):
SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ Filters out customers who haven’t placed orders, leading to missing data.

📌 Example Output (Inner Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 4         │
│ 2         │ Ines      │ 7         │
│ 5         │ Clemmie   │ 12        │
└───────────┴───────────┴───────────┘
✔ Customers without orders are missing.


📌 Fixing Missing Data With LEFT JOIN:
SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
LEFT JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ Ensures all customers appear, even those without orders.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ ✅ Has orders
│ 2         │ Ines      │ 7         │ ✅ Has orders
│ 3         │ Freddi    │ NULL      │ ❌ No orders
└───────────┴───────────┴───────────┘
✔ NULL values indicate missing orders.





📌 3. Adding Shipper Details With Another Left Join
✔ Some orders haven’t been shipped—we must ensure all orders appear, even if no shipper exists.

📌 Joining orders With shippers Using LEFT JOIN:

SELECT c.customer_id, c.first_name, o.order_id, sh.name AS shipper
FROM customers c
LEFT JOIN orders o 
ON c.customer_id = o.customer_id
LEFT JOIN shippers sh 
ON o.shipper_id = sh.shipper_id
ORDER BY c.customer_id;

🚀 Effect: ✔ Returns all orders, including those with no shipper.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │ Shipper   │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ FedEx     │ ✅ Shipped
│ 2         │ Ines      │ 7         │ NULL      │ ❌ Not shipped
│ 3         │ Freddi    │ NULL      │ NULL      │ ❌ No orders
└───────────┴───────────┴───────────┴───────────┘
✔ Orders without a shipper show NULL values.





📌 4. Exercise: Retrieving Orders With Customer, Shipper, and Status
🚀 Task: ✔ Retrieve all orders with their customer names, shipping companies, and order statuses.

📌 Expected Query Solution:

SELECT 
    o.order_id, 
    o.order_date, 
    c.first_name AS customer, 
    sh.name AS shipper, 
    os.name AS status
FROM orders o
JOIN customers c 
ON o.customer_id = c.customer_id 
LEFT JOIN shippers sh 
ON o.shipper_id = sh.shipper_id
JOIN order_statuses os 
ON o.status = os.order_status_id;

🚀 Effect: ✔ Ensures all orders appear, even if no shipper exists.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ Customer  │ Shipper   │ Status    │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ 2025-05-17│ Alex      │ FedEx     │ Processed │
│ 2         │ 2025-05-16│ Maria     │ NULL      │ Pending   │ ❌ Not shipped
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Orders missing a shipper still appear.

📌 Why We Used Different Joins
JOIN customers → Ensures all orders have a customer.
LEFT JOIN shippers → Ensures all orders appear, even if unshipped.
JOIN order_statuses → Ensures order status always exists.






Queries in this discussion: 

SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
JOIN shippers sh
	ON o.shipper_id = sh.shipper_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id,
	sh.name AS shipper 
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
LEFT JOIN shippers sh
	ON o.shipper_id = sh.shipper_id
ORDER BY c.customer_id;	



Exercise: 

SELECT
	o.order_id, 
	o.order_date, 
	c.first_name AS customer, 
	sh.name AS shipper, 
	os.name AS status
FROM orders o
JOIN customers c 
	ON o.customer_id = c.customer_id 
LEFT JOIN shippers sh 
	ON o.shipper_id = sh.shipper_id
JOIN order_statuses os 
	ON o.status = os.order_status_id
	
	



📌 5. Key Takeaways
✔ Multiple outer joins allow complete data retrieval without missing values. 
✔ Avoid right joins in multi-table joins for better query readability. 
✔ Always analyze missing values (NULL) to ensure correct query behavior. 
✔ Next steps: Learning how to use FULL OUTER JOINS for complete unmatched data retrieval.

🚀 Use multiple outer joins for comprehensive reports covering all possible data scenarios!






	
	
	









Self Outer Joins:
-----------------

🚀 Understanding Self Outer Joins in SQL
A self-join occurs when a table is joined with itself, often used to analyze hierarchical relationships such as employees and managers.

📌 1. Why Use Self Joins With Outer Joins?
✔ In the sql_hr database, the employees table stores manager relationships using the reports_to column. 
✔ This column references the employee_id of the manager, linking employees within the same table.

📌 Example: Employees Table:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Job Title │ Salary    │ ReportsTo │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 37270     │ John      │ CEO       │ 120000    │ NULL      │
│ 33391     │ Sarah     │ Manager   │ 75000     │ 37270     │
│ 37851     │ Alex      │ Engineer  │ 65000     │ 33391     │
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ John is the CEO, meaning reports_to = NULL. ✔ Sarah reports to John, and Alex reports to Sarah.





📌 2. Performing a Self Join
✔ To retrieve employees along with their managers, we join the employees table with itself.

📌 Joining Employees With Their Managers (Using INNER JOIN)

USE sql_hr;

SELECT 
    e.employee_id,
    e.first_name, 
    m.first_name AS manager
FROM employees e
JOIN employees m 
ON e.reports_to = m.employee_id;

🚀 Effect: ✔ Lists only employees who have a manager.

📌 Example Output (Inner Join):
┌───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Manager   │
├───────────┼───────────┼───────────┤
│ 33391     │ Sarah     │ John      │ ✅ Has manager
│ 37851     │ Alex      │ Sarah     │ ✅ Has manager
└───────────┴───────────┴───────────┘
✔ John (CEO) is missing, because he has no manager.





📌 3. Using LEFT JOIN to Include All Employees
✔ Some employees don’t have a manager (e.g., CEO)—these must still appear in the result. 
✔ LEFT JOIN ensures all employees are displayed, even if they have no manager.

📌 Fixing Missing Data With LEFT JOIN:

SELECT 
    e.employee_id,
    e.first_name, 
    m.first_name AS manager
FROM employees e
LEFT JOIN employees m 
ON e.reports_to = m.employee_id;

🚀 Effect: ✔ All employees appear, even those without a manager.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Manager   │
├───────────┼───────────┼───────────┤
│ 37270     │ John      │ NULL      │ ❌ No manager (CEO)
│ 33391     │ Sarah     │ John      │ ✅ Has manager
│ 37851     │ Alex      │ Sarah     │ ✅ Has manager
└───────────┴───────────┴───────────┘
✔ John (CEO) is now included with a NULL manager value.





Queries used in this discussion: 

USE sql_hr;

SELECT 
	e.employee_id,
	e.first_name, 
	m.first_name AS manager
FROM employees e
JOIN employees m 
	ON e.reports_to = m.employee_id;
	

SELECT 
	e.employee_id,
	e.first_name, 
	m.first_name AS manager
FROM employees e
LEFT JOIN employees m 
	ON e.reports_to = m.employee_id;







📌Key Takeaways
✔ Self-joins allow referencing rows within the same table, commonly used for hierarchical structures. 
✔ Inner joins filter out records without matches, whereas left joins include all records. 
✔ Explicit table aliases (e, m) simplify self-join queries. 
✔ Next steps: Learning how to use FULL OUTER JOINS to retrieve all unmatched records from both tables.

🚀 Use self outer joins for complete hierarchical relationships in SQL!



















The USING Clause:
-----------------

🚀 Using the USING Clause in SQL Joins:
The USING clause in SQL simplifies join conditions when column names are identical across tables. This tutorial covers how to use USING, when to use ON instead, and best practices for multiple-column joins.

📌 1. Understanding the USING Clause
✔ The standard way to join tables uses the ON clause. 
✔ If column names are identical, USING makes queries shorter and easier to read.

📌 Standard Join Condition Using ON:

SELECT 
    o.order_id, 
    c.first_name
FROM orders o
JOIN customers c
ON o.customer_id = c.customer_id;
📌 Equivalent Query Using USING


SELECT 
    o.order_id, 
    c.first_name
FROM orders o
JOIN customers c 
USING (customer_id);

🚀 Effect: ✔ Both queries produce identical results, but the second is simpler.





📌 2. Joining Multiple Tables With USING
✔ USING works for multiple tables, provided column names match in all tables.

📌 Joining orders With shippers Using USING


SELECT 
    o.order_id, 
    c.first_name,
    sh.name AS shipper
FROM orders o
JOIN customers c 
USING (customer_id)
LEFT JOIN shippers sh 
USING (shipper_id);

🚀 Effect: ✔ Retrieves orders, customers, and shippers, simplifying the query.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ OrderID   │ Customer  │ Shipper   │
├───────────┼───────────┼───────────┤
│ 1         │ Alex      │ FedEx     │
│ 2         │ Maria     │ NULL      │ ❌ Not shipped
└───────────┴───────────┴───────────┘
✔ Orders without shippers display NULL values.





📌 3. When USING Cannot Be Used
✔ USING only works when the column name is identical in both tables. 
✔ If names are different, we must use ON instead.

📌 Example: 
The order_statuses Table ✔ In orders, the column name is status, but in order_statuses, it’s order_status_id.

📌 Query Using ON Instead of USING

SELECT 
    o.order_id, 
    os.name AS status
FROM orders o
JOIN order_statuses os 
ON o.status = os.order_status_id;
🚀 Effect: ✔ USING cannot be applied, because the column names do not match.





📌 4. Using USING With Composite Keys
✔ If a table has a composite primary key, we must join using multiple columns.

📌 Standard Join Using ON:
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
ON oi.order_id = oin.order_id 
AND oi.product_id = oin.product_id;

📌 Simplified Query Using USING:
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
USING (order_id, product_id);

🚀 Effect: ✔ Avoids redundancy when joining tables with composite keys.





📌 5. Exercise: Using USING With the Payments Table
🚀 Task: ✔ Retrieve payments with client names and payment methods using USING where possible.

📌 Expected Query Solution:

SELECT 
    p.date, 
    c.name AS client,
    p.amount, 
    pm.name AS payment_method
FROM payments p
JOIN clients c USING (client_id)
JOIN payment_methods pm 
ON p.payment_method = pm.payment_method_id;

🚀 Effect: ✔ Uses USING for client_id, but ON for payment_method_id.

📌 Example Output:
┌───────────┬───────────┬───────────────┬─────────────┐
│ Date      │ Client    │ Amount        │ Method      │
├───────────┼───────────┼───────────────┼─────────────┤
│ 2025-05-01│ Vinte     │ 250.00        │ Credit Card │
│ 2025-04-30│ MyWorks   │ Wire Transfer │             │
└───────────┴───────────┴───────────────┴─────────────┘
✔ Payments are correctly linked to clients and payment methods.





Queries used in this discussion: 

SELECT 
	o.order_id, 
	c.first_name
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;
	
	
SELECT 
	o.order_id, 
	c.first_name,
	sh.name AS shipper
FROM orders o
JOIN customers c
	USING (customer_id)
LEFT JOIN shippers sh
	USING (shipper_id);
	
		
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	ON oi.order_id = oin.order_id 
	AND oi.product_id = oin.product_id;
	
	
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	USING (order_id, product_id);
	
		
Exercise: 

SELECT 
	p.date, 
	c.name AS client,
	p.amount, 
	pm.name AS payment_method
FROM payments p
JOIN clients c USING (client_id)
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
	
	





📌 Key Takeaways
✔ USING simplifies join conditions, but only works when column names match. 
✔ For different column names, use ON instead. 
✔ Multiple columns can be joined using USING (col1, col2). 
✔ Next steps: Learning how to optimize queries using indexes and query performance techniques.

🚀 Use the USING clause for cleaner and more readable SQL joins!





	
	
	
	
	
	
	
	
	
	
	
	
	
Natural Joins:
--------------

🚀 Understanding Natural Joins in SQL
A Natural Join is a simplified way to join tables, where the database automatically detects matching columns. 
While easy to write, Natural Joins can be unpredictable, making explicit joins preferable.

📌 1. How Natural Joins Work
✔ Natural Joins automatically match columns with the same name in both tables. 
✔ Unlike explicit joins (ON condition), the database engine determines the join condition.

📌 Example: Joining orders With customers Using a Natural Join

SELECT 
    o.order_id,
    c.first_name
FROM orders o
NATURAL JOIN customers c;

🚀 Effect: ✔ Automatically joins orders with customers, based on the customer_id column.

📌 Equivalent Explicit Join Using ON

SELECT 
    o.order_id,
    c.first_name
FROM orders o
JOIN customers c 
ON o.customer_id = c.customer_id;

✔ Both queries produce the same result, but the explicit join ensures clarity.





📌 2. Risks of Using Natural Joins
✔ Loss of Control → The database automatically determines the join columns, increasing the risk of accidental joins. 
✔ Unexpected Results → If tables contain multiple common columns, unintended joins may occur, leading to incorrect data retrieval.

📌 Why Explicit Joins Are Better? 
✔ Explicit joins clearly define conditions, ensuring the intended result. 
✔ Using explicit joins prevents accidental mismatches, unlike natural joins.





📌 3. When to Avoid Natural Joins
✔ If column names do not match across tables, natural joins cannot be used. 
✔ If multiple common columns exist, the database may use unintended columns for joining.

📌 Example of a Potential Issue:
Orders Table → customer_id, shipper_id
Customers Table → customer_id, region_id

✔ If both tables contain customer_id and region_id, the database may mistakenly join on both, causing data inconsistencies.




Queries in this discussion: 

SELECT 
	o.order_id,
	c.first_name
FROM orders o
NATURAL JOIN customers c






📌 Key Takeaways
✔ Natural Joins automatically match common column names but should be used cautiously. 
✔ Explicit joins (ON column1 = column2) ensure clarity, preventing unintended data mismatches. 
✔ Avoid Natural Joins when multiple matching columns exist, as unexpected results may occur. 
✔ Next steps: Learning cross joins and how they differ from natural joins.

🚀 Use explicit joins for safe and predictable SQL queries!





















Cross Joins: 
------------
🚀 Understanding Cross Joins in SQL
A Cross Join in SQL combines every record from the first table with every record from the second table, producing a Cartesian product.

📌 1. What Is a Cross Join?
✔ A Cross Join creates all possible combinations between two tables. 
✔ Unlike other joins, there is no join condition (ON column = column). 
✔ Each row from the first table combines with every row from the second table.

📌 Example Scenario ✔ We have customers and products, and we need to pair every customer with every product.





📌 2. Explicit Cross Join Syntax
✔ The explicit syntax uses the CROSS JOIN keyword.

📌 Query: Pairing Customers With Products

SELECT 
    c.first_name AS customer, 
    p.name AS product
FROM customers c
CROSS JOIN products p
ORDER BY c.first_name;

🚀 Effect: ✔ Each customer is paired with every product, producing a Cartesian product.

📌 Example Output (Cross Join):
┌───────────┬───────────┐
│ Customer  │ Product   │
├───────────┼───────────┤
│ Amber     │ Laptop    │
│ Amber     │ Mouse     │
│ Amber     │ Keyboard  │
│ Barbara   │ Laptop    │
│ Barbara   │ Mouse     │
│ Barbara   │ Keyboard  │
└───────────┴───────────┘
✔ Each customer is associated with every product.





📌 3. Implicit Cross Join Syntax
✔ Instead of using CROSS JOIN, we list both tables in the FROM clause.

📌 Query Using Implicit Syntax

SELECT 
    c.first_name AS customer, 
    p.name AS product
FROM customers c, products p
ORDER BY c.first_name;

🚀 Effect: ✔ Produces the same result, but explicit syntax is clearer.





📌 4. When to Use Cross Joins?
✔ Cross Joins are useful for generating all possible combinations between attributes.

📌 Example: 
Combining Sizes & Colors ✔ Assume we have a sizes table (small, medium, large) and a colors table (red, blue, green). ✔ A Cross Join will generate all possible combinations.

SELECT 
    s.size, 
    c.color
FROM sizes s
CROSS JOIN colors c;

🚀 Effect: ✔ Creates all color-size combinations, such as small-red, small-blue, large-green, etc.





📌 5. Exercise: Cross Joining Shippers With Products
🚀 Task: ✔ Perform a cross join between shippers and products using both implicit and explicit syntax.

📌 Expected Query Solution (Implicit Syntax)

SELECT 
    sh.name AS shipper, 
    p.name AS product 
FROM shippers sh, products p
ORDER BY sh.name;

📌 Expected Query Solution (Explicit Syntax)

SELECT 
    sh.name AS shipper, 
    p.name AS product 
FROM shippers sh
CROSS JOIN products p
ORDER BY sh.name;

🚀 Effect: ✔ Each shipper is paired with every product, creating a Cartesian result.

📌 Example Output:
┌───────────┬───────────┐
│ Shipper   │ Product   │
├───────────┼───────────┤
│ FedEx     │ Laptop    │
│ FedEx     │ Mouse     │
│ UPS       │ Keyboard  │
│ UPS       │ Monitor   │
└───────────┴───────────┘
✔ Shippers are associated with all products, ensuring comprehensive pairing.





Queries used in this discussion: 

SELECT 
	c.first_name AS customer, 
	p.name AS product
FROM customers c
CROSS JOIN products p
ORDER BY c.first_name; 


--Implicit syntax
SELECT 
	c.first_name AS customer, 
	p.name AS product
FROM customers c, products p
ORDER BY c.first_name; 



Exercise: 

-- Do a cross join between shippers and products
-- 		using the implicit syntax
-- 		and then using the explicit syntax 


SELECT 
	sh.name AS shipper, 
	p.name AS product 
FROM shippers sh, products p
ORDER BY sh.name 


SELECT 
	sh.name AS shipper, 
	p.name AS product 
FROM shippers sh
CROSS JOIN products p
ORDER BY sh.name 






📌 Key Takeaways
✔ Cross Joins create all possible record combinations, forming a Cartesian product. 
✔ Explicit syntax (CROSS JOIN) is clearer than implicit syntax (FROM table1, table2). 
✔ Useful for generating attribute combinations (e.g., size-color pairs). 
✔ Next steps: Learning FULL OUTER JOINS to retrieve complete unmatched records from both tables.

🚀 Use Cross Joins when pairing all possible combinations between tables!



















Unions: 
-------
🚀 Understanding UNION in SQL
SQL joins combine columns from multiple tables, but UNION allows combining rows from multiple tables. This is powerful for consolidating datasets, such as merging records from different time periods or tables.

📌 1. What Is UNION in SQL?
✔ UNION combines results from multiple queries into a single dataset. 
✔ All queries must return the same number of columns and compatible data types. 
✔ By default, UNION removes duplicates, but UNION ALL preserves all records.

📌 Example: Retrieve Orders, Labeling Them as Active or Archived

SELECT 
    order_id, 
    order_date, 
    'Active' AS status
FROM orders 
WHERE order_date >= '2019-01-01'
UNION 
SELECT 
    order_id, 
    order_date, 
    'Archived' AS status
FROM orders 
WHERE order_date < '2019-01-01';

🚀 Effect: ✔ Retrieves all orders, marking current year orders as "Active" and past orders as "Archived".

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ Status    │
├───────────┼───────────┼───────────┤
│ 101       │ 2025-03-10│ Active    │ ✅ Current Year
│ 87        │ 2024-08-22│ Archived  │ ❌ Previous Year
└───────────┴───────────┴───────────┘
✔ Merges both datasets into one.





📌 2. Using UNION Across Different Tables
✔ UNION can merge results from entirely different tables.

📌 Example: Retrieve Names From Customers and Shippers

SELECT first_name FROM customers
UNION 
SELECT name FROM shippers;
🚀 Effect: ✔ Merges customer first names and shipper names into a single list.

📌 Example Output:
┌───────────┐
│ Name      │
├───────────┤
│ Alice     │ ✅ Customer
│ Bob       │ ✅ Customer
│ UPS       │ ✅ Shipper
│ FedEx     │ ✅ Shipper
└───────────┘
✔ Combines records while removing duplicates.





📌 3. Union Errors: Mismatched Columns
✔ The number of columns must match in both queries. 
✔ Different column counts cause errors.

📌 Incorrect Query (Mismatched Columns):

SELECT first_name, last_name FROM customers
UNION 
SELECT name FROM shippers;  -- ⚠️ Error! Only one column returned

🚀 Effect: ✔ MySQL throws an error, as the first query returns two columns, but the second query returns one.

📌 Fix: Matching Column Structure

SELECT name FROM shippers
UNION 
SELECT first_name FROM customers;
✔ Now both queries return a single column, preventing errors.





📌 4. Exercise: Classifying Customers Based on Points
🚀 Task: ✔ Categorize customers into Bronze, Silver, and Gold, based on loyalty points.

📌 Expected Query Solution

SELECT 
    customer_id, 
    first_name, 
    points, 
    'Bronze' AS type
FROM customers 
WHERE points < 2000
UNION 
SELECT 
    customer_id, 
    first_name, 
    points, 
    'Silver' AS type
FROM customers 
WHERE points BETWEEN 2000 AND 3000
UNION 
SELECT 
    customer_id, 
    first_name, 
    points, 
    'Gold' AS type
FROM customers 
WHERE points > 3000
ORDER BY first_name;

🚀 Effect: ✔ Categorizes customers based on loyalty points.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ Points    │ Type      │
├───────────┼───────────┼───────────┼───────────┤
│ 12        │ Amber     │ 1785      │ Bronze    │
│ 7         │ Barbara   │ 2450      │ Silver    │
│ 3         │ Clemmie   │ 3120      │ Gold      │
└───────────┴───────────┴───────────┴───────────┘
✔ Loyalty-based segmentation ensures better customer management.




Queries used in this discussion: 

SELECT 
	order_id,
	order_date,
	'Active' AS status, 
FROM orders
WHERE order_date >= '2019-01-01'
UNION
SELECT 
	order_id,
	order_date,
	'Archived' AS status, 
FROM orders
WHERE order_date < '2019-01-01';



SELECT first_name
FROM customers
UNION 
SELECT name 
FROM shippers 




SELECT first_name, last_name   --Error
FROM customers
UNION 
SELECT name 
FROM shippers 



SELECT name 
FROM shippers 
UNION 
SELECT first_name
FROM customers


Exercise: 

SELECT 
	customer_id, 
	first_name,
	points, 
	'Bronze' AS type
FROM customers 
WHERE points < 2000
UNION 
SELECT 
	customer_id, 
	first_name,
	points, 
	'Silver' AS type
FROM customers 
WHERE points BETWEEN 2000 AND 3000
UNION 
SELECT 
	customer_id, 
	first_name,
	points, 
	'Gold' AS type
FROM customers 
WHERE points > 3000
ORDER BY first_name






📌 Key Takeaways
✔ UNION merges results from multiple queries into a single dataset. 
✔ Each query must return the same number of columns and compatible data types. 
✔ UNION removes duplicates; UNION ALL keeps them. 
✔ Use ORDER BY at the end to sort the merged results. 
✔ Next steps: Learning how to optimize UNION queries using indexing and query efficiency techniques.

🚀 Use UNION for powerful data consolidation in SQL!




















Inserting, Updating and Deleting Data:
--------------------------------------

Column Attributes: 
------------------

🚀 Understanding Column Attributes in SQL
Before working with inserting, updating, and deleting data, it's crucial to understand column attributes, which define data types, constraints, and behaviors within a table.

Column attributes in SQL define specific properties and constraints for a column in a table. These attributes help ensure data integrity, control how data is stored, and influence how queries interact with the column. Here are some key column attributes:

Data Type – Specifies the type of data stored in the column (e.g., INT, VARCHAR, DATE, BOOLEAN).
DEFAULT – Assigns a default value when no explicit value is provided in an INSERT operation.
NOT NULL – Ensures that the column cannot store NULL values.
UNIQUE – Guarantees that all values in the column are distinct.
PRIMARY KEY – Uniquely identifies each row in the table; combines UNIQUE and NOT NULL.
FOREIGN KEY – Establishes a relationship between tables by referencing a column in another table.
CHECK – Defines a condition that values in the column must satisfy.
AUTO_INCREMENT – Automatically generates sequential values for new rows (commonly used for primary keys).
INDEX – Improves query performance by creating a searchable structure for the column.



📌 1. Exploring Column Attributes in the customers Table:
✔ Every column in a database table has a specific type and constraints. 
✔ These attributes control what kind of data can be stored and how it behaves.

📌 Example: customers Table Schema
┌──────────────┬───────────┬──────────┬──────────────┬──────┬──────┬──────┬────────────────┐
│ Column Name  │ Data Type │ Max Size │ Default Value│ PK   │ NN   │ AI   │ Attributes     │
├──────────────┼───────────┼──────────┼──────────────┼──────┼──────┼──────┼────────────────┤
│ customer_id  │ INT       │ -        │ -            │ ✅   │ ✅    │ ✅   │ Auto-Increment │
│ first_name   │ VARCHAR   │ 50       │ -            │      │ ✅    │      │ -              |
│ last_name    │ VARCHAR   │ 50       │ -            │      │ ✅   │      │ -              |
│ birth_date   │ DATE      │ -        │ NULL         │      │      │      │ Nullable       |
│ phone        │ VARCHAR   │ 15       │ NULL         │      │      │      │ Nullable       │ 
│ points       │ INT       │ -        │ 0            │      │ ✅   │      │ Default Value  │
└──────────────┴───────────┴──────────┴──────────────┴──────┴──────┴──────┴────────────────┘

✔ Primary Key (PK): Ensures unique identification of rows. 
✔ Not Null (NN): Prevents empty values in columns. 
✔ Auto Increment (AI): Automatically increments primary key values. 
✔ Default Values: Assigns predefined values when none are supplied.





📌 2. Understanding Data Types:
✔ Each column must store specific types of data, defined by its data type.

📌 Common Data Types:

Data Type	Usage
INT	        Stores whole numbers (e.g., IDs, quantities).
VARCHAR(n)	Stores text up to n characters.
CHAR(n)	    Stores fixed-length text (n characters).
DATE	    Stores dates in YYYY-MM-DD format.

📌 VARCHAR vs. CHAR 
✔ VARCHAR (variable-length) saves space by storing only required characters. 
✔ CHAR (fixed-length) always reserves the full length, even for short values.

🚀 Example Difference

VARCHAR(50) → "John" (4 characters stored, space saved)
CHAR(50) → "John                                 " (50 characters stored, wasted space)
✔ Best Practice: Use VARCHAR for flexible text storage.





📌 3. Auto Increment & Default Values
✔ Auto Increment (AI) ensures automatic numbering for primary keys. 
✔ Default Values prevent NULL values by assigning pre-defined values.

📌 Auto Increment Behavior Example:
customer_id → [1, 2, 3, 4, …]  → Automatically increases for new rows.

✔ Default Values Example
points → Default = 0 → If no value is given, '0' is stored.
birth_date → Default = NULL → If no value is given, 'NULL' is stored.

🚀 Effect: ✔ Prevents inconsistent or missing data when inserting new records.





📌 Summary
✔ Column attributes define data storage rules for each table. 
✔ Primary keys (PK) ensure uniqueness, preventing duplicate records. 
✔ Not Null (NN) ensures required values, preventing incomplete data. 
✔ Auto Increment (AI) generates unique IDs, eliminating manual input. 
✔ Use VARCHAR instead of CHAR for efficient storage. 
✔ Default values prevent null issues, ensuring data integrity. 














Inserting a Row: 
----------------

🚀 Inserting a Row in SQL
The INSERT INTO statement allows adding new records to a table. This tutorial covers standard insertions, handling auto-increment values, dealing with optional columns, and using default values.

📌 1. Understanding the INSERT INTO Statement
✔ The basic syntax for inserting data into a table is:

📌 Standard Insert Statement:

INSERT INTO customers
VALUES (
    DEFAULT,  -- Auto-incremented customer_id
    'John',   -- First name
    'Smith',  -- Last name
    '1990-01-01',  -- Birth date
    NULL,     -- Phone (optional)
    'address',-- Address
    'city',   -- City
    'CA',     -- State
    DEFAULT   -- Default points (0)
);

🚀 Effect: ✔ Adds a new customer with automatically generated customer_id.

📌 Why Use DEFAULT Instead of a Number? 
✔ If a specific customer_id is inserted manually, it may conflict with an existing ID, causing an error. 
✔ Using DEFAULT, MySQL generates the next available ID automatically.





📌 2. Handling Optional Columns
✔ Some columns are optional (e.g., phone and birth_date). 
✔ If a column is optional, we can insert a NULL or let MySQL handle it using DEFAULT.

📌 Setting an Optional Value to NULL:

INSERT INTO customers
VALUES (
    DEFAULT, 'Alice', 'Brown', '1985-07-20',
    NULL, 'address', 'city', 'CA', DEFAULT
);

🚀 Effect: ✔ Stores NULL in the phone column, indicating no phone number available.





📌 3. Using Column Lists for Flexible Inserts
✔ Instead of inserting values for all columns, we can specify only required ones.

📌 Example: Specifying Only Certain Columns:

INSERT INTO customers (
    first_name, last_name, birth_date, address, city, state
) VALUES (
    'John', 'Smith', '1990-01-01', 'address', 'city', 'CA'
);

🚀 Effect: ✔ Avoids inserting values for columns like customer_id, phone, and points. ✔ MySQL automatically assigns default values where applicable.

📌 Key Benefits 
✔ Removes unnecessary NULL/default values from the statement. 
✔ Allows column reordering, making queries more readable.

🚀 Example With Reordered Columns

INSERT INTO customers (
    last_name, first_name, birth_date, address, city, state
) VALUES (
    'Smith', 'John', '1990-01-01', 'address', 'city', 'CA'
);

✔ Swapping the order of columns is valid as long as values match column positions.





📌 4. Verifying Inserted Data:
✔ After executing an INSERT INTO statement, we can verify the new row in the table.

📌 Example: Checking the Last Inserted Customer

SELECT * FROM customers;
🚀 Effect: ✔ Displays all records, including the newly inserted row.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ LastName  │ BirthDate │ Phone     │ Address   │ City      │ State     │ Points    │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ 11        │ John      │ Smith     │ 1990-01-01│ NULL      │ address   │ city      │ CA        │ 0         │
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘
✔ customer_id = 11 is generated automatically.





Queries used in this discussion: 

INSERT INTO customers
VALUES (
	DEFAULT, 
	'John', 
	'Smith',
	'1990-01-01',
	NULL, 
	'address',
	'city', 
	'CA',
	DEFAULT)
	
	
INSERT INTO customers(    -- we can optionally supply the list of columns and we can provide values according to this
	first_name, 
	last_name, 
	birth_date,
	address,
	city, 
	state)
VALUES ( 
	'John', 
	'Smith',
	'1990-01-01',
	'address',
	'city', 
	'CA')
	
	
	
	

📌 Summary
✔ Use INSERT INTO to add rows to a table, ensuring values match column attributes. 
✔ DEFAULT auto-generates primary key values, preventing conflicts. 
✔ Optional columns can use NULL or DEFAULT based on table rules. 
✔ Specifying column names allows flexible and readable insert statements. 
✔ Next steps: Learning how to update existing records efficiently.






	
	
	
	
	
	
	
	
Inserting Multiple Rows:
------------------------

🚀 Inserting Multiple Rows in SQL
When inserting data into a table, we can add multiple rows in a single statement, improving efficiency and reducing the need for repeated queries.

📌 1. Inserting Multiple Rows in One Statement
✔ Instead of executing multiple INSERT INTO statements, SQL allows inserting multiple rows in one execution.

📌 Example: Inserting Multiple Rows into shippers Table:

INSERT INTO shippers (name)
VALUES ('shipper1'),
       ('shipper2'),
       ('shipper3');
	   
🚀 Effect: ✔ Adds three new shippers to the table.

📌 Verifying the Inserted Data:

SELECT * FROM shippers;
📌 Example Output

┌───────────┬───────────┐
│ ShipperID │ Name      │
├───────────┼───────────┤
│ 6         │ shipper1  │
│ 7         │ shipper2  │
│ 8         │ shipper3  │
└───────────┴───────────┘
✔ ShipperID values are automatically generated due to the AUTO_INCREMENT attribute.





📌 2. Exercise: Inserting Multiple Products
🚀 Task: ✔ Insert three rows into the products table.

📌 Expected Query Solution:

INSERT INTO products (name, quantity_in_stock, unit_price)
VALUES ('Product1', 10, 1.95),
       ('Product2', 11, 1.95),
       ('Product3', 12, 1.95);
🚀 Effect: ✔ Adds three new products into the table.

📌 Verifying the Inserted Data:

SELECT * FROM products;
📌 Example Output

┌───────────┬───────────┬───────────────┬───────────┐
│ ProductID │ Name      │ QuantityStock │ UnitPrice │
├───────────┼───────────┼───────────────┼───────────┤
│ 15        │ Product1  │ 10            │ 1.95      │
│ 16        │ Product2  │ 11            │ 1.95      │
│ 17        │ Product3  │ 12            │ 1.95      │
└───────────┴───────────┴───────────────┴───────────┘
✔ Product IDs are automatically assigned based on previous records, even if previous rows were deleted.

📌 Why Do ProductID Values Start from 15 Instead of 11? ✔ Even though rows may have been deleted, MySQL remembers previous IDs and continues from the highest existing value.





📌 3. Why Use Multi-Row Inserts?
✔ Improves query efficiency → Reduces repeated statements. 
✔ Minimizes transaction overhead → Fewer queries lead to better performance. 
✔ Ensures consistent batch entry → Helps bulk insert operations.

🚀 Example Use Case ✔ Inserting multiple employee records at once:

INSERT INTO employees (first_name, last_name, job_title)
VALUES ('John', 'Doe', 'Manager'),
       ('Alice', 'Smith', 'Developer'),
       ('Bob', 'Brown', 'Designer');
✔ Faster than three separate INSERT statements.





Queries used in this discussion: 

INSERT INTO shippers (name)
VALUES ('shipper1'),
	   ('shipper2'),
	   ('shipper3');
	   
	   
Exercise: 

-- Insert three rows in the products table

INSERT INTO products (name, quantity_in_stock, unit_price)
VALUES ('Product1', 10, 1.95),
	   ('Product2', 11, 1.95),
	   ('Product3', 12, 1.95);
	   
	   
	   
	   
	   
📌 Summary
✔ Multi-row inserts optimize SQL execution, reducing redundancy. 
✔ AUTO_INCREMENT handles ID assignment, even after deletions. 
✔ SQL preserves previous IDs, ensuring uniqueness. 
✔ Use SELECT * to verify successful insertions. 
✔ Next steps: Learning how to update data efficiently using the UPDATE statement.






	   



Inserting Hierarchial Rows:
---------------------------
🚀 Inserting Hierarchical Rows in SQL
In many databases, an order consists of multiple items, meaning we need to insert data into multiple tables while maintaining relationships. This tutorial covers how to insert hierarchical data into parent-child tables.

📌 1. Understanding Parent-Child Relationships
✔ In relational databases, some tables depend on others. 
✔ The orders table (parent) contains general order details, while the order_items table (child) contains specific ordered products.

📌 Example Relationship:
Orders Table → Stores overall order details (ID, date, customer, status).
Order Items Table → Stores individual products per order (ID, quantity, price).

✔ Each order may have multiple items, meaning one order → many items.





📌 2. Inserting an Order Into the orders Table
✔ First, we add an order without specifying the order_id, since it’s auto-incremented.

📌 Inserting an Order

INSERT INTO orders (customer_id, order_date, status)
VALUES (1, '2019-01-02', 1);

🚀 Effect: ✔ Adds a new order for customer_id = 1, with order status 1 (processed, shipped, etc.).

📌 Verifying the Inserted Order:
sql
SELECT * FROM orders;

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │ Status    │
├───────────┼───────────┼───────────┼───────────┤
│ 13        │ 1         │ 2019-01-02│ 1         │ ✅ New Order
└───────────┴───────────┴───────────┴───────────┘
✔ Order ID = 13 is auto-generated.





📌 3. Inserting Items Into order_items Using LAST_INSERT_ID()
✔ After inserting the order, we need its order_id to insert items. 
✔ MySQL provides the LAST_INSERT_ID() function, which returns the ID of the last inserted record.

📌 Inserting Items Using Auto-Generated Order ID:
INSERT INTO order_items
VALUES 
    (LAST_INSERT_ID(), 1, 1, 2.95),
    (LAST_INSERT_ID(), 2, 1, 3.95);
	
🚀 Effect: ✔ Adds two items to the latest order.

📌 Verifying the Inserted Items:
SELECT * FROM order_items;

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │
├───────────┼───────────┼───────────┼───────────┤
│ 13        │ 1         │  1        │ 2.95      │ ✅ Product 1
│ 13        │ 2         │  1        │ 3.95      │ ✅ Product 2
└───────────┴───────────┴───────────┴───────────┘
✔ Products correctly linked to Order 13.

📌 Why Use LAST_INSERT_ID()? 
✔ Automatically retrieves the latest order_id, ensuring accurate order-item linkage. 
✔ Prevents manual ID tracking, reducing errors and mismatches.





Queries used in this discussion: 

INSERT INTO orders (customer_id, order_date, status)
VALUES (1, '2019-01-02', 1);


INSERT INTO order_items
VALUES 
	(LAST_INSERT_ID(), 1, 1, 2.95)
	(LAST_INSERT_ID(), 2, 1, 3.95);
	




📌 Summary
✔ Orders (parent) link to multiple items (child) using foreign keys (order_id). 
✔ Insert the order first, then use LAST_INSERT_ID() to insert items. 
✔ Auto-increment ensures unique IDs, avoiding manual entry errors. 
✔ Next steps: Learning how to update hierarchical records efficiently.


	
	
	
	
	
	
	
	
	
	
	



Creating a Copy of a Table: 
---------------------------

🚀 Creating a Copy of a Table in SQL:
SQL allows copying data from one table to another efficiently using subqueries and CREATE TABLE AS statements. This technique is useful for archiving, backups, and filtered data copies.

📌 1. Using CREATE TABLE AS to Copy a Table
✔ The CREATE TABLE AS statement creates a new table and copies data from an existing one.

📌 Example: Copying the orders Table to orders_archived

CREATE TABLE orders_archived AS 
SELECT * FROM orders;

🚀 Effect: ✔ Creates orders_archived and copies all records from orders.

📌 Verifying the Newly Created Table
SELECT * FROM orders_archived;

📌 Example Output
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │ Status    │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 5         │ 2025-03-10│ Processed │
│ 2         │ 3         │ 2024-08-22│ Shipped   │
└───────────┴───────────┴───────────┴───────────┘
✔ All data is copied from the orders table.

📌 Limitations of This Approach ✔ Primary keys and constraints are NOT copied, meaning auto-increment and uniqueness rules must be redefined.





📌 2. Using INSERT INTO With a Subquery
✔ Instead of copying an entire table, we can copy filtered records using a subquery in an INSERT INTO statement.

📌 Example: Copying Only Archived Orders:
INSERT INTO orders_archived 
SELECT * 
FROM orders
WHERE order_date < '2019-01-01';
🚀 Effect: ✔ Copies only past orders into orders_archived.

📌 Verifying the Archived Orders:
SELECT * FROM orders_archived;

✔ Orders placed before 2019 are retained, while new orders are ignored.

📌 Why Use This Approach? ✔ Optimizes storage by copying only relevant records. ✔ Maintains data integrity without manual filtering.





📌 3. Exercise: Copying Filtered Invoices Into an Archive Table
🚀 Task: ✔ Create a copy of the invoices table, replacing client_id with client names and filtering only paid invoices.

📌 Expected Query Solution:
USE sql_invoicing;

CREATE TABLE invoices_archived AS
SELECT 
    i.invoice_id, 
    i.number,
    c.name AS client,
    i.invoice_total, 
    i.payment_total, 
    i.invoice_date,
    i.payment_date,
    i.due_date
FROM invoices i
JOIN clients c 
USING (client_id)
WHERE payment_date IS NOT NULL;

🚀 Effect: ✔ Creates a filtered archive, ensuring only paid invoices are copied.

📌 Verifying the Archived Invoices:
SELECT * FROM invoices_archived;

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ InvoiceID │ Number    │ Client    │ Total     │ Paid      │ InvoiceDt │ PaymentDt │ DueDt     │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1001      │ INV2024-5 │ Vinte     │ 500.00    │ 500.00    │ 2024-02-10│ 2024-03-01│ 2024-03-10│ ✅ Paid Invoice
│ 1005      │ INV2023-3 │ MyWorks   │ 250.00    │ 250.00    │ 2023-05-15│ 2023-06-01│ 2023-06-15│ ✅ Paid Invoice
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Invoices without payments are excluded.





📌 4. Managing Existing Tables
✔ If the archived table already exists, re-running the query causes an error. ✔ To recreate the archive, drop the table first.

📌 Dropping an Existing Archive Table:
DROP TABLE invoices_archived;

🚀 Effect: ✔ Removes the existing archive table, allowing fresh data copies.

📌 Recreating the Table:
CREATE TABLE invoices_archived AS 
SELECT ... ;  -- Re-run the archive query

✔ Ensures the latest data is archived.





Queries used in this discussion: 

CREATE TABLE orders_archived AS 
SELECT * FROM orders


INSERT INTO orders_archived    --example of using a select statement as a sub query in an insert statement
SELECT * 
FROM orders
WHERE order_date < '2019-01-01';



Exercise: 

USE sql_invoicing; 

CREATE TABLE invoices_archived AS
SELECT 
	i.invoice_id, 
	i.number,
	c.name AS client,
	i.invoice_total, 
	i.payment_total, 
	i.invoice_date,
	i.payment_date,
	i.due_date
FROM invoices i
JOIN clients c
	USING (client_id)
WHERE payment_date IS NOT NULL; 







📌 Summary
✔ CREATE TABLE AS copies a table but omits constraints. 
✔ Subqueries in INSERT INTO allow selective data copying, optimizing storage. 
✔ Using JOIN ensures relevant column replacements (e.g., client_id → client_name). 
✔ Dropping tables (DROP TABLE) allows rebuilding archive copies as needed. 



















Updating a Single Row: 
----------------------
🚀 Updating a Single Row in SQL
The UPDATE statement in SQL allows us to modify existing records in a table. This tutorial covers how to update specific values, restore original data, and use expressions for calculated updates.

📌 1. Understanding the UPDATE Statement
✔ The UPDATE statement modifies existing records, targeting specific rows using the WHERE clause. 
✔ The SET clause specifies which column(s) to update.

📌 Example: Updating Payment Information for an Invoice:
UPDATE invoices 
SET payment_total = 10, payment_date = '2019-03-01'
WHERE invoice_id = 1;

🚀 Effect: ✔ Sets payment_total = 10 and payment_date = '2019-03-01' for invoice ID 1.

📌 Verifying the Updated Data:
SELECT * FROM invoices WHERE invoice_id = 1;
📌 Example Output

┌───────────┬──────────────┬─────────────┬───────────┐
│ InvoiceID │ PaymentTotal │ PaymentDate │ Status    │
├───────────┼──────────────┼─────────────┼───────────┤
│ 1         │ 10           │ 2019-03-01  │ Paid      │ ✅ Updated
└───────────┴──────────────┴─────────────┴───────────┘
✔ Payment details are successfully updated.





📌 2. Resetting Values Using NULL and DEFAULT
✔ If an update was made incorrectly, we can restore values using NULL or DEFAULT.

📌 Resetting the Payment Details for Invoice 1:
UPDATE invoices 
SET payment_total = DEFAULT, payment_date = NULL
WHERE invoice_id = 1;

🚀 Effect: ✔ Resets payment_total to default (0) and payment_date to NULL, restoring original values.

📌 Why Use DEFAULT Instead of a Specific Value? 
✔ Using DEFAULT ensures consistency, reflecting predefined table rules.





📌 3. Using Expressions in Updates
✔ Instead of inserting hardcoded values, we can use calculations.

📌 Example: Calculating 50% of Invoice Total for Invoice 3:
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE invoice_id = 3;

🚀 Effect: ✔ Updates payment_total to 50% of invoice_total, ensuring accurate calculations.

📌 Example Output:
┌───────────┬──────────────┬─────────────┬───────────┐
│ InvoiceID │ PaymentTotal │ PaymentDate │ DueDate   │
├───────────┼──────────────┼─────────────┼───────────┤
│ 3         │ 73.5         │ 2024-08-22  │ 2024-08-22│ ✅ Updated
└───────────┴──────────────┴─────────────┴───────────┘
✔ The payment total updates to 50% of the original invoice amount.


📌 Why Use Calculations Instead of Manual Updates? 
✔ Ensures dynamic updates without manual entry errors. 
✔ Helps with business logic operations (e.g., applying discounts, updating tax rates).





📌 4. Handling Decimal Precision:
✔ Some calculations truncate decimals automatically. 
✔ When updating currency values, ensure proper data types to preserve decimal places.

📌 Solution for Decimal Truncation ✔ Using data type adjustments (DECIMAL(x, y)) ensures correct rounding.

🚀 Example: Ensure Payment Total Maintains Precision
ALTER TABLE invoices 
MODIFY COLUMN payment_total DECIMAL(10,2);

✔ Preserves decimal values properly.


The ALTER statement in SQL is used to modify an existing table structure. It allows you to add, modify, or delete columns and constraints without recreating the table. Since you're methodical in your learning approach, I'll break this down clearly:

Common Uses of ALTER
1. Adding a Column

ALTER TABLE employees 
ADD age INT;

This adds a new column (age) to the employees table.

2. Modifying a Column Data Type or Constraints

ALTER TABLE employees 
MODIFY age SMALLINT NOT NULL;

Changes age column type to SMALLINT and ensures it cannot contain NULL values.

3. Renaming a Column (Supported in Some Databases)

ALTER TABLE employees 
RENAME COLUMN age TO employee_age;

4. Dropping a Column

ALTER TABLE employees 
DROP COLUMN age;

This removes the age column from the table.

5. Adding a Constraint

ALTER TABLE employees 
ADD CONSTRAINT unique_email UNIQUE (email);

Ensures the email column has unique values.


Where is ALTER Used?
Database Maintenance: Modifying table structures without affecting stored data.
Schema Evolution: Adjusting columns and constraints as data needs evolve.
Index and Key Management: Ensuring data integrity and optimizing performance.





Queries used in this discussion: 

UPDATE invoices 
SET payment_total = 10, payment_date = '2019-03-01'
WHERE invoice_id = 1;


UPDATE invoices 
SET payment_total = DEFAULT, payment_date = NULL
WHERE invoice_id = 1;


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE invoice_id = 3;





📌 Summary
✔ Use UPDATE to modify existing records, targeting specific rows using WHERE. 
✔ Reset values using NULL or DEFAULT to restore original data. 
✔ Expressions (invoice_total * 0.5) allow calculated updates, preventing manual input errors. 
✔ Next steps: Learning batch updates to modify multiple rows efficiently.












Updating Multiple Rows: 
-----------------------
🚀 Updating Multiple Rows in SQL:
When modifying multiple records in a table, we use the same UPDATE statement, but with a broader condition in the WHERE clause. This tutorial covers how to update multiple rows efficiently, bypass safe update restrictions, and use advanced filtering techniques.

📌 1. Using UPDATE for Multiple Records
✔ The UPDATE statement modifies multiple rows when a general condition is used.

📌 Example: Updating All Invoices for Client ID 3:
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE client_id = 3;

🚀 Effect: ✔ Updates payment_total to 50% of invoice_total for all invoices of client ID 3.

📌 Verifying the Updated Data:
SELECT * FROM invoices WHERE client_id = 3;

📌 Example Output:
┌───────────┬──────────────┬─────────────┬───────────┐
│ InvoiceID │ PaymentTotal │ PaymentDate │ ClientID  │
├───────────┼──────────────┼─────────────┼───────────┤
│ 102       │ 145.00       │ 2024-08-22  │ 3         │ ✅ Updated
│ 108       │ 210.50       │ 2024-09-01  │ 3         │ ✅ Updated
└───────────┴──────────────┴─────────────┴───────────┘
✔ All invoices for Client 3 now reflect updated payment details.





📌 2. Safe Update Mode in MySQL Workbench
✔ MySQL Workbench prevents updating multiple rows by default (to prevent accidental bulk changes). 
✔ If you attempt an update on more than one row, you may receive a safe update error.

📌 Disabling Safe Update Mode 
 - Go to MySQL Workbench Menu → Preferences. 
 - Click SQL Editor (left panel). 
 - Scroll down to "Safe Updates" and uncheck the box. 
 - Reconnect to MySQL instance to apply changes.

🚀 Effect: ✔ Now you can safely update multiple rows without errors.





📌 3. Using IN for More Flexible Updates:
✔ If multiple clients need updates, use IN (value1, value2, …) to target specific records.

📌 Example: Updating Invoices for Clients 3 and 4:
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE client_id IN (3, 4);

🚀 Effect: ✔ Expands the update to include invoices for clients 3 and 4, ensuring batch modifications.





📌 4. Exercise: Adding Loyalty Points to Customers Born Before 1990
🚀 Task: ✔ Increase loyalty points by 50 for all customers born before 1990.

📌 Expected Query Solution:
USE sql_store;

UPDATE customers 
SET points = points + 50 
WHERE birth_date < '1990-01-01';

🚀 Effect: ✔ Modifies all customers born before 1990, boosting their loyalty points.

📌 Verifying Updated Data:
SELECT * FROM customers WHERE birth_date < '1990-01-01';

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ BirthDate │ Points    │ Status    │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ 1985-06-15│ 250       │ Active    │ ✅ Updated
│ 8         │ 1978-02-22│ 220       │ Active    │ ✅ Updated
└───────────┴───────────┴───────────┴───────────┘
✔ Each customer born before 1990 now has 50 extra points.





Queries used in this discussion: 

UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id = 3;


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id IN (3, 4);


Exercise: 

-- Write a SQL statement to 
-- 	   give any customers born before 1990
--     50 extra points 


USE sql_store;

UPDATE customers 
SET points = points + 50 
WHERE birth_date < '1990-01-01';





📌 Summary
✔ Use UPDATE to modify multiple rows, targeting them via WHERE. 
✔ Safe Update Mode in MySQL Workbench must be disabled to avoid errors. 
✔ Using IN allows flexible multi-row updates, improving efficiency. 
✔ Expressions (points + 50) enable dynamic updates instead of manual values. 












Using Subqueries in updates:
----------------------------

🚀 Using Subqueries in SQL Updates
Subqueries enhance SQL updates by dynamically retrieving values, making updates more precise and scalable. This tutorial covers how to use subqueries in UPDATE statements, handle multiple records, and follow best practices to prevent accidental updates.

📌 1️⃣ Understanding Subqueries in Updates
✔ A subquery is a SELECT statement nested within another SQL statement. ✔ It retrieves dynamic values used in UPDATE conditions.

📌 Example: Updating Invoices for a Client Based on Name

sql
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE client_id = 
        (SELECT client_id
        FROM clients
        WHERE name = 'Myworks');
🚀 Effect: ✔ Finds the client ID for "Myworks" and updates all their invoices accordingly.

📌 Why Use a Subquery Instead of Hardcoding IDs? ✔ Eliminates manual entry errors. ✔ Ensures dynamic retrieval of IDs based on user input.

📌 2️⃣ Handling Multiple Records in Subqueries
✔ If a subquery returns multiple results, we must use the IN operator instead of =.

📌 Example: Updating Invoices for Clients in Specific States

sql
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE client_id IN 
        (SELECT client_id
        FROM clients
        WHERE state IN ('CA', 'NY'));
🚀 Effect: ✔ Updates invoices for all clients located in California and New York.

📌 Verifying the Query Before Execution

sql
SELECT client_id 
FROM clients 
WHERE state IN ('CA', 'NY');
🚀 Effect: ✔ Ensures correct records are targeted, preventing unintended updates.

📌 Example Output

┌───────────┐
│ ClientID  │
├───────────┤
│ 1         │ ✅ CA Client
│ 3         │ ✅ NY Client
└───────────┘
✔ Using IN allows multi-client updates efficiently.

📌 3️⃣ Best Practice: Verifying Updates Before Execution
✔ Always run a SELECT query first to preview affected rows.

📌 Example: Checking Invoices With No Payments Before Updating

sql
SELECT * FROM invoices WHERE payment_date IS NULL;
🚀 Effect: ✔ Displays records that will be updated, preventing mistakes.

📌 If Correct, Proceed With Update

sql
UPDATE invoices 
SET 
    payment_total = invoice_total * 0.5, 
    payment_date = due_date
WHERE payment_date IS NULL;
✔ Ensures only unpaid invoices are updated.

📌 4️⃣ Exercise: Updating Orders for Gold Customers
🚀 Task: ✔ Find customers with more than 3000 points and update order comments to "Gold Customer".

📌 Expected Query Solution

sql
UPDATE orders
SET comments = 'Gold Customer'
WHERE customer_id IN 
        (SELECT customer_id
        FROM customers 
        WHERE points > 3000);
🚀 Effect: ✔ Updates orders for high-loyalty customers, marking them as Gold Customers.

📌 Example Output

┌───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ Comments  │
├───────────┼───────────┼───────────┤
│ 25        │ 5        │ Gold Customer │ ✅ High Loyalty
│ 34        │ 8        │ Gold Customer │ ✅ High Loyalty
└───────────┴───────────┴───────────┘
✔ Correct records are updated dynamically.







Queries used in this discussion: 

UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id = 
		(SELECT client_id
		FROM clients
		WHERE name = 'Myworks');

-- the sub query is a select statement and is within another SQL statement


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id IN 
		(SELECT client_id
		FROM clients
		WHERE state IN ('CA', 'NY'));
		
		
		
UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE payment_date IS NULL
	
	
-- So, as a best practice before executing your update statement, run your query to see what records you're going to update
-- So, you don't accidentally update the records that shouldn't be updated. 



Exercise: 

UPDATE orders
SET comments = 'Gold Customer'
WHERE customer_id IN 
		(SELECT customer_id
		FROM customers 
		WHERE points > 3000);
		
		
		




📌 Summary
✔ Use subqueries in UPDATE statements for dynamic, accurate updates. 
✔ Replace hardcoded values with subqueries to retrieve data automatically. 
✔ Use IN for multi-record updates when subqueries return multiple results. 
✔ Always verify records before executing updates using a SELECT statement. 




		
		
		
		
		
		
		







Deleting Rows:
--------------
🚀 Deleting Rows in SQL:
The DELETE FROM statement in SQL allows removing specific records from a table. This tutorial covers how to delete individual rows, bulk delete using conditions, and safely using subqueries to target related data.

📌 1. Using DELETE FROM to Remove a Single Record
✔ The basic syntax for deleting data from a table requires specifying a condition in WHERE.

📌 Example: Deleting Invoice with ID 1:
DELETE FROM invoices  
WHERE invoice_id = 1;

🚀 Effect: ✔ Removes the invoice with ID 1 from the table.

📌 Verifying the Deletion:
SELECT * FROM invoices WHERE invoice_id = 1;

🚀 Effect: ✔ If the query returns no records, the deletion was successful.





📌 2. Warning: Deleting All Records Without WHERE
✔ If WHERE is omitted, ALL rows in the table are deleted. 
✔ This cannot be undone unless backups exist.

📌 Example of a Dangerous Query:
DELETE FROM invoices;  -- ❌ Deletes ALL records!

🚀 Effect: ✔ Removes all rows in the invoices table, wiping out all stored data.

📌 Best Practice ✔ Always double-check queries before execution to prevent accidental deletions.





📌 3. Using Subqueries to Delete Rows Based on Related Data
✔ Subqueries help dynamically retrieve conditions for deletion.

📌 Example: Deleting Invoices for a Specific Client (Using Subquery)
DELETE FROM invoices  
WHERE client_id = (
        SELECT client_id  
        FROM clients  
        WHERE name = 'MyWorks'
);

🚀 Effect: ✔ Finds the client ID for "MyWorks" and deletes all their invoices.

📌 Verifying Before Deletion:
SELECT client_id  
FROM clients  
WHERE name = 'MyWorks';

🚀 Effect: ✔ Ensures correct client is targeted, preventing unintended deletions.

📌 Example Output of Subquery:
┌───────────┐
│ ClientID  │
├───────────┤
│ 2         │ ✅ MyWorks
└───────────┘
✔ Client ID 2 is dynamically retrieved, ensuring precise deletions.





Queries used in this discussion: 

DELETE FROM invoices  
WHERE invoice_id =1; 

-- without where statement, will delete all the records from the particular table


DELETE FROM invoices  
WHERE client_id = (
        SELECT * 
		FROM clients
		WHERE name = 'Myworks');





📌 Summary
✔ DELETE FROM removes records using specific conditions. 
✔ Always include WHERE to avoid deleting all rows unintentionally. 
✔ Use subqueries for dynamic deletions, ensuring accuracy and efficiency. 




		
		
		
		
		









Restoring the Databases: 
------------------------
🚀 Restoring Databases to Their Original State:
After modifying databases through inserting, updating, and deleting data, restoring them to their original state ensures consistency for future operations.

📌 1. Why Restore the Databases?
✔ Modifications made in this section (data insertions, updates, deletions) alter the datasets. 
✔ If databases are not restored, queries in future lessons may produce different results. 
✔ Resetting databases maintains a structured learning environment.





📌 2. Steps to Restore Databases in MySQL Workbench
✔ The quickest way to reset databases is by executing a SQL script.

📌 Follow these steps: 
 - Open MySQL Workbench. 
 - Go to the "File" menu → Click "Open SQL Script". 
 - Navigate to the directory where the SQL script (create_databases.sql) is stored.

If the directory is lost, refer to the first section of the course for downloading supplementary materials. 
 - Select the script → Click "Open". 
 - Execute the script to recreate all databases.





📌 3. Refreshing the Navigator Panel
✔ After execution, databases may disappear from the navigator panel. 
✔ To make them visible again:

Click the "Refresh" icon in the navigator panel.

Verify that all databases reappear, ensuring successful restoration.





📌 Summary
✔ Restoring databases ensures data consistency for future queries. 
✔ Executing a SQL script (create_databases.sql) resets all tables and records. 
✔ Refreshing the navigator panel re-displays the restored databases. 














Summarizing Data:
-----------------

Aggregate Functions:
--------------------
🚀 Understanding Aggregate Functions in SQL
Aggregate functions summarize data by performing calculations across multiple rows, helping businesses analyze sales, revenue, and performance trends.

📌 1. What Are Aggregate Functions?
✔ Aggregate functions process multiple rows to return a single summary value. 
✔ These functions operate on numerical, date, and string data types.

📌 Common Aggregate Functions:
Function	Description
MAX()	    Returns the highest value in a column.
MIN()	    Returns the lowest value in a column.
AVG()	    Calculates the average of numeric values.
SUM()	    Computes the total sum of column values.
COUNT()	    Counts the number of records in a column.





📌 2. Using Aggregate Functions in Queries
✔ Apply aggregate functions to summarize invoices and payments.

📌 Example: Calculating Summary Statistics for Invoices

SELECT 
    MAX(invoice_total) AS highest, 
    MIN(invoice_total) AS lowest, 
    AVG(invoice_total) AS average,
    SUM(invoice_total) AS total,
    COUNT(invoice_total) AS number_of_invoices,
    COUNT(payment_date) AS count_of_payments,
    COUNT(*) AS total_records
FROM invoices;

🚀 Effect: ✔ Retrieves highest invoice amount, lowest invoice amount, average invoice, total sales, and record count.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ Highest   │ Lowest    │ Average   │ Total     │ Invoices  │ Payments  │ Records   │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ 189.00    │ 72.50     │ 150.20    │ 2550.75   │ 17        │ 15        │ 17        │
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Total invoices processed: 17 ✔ Total payments recorded: 15 ✔ Total revenue: $2,550.75





📌 3. Handling NULL Values in Aggregate Functions
✔ Aggregate functions ignore NULL values unless explicitly handled.

📌 Example: Counting Only Non-NULL Payments:
SELECT COUNT(payment_date) AS count_of_payments 
FROM invoices;

🚀 Effect: ✔ Only invoices with recorded payment dates are counted.

📌 Alternative: Counting ALL Records, Including NULL Values:
SELECT COUNT(*) AS total_records 
FROM invoices;

🚀 Effect: ✔ Counts all invoices, regardless of payment status.

📌 Example Output Difference:
COUNT(payment_date) → 15 (Only invoices with payments)
COUNT(*) → 17 (Includes unpaid invoices)

✔ Always verify how NULL values impact calculations.





📌 4. Using Expressions in Aggregate Functions
✔ We can apply mathematical operations within aggregate functions.

📌 Example: Calculating Total Sales With a 10% Tax Increase:
SELECT SUM(invoice_total * 1.1) AS total_sales_tax_included
FROM invoices;

🚀 Effect: ✔ Computes total revenue, including a 10% tax adjustment.

📌 Example Output:
SUM(invoice_total) → $2,550.75
SUM(invoice_total * 1.1) → $2,805.82 (After 10% increase)





📌 5. Filtering Aggregate Results
✔ Adding filters refines calculations, extracting insights from specific periods.

📌 Example: Calculating Sales Only for Second Half of the Year:
SELECT 
    SUM(invoice_total) AS total_sales
FROM invoices
WHERE invoice_date > '2019-07-01';

🚀 Effect: ✔ Retrieves total sales only for invoices issued after July 1, 2019.

📌 Example Output:
┌────────────┐
│ Total Sales│
├────────────┤
│ 1350.25    │ ✅ Revenue from second half of 2019
└────────────┘





📌 6. Using DISTINCT With Aggregate Functions
✔ Aggregate functions count ALL values, but use DISTINCT to filter unique entries.

📌 Example: Counting Unique Clients:
SELECT COUNT(DISTINCT client_id) AS unique_clients
FROM invoices
WHERE invoice_date > '2019-07-01';

🚀 Effect: ✔ Ensures each client is counted only once, avoiding duplicates.

📌 Example Output:
COUNT(client_id) → 7 (Counts all invoices with client IDs)
COUNT(DISTINCT client_id) → 3 (Counts unique clients)





📌 7. Exercise: Generating a Sales Report by Date Range
🚀 Task: ✔ Create a report to summarize sales, payments, and expected revenue for:
First half of 2019
Second half of 2019
Full year total

📌 Expected Query Solution:

SELECT 
    'First half of 2019' AS date_range, 
    SUM(invoice_total) AS total_sales, 
    SUM(payment_total) AS total_payments, 
    SUM(invoice_total - payment_total) AS expected_revenue
FROM invoices 
WHERE invoice_date BETWEEN '2019-01-01' AND '2019-06-30'
UNION 
SELECT 
    'Second half of 2019' AS date_range, 
    SUM(invoice_total) AS total_sales, 
    SUM(payment_total) AS total_payments, 
    SUM(invoice_total - payment_total) AS expected_revenue
FROM invoices 
WHERE invoice_date BETWEEN '2019-07-01' AND '2019-12-31'
UNION 
SELECT 
    'Total' AS date_range, 
    SUM(invoice_total) AS total_sales, 
    SUM(payment_total) AS total_payments, 
    SUM(invoice_total - payment_total) AS expected_revenue
FROM invoices 
WHERE invoice_date BETWEEN '2019-01-01' AND '2019-12-31';

🚀 Effect: ✔ Provides a structured sales analysis across different periods.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ DateRange │ Sales     │ Payments  │ Expected  │
├───────────┼───────────┼───────────┼───────────┤
│ 1H 2019   │ 1200.00   │ 1050.00   │ 150.00    │
│ 2H 2019   │ 1350.25   │ 1280.50   │ 69.75     │
│ Total     │ 2550.75   │ 2330.50   │ 220.25    │
└───────────┴───────────┴───────────┴───────────┘

✔ First half vs. second half revenue comparison ✔ Final total for the year





Queries and other notes in this discussion: 

-- MAX()
-- MIN()
-- AVG()
-- SUM()
-- COUNT()


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total) AS total,
	COUNT(invoice_total) AS number_of_invoices,
	COUNT(payment_date) AS count_of_payments,
	COUNT(*) AS total_records
FROM invoices; 

SELECT 
	MAX(payment_date) AS highest
FROM invoices;	


-- SUM(invoice_total * 1.1 ) AS total,


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total * 1.1) AS total,
	COUNT(*) AS total_records
FROM invoices
WHERE invoice_date > '2019-07-01';


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total * 1.1) AS total,
	COUNT(DISTINCT client_id) AS total_records
FROM invoices
WHERE invoice_date > '2019-07-01';



Exercise:

SELECT 
	'First half of 2019' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-01-01' AND '2019-06-30'
UNION 
SELECT 
	'Second half of 2019' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-07-01' AND '2019-12-31'
UNION 
SELECT 
	'Total' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-01-01' AND '2019-12-31';
	
	
	


📌 Summary
✔ Aggregate functions provide summarized insights, crucial for business analytics. 
✔ Use filters (WHERE invoice_date > …) to analyze specific periods. 
✔ Apply DISTINCT to count unique values, ensuring accurate reporting. 
✔ Expressions within aggregates (SUM(invoice_total * 1.1)) refine calculations dynamically. 







	
	
	
	
	
	
	
	
	
	
	
	
The GROUP BY Clause:
--------------------
🚀 Understanding the GROUP BY Clause in SQL
Grouping data using the GROUP BY clause helps organize records into meaningful categories based on specific column values, allowing businesses to analyze sales, payments, and trends effectively.

📌 1. What Does GROUP BY Do?
✔ GROUP BY groups records with matching column values, applying aggregate functions to summarize each group. 
✔ Used with SUM(), COUNT(), AVG(), MAX(), MIN(), and more.

📌 Example: Calculating Total Sales Using SUM():
SELECT SUM(invoice_total) AS total_sales
FROM invoices;

🚀 Effect: ✔ Returns a single total sales value.

📌 Example Output:
┌───────────┐
│ TotalSales│
├───────────┤
│ 2550.75   │ ✅ All invoices combined
└───────────┘
✔ Useful but lacks detailed insights per client or region.





📌 2. Grouping Data By a Single Column:
✔ If we want total sales per client, we group by client_id.

📌 Example: Total Sales Per Client:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
ORDER BY total_sales DESC;

🚀 Effect: ✔ Groups invoices by client ID, summarizing their total spending.

📌 Example Output:
┌───────────┬───────────┐
│ ClientID  │ TotalSales│
├───────────┼───────────┤
│ 5         │ 720.00    │ ✅ Highest spender
│ 3         │ 610.50    │
│ 1         │ 545.25    │
└───────────┴───────────┘
✔ Now we know which clients generate the highest revenue.


📌 Adding a Filter Before Grouping ✔ We can limit the dataset before grouping using WHERE.

🚀 Example: Filter for Second Half of the Year:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales
FROM invoices
WHERE invoice_date >= '2019-07-01'
GROUP BY client_id
ORDER BY total_sales DESC;

✔ Summarizes sales per client, but only for invoices issued after July 1, 2019.





📌 3. Grouping Data By Multiple Columns
✔ Sometimes, we need a more detailed breakdown—for example, sales per state and city.

📌 Example: Grouping by State and City:
SELECT 
    state,
    city,
    SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients USING (client_id)
GROUP BY state, city;

🚀 Effect: ✔ Displays total sales for each state and city combination.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ State     │ City      │ TotalSales│
├───────────┼───────────┼───────────┤
│ CA        │ San Diego │ 520.00    │
│ NY        │ Buffalo   │ 450.75    │
└───────────┴───────────┴───────────┘
✔ Allows region-specific analysis.

📌 Why Use Multiple Columns? ✔ Provides granular breakdowns for deeper insights. ✔ Essential for regional sales comparisons.





📌 4. Exercise: Summarizing Payments by Date and Payment Method
🚀 Task: ✔ Generate a report showing total payments for each date and payment method.

📌 Expected Query Solution:
SELECT 
    date,
    pm.name AS payment_method,
    SUM(amount) AS total_payments
FROM payments p
JOIN payment_methods pm
    ON p.payment_method = pm.payment_method_id
GROUP BY date, payment_method 
ORDER BY date;

🚀 Effect: ✔ Displays how payments were received per day.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ Date      │ Method    │ TotalPaid │
├───────────┼───────────┼───────────┤
│ 2025-01-08│ CreditCard│ 32.00     │
│ 2025-01-08│ Cash      │ 10.00     │
│ 2025-01-09│ WireTrnsf │ 25.50     │
└───────────┴───────────┴───────────┘
✔ Organizes payments efficiently for better financial tracking.





📌 5. Understanding SQL Query Execution Order
✔ Queries follow a strict order for execution.

📌 SQL Execution Order:
1.SELECT → Retrieves data.
2.FROM → Specifies the table.
3.WHERE → Filters data.
4.GROUP BY → Groups results into categories.
5.ORDER BY → Sorts the final output.

✔ Always place GROUP BY before ORDER BY, or else SQL throws a syntax error.





Queries used in this discussion: 

SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
ORDER BY DESC



SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
WHERE invoice_date >= '2019-07-01'
GROUP BY client_id
ORDER BY DESC;




SELECT 
	state,
	city
	SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients USING (client_id)
GROUP BY state, city;


Exercise: 

SELECT 
	date,
	pm.name AS payment_method,
	SUM(amount) AS total_payments
FROM payments p
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
GROUP BY date, payment_method 
ORDER BY date;






📌 Summary
✔ GROUP BY organizes data into meaningful groups, improving reporting. 
✔ Use SUM() and COUNT() with GROUP BY to compute totals per group. 
✔ Filter data first (WHERE), then group it (GROUP BY). 
✔ Use multiple columns to refine summaries, like sales per state and city. 


















The HAVING Clause:
------------------
🚀 Understanding the HAVING Clause in SQL
The HAVING clause filters grouped data, ensuring aggregated results meet specific conditions. This tutorial covers how HAVING differs from WHERE, using multiple conditions, and practical examples for real-world applications.

📌 1. Difference Between WHERE and HAVING
✔ WHERE filters records before grouping, while HAVING filters after grouping. 
✔ HAVING is used with aggregate functions, whereas WHERE filters individual rows.

📌 Example: Filtering Clients With Sales Over $500:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
HAVING total_sales > 500;

🚀 Effect: ✔ Groups invoices by client ID, then filters out clients with less than $500 in total sales.

📌 Example Output:
┌───────────┬───────────┐
│ ClientID  │ TotalSales│
├───────────┼───────────┤
│ 5         │ 720.00    │ ✅ High-spending client
│ 3         │ 610.50    │ ✅ High-spending client
└───────────┴───────────┘

✔ Client 2 is excluded because their total sales are below $500.

📌 Incorrect Use of WHERE:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales
FROM invoices
WHERE total_sales > 500  -- ❌ Error! Column not yet aggregated
GROUP BY client_id;

🚀 Effect: ✔ Returns an error because total_sales doesn’t exist before aggregation. ✔ Use HAVING instead to filter grouped results.





📌 2. Using Multiple Conditions in HAVING
✔ Combine multiple conditions for refined queries.

📌 Example: Filtering Clients With High Sales and Multiple Invoices:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales,
    COUNT(*) AS number_of_invoices
FROM invoices
GROUP BY client_id
HAVING total_sales > 500 AND number_of_invoices > 5;

🚀 Effect: ✔ Filters clients with at least $500 in total sales AND more than 5 invoices.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Sales     │ Invoices  │
├───────────┼───────────┼───────────┤
│ 5         │ 720.00    │ 8         │ ✅ High-spending & frequent buyer
│ 3         │ 610.50    │ 6         │ ✅ High-spending & frequent buyer
└───────────┴───────────┴───────────┘
✔ Clients with fewer than 5 invoices are excluded.

📌 Rules for HAVING Conditions ✔ Every column in HAVING must be in SELECT, unlike WHERE. ✔ Ensure aggregation occurs first before filtering.





📌 3. Exercise: Finding High-Spending Customers in Virginia
🚀 Task: ✔ Retrieve customers in Virginia who have spent more than $100.

📌 Expected Query Solution:
USE sql_store; 

SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    SUM(oi.quantity * oi.unit_price) AS total_sales  
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE state = 'VA'
GROUP BY 
    c.customer_id,
    c.first_name,
    c.last_name
HAVING total_sales > 100;
🚀 Effect: ✔ Identifies high-spending customers in Virginia.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ LastName  │ TotalSpent│
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ Alice     │ Thompson  │ 157.00    │ ✅ High spender in VA
└───────────┴───────────┴───────────┴───────────┘
✔ Only customers in Virginia with over $100 spent are listed.

📌 Steps Used:
 - Filtered Virginia customers using WHERE state = 'VA'. 
 - Joined orders and order_items to calculate total spending. 
 - Grouped by customer ID, first name, and last name. 
 - Filtered final results with HAVING total_sales > 100.





Queries used in this discussion: 

SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id



SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
-- WHERE total_sales > 500      -- not possible 
GROUP BY client_id


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
HAVING total_sales > 500 


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
	COUNT(*) AS number_of_invoices
FROM invoices
GROUP BY client_id
HAVING total_sales > 500 AND number_of_invoices > 5


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
	COUNT(*) AS number_of_invoices
FROM invoices
GROUP BY client_id
HAVING payment_date   -- wrong


Exercise: 

-- Get the customers
-- 		located in Virginia
--		who have spent more than $100


USE sql_store; 

SELECT 
	c.customer_id,
	c.first_name,
	c.last_name,
	SUM(oi.quantity * oi.unit_price) AS total_sales  
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE state = 'VA'
GROUP BY 
	c.customer_id,
	c.first_name,
	c.last_name
HAVING total_sales > 100;





📌 Summary
✔ Use WHERE to filter records before aggregation, and HAVING after grouping. 
✔ Ensure every column in HAVING is part of SELECT. 
✔ Combine multiple conditions (HAVING total_sales > X AND invoices > Y) for precise filtering. 

















The ROLLUP Operator:
--------------------
🚀 Understanding the ROLLUP Operator in SQL
The ROLLUP operator in SQL extends aggregate functions by providing additional summary rows, making data analysis more efficient.

📌 1. What Is the ROLLUP Operator?
✔ ROLLUP automatically generates subtotal and grand total rows, summarizing data within groups. 
✔ It works with GROUP BY to provide hierarchical totals.

📌 Example: Calculating Total Sales Per Client:
SELECT 
    client_id,
    SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id WITH ROLLUP;
🚀 Effect: ✔ Displays total sales for each client, plus a grand total row.

📌 Example Output:
┌───────────┬───────────┐
│ ClientID  │ TotalSales│
├───────────┼───────────┤
│ 1         │ 500.00    │ ✅ Individual Client Total
│ 2         │ 450.00    │ ✅ Individual Client Total
│ 3         │ 900.00    │ ✅ Individual Client Total
│ NULL      │ 1850.00   │ ✅ Grand Total (ALL Clients)
└───────────┴───────────┘
✔ The last row represents the grand total, with NULL in client_id.





📌 2. Grouping by Multiple Columns:
✔ When multiple columns are grouped, ROLLUP provides subtotals for each group level.

📌 Example: Grouping by State and City:
SELECT 
    state,
    city,
    SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients c USING (client_id)
GROUP BY state, city WITH ROLLUP;

🚀 Effect: ✔ Computes total sales per city, total per state, and an overall grand total.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ State     │ City      │ TotalSales│
├───────────┼───────────┼───────────┤
│ CA        │ SanFran   │ 820.00    │ ✅ City Total
│ CA        │ NULL      │ 820.00    │ ✅ State Total (California)
│ NY        │ Buffalo   │ 650.00    │ ✅ City Total
│ NY        │ NULL      │ 650.00    │ ✅ State Total (New York)
│ NULL      │ NULL      │ 1470.00   │ ✅ Grand Total (All States)
└───────────┴───────────┴───────────┘
✔ Each state has a total, and a grand total for all states is included.





📌 3. Exercise: Summarizing Payments Using ROLLUP
🚀 Task: ✔ Generate a payment report showing the total amount received for each method and the overall total.

📌 Expected Query Solution:
SELECT 
    pm.name AS payment_method,
    SUM(amount) AS total
FROM payments p
JOIN payment_methods pm
    ON p.payment_method = pm.payment_method_id
GROUP BY pm.name WITH ROLLUP;

🚀 Effect: ✔ Displays total payments per method, plus an overall total row.

📌 Example Output:
┌───────────┬───────────┐
│ Method    │ TotalPaid │
├───────────┼───────────┤
│ CreditCard│ 320.00    │ ✅ Individual Method Total
│ Cash      │ 150.00    │ ✅ Individual Method Total
│ WireTransf│ 90.50     │ ✅ Individual Method Total
│ NULL      │ 560.50    │ ✅ Grand Total (All Methods)
└───────────┴───────────┘
✔ The last row provides the overall total for all payment methods.

📌 Important Detail ✔ Column aliases (payment_method) cannot be used in GROUP BY WITH ROLLUP, so we must use actual column names (pm.name) instead.





Queries used in this discussion: 

SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id WITH ROLLUP;


SELECT 
	state,
	city
	SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients c USING (client_id)
GROUP BY state, city WITH ROLLUP;



Exercise: 
SELECT 
	pm.name AS payment_method,
	SUM(amount) AS total
FROM payments p
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
GROUP BY pm.name WITH ROLLUP;   -- when we use the rollup operator, we cannot use the column alias in the group by clause, we need to provide actual column name





📌 Summary
✔ The ROLLUP operator adds subtotal and grand total rows, enhancing aggregated reports. 
✔ Works with GROUP BY to structure hierarchical calculations. 
✔ Provides automatic breakdowns across multiple columns, showing summary values at different levels. 
✔ Next steps: Exploring advanced SQL grouping techniques like CUBE and GROUPING SETS.


















Writing Complex Query:
----------------------


Introduction: 
-------------
In this section we're going to learn how to write complex queries in sql. Mostly we're going to revisit sub queries that you learned about earlier in the course, a sub query is a select statement that is within another sql statement. In this section we're going to take a closer look at these sub queries, we're going to work on lots of examples that help you master writing complex queries. 

Now before getting started, I want you to restore all of our databases to their original state, because earlier in the course we added some new records we updated existing ones, I want to make sure that going forward we both have the exact same data set. So what I show you in these videos look exactly the same on your computer. 
So here in mysql workbench, on the top go to the file menu, and then open sql script. Then browse to the folder where you stored all the scripts for creating these databases, in case you lost that folder, simply go back to the first section there is a lecture for downloading this script. Now in this list, open create databases, this will recreate all of our databases. So we'll have the exact same data set. Now to execute this either click on this icon here or use your shortcut. There you go, all of my databases are restored to their original state, beautiful. Now let's jump in and get started.



Subqueries:
-----------
🚀 Understanding Subqueries in SQL
A subquery is a SELECT statement nested within another SQL statement, allowing dynamic value retrieval. This tutorial covers how subqueries work, where they can be used, and practical examples.

📌 1. What Is a Subquery?
✔ A subquery is evaluated before the outer query executes. 
✔ The result of the subquery is used as a condition or value in the main query.

📌 Example: Finding Products More Expensive Than "Lettuce":

SELECT * 
FROM products
WHERE unit_price > (
        SELECT unit_price
        FROM products 
        WHERE product_id = 3
);

🚀 Effect: ✔ Retrieves all products priced higher than "Lettuce", dynamically comparing against its price.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Price     │
├───────────┼───────────┼───────────┤
│ 5         │ Steak     │ 15.99     │ ✅ More expensive than Lettuce
│ 7         │ Salmon    │ 22.50     │ ✅ More expensive than Lettuce
└───────────┴───────────┴───────────┘
✔ Only products exceeding the price of Lettuce (product_id = 3) are listed.

📌 How It Works: 
 - Subquery (SELECT unit_price FROM products WHERE product_id = 3) retrieves Lettuce's price. 
 - Outer query (WHERE unit_price > (…)) filters all products priced higher than the retrieved value.





📌 2. Types of Subquery Placement:
✔ Subqueries can appear in different parts of SQL queries:

📌 Subquery in WHERE Clause ✔ Filters based on computed values.

SELECT * FROM employees
WHERE salary > (
        SELECT AVG(salary)
        FROM employees
);

🚀 Effect: ✔ Retrieves employees earning above the average salary.


📌 Subquery in SELECT Clause ✔ Returns computed values alongside main query results.

SELECT name, 
    (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees;

🚀 Effect: ✔ Displays each employee’s name alongside the company-wide average salary.


📌 Subquery in FROM Clause ✔ Acts like a temporary table within the main query.

sql
SELECT e.name, s.avg_salary
FROM employees e
JOIN (
    SELECT AVG(salary) AS avg_salary FROM employees
) s;

🚀 Effect: ✔ Joins employee data with calculated average salary.





📌3. Exercise: Finding Employees Who Earn Above Average

🚀 Task: ✔ Retrieve all employees earning more than the average salary.

📌 Expected Query Solution

SELECT *
FROM employees
WHERE salary > (
        SELECT AVG(salary)
        FROM employees
);

🚀 Effect: ✔ Dynamically filters employees based on computed average salary.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ EmpID     │ Name      │ Salary    │
├───────────┼───────────┼───────────┤
│ 6         │ Alice     │ 65,000    │ ✅ Above average salary
│ 9         │ John      │ 72,500    │ ✅ Above average salary
└───────────┴───────────┴───────────┘
✔ Only employees earning more than the average are displayed.

📌 Steps Used 
 - Subquery calculates the average salary (SELECT AVG(salary) FROM employees). 
 - Main query filters employees earning above this computed value.






Queries used in this discussion: 

-- Find products that are more
-- expensive than Lettuce(id = 3)


SELECT * 
FROM products
WHERE unit_price > (
		SELECT unit_price
		FROM products 
		WHERE product_id = 3
)


Exercise:

--  In sql_hr database:
-- 		Find employees whose earn more than average


SELECT *
FROM employees
WHERE salary > (
		SELECT AVG(salary)
		FROM employees
)






📌 Summary
✔ Subqueries enable dynamic value retrieval, improving query flexibility. 
✔ Use subqueries in WHERE, SELECT, and FROM clauses to enhance efficiency. 
✔ Always verify subquery results independently before using them in a query. 











The IN Operator:
----------------
🚀 Using the IN Operator in SQL Subqueries
The IN operator allows filtering records based on a list of values, which can be dynamically generated using subqueries. This tutorial covers how to use IN for effective filtering, handling duplicates, and practical applications.

📌 1. Understanding the IN Operator in Subqueries
✔ The IN operator checks if a value exists within a list of specified values. 
✔ A subquery inside IN dynamically generates the list, eliminating manual entry.

📌 Example: Finding Products That Have Never Been Ordered

USE sql_store;

SELECT * 
FROM products 
WHERE product_id NOT IN (
        SELECT DISTINCT product_id
        FROM order_items
);

🚀 Effect: ✔ Retrieves all products that have never been included in any order.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Price     │
├───────────┼───────────┼───────────┤
│ 7         │ Broccoli  │ 2.50      │ ✅ Never ordered
└───────────┴───────────┴───────────┘
✔ Product ID = 7 is missing from order_items, so it appears in the results.





📌 2. Steps to Implement IN With Subqueries
✔ Step 1: Retrieve all ordered products from order_items.

SELECT DISTINCT product_id
FROM order_items;

✔ Step 2: Use this result inside NOT IN to exclude ordered products.

SELECT * 
FROM products 
WHERE product_id NOT IN (
        SELECT DISTINCT product_id 
        FROM order_items
);

🚀 Effect: ✔ The subquery dynamically generates the product list, removing manual filtering.





📌 3. Comparing Different Subquery Types
✔ Single-value subquery:

Example: "Find employees earning above the company average"

SELECT * 
FROM employees 
WHERE salary > (
        SELECT AVG(salary) 
        FROM employees
);
✔ List-based subquery (IN operator):

Example: "Find all clients with no invoices"

SELECT * 
FROM clients 
WHERE client_id NOT IN (
        SELECT DISTINCT client_id 
        FROM invoices
);
🚀 Effect: ✔ Finds clients missing from the invoices table, identifying those who haven’t made any purchases.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ Location  │
├───────────┼───────────┼───────────┤
│ 12        │ GreenCorp │ NY        │ ✅ Never invoiced
└───────────┴───────────┴───────────┘





📌 4. Exercise: Finding Clients Without Invoices
🚀 Task: ✔ Retrieve all clients who have never received an invoice.

📌 Expected Query Solution:

USE sql_invoicing; 

SELECT * 
FROM clients 
WHERE client_id NOT IN (
        SELECT DISTINCT client_id 
        FROM invoices
);
🚀 Effect: ✔ Returns clients who do not have any associated invoices.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ Location  │
├───────────┼───────────┼───────────┤
│ 15        │ SwiftTech │ TX        │ ✅ No invoices
└───────────┴───────────┴───────────┘
✔ Helps businesses identify inactive clients.





Queries used in this discussion: 

-- Find the products that have never been ordered

USE sql_store;

SELECT *
FROM products 
WHERE product_id NOT IN (
		SELECT DISTINCT product_id
		FROM order_items
)

Exercise: 

-- Find clients without invoices

USE sql_invoicing; 

SELECT *
FROM clients
WHERE client_id NOT IN (
	SELECT DISTINCT client_id
	FROM invoices
)





📌 5. Summary
✔ Use IN to check if values exist within a dynamically generated list. 
✔ NOT IN filters out values that appear in the subquery result. 
✔ The DISTINCT keyword prevents duplicate values, optimizing query performance. 















Subqueries vs Joins:
--------------------
🚀 Subqueries vs. Joins in SQL
Subqueries and joins both retrieve related data, but choosing between them depends on performance and readability. This tutorial covers how to rewrite subqueries as joins, when to use each method, and a practical comparison exercise.

📌 1. Understanding the Difference Between Subqueries and Joins
✔ Subqueries return data as part of another query, useful when filtering based on a single column or computed value. 
✔ Joins combine multiple tables, allowing more intuitive relationships between datasets.

📌 Example: Finding Clients Without Invoices (Using a Subquery)

SELECT *
FROM clients
WHERE client_id NOT IN (
    SELECT DISTINCT client_id
    FROM invoices
);
🚀 Effect: ✔ Retrieves clients who do not appear in the invoices table, meaning they have never made a purchase.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ Location  │
├───────────┼───────────┼───────────┤
│ 15        │ GreenCorp │ TX        │ ✅ No invoices
└───────────┴───────────┴───────────┘





📌 2. Rewriting a Subquery Using a Join
✔ Instead of filtering clients based on a subquery, we can use a LEFT JOIN.

📌 Example: Finding Clients Without Invoices (Using a Join)

SELECT *
FROM clients
LEFT JOIN invoices USING (client_id)
WHERE invoice_id IS NULL;
🚀 Effect: ✔ Retrieves all clients, but only displays those without an invoice.

📌 Which Approach Is Better? 
✔ If working with a simple exclusion (NOT IN), subqueries are more intuitive. 
✔ If joining related tables (clients & invoices), LEFT JOIN is more readable.





📌 3. Exercise: Finding Customers Who Ordered "Lettuce"
🚀 Task: ✔ Retrieve customers who ordered "Lettuce" (product_id = 3), displaying customer ID, first name, and last name.

Solution Using a Subquery:
USE sql_store;

SELECT customer_id, first_name, last_name  
FROM customers 
WHERE customer_id IN (
    SELECT o.customer_id
    FROM order_items oi
    JOIN orders o USING (order_id)
    WHERE product_id = 3
);
🚀 Effect: ✔ Retrieves customers who placed orders containing product ID 3.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ LastName  │
├───────────┼───────────┼───────────┤
│ 8         │ Alice     │ Johnson   │ ✅ Ordered Lettuce
│ 2         │ Bob       │ Smith     │ ✅ Ordered Lettuce
│ 10        │ Maria     │ Roberts   │ ✅ Ordered Lettuce
└───────────┴───────────┴───────────┘


Solution Using a Join:
SELECT DISTINCT customer_id, first_name, last_name 
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE oi.product_id = 3;
🚀 Effect: ✔ Uses a natural relationship between customers, orders, and order items to retrieve relevant results.


📌 Comparing Both Approaches 
✔ Subquery is more direct, as it retrieves customer IDs from order records. 
✔ Join is more readable, as it traces the natural flow of data across tables (customers → orders → order_items). 
✔ In this case, the join is preferable, as it provides clear visibility into relationships.





Queries used in this discussion: 

SELECT *
FROM clients
WHERE client_id NOT IN (
	SELECT DISTINCT client_id
	FROM invoices
)



SELECT *
FROM clients
LEFT JOIN invoices USING (client_id)
WHERE invoice_id IS NULL




Exercise: 
--  Find customers who have ordered lettuce (id = 3)
-- 		Select customer_id, first_name, last_name 


USE sql_store;


SELECT customer_id, first_name, last_name  
FROM customers 
WHERE cutomer_id IN (
	SELECT o.customer_id
	FROM order_items oi
	JOIN orders o USING (order_id)
	WHERE product_id = 3
)


SELECT DISTINCT customer_id, first_name, last_name 
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE oi.product_id = 3





📌 Summary
✔ Subqueries filter data based on computed results, suitable for exclusion queries (NOT IN). 
✔ Joins follow natural data relationships, making multi-table queries more readable. 
✔ Choose based on performance and readability—always analyze execution plans for efficiency. 















The ALL Keyword:
----------------
🚀 Understanding the ALL Keyword in SQL Subqueries
The ALL keyword allows comparison against multiple values retrieved by a subquery, ensuring the condition applies to all results. This tutorial covers how ALL works, when to use it, and its relationship with aggregate functions.

📌 1. Using a Subquery to Retrieve Invoices Larger Than All Invoices of Client 3
✔ To find invoices larger than every invoice issued by Client 3, we need to:
 - Retrieve the highest invoice total of Client 3 (MAX(invoice_total))
 - Use this value in a subquery to filter invoices

📌 Approach Using MAX():

USE sql_invoicing;

SELECT *
FROM invoices 
WHERE invoice_total > (
    SELECT MAX(invoice_total)
    FROM invoices
    WHERE client_id = 3
);
🚀 Effect: ✔ Filters invoices where invoice_total exceeds $167, which is Client 3's largest invoice.

📌 Example Output:
┌───────────┬───────────┬──────────────┐
│ InvoiceID │ ClientID  │ InvoiceTotal │
├───────────┼───────────┼──────────────┤
│ 18        │ 1         │ 185.00       │ ✅ Larger than Client 3's highest invoice
│ 20        │ 5         │ 190.50       │ ✅ Larger than Client 3's highest invoice
└───────────┴───────────┴──────────────┘
✔ Only invoices with totals greater than Client 3's highest invoice are selected.





📌 2. Using the ALL Keyword for Comparison Against Multiple Values
✔ Instead of using MAX(), we can compare invoices against all invoices from Client 3.

📌 Approach Using ALL:
SELECT *
FROM invoices 
WHERE invoice_total > ALL(
    SELECT invoice_total
    FROM invoices
    WHERE client_id = 3
);
🚀 Effect: ✔ Filters invoices greater than every invoice issued by Client 3.

📌 Example Output:
┌───────────┬───────────┬──────────────┐
│ InvoiceID │ ClientID  │ InvoiceTotal │
├───────────┼───────────┼──────────────┤
│ 18        │ 1         │ 185.00       │ ✅ Larger than ALL of Client 3’s invoices
│ 20        │ 5         │ 190.50       │ ✅ Larger than ALL of Client 3’s invoices
└───────────┴───────────┴──────────────┘
📌 How It Works 
 - Subquery retrieves all invoice totals from Client 3. 
 - Main query selects invoices where the total is greater than ALL subquery results.


📌 Technical Representation:
SELECT *
FROM invoices 
WHERE invoice_total > ALL(150, 130, 167,...);
✔ The query compares each invoice against every value in the subquery list.





📌 3. Comparing MAX() vs. ALL Approaches
Approach	Use Case	                                                   Comparison Type
MAX()	    When comparing against a single highest value	               WHERE invoice_total > (SELECT MAX(...))
ALL	        When ensuring values exceed every result in a subquery	       WHERE invoice_total > ALL(SELECT …)

📌 Which Method Is Better? ✔ Both approaches are interchangeable, but:
Use MAX() if filtering against a single value.
Use ALL if filtering against multiple values dynamically.

✔ In this case, ALL better aligns with the problem statement ("larger than all invoices of Client 3"), making it more intuitive.





Queries used in this discussion: 

-- Select invoices larger than all invoices of client 3

USE sql_invoicing;

SELECT *
FROM invoices 
WHERE invoice_total > (
	SELECT MAX(invoice_total)
	FROM invoices
	WHERE client_id = 3
)



SELECT *
FROM invoices 
WHERE invoice_total > ALL(
	SELECT invoice_total
	FROM invoices
	WHERE client_id = 3
)


The above subquery will be tecnically returned as:
SELECT *
FROM invoices 
WHERE invoice_total > ALL(150, 130, 167,...)





📌 Summary
✔ Use MAX() for single-value comparisons. 
✔ Use ALL to ensure a value exceeds ALL results in a subquery. 
✔ Both approaches can be rewritten interchangeably, depending on readability and intent. 


















The ANY Keyword:
----------------
🚀 Understanding the ANY Keyword in SQL Subqueries
The ANY keyword allows comparison against multiple values, ensuring a condition applies to at least one result from a subquery. This tutorial covers how ANY works, when to use it, and how it compares to the IN operator.

📌 1. Difference Between ALL and ANY
✔ ALL ensures a condition is met for every subquery result (> ALL = greater than all values). 
✔ ANY ensures a condition is met for at least one subquery result (> ANY = greater than at least one value). 
✔ SOME is an alias for ANY, meaning they can be used interchangeably.

📌 Example: Finding Invoices Larger Than Any Invoice of Client 3

SELECT *
FROM invoices 
WHERE invoice_total > ANY(
    SELECT invoice_total
    FROM invoices
    WHERE client_id = 3
);
🚀 Effect: ✔ Selects invoices with totals greater than at least one invoice issued by Client 3.

📌 Example Output:
┌───────────┬───────────┬──────────────┐
│ InvoiceID │ ClientID  │ InvoiceTotal │
├───────────┼───────────┼──────────────┤
│ 18        │ 1         │ 160.00       │ ✅ Greater than at least one invoice from Client 3
│ 20        │ 5         │ 170.50       │ ✅ Greater than at least one invoice from Client 3
└───────────┴───────────┴──────────────┘
✔ Unlike ALL, some invoices below the highest value of Client 3's invoices may still be selected.

📌 Technical Representation:

SELECT *
FROM invoices 
WHERE invoice_total > ANY(150, 130, 167,...);
✔ The query compares each invoice against at least one value in the subquery list.





📌 2. Using ANY to Select Clients With At Least Two Invoices
✔ Instead of filtering invoices one-by-one, we can group them by client and count occurrences.

📌 Step 1: Retrieve Clients With At Least Two Invoices

SELECT client_id
FROM invoices 
GROUP BY client_id
HAVING COUNT(*) >= 2;
🚀 Effect: ✔ Retrieves clients who have issued at least two invoices.

📌 Example Output:
┌───────────┐
│ ClientID  │
├───────────┤
│ 1         │ ✅ Issued 2+ invoices
│ 3         │ ✅ Issued 2+ invoices
│ 5         │ ✅ Issued 2+ invoices
└───────────┘





📌 3. Using IN vs ANY to Select These Clients
✔ Approach Using IN

SELECT *
FROM clients
WHERE client_id IN (
    SELECT client_id
    FROM invoices 
    GROUP BY client_id
    HAVING COUNT(*) >= 2
);
🚀 Effect: ✔ Selects clients present in the subquery list.


✔ Approach Using ANY (Equivalent to IN)

SELECT *
FROM clients
WHERE client_id = ANY(
    SELECT client_id
    FROM invoices 
    GROUP BY client_id
    HAVING COUNT(*) >= 2
);
🚀 Effect: ✔ Selects clients if their ID matches any result from the subquery.


📌 Comparing IN vs ANY:

Approach	Use Case	                                                    Comparison Type
IN	        Matches exact values from subquery results	                    WHERE column IN (SELECT …)
ANY	        Matches if condition applies to at least one subquery result	WHERE column = ANY(SELECT …)

✔ Both queries return the same results, but IN is more intuitive for matching exact values.




Queries used in this discussion:  

SELECT *
FROM invoices 
WHERE invoice_total > ANY(      --   you can also use 'SOME' 
	SELECT invoice_total
	FROM invoices
	WHERE client_id = 3
)


-- SELECT clients with at least two invoices 


SELECT *
FROM clients
WHERE client_id IN (
	SELECT client_id
	FROM invoices 
	GROUP BY client_id
	HAVING COUNT(*) >= 2
)


SELECT *
FROM clients
WHERE client_id = ANY(
	SELECT client_id
	FROM invoices 
	GROUP BY client_id
	HAVING COUNT(*) >= 2
)






📌 Summary
✔ Use ALL to compare values against every subquery result. 
✔ Use ANY to compare values against at least one subquery result. 
✔ SOME is interchangeable with ANY—use either based on preference. 
✔ IN and = ANY are equivalent—choose based on readability. 


















Correlated Subqueries:
----------------------

🚀 Understanding Correlated Subqueries in SQL
A correlated subquery is a subquery that executes once for each row in the main query, allowing comparisons based on dynamic calculations. This tutorial covers how correlated subqueries work, their differences from uncorrelated subqueries, and performance considerations.

📌 1. What Is a Correlated Subquery?
✔ A correlated subquery references a value from the outer query, meaning each row triggers a subquery execution. 
✔ Unlike regular subqueries, correlated subqueries depend on values in the main query.

📌 Example: Finding Employees With Salaries Above the Average in Their Office

USE sql_hr;

SELECT *
FROM employees e
WHERE salary > (
    SELECT AVG(salary)
    FROM employees
    WHERE office_id = e.office_id
);
🚀 Effect: ✔ Retrieves employees who earn above the average salary within their respective offices.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ EmpID     │ Name      │ Salary    │ OfficeID  │
├───────────┼───────────┼───────────┼───────────┤
│ 6         │ Alice     │ 65,000    │ 1         │ ✅ Above average for Office 1
│ 9         │ John      │ 72,500    │ 2         │ ✅ Above average for Office 2
└───────────┴───────────┴───────────┴───────────┘
✔ Average salary is calculated separately for each office, ensuring employee comparisons remain relevant.

📌 How It Works 
 - Outer query selects employees (SELECT * FROM employees e). 
 - Subquery calculates the average salary (SELECT AVG(salary) FROM employees WHERE office_id = e.office_id). 
 - Main query compares each employee’s salary against their office average (WHERE salary > (subquery)).





📌 2. Comparing Correlated vs. Uncorrelated Subqueries
✔ Uncorrelated subqueries execute ONCE, returning a fixed dataset. 
✔ Correlated subqueries execute ONCE PER ROW, adapting results dynamically.

📌 Example of an Uncorrelated Subquery ✔ Find employees earning above the company-wide average

SELECT *
FROM employees
WHERE salary > (
    SELECT AVG(salary)
    FROM employees
);
🚀 Effect: ✔ Compares salaries against a single company-wide average, rather than office-specific averages.

📌 Key Differences:

Type	        Execution Count	       Use Case
Uncorrelated	Once	               Returns a single result for filtering
Correlated	    Once per row	       Dynamically compares each row against computed values

✔ Uncorrelated subqueries are generally faster, while correlated subqueries allow contextual comparisons.





📌 3. Performance Considerations
✔ Correlated subqueries execute repeatedly, increasing computational overhead. 
✔ When handling large datasets, consider using joins or indexed queries for optimization.

📌 Example: Optimizing Using Joins Instead of Correlated Subqueries

sql
SELECT e.*
FROM employees e
JOIN (
    SELECT office_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY office_id
) a ON e.office_id = a.office_id
WHERE e.salary > a.avg_salary;

🚀 Effect: ✔ Precomputes office averages once, improving query efficiency.





📌 4. Exercise: Finding Invoices Larger Than the Client’s Average Invoice Amount
🚀 Task: ✔ Retrieve invoices where the total amount exceeds the average invoice total for that specific client.

📌 Expected Query Solution

USE sql_invoicing;

SELECT *
FROM invoices i
WHERE invoice_total > (
    SELECT AVG(invoice_total)
    FROM invoices 
    WHERE client_id = i.client_id
);
🚀 Effect: ✔ Retrieves only invoices exceeding the client's average invoice amount, ensuring a fair comparison.

📌 Example Output:
┌───────────┬───────────┬──────────────┐
│ InvoiceID │ ClientID  │ InvoiceTotal │
├───────────┼───────────┼──────────────┤
│ 2         │ 1         │ 320.00       │ ✅ Above client’s average invoice
│ 4         │ 3         │ 250.00       │ ✅ Above client’s average invoice
└───────────┴───────────┴──────────────┘
✔ Ensures invoices are filtered based on dynamic client-specific averages.

📌 Steps Used 
 - Subquery calculates each client’s average invoice total (SELECT AVG(invoice_total) FROM invoices WHERE client_id = i.client_id). 
 - Main query selects invoices where total exceeds this average (WHERE invoice_total > (subquery)). 
 - Each invoice is compared dynamically against its client’s historical invoices.





Queries used in this discussion:

-- Select employees whose salary is 
-- above the average in their office 


USE sql_hr; 

-- for each employee 
-- 		calculate the avg salary for employee.office
--  	return the employee if salary > avg



SELECT *
FROM employees e
WHERE salary > (
	SELECT AVG(salary)
	FROM employees
	WHERE office_id = e.office_id
)


Exercise: 

-- Get invoices that are larger than the 
-- Client's average invoice amount


USE sql_invoicing; 


SELECT *
FROM invoices i
WHERE invoice_total > (
	SELECT AVG(invoice_total)
	FROM invoices 
	WHERE client_id = i.client_id
)





📌 Summary
✔ Correlated subqueries execute once per row, enabling contextual comparisons. 
✔ Uncorrelated subqueries execute once, filtering against a static result set. 
✔ Performance can degrade with large datasets—use indexed joins for optimization. 























The EXISTS Opertor:
-------------------

🚀 Understanding the EXISTS Operator in SQL
The EXISTS operator efficiently checks whether a subquery returns any matching rows, making it useful for large datasets where performance matters.

📌 1. What Does the EXISTS Operator Do?
✔ EXISTS verifies if a subquery returns at least one matching row, without retrieving actual data. 
✔ Unlike the IN operator, which returns a complete list, EXISTS checks for existence and stops once a match is found.

📌 Example: Finding Clients Who Have an Invoice Using IN

sql
SELECT * 
FROM clients 
WHERE client_id IN ( 
        SELECT DISTINCT client_id
        FROM invoices
);
🚀 Effect: ✔ Retrieves clients whose IDs are present in the invoices table.


📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ Location  │
├───────────┼───────────┼───────────┤
│ 1         │ Alice     │ NY        │ ✅ Has invoices
│ 3         │ John      │ TX        │ ✅ Has invoices
└───────────┴───────────┴───────────┘





📌 2. Using EXISTS for More Efficient Filtering
✔ Instead of returning a full list of client IDs, EXISTS checks for matching entries dynamically.

📌 Example: Finding Clients Who Have an Invoice Using EXISTS

SELECT * 
FROM clients c
WHERE EXISTS ( 
    SELECT client_id
    FROM invoices
    WHERE client_id = c.client_id
);
🚀 Effect: ✔ Retrieves clients where at least one invoice exists, avoiding unnecessary full-list comparisons.

📌 Key Differences Between IN and EXISTS

Approach	Execution Behavior	                                     Performance Impact
IN	        Returns a full list of IDs, then filters records	     Slow with large datasets
EXISTS	    Checks for matches row-by-row, stopping at first match	 More efficient for large datasets

📌 When to Use EXISTS? 
✔ Use EXISTS when the subquery produces a large dataset (millions of rows). 
✔ Use IN when handling small lists (fewer than a few thousand rows).





📌 3. Exercise: Finding Products That Have Never Been Ordered
🚀 Task: ✔ Retrieve all products that do not appear in any order.

📌 Solution Using IN

USE sql_store; 

SELECT * 
FROM products 
WHERE product_id NOT IN (
    SELECT product_id 
    FROM order_items
);

🚀 Effect: ✔ Selects products missing from order_items, meaning they have never been ordered.


📌 Optimized Solution Using EXISTS:

SELECT * 
FROM products p
WHERE NOT EXISTS (
    SELECT product_id 
    FROM order_items
    WHERE product_id = p.product_id 
);

🚀 Effect: ✔ Dynamically checks each product for existence in order_items, improving efficiency.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Price     │
├───────────┼───────────┼───────────┤
│ 7         │ Broccoli  │ 2.50      │ ✅ Never ordered
└───────────┴───────────┴───────────┘
✔ Ensures only truly unpurchased products appear.





Queries used in this discussion:

-- Select clients that have an invoice 

SELECT * 
FROM clients 
WHERE client_id IN ( 
		SELECT DISTINCT client_id
		FROM invoices
)


SELECT * 
FROM clients c
WHERE  EXISTS ( 
	SELECT client_id
	FROM invoices
	WHERE client_id = c.client_id   -- more efficient if the IN operator returns a larger dataset 
)



Exercise: 

-- Find the products that have never been ordered 

USE sql_store; 


SELECT * 
FROM products 
WHERE product_id NOT IN (
	SELECT product_id 
	FROM order_items
)


SELECT * 
FROM products p
WHERE NOT EXISTS (
	SELECT product_id 
	FROM order_items
	WHERE product_id = p.product_id 
)






📌 Summary
✔ Use EXISTS for efficient existence checks, avoiding full-list retrieval. 
✔ IN works well for smaller datasets, but scales poorly for larger tables. 
✔ Both approaches achieve the same result, but EXISTS is faster when subqueries return large datasets. 

















Subqueries in the SELECT Clause:
--------------------------------
🚀 Using Subqueries in the SELECT Clause in SQL
Subqueries are not limited to WHERE clauses—they can also be used in the SELECT clause to compute additional values dynamically. This technique is useful for reporting and analytics, enabling column-level calculations.

📌 1. What Are Subqueries in the SELECT Clause?
✔ Subqueries within SELECT retrieve computed values for each row. 
✔ Used for dynamic calculations, such as totals, averages, and differences.

📌 Example: Creating an Invoice Report With Dynamic Columns 
✔ We need four columns: 
 - Invoice ID 
 - Invoice Total 
 - Invoice Average (average of all invoices) 
 - Difference (invoice total minus invoice average)


📌 Query Solution:

SELECT 
    invoice_id, 
    invoice_total, 
    (SELECT AVG(invoice_total) FROM invoices) AS invoice_average,
    invoice_total - (SELECT AVG(invoice_total) FROM invoices) AS difference
FROM invoices;
🚀 Effect: ✔ Dynamically computes the invoice average for all records.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ InvoiceID │ Total     │ Average   │ Difference│
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 250.00    │ 180.50    │ 69.50     │ ✅ Above average
│ 2         │ 150.00    │ 180.50    │ -30.50    │ ❌ Below average
└───────────┴───────────┴───────────┴───────────┘
✔ Allows comparison between individual invoice totals and the company-wide average.

📌 Why Use a Subquery Instead of a Separate Computation? 
✔ Ensures real-time dynamic calculation without requiring additional queries. 
✔ Avoids repetition—AVG(invoice_total) does not need to be manually computed elsewhere.





📌 2. Exercise: Generating a Client Sales Report
🚀 Task: ✔ Retrieve total sales for each client, comparing it against the average sales across all clients.

📌 Expected Query Solution

SELECT 
    client_id, 
    name,
    (SELECT SUM(invoice_total)
        FROM invoices
        WHERE client_id = c.client_id) AS total_sales, 
    (SELECT AVG(invoice_total) FROM invoices) AS average, 
    (SELECT SUM(invoice_total)
        FROM invoices
        WHERE client_id = c.client_id) - (SELECT AVG(invoice_total) FROM invoices) AS difference
FROM clients c;
🚀 Effect: ✔ Computes total sales per client, compares against the company-wide average, and calculates the difference dynamically.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│ Average   │ Difference│
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ 500.00    │ 150.00    │ ✅ Above average
│ 4         │ Beta Ltd  │ NULL      │ 500.00    │ NULL      │ ❌ No invoices
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Client 4 has no invoices, resulting in NULL values for total sales and difference.

📌 Steps Used: 
 - Retrieve each client's total sales using a correlated subquery (SUM(invoice_total) WHERE client_id = c.client_id). 
 - Compute the company-wide average sales using an uncorrelated subquery (AVG(invoice_total) FROM invoices). 
 - Calculate the difference between total client sales and the company average.





📌 3. Key Considerations When Using Subqueries in SELECT
✔ Avoid aliasing inside expressions (SELECT total_sales - average is invalid). 
✔ For correlated subqueries, prefix table aliases properly (c.client_id) to ensure accurate filtering. 
✔ Check for NULL values—if a client has no invoices, ensure the result handles empty data correctly.

📌 How to Handle NULL Values Gracefully ✔ Use COALESCE() to replace NULL values with default values

SELECT COALESCE((SELECT SUM(invoice_total) FROM invoices WHERE client_id = c.client_id), 0) AS total_sales
🚀 Effect: ✔ Ensures clients without invoices show 0 instead of NULL.





Queries used in this discussion:

SELECT 
	invoice_id, 
	invoice_total, 
	(SELECT AVG(invoice_total)
		FROM invoices) AS invoice_average
	invoice_total - (SELECT invoice_average) AS difference 
FROM invoices 



Exercise:

SELECT 
	client_id, 
	name,
	(SELECT SUM(invoice_total)
		FROM invoices
		WHERE client_id = c.client_id) AS total_sales 
	(SELECT AVG(invoice_total) FROM invoices) AS average 
	(SELECT total_sales - average) AS difference 
FROM clients c





📌 Summary
✔ Subqueries in SELECT dynamically compute additional columns, improving reporting accuracy. 
✔ Correlated subqueries filter based on individual rows, allowing row-specific calculations. 
✔ Uncorrelated subqueries return static values, such as overall averages.










Subqueries in the FROM clause:
------------------------------
🚀 Using Subqueries in the FROM Clause in SQL
Subqueries can be used not only in WHERE and SELECT clauses but also in the FROM clause, enabling dynamic table creation for advanced SQL operations.

📌 1. What Are Subqueries in the FROM Clause?
✔ Subqueries in FROM behave like temporary tables, allowing further filtering, aggregation, and joining. 
✔ They provide structured datasets, useful when the database lacks pre-existing summarized tables.

📌 Example: Generating a Sales Summary Table ✔ We need four columns: 
 - Client ID 
 - Client Name 
 - Total Sales (sum of all invoices per client) 
 - Difference from Average Sales

📌 Query Solution

SELECT *
FROM (
    SELECT 
        client_id, 
        name,
        (SELECT SUM(invoice_total)
            FROM invoices
            WHERE client_id = c.client_id) AS total_sales, 
        (SELECT AVG(invoice_total) FROM invoices) AS average, 
        (SELECT SUM(invoice_total)
            FROM invoices
            WHERE client_id = c.client_id) - (SELECT AVG(invoice_total) FROM invoices) AS difference 
    FROM clients c
) AS sales_summary;

🚀 Effect: ✔ Creates a temporary table (sales_summary) containing summarized sales data.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│ Average   │ Difference│
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ 500.00    │ 150.00    │ ✅ Above average
│ 4         │ Beta Ltd  │ NULL      │ 500.00    │ NULL      │ ❌ No invoices
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Client 4 has no invoices, resulting in NULL values for total sales and difference.

📌 Why Use This Approach? 
✔ Subqueries create virtual tables, allowing filtering, grouping, and joining just like real tables. 
✔ Prevents repetitive calculations, improving query efficiency.





📌 2. Filtering Data From the Subquery
✔ Instead of displaying all records, we can filter clients who have invoices.

📌 Adding a WHERE Clause to Remove Clients Without Sales

SELECT *
FROM (
    SELECT 
        client_id, 
        name,
        (SELECT SUM(invoice_total)
            FROM invoices
            WHERE client_id = c.client_id) AS total_sales, 
        (SELECT AVG(invoice_total) FROM invoices) AS average, 
        (SELECT SUM(invoice_total)
            FROM invoices
            WHERE client_id = c.client_id) - (SELECT AVG(invoice_total) FROM invoices) AS difference 
    FROM clients c
) AS sales_summary
WHERE total_sales IS NOT NULL;
🚀 Effect: ✔ Removes clients with no invoices, ensuring clean reporting.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│ Average   │ Difference│
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ 500.00    │ 150.00    │ ✅ Above average
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Only clients with recorded invoices appear.





📌 3. When to Use Subqueries in the FROM Clause?
✔ Use subqueries when creating temporary tables for further filtering or aggregation. 
✔ Avoid them for complex queries—instead, use views to simplify queries.

📌 Alternative Approach Using Views ✔ Instead of writing complex subqueries repeatedly, store them as a view.

🚀 Example: Creating a View for Sales Summary

CREATE VIEW sales_summary AS
SELECT 
    client_id, 
    name,
    (SELECT SUM(invoice_total)
        FROM invoices
        WHERE client_id = c.client_id) AS total_sales, 
    (SELECT AVG(invoice_total) FROM invoices) AS average, 
    (SELECT SUM(invoice_total)
        FROM invoices
        WHERE client_id = c.client_id) - (SELECT AVG(invoice_total) FROM invoices) AS difference 
FROM clients c;

📌 Querying the View Instead of Using Subqueries

SELECT * FROM sales_summary WHERE total_sales IS NOT NULL;
🚀 Effect: ✔ Simplifies future queries, improving readability and efficiency.






Queries used in this discussion:

SELECT *
FROM (
	SELECT 
		client_id, 
		name,
		(SELECT SUM(invoice_total)
			FROM invoices
			WHERE client_id = c.client_id) AS total_sales 
		(SELECT AVG(invoice_total) FROM invoices) AS average 
		(SELECT total_sales - average) AS difference 
	FROM clients c
) AS sales_summary



SELECT *
FROM (
	SELECT 
		client_id, 
		name,
		(SELECT SUM(invoice_total)
			FROM invoices
			WHERE client_id = c.client_id) AS total_sales 
		(SELECT AVG(invoice_total) FROM invoices) AS average 
		(SELECT total_sales - average) AS difference 
	FROM clients c
) AS sales_summary
WHERE total_sales IS NOT NULL 





📌 Summary
✔ Subqueries in FROM act as temporary tables, allowing advanced data manipulation. 
✔ Filtering subquery results is possible using WHERE in the main query. 
✔ For complex queries, consider creating a view instead of repeating subqueries. 
✔ Next steps: Exploring indexed views for database optimization.



















Essential MySQl Functions:
--------------------------


Numeric Functions:
------------------
🚀 Understanding Numeric Functions in MySQL
MySQL provides built-in numeric functions that allow rounding, truncating, computing absolute values, and generating random numbers, making calculations precise and efficient.

📌 1. Rounding and Truncating Numbers
✔ ROUND(number, precision) → Rounds a number to the nearest value, keeping optional decimal places.

📌 Examples:

SELECT ROUND(5.73);  -- Returns 6
SELECT ROUND(5.73, 1);  -- Returns 5.7
SELECT ROUND(5.7345, 2);  -- Returns 5.73
🚀 Effect: ✔ Without precision, rounding gives the nearest integer. ✔ With precision, retains specified decimal places.

📌 Example Output:
ROUND(5.73) → 6
ROUND(5.73, 1) → 5.7
ROUND(5.7345, 2) → 5.73


✔ TRUNCATE(number, precision) → Cuts off decimal places without rounding.

📌 Example

SELECT TRUNCATE(5.7345, 2);  -- Returns 5.73
🚀 Effect: ✔ Removes extra decimal places, keeping only specified digits.

📌 Example Output

TRUNCATE(5.7345, 2) → 5.73
✔ Use when precision matters but rounding is not needed.





📌 2. Controlling Decimal Values
✔ CEILING(number) → Returns the next highest integer. 
✔ FLOOR(number) → Returns the next lowest integer.

📌 Examples

SELECT CEILING(5.7);  -- Returns 6
SELECT FLOOR(5.2);  -- Returns 5
🚀 Effect: ✔ CEILING() moves upward—always rounds up. ✔ FLOOR() moves downward—always rounds down.

📌 Example Output

CEILING(5.7) → 6
FLOOR(5.2) → 5
✔ Use when needing precise integer thresholds.





📌 3. Computing Absolute Values
✔ ABS(number) → Always returns a positive number.

📌 Examples:

SELECT ABS(5.2);  -- Returns 5.2
SELECT ABS(-5.2);  -- Returns 5.2
🚀 Effect: ✔ Removes negativity, ensuring non-negative values only.

📌 Example Output

ABS(5.2) → 5.2
ABS(-5.2) → 5.2
✔ Useful in financial calculations where magnitude matters more than direction.





📌 4. Generating Random Numbers
✔ RAND() → Generates a floating-point number between 0 and 1.

📌 Example
SELECT RAND();
🚀 Effect: ✔ Each execution returns a unique random decimal between 0 and 1.

📌 Example Output:
RAND() → 0.8524 (random)
RAND() → 0.4521 (random)
✔ Use for simulations, unique IDs, and random selection.





📌 5. Exploring Additional Numeric Functions
✔ MySQL offers more numeric functions beyond those listed here.

📌 Reference Link for Complete List 🔗 MySQL Numeric Functions

🚀 Effect: ✔ Provides full documentation on numeric manipulation functions, including modulus operations and logarithmic calculations.




Functions and other notes used in this discussion: 

ROUND(5.73) -- 6
ROUND(5.73, 1) -- 5.7
ROUND(5.7345, 2) -- 5.73
TRUNCATE(5.7345, 2) -- 5.73
CEILING(5.7) -- 6
FLOOR(5.2) -- 5
ABS(5.2) -- 5.2
ABS(-5.2) -- 5.2
RAND() 

Go to browser --> mysql numeric functions  --> https://dev.mysql.com/doc/refman/8.4/en/numeric-functions.html





📌 Summary
✔ ROUND() and TRUNCATE() control decimal precision, determining rounding behavior. 
✔ CEILING() and FLOOR() adjust integers upward/downward, ensuring range control. 
✔ ABS() computes absolute values, keeping numbers positive. 
✔ RAND() generates unpredictable values, assisting with randomness. 










String Functions: 
-----------------

🚀 String Functions in MySQL
MySQL offers powerful string functions to manipulate text efficiently, including length calculation, case conversion, trimming spaces, extracting substrings, searching, replacing, and concatenation.

📌 1.Measuring String Length
✔ LENGTH(string) → Returns the number of characters in a string.

📌 Examples:
SELECT LENGTH('Sky');  -- Returns 3
🚀 Effect: ✔ Counts all characters, including spaces.

📌 Example Output
LENGTH('Sky') → 3
✔ Useful for validating string lengths.





📌 2. Converting Case
✔ UPPER(string) → Converts text to uppercase. ✔ LOWER(string) → Converts text to lowercase.

📌 Examples:
SELECT UPPER('Sky');  -- Returns 'SKY'
SELECT LOWER('Sky');  -- Returns 'sky'
🚀 Effect: ✔ Ensures consistent formatting for case-sensitive applications.

📌 Example Output:
UPPER('Sky') → SKY
LOWER('Sky') → sky





📌 3. Removing Spaces
✔ LTRIM(string) → Removes leading spaces. ✔ RTRIM(string) → Removes trailing spaces. ✔ TRIM(string) → Removes both leading and trailing spaces.

📌 Examples:
SELECT LTRIM('  Sky');  -- Returns 'Sky'
SELECT RTRIM('Sky  ');  -- Returns 'Sky'
SELECT TRIM('  Sky  ');  -- Returns 'Sky'
🚀 Effect: ✔ Cleans up user input, ensuring consistent spacing.

📌 Example Output:
LTRIM('  Sky') → 'Sky'
RTRIM('Sky  ') → 'Sky'
TRIM('  Sky  ') → 'Sky'





📌 4. Extracting Substrings
✔ LEFT(string, length) → Extracts characters from the start. 
✔ RIGHT(string, length) → Extracts characters from the end. 
✔ SUBSTRING(string, start, length) → Extracts characters from anywhere in a string.

📌 Examples:
SELECT LEFT('Kindergarten', 4);  -- Returns 'Kind'
SELECT RIGHT('Kindergarten', 6);  -- Returns 'garten'
SELECT SUBSTRING('Kindergarten', 3, 5);  -- Returns 'nderg'
🚀 Effect: ✔ Enables precise string extraction for structured data processing.

📌 Example Output:
LEFT('Kindergarten', 4) → 'Kind'
RIGHT('Kindergarten', 6) → 'garten'
SUBSTRING('Kindergarten', 3, 5) → 'nderg'





📌 5. Finding Text Positions
✔ LOCATE(search_string, string) → Finds the first occurrence position of a substring.

📌 Examples:
SELECT LOCATE('n', 'Kindergarten');  -- Returns 3
SELECT LOCATE('garden', 'Kindergarten');  -- Returns 7
SELECT LOCATE('x', 'Kindergarten');  -- Returns 0 (not found)
🚀 Effect: ✔ Locates where text appears within a string.

📌 Example Output:
LOCATE('n', 'Kindergarten') → 3
LOCATE('garden', 'Kindergarten') → 7
LOCATE('x', 'Kindergarten') → 0
✔ Returns 0 if the text does not exist (unlike -1 in many programming languages).





📌 6. Replacing Text
✔ REPLACE(string, find, replacement) → Replaces specific text within a string.

📌 Example:
SELECT REPLACE('Kindergarten', 'garten', 'garden');  -- Returns 'Kindergarden'
🚀 Effect: ✔ Modifies text without changing its structure.

📌 Example Output:
REPLACE('Kindergarten', 'garten', 'garden') → 'Kindergarden'





📌 7. Concatenating Strings
✔ CONCAT(string1, string2, ...) → Joins multiple strings.

📌 Example:
SELECT CONCAT('First', ' ', 'Last');  -- Returns 'First Last'
🚀 Effect: ✔ Merges multiple text fragments into a single value.

📌 Example Output:
CONCAT('First', ' ', 'Last') → 'First Last'
✔ Use for formatting names, addresses, and messages.

📌 Example: Combining First and Last Names:
SELECT CONCAT(first_name, ' ', last_name) AS full_name 
FROM customers;
🚀 Effect: ✔ Dynamically creates full names for each customer.





📌 8. Exploring Additional String Functions
✔ MySQL offers many more string functions beyond those listed here.

📌 Reference Link for Complete List 🔗 MySQL String Functions

🚀 Effect: ✔ Provides full documentation on advanced string manipulation techniques.



Functions and other notes in this discussion: 

LENGTH()
UPPER()
LOWER()
LTRIM()
RTRIM()
TRIM()
LEFT('Kindergarten', 3)
RIGHT('Kindergarten', 4)
SUBSTRING('Kindergarten', 3, 5)
LOCATE('n', 'Kindergarten')
REPLACE('Kindergarten', 'garten', 'garden')
CONCAT('first', 'last')


SELECT CONCAT(first_name, ' ', last_name) AS full_name 
FROM customers 


mysql string functions -->  https://dev.mysql.com/doc/refman/8.4/en/string-functions.html





📌 Summary
✔ LENGTH() measures character count in a string. 
✔ UPPER() and LOWER() standardize text casing. 
✔ TRIM() removes unnecessary spaces, ensuring clean formatting. 
✔ LEFT(), RIGHT(), and SUBSTRING() extract portions of text dynamically. 
✔ LOCATE() finds text positions, enabling structured search operations. 
✔ REPLACE() modifies text efficiently, making replacements within strings. 
✔ CONCAT() merges text values, improving data readability. 

















Date Functions in MySQL:
------------------------
🚀 Date Functions in MySQL
MySQL provides built-in functions to work with date and time values, enabling efficient extraction, formatting, and manipulation.

📌 1. Retrieving Current Date and Time
✔ NOW() → Returns current date and time. ✔ CURDATE() → Returns current date (without time). ✔ CURTIME() → Returns current time (without date).

📌 Examples:
SELECT NOW();  -- Current date & time
SELECT CURDATE();  -- Current date only
SELECT CURTIME();  -- Current time only
🚀 Effect: ✔ Captures real-time system timestamps, useful for tracking transactions.

📌 Example Output:
NOW() → 2025-05-29 14:25:30
CURDATE() → 2025-05-29
CURTIME() → 14:25:30





📌 2. Extracting Specific Components from Date-Time
✔ YEAR(date) → Returns year component. 
✔ MONTH(date) → Returns month component. 
✔ DAY(date) → Returns day component. 
✔ HOUR(date) → Extracts hour from a timestamp. 
✔ MINUTE(date) → Extracts minute component. 
✔ SECOND(date) → Extracts second component.

📌 Examples:
SELECT YEAR(NOW());  -- Extracts current year
SELECT MONTH(NOW());  -- Extracts current month
SELECT DAY(NOW());  -- Extracts current day
SELECT HOUR(NOW());  -- Extracts current hour
SELECT MINUTE(NOW());  -- Extracts current minute
SELECT SECOND(NOW());  -- Extracts current second
🚀 Effect: ✔ Extracts granular date-time components, useful for calculations and filtering.

📌 Example Output:
YEAR(NOW()) → 2025
MONTH(NOW()) → 5
DAY(NOW()) → 29
HOUR(NOW()) → 14
MINUTE(NOW()) → 25
SECOND(NOW()) → 30





📌 3. Extracting Day & Month Names
✔ DAYNAME(date) → Returns weekday name. 
✔ MONTHNAME(date) → Returns month name.

📌 Examples:
SELECT DAYNAME(NOW());  -- Returns the current day of the week
SELECT MONTHNAME(NOW());  -- Returns the current month name
🚀 Effect: ✔ Converts numeric dates into readable formats, improving user-friendliness.

📌 Example Output:
DAYNAME(NOW()) → Thursday
MONTHNAME(NOW()) → May





📌 4. Using the EXTRACT() Function
✔ The EXTRACT() function is part of standard SQL, making queries portable across database systems.

📌 Syntax:
SELECT EXTRACT(YEAR FROM NOW());  -- Extracts current year
SELECT EXTRACT(DAY FROM NOW());  -- Extracts current day
🚀 Effect: ✔ Similar to YEAR() and DAY(), but ensures compatibility across different SQL databases.

📌 Example Output:
EXTRACT(YEAR FROM NOW()) → 2025
EXTRACT(DAY FROM NOW()) → 29





📌 5. Exercise: Retrieving Orders Placed in the Current Year
🚀 Task: ✔ Modify the query to dynamically filter orders based on the current year.

📌 Incorrect Query Using Hardcoded Year:
SELECT * 
FROM orders
WHERE order_date >= '2019-01-01';  -- ❌ Not reliable
🚀 Problem: ✔ The query does not update dynamically, meaning in 2026, it may return results for 2019, 2020, etc.

📌 Correct Query Using Dynamic Year Extraction:
SELECT * 
FROM orders
WHERE YEAR(order_date) = YEAR(NOW());
🚀 Effect: ✔ Ensures the query always filters based on the current year, no matter when it runs.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ Total     │
├───────────┼───────────┼───────────┤
│ 45        │ 2025-05-10│ 500.00    │ ✅ Placed this year
│ 50        │ 2025-04-22│ 320.50    │ ✅ Placed this year
└───────────┴───────────┴───────────┘

📌 Key Takeaways 
✔ Uses YEAR(NOW()) to retrieve the current year dynamically. 
✔ Compares YEAR(order_date) with YEAR(NOW()) for real-time filtering. 
✔ Ensures accuracy across different years, avoiding hardcoded values.





Queries and other notes in this discussion:

NOW(), CURDATE(),  CURTIME()
YEAR(NOW())
MONTH(NOW())
HOUR(NOW())
MINUTE(NOW())
SECOND(NOW())
DAYNAME(NOW())
MONTHNAME(NOW())

SELECT EXTRACT(DAY FROM NOW())
SELECT EXTRACT(YEAR FROM NOW())


Exercise:
SELECT * 
FROM orders
WHERE order_date >= '2019-01-01';

Solution:
SELECT * 
FROM orders
WHERE YEAR(order_date) =  YEAR(NOW());





📌 Summary
✔ NOW() retrieves current timestamps, essential for tracking operations. 
✔ YEAR(), MONTH(), DAY() extract specific date components, refining analytics. 
✔ DAYNAME() and MONTHNAME() improve readability, making outputs more human-friendly. 
✔ EXTRACT() ensures cross-database compatibility, making SQL queries portable. 
✔ Dynamic filtering prevents outdated queries, ensuring real-time accuracy. 


















Formatting Dates and Times: 
---------------------------
🚀 Formatting Dates and Times in MySQL
MySQL represents dates using the format YYYY-MM-DD, which is ideal for developers but may not be user-friendly in reports or applications. To customize date and time formats, MySQL offers DATE_FORMAT() and TIME_FORMAT() functions.

📌 1. Understanding DATE_FORMAT()
✔ DATE_FORMAT(date, format_string) → Formats a date value using special specifiers.

📌 Examples:
SELECT DATE_FORMAT(NOW(), '%y');  -- Returns two-digit year (19)
SELECT DATE_FORMAT(NOW(), '%Y');  -- Returns full four-digit year (2019)
🚀 Effect: ✔ Controls how dates appear, ensuring better readability.

📌 Example Output:
DATE_FORMAT(NOW(), '%y') → 19
DATE_FORMAT(NOW(), '%Y') → 2019





📌 2. Formatting Month and Day Components
✔ Use %m for numeric month, %M for month name. ✔ Use %d for day.

📌 Examples:
SELECT DATE_FORMAT(NOW(), '%m %y');  -- Returns '03 2019'
SELECT DATE_FORMAT(NOW(), '%M %Y');  -- Returns 'March 2019'
SELECT DATE_FORMAT(NOW(), '%M %d %y');  -- Returns 'March 11 2019'
🚀 Effect: ✔ Displays dates in a readable format for users.

📌 Example Output:
DATE_FORMAT(NOW(), '%m %y') → 03 2019
DATE_FORMAT(NOW(), '%M %Y') → March 2019
DATE_FORMAT(NOW(), '%M %d %y') → March 11 2019





📌 3. Using TIME_FORMAT() for Time Formatting
✔ TIME_FORMAT(time, format_string) → Formats a time value with special specifiers.

📌 Examples:
SELECT TIME_FORMAT(NOW(), '%H:%i %p');  -- Returns '14:25 PM'
🚀 Effect: ✔ Converts time formats, improving clarity for reports and logs.

📌 Example Output:
TIME_FORMAT(NOW(), '%H:%i %p') → 14:25 PM
✔ %H (24-hour format), %i (minutes), %p (AM/PM).





📌 4. Reference Guide for Additional Format Specifiers
✔ Instead of memorizing format codes, refer to MySQL's official documentation.

📌 Reference Link for Full Format Specifiers 🔗 MySQL Date & Time Formatting

🚀 Effect: ✔ Provides a detailed list of format specifiers, ensuring customized outputs.





Queries and other notes in this discussion:
DATE_FORMAT(NOW(), '%y') -- 19
DATE_FORMAT(NOW(), '%Y') -- 2019


DATE_FORMAT(NOW(), '%m %y') -- 03 2019
DATE_FORMAT(NOW(), '%M %Y') -- March 2019 

DATE_FORMAT(NOW(), '%M %d %y') -- March 11 2019


search for mysql date format string --> https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html

TIME_FORMAT(NOW(), '%H:%i %p')




📌 Summary
✔ DATE_FORMAT() modifies date appearance, using %Y, %M, %d, etc. 
✔ TIME_FORMAT() customizes time formats, making AM/PM formats easier to read. 
✔ Refer to MySQL documentation for additional format options. 












Calculating Dates and Times:
-----------------------------
🚀 Calculating Dates and Times in MySQL
MySQL provides powerful built-in functions for manipulating dates and times, enabling dynamic operations such as adding/subtracting intervals and computing differences between timestamps.

📌 1. Adding and Subtracting Dates
✔ DATE_ADD(date, INTERVAL x unit) → Adds a specific interval to a date. 
✔ DATE_SUB(date, INTERVAL x unit) → Subtracts an interval from a date.

📌 Examples:
SELECT DATE_ADD(NOW(), INTERVAL 1 DAY);  -- Adds 1 day to the current date
SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);  -- Adds 1 year to the current date
SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);  -- Subtracts 1 year
SELECT DATE_SUB(NOW(), INTERVAL 1 YEAR);  -- Alternative way to subtract 1 year
🚀 Effect: ✔ Enables date manipulation, useful for scheduling and forecasting.

📌 Example Output:
DATE_ADD(NOW(), INTERVAL 1 DAY) → 2025-05-30
DATE_ADD(NOW(), INTERVAL 1 YEAR) → 2026-05-29
DATE_ADD(NOW(), INTERVAL -1 YEAR) → 2024-05-29
DATE_SUB(NOW(), INTERVAL 1 YEAR) → 2024-05-29
✔ Both DATE_ADD() and DATE_SUB() work similarly, with DATE_SUB() simplifying subtraction operations.





📌 2. Calculating Date Differences
✔ DATEDIFF(date1, date2) → Returns the difference between two dates in days.

📌 Examples:
SELECT DATEDIFF('2019-01-05', '2019-01-01');  -- Returns 4 days
SELECT DATEDIFF('2019-01-05 09:00', '2019-01-01 17:00');  -- Ignores time, still returns 4 days
🚀 Effect: ✔ Computes differences in days only, ignoring time components.

📌 Example Output:
DATEDIFF('2019-01-05', '2019-01-01') → 4
DATEDIFF('2019-01-05 09:00', '2019-01-01 17:00') → 4
✔ Even if times are included, only the day difference is considered.

📌 Swapping Order of Dates 
✔ If date1 is later than date2, the result is positive. 
✔ If date1 is earlier than date2, the result is negative.


SELECT DATEDIFF('2019-01-01', '2019-01-05');  -- Returns -4
🚀 Effect: ✔ Negative values indicate that date1 is before date2.

📌 Example Output:
DATEDIFF('2019-01-01', '2019-01-05') → -4





📌 3. Calculating Time Differences
✔ TIME_TO_SEC(time) → Converts time values into seconds since midnight.

📌 Examples:
SELECT TIME_TO_SEC('09:00');  -- Returns 32,400 seconds (9 hours)
SELECT TIME_TO_SEC('09:02') - TIME_TO_SEC('09:00');  -- Returns 120 seconds
🚀 Effect: ✔ Enables time interval calculations, useful for scheduling tasks.

📌 Example Output:
TIME_TO_SEC('09:00') → 32,400
TIME_TO_SEC('09:02') - TIME_TO_SEC('09:00') → 120
✔ Order Matters:

If time1 is earlier than time2, the result is negative.

SELECT TIME_TO_SEC('09:00') - TIME_TO_SEC('09:02');  -- Returns -120
🚀 Effect: ✔ Helps track elapsed time in seconds, useful for performance metrics.





Queries and other notes in this discussion: 

SELECT DATE_ADD(NOW(), INTERVAL 1 DAY);
SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);
SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);
SELECT DATE_SUB(NOW(), INTERVAL 1 YEAR);
SELECT DATEDIFF('2019-01-05', '2019-01-01');
SELECT DATEDIFF('2019-01-05 09:00', '2019-01-01 17:00'); --only returns difference in days, even if we include time values

SELECT TIME_TO_SEC('09:00')
SELECT TIME_TO_SEC('09:02') - TIME_TO_SEC('09:00') -- 120 




📌 Summary
✔ Use DATE_ADD() and DATE_SUB() to manipulate dates dynamically, adding or subtracting years, months, or days. 
✔ Use DATEDIFF() to compute differences in days, ignoring time values. 
✔ Use TIME_TO_SEC() for precise time interval calculations, converting hours, minutes, and seconds into seconds since midnight. 
















The IFNULL and COALESCE Functions: 
----------------------------------
🚀 Using the IFNULL and COALESCE Functions in MySQL
Handling NULL values efficiently in MySQL ensures clean, user-friendly data representation. This tutorial covers how to replace NULL values dynamically using IFNULL and COALESCE.

📌 1. Understanding IFNULL()
✔ IFNULL(column, replacement_value) → Replaces NULL with a specified alternative. 
✔ Accepts two arguments:
First argument → The column or expression to check.
Second argument → The replacement value if the first argument is NULL.

📌 Example: Handling Missing Shipper Information ✔ In the orders table, some orders have NULL shipper IDs, meaning they haven’t been assigned yet.

SELECT 
    order_id, 
    IFNULL(shipper_id, 'Not assigned') AS shipper
FROM orders;

🚀 Effect: ✔ Replaces NULL shipper IDs with "Not assigned", making the data readable.

📌 Example Output:
┌───────────┬──────────────┐
│ OrderID   │ Shipper      │
├───────────┼──────────────┤
│ 1         │ 103          │ ✅ Assigned
│ 2         │ Not assigned │ ❌ No shipper assigned
│ 5         │ 205          │ ✅ Assigned
└───────────┴──────────────┘
✔ Ensures missing shipper data is displayed clearly.





📌 2. Understanding COALESCE()
✔ COALESCE(value1, value2, ..., default_value) → Returns the first non-NULL value from the list. ✔ More flexible than IFNULL(), since it can check multiple values.

📌 Example: Using COALESCE() to Handle Multiple Columns ✔ If shipper_id is NULL, retrieve the comments column instead. ✔ If both are NULL, display "Not assigned".

sql
SELECT 
    order_id, 
    COALESCE(shipper_id, comments, 'Not assigned') AS shipper
FROM orders;

🚀 Effect: ✔ Displays shipper ID if available. ✔ If shipper ID is missing, displays comments. ✔ If both are missing, displays "Not assigned".

📌 Example Output:
┌───────────┬──────────────────┐
│ OrderID   │ Shipper          │
├───────────┼──────────────────┤
│ 1         │ 103              │ ✅ Assigned
│ 2         │ Delayed Shipment │ 📝 Uses comment field
│ 5         │ Not assigned     │ ❌ No data available
└───────────┴──────────────────┘
✔ Provides a fallback system to ensure meaningful output.





📌 3. Exercise: Formatting Customer Information
🚀 Task: ✔ Display customer full name (first + last name). ✔ If phone number is missing (NULL), display "Unknown".

📌 Expected Query Solution:
SELECT 
    CONCAT(first_name, ' ', last_name) AS customer, 
    COALESCE(phone, 'Unknown') AS phone
FROM customers;
🚀 Effect: ✔ Ensures readable customer data, replacing missing phone numbers with "Unknown".

📌 Example Output:
┌───────────────┬───────────┐
│ Customer      │ Phone     │
├───────────────┼───────────┤
│ Alice Johnson │ 555-1234  │ ✅ Has phone number
│ Bob Smith     │ Unknown   │ ❌ Missing phone number
└───────────────┴───────────┘
✔ Improves user experience by handling missing data effectively.

📌 Steps Used 
 - Used CONCAT() to merge first and last names into a single column (customer). 
 - Applied COALESCE() to replace missing phone values with "Unknown".





📌 4. Comparing IFNULL and COALESCE

Function	                                     Use Case	                                              Flexibility
IFNULL(column, replacement)	                     Checks one column and replaces NULL	                  Limited
COALESCE(column1, column2, fallback_value)	     Checks multiple columns, using first non-NULL value	  More flexible

📌 When to Use Each? 
✔ Use IFNULL() if replacing a single column value with a fallback. 
✔ Use COALESCE() if selecting from multiple columns, ensuring the first available value is used.





Queries and other notes used in this discussion:

SELECT 
	order_id, 
	IF_NULL(shipper_id, 'Not assigned') AS shipper
FROM orders;


SELECT 
	order_id
	COALESCE(shipper_id, comments, 'Not assigned')
FROM orders;


Exercise:
SELECT 
	CONCAT(first_name, ' ', last_name) AS customer, 
	COALESCE(phone, 'Unknown') AS phone
FROM customers;






📌 Summary
✔ IFNULL() replaces missing values with a fixed alternative, ensuring readable outputs. 
✔ COALESCE() selects the first non-NULL value from multiple columns, providing fallbacks. 
✔ Improves data clarity, making reports and user-facing data meaningful. 

















The IF Function:
----------------
🚀 Understanding the IF Function in MySQL
The IF function in MySQL allows conditional evaluations, returning different values based on whether a condition evaluates to TRUE or FALSE. It is useful for categorizing data dynamically, reducing the need for multiple queries.

📌 1. Using IF to Categorize Orders
✔ Scenario:
We want to classify orders as Active or Archived.
Orders placed in the current year → Active.
Older orders → Archived.

✔ Instead of using UNION between two queries, we use IF to streamline logic.

📌 Query Solution

SELECT
    order_id, 
    order_date, 
    IF(
        YEAR(order_date) = YEAR(NOW()),  
        'Active', 
        'Archived'
    ) AS category
FROM orders;
🚀 Effect: ✔ Returns order classification dynamically, ensuring real-time accuracy.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ Category  │
├───────────┼───────────┼───────────┤
│ 45        │ 2025-05-10│ Active    │ ✅ Order placed this year
│ 38        │ 2022-03-15│ Archived  │ ❌ Older order
└───────────┴───────────┴───────────┘
📌 Key Elements ✔ Condition (YEAR(order_date) = YEAR(NOW())) → Checks if the order belongs to the current year. ✔ First return value (Active) → If condition is TRUE. ✔ Second return value (Archived) → If condition is FALSE.

✔ More concise than using UNION queries for classification.





📌 2. Exercise: Categorizing Product Order Frequency
🚀 Task: ✔ Retrieve each product, displaying:
 - Number of times it was ordered (COUNT(*)).
 - Frequency Category (Many times or Once).

📌 Expected Query Solution:
SELECT 
    product_id, 
    name, 
    COUNT(*) AS orders,
    IF(COUNT(*) > 1, 'Many times', 'Once') AS frequency
FROM products
JOIN order_items USING (product_id)
GROUP BY product_id, name;

🚀 Effect: ✔ Counts the number of orders for each product and categorizes its frequency.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Orders    │ Frequency │
├───────────┼───────────┼───────────┼───────────┤
│ 101       │ Laptop    │ 5         │ Many times│ ✅ Frequently purchased
│ 204       │ Keyboard  │ 1         │ Once      │ ❌ Ordered only once
└───────────┴───────────┴───────────┴───────────┘

📌 Steps Used 
 - Retrieve product_id and name from products. 
 - Use COUNT(*) to track order frequency. 
 - Apply IF(COUNT(*) > 1, 'Many times', 'Once') to classify order frequency dynamically. 
 - Group the query by product_id, name to ensure correct counts.

✔ Simplifies analysis, helping businesses track product demand.






Queries and other notes in this discussion: 

IF(expression, first, second)


SELECT
	order_id, 
	order_date, 
	IF(
		YEAR(order_date) = YEAR(NOW()),
	    'Active', 
		'Archived') AS category
FROM orders



Exercise: 
SELECT 
	product_id, 
	name, 
	COUNT(*) AS orders,
	IF (COUNT(*) > 1, 'Many times', 'Once') AS frequency
FROM products
JOIN order_items USING (product_id)
GROUP BY product_id, name;







📌 Summary
✔ The IF function dynamically classifies data, improving readability and accuracy. 
✔ Condition evaluation (IF(expression, value_if_true, value_if_false)) simplifies categorization. 
✔ More efficient than UNION queries, reducing code complexity.



















The CASE Operator:
------------------

🚀 Using the CASE Operator in MySQL
The CASE operator in MySQL allows complex conditional evaluations, enabling multiple conditions within a single query. It is useful for categorizing data dynamically, reducing the need for multiple queries or UNION operations.

📌 1. Understanding the CASE Operator
✔ CASE tests multiple conditions, returning different values based on the result. ✔ It functions like an IF-ELSE structure in programming.

📌 Syntax:

CASE 
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ELSE default_result
END AS alias

✔ Multiple conditions can be defined, ensuring accurate categorization.





📌 2. Categorizing Orders Based on Placement Year
✔ Scenario:
Orders placed in the current year → Active.
Orders placed last year → Last Year.
Older orders → Archived.
Future orders → Future.

📌 Query Solution:
SELECT 
    order_id, 
    CASE 
        WHEN YEAR(order_date) = YEAR(NOW()) THEN 'Active'
        WHEN YEAR(order_date) = YEAR(NOW()) - 1 THEN 'Last Year'
        WHEN YEAR(order_date) < YEAR(NOW()) - 1 THEN 'Archived'
        ELSE 'Future'
    END AS category
FROM orders;

🚀 Effect: ✔ Classifies orders dynamically, ensuring real-time accuracy.

📌 Example Output:
┌───────────┬───────────┬────────────┐
│ OrderID   │ Category  │ OrderDate  │
├───────────┼───────────┼────────────┤
│ 45        │ Active    │ 2025-05-10 │ ✅ Placed this year
│ 38        │ Last Year │ 2024-03-15 │ 🗂 From last year
│ 20        │ Archived  │ 2020-08-22 │ 📁 Older order
└───────────┴───────────┴────────────┘
✔ Ensures categorized order tracking without separate queries.





📌 3. Exercise: Categorizing Customers Based on Loyalty Points
🚀 Task: ✔ Classify customers based on points:

Gold → Above 3000 points.
Silver → Between 2000 and 3000 points (inclusive).
Bronze → Below 2000 points.

📌 Expected Query Solution:
SELECT 
    CONCAT(first_name, ' ', last_name) AS customer, 
    points, 
    CASE
        WHEN points > 3000 THEN 'Gold'
        WHEN points >= 2000 THEN 'Silver'
        ELSE 'Bronze' 
    END AS category
FROM customers;

🚀 Effect: ✔ Categorizes customer loyalty dynamically, eliminating the need for multiple queries.

📌 Example Output:
┌───────────────┬───────────┬───────────┐
│ Customer      │ Points    │ Category  │
├───────────────┼───────────┼───────────┤
│ Alice Johnson │ 4200      │ Gold      │ 🥇 Premium member
│ Bob Smith     │ 2500      │ Silver    │ 🥈 Mid-tier loyalty
│ Sarah Lee     │ 1500      │ Bronze    │ 🥉 Entry-level member
└───────────────┴───────────┴───────────┘
📌 Steps Used 
 - Retrieve first_name and last_name, merging them using CONCAT(). 
 - Classify points dynamically using CASE, avoiding redundant queries. 
 - Assign meaningful labels (Gold, Silver, Bronze), improving user-friendliness.

✔ Provides structured insights for loyalty programs.





📌 4. Comparing IF vs. CASE:
Function	                                             Use Case	                      Flexibility
IF(condition, value_if_true, value_if_false)	         Single condition evaluation	  Limited
CASE WHEN condition THEN result ... ELSE default END	 Multiple conditions	          Highly flexible


✔ Use IF for simple evaluations, use CASE for complex categorization.




Queries and other notes in this discussion: 

SELECT 
	order_id
	CASE 
		WHEN YEAR(order_date) = YEAR(NOW()) THEN 'Active'
		WHEN YEAR(order_date) = YEAR(NOW()) - 1  THEN 'Last Year'
		WHEN YEAR(order_date) < YEAR(NOW()) - 1  THEN 'Archived'
		ELSE 'Future'
	END AS category
FROM orders;



Exercise: 

SELECT 
	CONCAT(first_name, ' ', last_name) AS customer, 
	points, 
	CASE
		WHEN points > 3000 THEN 'Gold'
		WHEN points >=  2000 THEN 'Silver'
		ELSE 'Bronze' 
	END AS category
FROM customers; 






📌 Summary
✔ CASE simplifies multi-condition evaluations, improving readability. 
✔ Allows flexible categorization, reducing UNION query complexity. 
✔ Use for structured filtering, ensuring optimized reporting and tracking. 


















Views:
------

Creating Views:
---------------
🚀 Creating Views in MySQL
Views in MySQL simplify complex queries, making them reusable and more manageable. They act as virtual tables, allowing you to store SQL logic without duplicating code.

📌 1. What Are Views in MySQL?
✔ A view is a stored query that behaves like a table, allowing users to select, filter, and join data dynamically. 
✔ Unlike tables, views do not store data—they only retrieve information from underlying tables.





📌 2. Creating a View for Sales Per Client
🚀 Scenario: ✔ Compute total sales per client to simplify future queries.

📌 Query to Get Sales Per Client:
USE sql_invoicing; 

CREATE VIEW sales_by_client AS
SELECT 
    c.client_id, 
    c.name, 
    SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;

🚀 Effect: ✔ Stores the logic for retrieving total sales per client, making it reusable for multiple queries.

📌 Selecting Data from the View:
SELECT * FROM sales_by_client;
🚀 Effect: ✔ Retrieves total sales for each client, behaving like a regular table.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│
├───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ ✅ Top client
│ 3         │ Beta Ltd  │ 520.00    │ ✅ Regular client
└───────────┴───────────┴───────────┘





📌 3. Querying and Filtering the View
✔ Filter sales data directly from the view.

📌 Ordering Sales by Highest Revenue:
SELECT * 
FROM sales_by_client 
ORDER BY total_sales DESC;
🚀 Effect: ✔ Sorts clients by total sales, ranking top customers.

📌 Filtering High-Revenue Clients:
SELECT * 
FROM sales_by_client 
WHERE total_sales > 500;
🚀 Effect: ✔ Displays only clients with sales above $500.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│
├───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ ✅ Eligible for premium benefits
└───────────┴───────────┴───────────┘





📌 4. Joining Views with Other Tables:
✔ Views can be joined with other tables, enabling advanced queries.

📌 Joining sales_by_client with clients:
SELECT * 
FROM sales_by_client 
JOIN clients USING (client_id);
🚀 Effect: ✔ Retrieves additional client details, enriching insights.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ TotalSales│ City      │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ 650.00    │ New York  │ ✅ High-revenue client
└───────────┴───────────┴───────────┴───────────┘
✔ Allows cross-table analysis, helping businesses optimize customer segmentation.





📌 5. Exercise: Creating a View for Client Balances
🚀 Task: ✔ Create a view to compute the balance for each client, showing: 
1.Client ID 
2.Client Name 
3.Balance (Invoice total - Payment total)

📌 Expected Query Solution:
CREATE VIEW clients_balance AS 
SELECT 
    c.client_id,
    c.name, 
    SUM(invoice_total - payment_total) AS balance
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;
🚀 Effect: ✔ Stores client balances dynamically, simplifying accounting queries.

📌 Retrieving Client Balances:
SELECT * FROM clients_balance;
🚀 Effect: ✔ Displays balance details for each client.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ Balance   │
├───────────┼───────────┼───────────┤
│ 5         │ XYZ Inc   │ 150.75    │ ✅ Outstanding balance
│ 3         │ Beta Ltd  │ -20.00    │ ✅ Overpaid client
└───────────┴───────────┴───────────┘
✔ Balances help businesses track outstanding invoices.





Queries used in this discussion: 

USE sql_invoicing; 

CREATE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name; 



SELECT * 
FROM sales_by_client 
ORDER BY total_sales DESC;


SELECT * 
FROM sales_by_client 
WHERE total_sales > 500;


SELECT * 
FROM sales_by_client 
JOIN clients USING (client_id);



Exercise: 

-- Create a view to see the balance 
-- for each client 
--
-- client_balance 

-- client_id
-- name
-- balance 


CREATE VIEW clients_balance AS 
SELECT 
	c.client_id,
	c.name, 
	SUM(invoice_total - payment_total) AS balance
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;





📌 Summary
✔ Views simplify complex queries, making SQL easier to manage and reuse. 
✔ They act as virtual tables, storing query logic without duplicating data. 
✔ Use views for reports, aggregations, and filtering operations, improving query performance. 













Altering or Dropping Views:
---------------------------
🚀 Altering or Dropping Views in MySQL
Views in MySQL help simplify complex queries, but sometimes modifications are necessary. There are two primary ways to alter views: dropping and recreating, or using CREATE OR REPLACE for efficient updates.

📌 1. Dropping and Recreating Views:
✔ DROP VIEW view_name; → Removes the view from the database.

📌 Example: Dropping a View:
DROP VIEW sales_by_client;
🚀 Effect: ✔ Completely removes the view, requiring it to be manually recreated.

📌 Recreating the View:
CREATE VIEW sales_by_client AS
SELECT 
    c.client_id, 
    c.name, 
    SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;
🚀 Effect: ✔ Restores the view after dropping it, allowing further modifications.

📌 Drawbacks ✔ Manually dropping views is inefficient, especially when frequently updating queries.

📌 2. Using CREATE OR REPLACE for Easier Modifications
✔ Instead of dropping and recreating a view, use CREATE OR REPLACE VIEW.

📌 Example: Modifying the View Without Dropping It:
CREATE OR REPLACE VIEW sales_by_client AS
SELECT 
    c.client_id, 
    c.name, 
    SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;
🚀 Effect: ✔ Replaces an existing view without manual deletion. ✔ Preserves queries dependent on the view, preventing disruptions.

📌 Advantages ✔ More efficient—avoids unnecessary view deletion. ✔ Ensures continuity for applications relying on the view.





📌 3. Best Practices for Managing Views
✔ Save view definitions in SQL files to ensure reproducibility. 
✔ Store views in a version-controlled repository (e.g., Git) for collaboration and tracking changes. 
✔ Organize views into separate folders for structured management.

📌 Example Folder Structure for SQL Views

views/
   ├── sales_by_client.sql
   ├── client_balance.sql
🚀 Effect: ✔ Enables easier tracking, sharing, and recovery.





📌 4. Viewing and Editing Existing Views
✔ MySQL stores views as metadata, allowing access via GUI or SQL commands.

📌 Manually Editing Views in MySQL Workbench 
✔ Find the views panel, then click the edit icon. 
✔ Modify the query, ensuring any necessary ORDER BY or WHERE conditions. 
✔ Click Apply to commit changes.

📌 Adding Sorting to a View:
CREATE OR REPLACE VIEW sales_by_client AS
SELECT 
    c.client_id, 
    c.name, 
    SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name
ORDER BY total_sales DESC;

🚀 Effect: ✔ Ensures client sales are sorted in descending order.





Queries used in this discussion: 

DROP VIEW sales_by_client; 


CREATE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;


CREATE OR REPLACE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;





📌 Summary
✔ Use DROP VIEW to remove views manually, followed by CREATE VIEW for recreation. 
✔ Use CREATE OR REPLACE VIEW for efficient modifications without disruptions. 
✔ Store SQL view files in version control systems (Git) for tracking and collaboration. 
✔ Modify views directly in MySQL Workbench when necessary. 
















Updatable Views:
----------------
🚀 Updatable Views in MySQL
Views in MySQL can be used in SELECT statements. But under certain conditions, they can also support INSERT, UPDATE, and DELETE operations. These are known as updatable views.

📌 1. What Makes a View Updatable?
✔ A view can be modified using INSERT, UPDATE, or DELETE if it does not contain:
DISTINCT keyword.
Aggregate functions (SUM(), AVG(), MAX(), etc.).
GROUP BY or HAVING clauses.
UNION operations.

📌 Updatable Views vs. Non-Updatable Views

View Type	          Supports Insert, Update, Delete?
Updatable View	      ✅ Yes (if it meets all conditions)
Non-Updatable View	  ❌ No (contains aggregate/grouping functions, unions, etc.)

✔ If a view follows these rules, it can be modified like a regular table.





📌 2. Creating an Updatable View:
🚀 Scenario: ✔ The invoices table contains invoice_total and payment_total, but no balance column. ✔ Instead of recalculating the balance each time, create an updatable view to display and modify balances.

📌 Creating the View

CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
    invoice_id, 
    number, 
    client_id, 
    invoice_total, 
    payment_total, 
    invoice_total - payment_total AS balance, 
    invoice_date, 
    due_date, 
    payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0;

🚀 Effect: ✔ Creates a virtual table displaying invoice balances without modifying the original table structure.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ InvoiceID │ ClientID  │ Balance   │ DueDate   │
├───────────┼───────────┼───────────┼───────────┤
│ 101       │ 5         │ 150.75    │ 2025-06-10│ ✅ Open balance
│ 204       │ 3         │ 75.00     │ 2025-06-15│ ✅ Pending payment
└───────────┴───────────┴───────────┴───────────┘
✔ Ensures only invoices with an outstanding balance are displayed.

📌 Important Note ✔ Aliases (AS balance) cannot be used in the WHERE clause, so use the full expression instead.





📌 3. Updating and Deleting Data Using an Updatable View
✔ Once a view is updatable, we can modify data just like a regular table.

📌 Deleting an Invoice:
DELETE FROM invoices_with_balance
WHERE invoice_id = 1;
🚀 Effect: ✔ Deletes the invoice with ID 1, just like a normal table operation.

📌 Updating an Invoice Due Date:
UPDATE invoices_with_balance
SET due_date = DATE_ADD(due_date, INTERVAL 2 DAY)
WHERE invoice_id = 2;
🚀 Effect: ✔ Extends the due date for invoice ID 2 by two days.

📌 Example: Due Date Changes

Before Update → Due Date: 2025-06-01
After Update → Due Date: 2025-06-03
✔ Direct updates allow easy modifications through the view.





📌 4. Inserting Data Through an Updatable View
✔ Inserting data works if the view contains all required columns from the underlying table. 
✔ If a column allows NULL values, inserting through the view may fail.

📌 Key Rule for Inserts ✔ Ensure required columns (invoice_date, client_id, etc.) exist in the view.






Queries and other notes in this discussion: 

-- DISTINCT
-- Aggregate Functions (MIN, MAX, SUM,..) 
-- GROUP BY/ HAVING
-- UNION 


CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
	invoice_id, 
	number, 
	client_id, 
	invoice_total, 
	payment_total, 
	invoice_total - payment_total AS balance, 
	invoice_date, 
	due_date, 
	payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0; 



DELETE FROM invoices_with_balance
WHERE invoice_id = 1;


UPDATE invoices_with_balance
SET due_date = DATE_ADD(due_date, INTERVAL 2 DAY)
WHERE invoice_id = 2; 





📌 Summary
✔ Updatable views allow INSERT, UPDATE, and DELETE operations, provided no aggregation, grouping, or unions exist. 
✔ Views simplify complex calculations, making data handling more intuitive. 
✔ Using UPDATE and DELETE on views modifies the original table, ensuring changes reflect correctly. 















The WITH OPTION CHECK Clause: 
-----------------------------
🚀 Understanding the WITH CHECK OPTION Clause in MySQL Views
The WITH CHECK OPTION clause ensures that updates or deletions within a view do not remove rows from the view's result set. This prevents modifications that would cause records to disappear unexpectedly.

📌 1. Default Behavior of Updatable Views
✔ Views allow modifying data (INSERT, UPDATE, DELETE) under certain conditions. 
✔ However, changes may cause rows to no longer meet the view's filter criteria, removing them from results.

📌 Example: Removing a Record by Updating a Value 
✔ Suppose an invoice has an outstanding balance. 
✔ If we update the payment_total to match invoice_total, the balance becomes 0, and the record disappears from the view.

📌 Updating Payment Total to Match Invoice Total:
UPDATE invoices_with_balance
SET payment_total = invoice_total 
WHERE invoice_id = 2;
🚀 Effect: ✔ Invoice disappears from the view, because it no longer matches the condition (balance > 0).

📌 Refreshing the View ✔ Before update::
┌───────────┬──────────────┬───────────┐
│ InvoiceID │ InvoiceTotal │ Balance   │
├───────────┼──────────────┼───────────┤
│ 2         │ 450.00       │ 50.00     │ ✅ Balance exists
└───────────┴──────────────┴───────────┘

✔ After update:
(No results—InvoiceID '2' is removed from the view)

✔ Default behavior: rows disappear if modifications break view conditions.





📌 2. Using WITH CHECK OPTION to Prevent Data Loss
✔ Adding WITH CHECK OPTION prevents updates that would remove records from the view. 
✔ Any attempt to modify a row such that it no longer meets the view’s criteria will result in an error.

📌 Updating the View Definition:
CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
    invoice_id, 
    number, 
    client_id, 
    invoice_total, 
    payment_total, 
    invoice_total - payment_total AS balance, 
    invoice_date, 
    due_date, 
    payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0
WITH CHECK OPTION;

🚀 Effect: ✔ Ensures modifications keep records within the view.

📌 Attempting an Update That Would Remove a Row:
UPDATE invoices_with_balance
SET payment_total = invoice_total 
WHERE invoice_id = 3;

🚀 Effect: ✔ Fails with an error:

ERROR 1369 (HY000): CHECK OPTION failed
✔ Prevents removal of records due to modifications.





📌 3. When to Use WITH CHECK OPTION?
✔ Use WITH CHECK OPTION when you want to enforce view constraints, ensuring:
Data integrity is maintained.
Records do not unexpectedly disappear.
Users modifying data through views are restricted from breaking conditions.

📌 Best Practice ✔ Apply WITH CHECK OPTION on views with filtering conditions (WHERE, HAVING) to prevent unintended updates.





Queries used in this discussion: 

UPDATE invoices_with_balance
SET payment_total = invoice_total 
WHERE invoice_id = 2; 


CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
	invoice_id, 
	number, 
	client_id, 
	invoice_total, 
	payment_total, 
	invoice_total - payment_total AS balance, 
	invoice_date, 
	due_date, 
	payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0
WITH CHECK OPTION; 





📌 Summary
✔ Updatable views allow modifications, but rows may disappear if updates break view conditions. 
✔ Using WITH CHECK OPTION enforces constraints, preventing deletions due to updates. 
✔ Unsuccessful updates will trigger an error, ensuring data integrity within views.









Other Benefits Of Views:
------------------------
🚀 Key Benefits of Views in MySQL
Views in MySQL offer powerful advantages beyond simplifying queries. They help reduce the impact of database changes, provide data security, and improve maintainability.

📌 1. Simplifying Queries
✔ Views encapsulate complex queries, making them easier to manage and reuse. 
✔ Instead of writing lengthy JOIN, GROUP BY, and filtering logic repeatedly, store these operations within a view. 
✔ Example: Calculating Invoice Balances

CREATE VIEW invoices_with_balance AS
SELECT 
    invoice_id, 
    client_id, 
    invoice_total, 
    payment_total, 
    invoice_total - payment_total AS balance
FROM invoices;
🚀 Effect: ✔ Provides a structured way to retrieve balances, preventing repetition in multiple queries.





📌 2. Reducing the Impact of Database Changes
✔ Views create an abstraction layer, protecting queries from underlying table modifications. 
✔ If a table is renamed or a column is moved, queries referencing the view remain unaffected.

📌 Example: Handling Column Changes 
✔ If payment_total is renamed to total_paid, queries relying on invoices_with_balance would break. 
✔ Instead of modifying every query, simply update the view definition.

CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
    invoice_id, 
    client_id, 
    invoice_total, 
    total_paid AS payment_total,  -- Restoring old column name
    invoice_total - total_paid AS balance
FROM invoices;
🚀 Effect: ✔ Queries using the view remain unchanged, even if the original table column names change.





📌 Why It Matters? 
✔ Reduces maintenance overhead—only the view needs updating, not hundreds of queries. 
✔ Ensures backward compatibility for applications and reports.





📌 3. Restricting Access to Sensitive Data
✔ Views can restrict access to certain columns or rows, enhancing data security. 
✔ Instead of granting direct access to tables, users interact only with views, ensuring controlled visibility.

📌 Example: Restricting Sensitive Information 
✔ Suppose the invoices table contains financial data that some users should not access. 
✔ Instead of granting direct access, create a restricted view.

CREATE VIEW public_invoices AS
SELECT 
    invoice_id, 
    client_id, 
    invoice_total, 
    invoice_date 
FROM invoices;
🚀 Effect: ✔ Users can query public_invoices, but cannot see payment_total or balance.

📌 Additional Security Using WITH CHECK OPTION ✔ Prevent modifications that remove rows from a view.

CREATE VIEW invoices_with_balance AS
SELECT * FROM invoices WHERE invoice_total - payment_total > 0
WITH CHECK OPTION;
🚀 Effect: ✔ Ensures users cannot modify records in a way that removes them from the view.





📌 4. Best Practices for Using Views
✔ Use views for repeated queries, minimizing redundant code. 
✔ Ensure views remain updatable if required, avoiding aggregation functions like SUM() and GROUP BY. 
✔ Apply security controls to restrict access, improving data protection and compliance. 
✔ Store view definitions in version control, making updates easier for teams.




Main points in this discussion:

Simplify Queries
Reduce the impact of changes
Restrict access to the data 


📌 Summary
✔ Views simplify complex queries, making database management more efficient. 
✔ They protect queries from schema changes, preventing query disruptions. 
✔ They enhance security, limiting data exposure through controlled visibility. 




















Stored Procedures:
------------------
🚀 Understanding Stored Procedures in MySQL
Stored procedures in MySQL help organize SQL code, making database operations efficient, secure, and easier to maintain.

📌 1. What Are Stored Procedures?
✔ Stored procedures are database objects that contain SQL logic, allowing structured execution. 
✔ Instead of writing SQL queries in application code, procedures store queries within the database. 
✔ Applications call stored procedures to retrieve, update, or modify data efficiently.

📌 Example Use Case: 
✔ If building an application with Java, Python, or C#, embedding raw SQL within the application code makes it cluttered and hard to maintain. 
✔ Instead of mixing SQL with application logic, store queries in a MySQL stored procedure.





📌 2. Why Store SQL Code in Procedures?
✔ Avoid Messy Code Integration

Mixing SQL with application logic (C#, Java, Python) makes debugging difficult. ✔ Prevent Recompilation Issues
Some languages require compilation. If queries change, entire code recompile and redeployment may be needed. ✔ Improve Performance
Most database systems optimize stored procedures, making execution faster. ✔ Enhance Security
Restrict direct table access, ensuring only stored procedures modify records.

📌 Example: Calling a Stored Procedure from an Application ✔ Instead of writing:
SELECT * FROM orders WHERE order_date > '2024-01-01';

✔ Store it inside a procedure:
CREATE PROCEDURE GetRecentOrders()
BEGIN
    SELECT * FROM orders WHERE order_date > '2024-01-01';
END;
🚀 Effect: ✔ Allows applications to call GetRecentOrders(), simplifying query execution.





📌 3. Performance and Security Benefits
✔ Stored procedures improve execution speed by precompiling SQL logic. 
✔ Restrict direct access to tables, preventing unauthorized modifications.

📌 Example: Enforcing Security with Stored Procedures 
✔ Instead of granting direct table access, users only execute stored procedures.

GRANT EXECUTE ON PROCEDURE GetRecentOrders TO 'report_user';
🚀 Effect: ✔ Limits query execution privileges, ensuring restricted database interaction.





Queries and other notes used in this discussion:

Store and organize SQL
Faster execution
Data security


📌 Summary
✔ Stored procedures organize SQL code, reducing messiness in application logic. 
✔ They enhance performance, as databases optimize procedure execution. 
✔ They improve security, restricting direct table modifications. 

















Creating a Stored Procedure:
----------------------------
🚀 Creating a Stored Procedure in MySQL
Stored procedures allow SQL logic to be stored within the database, ensuring organized, reusable, and efficient queries.

📌 1.What Is a Stored Procedure?
✔ A stored procedure is a database object that contains SQL statements, which can be executed repeatedly without rewriting queries. 
✔ Instead of embedding SQL in application code, procedures store and execute queries within the database. 
✔ Stored procedures improve performance, maintainability, and security.

📌 Syntax for Creating a Stored Procedure:

CREATE PROCEDURE procedure_name()
BEGIN
    SQL_statement;
END;
✔ SQL statements within BEGIN ... END define the procedure’s functionality.





📌 2. Creating a Simple Stored Procedure
🚀 Scenario: ✔ We need a procedure to retrieve all clients.

📌 Defining the Stored Procedure:

DELIMITER $$

CREATE PROCEDURE get_clients()
BEGIN 
    SELECT * FROM clients;
END$$

DELIMITER ;
🚀 Effect: ✔ Creates a stored procedure called get_clients(), which retrieves all client records.

📌 Why Change the Delimiter? 
✔ MySQL uses ; as the default statement separator. 
✔ Stored procedures contain multiple statements, requiring a different delimiter ($$) to prevent execution issues.

📌 Example Output:
┌───────────┬───────────┬───────────────┐
│ ClientID  │ Name      │ City          │
├───────────┼───────────┼───────────────┤
│ 1         │ ABC Corp  │ New York      │ ✅ Client record
│ 2         │ Beta Ltd  │ San Francisco │ ✅ Client record
└───────────┴───────────┴───────────────┘
✔ Eliminates the need to rewrite queries for every request.





📌 3. Executing a Stored Procedure
✔ Stored procedures can be executed using the CALL statement.

📌 Executing get_clients()

CALL get_clients();
🚀 Effect: ✔ Retrieves all clients without rewriting SELECT queries.

📌 Best Practice ✔ Most applications call stored procedures using C#, Java, Python, rather than directly in SQL.





📌 4. Exercise: Creating a Stored Procedure for Invoice Balances
🚀 Task: ✔ Define a stored procedure get_invoices_with_balance() to retrieve invoices with outstanding balances.

📌 Writing the Query:
SELECT * FROM invoices WHERE invoice_total - payment_total > 0;
🚀 Effect: ✔ Retrieves invoices where payment total is less than invoice total, meaning balance > 0.

📌 Creating the Stored Procedure:
DELIMITER $$

CREATE PROCEDURE get_invoices_with_balance()
BEGIN 
    SELECT * 
    FROM invoices_with_balance
    WHERE balance > 0;  
END$$

DELIMITER ;
🚀 Effect: ✔ Stores invoice retrieval logic inside the procedure, making it reusable.

📌 Executing the Procedure:
CALL get_invoices_with_balance();
🚀 Effect: ✔ Returns all invoices with outstanding balances.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ InvoiceID │ ClientID  │ Total     │ Balance   │
├───────────┼───────────┼───────────┼───────────┤
│ 101       │ 5         │ 250.00    │ 75.00     │ ✅ Balance due
│ 204       │ 3         │ 320.00    │ 120.00    │ ✅ Pending payment
└───────────┴───────────┴───────────┴───────────┘
✔ Optimizes invoice tracking, eliminating repetitive queries.





Queries and other notes used in this discussion:

CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients;
END 



DELIMITER $$
CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients;
END$$ 

DELIMITER ;


CALL get_clients()


Exercise: 
-- create a stored procedure called 
--  get_invoices_with_balance
--  to return all the invoices with a balance > 0


SELECT *
FROM invoices 
WHERE invoice_total - payment_total > 0  


DELIMITER $$
CREATE PROCEDURE get_invoices_with_balance()
BEGIN 
	SELECT * 
	FROM invoices_with_balance
	WHERE balance > 0;  
END$$

DELIMITER ; 





📌 Summary
✔ Stored procedures encapsulate SQL logic, improving code reuse and efficiency. 
✔ Changing the delimiter ensures MySQL correctly processes multi-statement procedures. 
✔ Procedures are executed using the CALL statement, making queries reusable. 
















Creating Procedures Using MySQLWorkbench:
-----------------------------------------
🚀 Creating Stored Procedures Using MySQL Workbench
Creating stored procedures manually in MySQL requires modifying the default delimiter, which can be tedious. However, MySQL Workbench provides an easier way, allowing direct procedure creation without manually adjusting delimiters.

📌 1. Using MySQL Workbench for Stored Procedures
✔ MySQL Workbench allows procedure creation through its GUI, simplifying workflow.

📌 Steps for Creating a Procedure Using MySQL Workbench 
1. Open MySQL Workbench and navigate to your database. 
2. Right-click the Stored Procedures folder in the navigator panel. 
3. Click "Create Stored Procedure" to open the procedure editor. 
4. Define the procedure name (e.g., get_payments). 
5. Write the SQL statements, ensuring each ends with a ;. 
6. Click "Apply" to save and execute.

📌 Example Procedure in Workbench:
CREATE PROCEDURE 'get_payments' ()
BEGIN 
    SELECT * FROM payments; 
END;

🚀 Effect: ✔ Stores the query inside a procedure for easy execution.





📌 2. Handling Delimiters in Workbench
✔ Unlike manual SQL entry, MySQL Workbench automatically handles delimiters. ✔ Upon clicking "Apply," MySQL Workbench generates necessary SQL commands, ensuring smooth execution.

📌 MySQL Workbench Generates These SQL Statements Automatically:
USE 'sql_invoicing';

DROP PROCEDURE IF EXISTS 'get_payments';

DELIMITER $$

USE 'sql_invoicing'$$
CREATE PROCEDURE 'get_payments' ()
BEGIN
    SELECT * FROM payments; 
END$$

DELIMITER ;

🚀 Effect: ✔ Automatically sets delimiters, preventing manual adjustments.





📌 3. Executing a Stored Procedure
✔ Once created, stored procedures can be executed using CALL.

📌 Calling get_payments():

CALL get_payments();
🚀 Effect: ✔ Returns all payments from the payments table.

📌 Example Output:
┌───────────┬───────────┬────────────┐
│ PaymentID │ Amount    │ Date       │
├───────────┼───────────┼────────────┤
│ 1         │ 450.00    │ 2025-06-01 │ ✅ Completed payment
│ 2         │ 320.00    │ 2025-06-03 │ ✅ Pending transaction
└───────────┴───────────┴────────────┘
✔ Simplifies payment retrieval without rewriting SELECT queries.





Queries and other notes used in this discussion:

Stored Procedures --> Create Stored Procedure 


CREATE PROCEDURE 'get_payments' ()
BEGIN 
	SELECT * FROM payments; 
END 



MySQL generates these SQL statements: 

USE 'sql_invoicing';
DROP procedure IF EXISTS 'get_payments';

DELIMITER $$
USE 'sql_invoicing'$$
CREATE PROCEDURE 'get_payments' ()
BEGIN
	SELECT * FROM payments; 
END$$

DELIMITER ;







📌 Summary:
✔ MySQL Workbench makes stored procedure creation easier, eliminating manual delimiter changes. 
✔ Stored procedures ensure structured, efficient queries, improving database maintainability. 
✔ Workbench generates necessary SQL commands automatically, saving development time. 

















Dropping Stored Procedures:
---------------------------
🚀 Dropping Stored Procedures in MySQL
Stored procedures help structure SQL logic within the database. However, when modifications are needed, procedures must be dropped and recreated. This guide covers how to safely drop stored procedures while maintaining version control.

📌 1. Dropping a Stored Procedure:
✔ The DROP PROCEDURE statement removes a stored procedure from the database. ✔ Attempting to drop a nonexistent procedure results in an error.

📌 Basic Syntax:
DROP PROCEDURE get_clients;
🚀 Effect: ✔ Removes get_clients from the database.

📌 Handling Errors When Dropping Procedures ✔ If a procedure does not exist, MySQL raises an error.
DROP PROCEDURE get_clients;
-- ERROR 1305 (42000): PROCEDURE get_clients does not exist

✔ To prevent errors, use IF EXISTS.





📌 2. Safely Dropping a Procedure Using IF EXISTS
✔ Adding IF EXISTS prevents MySQL from raising an error if the procedure doesn't exist.

📌 Recommended Safe Dropping Syntax:
DROP PROCEDURE IF EXISTS get_clients;
🚀 Effect: ✔ Ensures smooth execution, avoiding unnecessary errors.





📌 3. Best Practices for Managing Stored Procedures
✔ Store procedure definitions in SQL files, ensuring organized version control. 
✔ Use Git for tracking changes, allowing teams to maintain consistency.

📌 Example SQL File Structure:
stored_procedures/
   ├── get_clients.sql
   ├── get_invoices.sql
   
🚀 Effect: ✔ Allows developers to revert changes or deploy procedures seamlessly.

📌 Typical SQL File Contents:
DROP PROCEDURE IF EXISTS get_clients;

DELIMITER $$

CREATE PROCEDURE get_clients()
BEGIN 
    SELECT * FROM clients; 
END$$

DELIMITER ;
✔ Ensures every stored procedure can be recreated when needed.





Queries and other notes used in this discussion:

DROP PROCEDURE get_clients

DROP PROCEDURE IF EXISTS get_clients;

DELIMITER $$
CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients; 
END$$

DELIMITER ; 






📌 Summary
✔ Use DROP PROCEDURE to remove stored procedures when modifications are required. 
✔ Using IF EXISTS prevents errors when dropping nonexistent procedures. 
✔ Maintain stored procedures in SQL files within version control, ensuring structured updates and collaboration. 













Parameters:
----------
🚀 Using Parameters in MySQL Stored Procedures
Stored procedures can accept parameters, allowing dynamic query execution. This tutorial covers how to define and use parameters in MySQL stored procedures.

📌 1. What Are Parameters in Stored Procedures?
✔ Parameters allow passing values into stored procedures, making queries flexible and reusable. 
✔ They can be used for filtering data dynamically, instead of hardcoding values. 
✔ Types of parameters:
CHAR(n) → Fixed-length string (Example: "CA" for California).
VARCHAR(n) → Variable-length string (Example: "California").
INT → Whole numbers (Example: 1, 10, 250).





📌 2. Creating a Stored Procedure with a Parameter
🚀 Scenario: ✔ Create a stored procedure to retrieve clients by state.

📌 Defining the Procedure:
DROP PROCEDURE IF EXISTS get_clients_by_state;

DELIMITER $$

CREATE PROCEDURE get_clients_by_state(
    state CHAR(2)  -- Two-character state code
)
BEGIN 
    SELECT * FROM clients c
    WHERE c.state = state; 
END $$

DELIMITER ;
🚀 Effect: ✔ Defines a procedure get_clients_by_state(), which filters clients based on the passed state parameter.


📌 Executing the Procedure:
CALL get_clients_by_state('CA');
🚀 Effect: ✔ Returns all clients in California (CA).


📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ CA        │ ✅ California-based client
│ 2         │ Beta Ltd  │ CA        │ ✅ California-based client
└───────────┴───────────┴───────────┘
📌 Handling Column vs. Parameter Naming ✔ Avoid confusion when column and parameter names match. ✔ Prefix table aliases (c.state) to differentiate column names from parameters.





📌 3. Exercise: Creating a Procedure for Invoice Retrieval
🚀 Task: ✔ Create a stored procedure get_invoices_by_client() to retrieve invoices by client ID.
📌 Finding the Correct Parameter Type 
✔ Look at the client_id column in the invoices table. 
✔ If client_id is INT, the parameter should also be INT.

📌 Creating the Procedure:
DROP PROCEDURE IF EXISTS get_invoices_by_client;

DELIMITER $$

CREATE PROCEDURE get_invoices_by_client(
    client_id INT  -- Client ID as integer
)
BEGIN 
    SELECT * FROM invoices i
    WHERE i.client_id = client_id; 
END $$

DELIMITER ;
🚀 Effect: ✔ Allows retrieving invoices dynamically based on the given client ID.


📌 Calling the Procedure:
CALL get_invoices_by_client(1);
🚀 Effect: ✔ Fetches invoices for Client ID 1.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ InvoiceID │ ClientID  │ Amount    │ Date      │
├───────────┼───────────┼───────────┼───────────┤
│ 101       │ 1        │ 450.00    │ 2025-06-10 │ ✅ Invoice linked to Client 1
│ 102       │ 1        │ 320.00    │ 2025-06-15 │ ✅ Invoice linked to Client 1
└───────────┴───────────┴───────────┴───────────┘
✔ Retrieves invoices dynamically, eliminating hardcoded queries.






Queries and other notes in this discussion:

DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	SELECT * FROM clients c
	WHERE c.state = state; 
END $$

DELIMITER ;



CALL get_clients_by_state('CA')


Exercise: 

-- Write a stored procedure to return invoices 
-- for a given client 
--
-- get_invoices_by_client 


DROP PROCEDURE IF EXISTS get_invoices_by_client();

DELIMITER$$
CREATE PROCEDURE get_invoices_by_client
(
	client_id INT 
)
BEGIN 
	SELECT * FROM invoices i
	WHERE i.client_id = client_id; 
END $$

DELIMITER ;





📌 Summary
✔ Parameters allow stored procedures to accept dynamic inputs, improving query flexibility. 
✔ Use CHAR(n), VARCHAR(n), or INT based on column data type, ensuring correct execution. 
✔ Alias table names (c.state) when parameters match column names, preventing filtering errors. 
✔ Stored procedures simplify execution, making queries structured and efficient.






















Parameter With Default Value:
-----------------------------
🚀 Using Default Values in Stored Procedure Parameters in MySQL
Stored procedures in MySQL can accept parameters with default values, allowing flexibility in execution. This tutorial covers how to assign default values, conditionally filter data, and optimize queries.

📌 1. Why Use Default Values in Stored Procedures?
✔ Allows procedures to execute even when parameters are missing. 
✔ Enables flexible filtering, returning default results when parameters are null. 
✔ Reduces redundant queries, making stored procedures efficient and reusable.





📌 2. Assigning Default Values Using IF Statements
🚀 Scenario: ✔ Modify get_clients_by_state() to return California (CA) by default when no state is provided.

📌 Procedure Definition:
DROP PROCEDURE IF EXISTS get_clients_by_state;

DELIMITER $$

CREATE PROCEDURE get_clients_by_state(
    state CHAR(2)  -- Two-character state code
)
BEGIN 
    IF state IS NULL THEN 
        SET state = 'CA';  -- Default state
    END IF;
    
    SELECT * FROM clients c
    WHERE c.state = state; 
END $$

DELIMITER ;

🚀 Effect: ✔ If NULL is passed, procedures return clients from California (CA).

📌 Executing the Procedure:
CALL get_clients_by_state(NULL);

🚀 Effect: ✔ Returns California clients when no state is supplied.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ ClientID  │ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 1         │ ABC Corp  │ CA        │ ✅ California-based client
│ 2         │ Beta Ltd  │ CA        │ ✅ California-based client
└───────────┴───────────┴───────────┘





📌 3. Returning All Clients When No State is Provided
✔ Instead of assigning CA as the default, return all clients if NULL is passed.

📌 Procedure Definition:
DROP PROCEDURE IF EXISTS get_clients_by_state;

DELIMITER $$

CREATE PROCEDURE get_clients_by_state(
    state CHAR(2) 
)
BEGIN 
    IF state IS NULL THEN 
        SELECT * FROM clients;  -- Return all clients
    ELSE
        SELECT * FROM clients c WHERE c.state = state;
    END IF;
END $$

DELIMITER ;
🚀 Effect: ✔ Returns all clients when no state is specified. ✔ When a state is provided, filters clients by state.

📌 Executing the Procedure:
CALL get_clients_by_state(NULL);  -- Returns all clients
CALL get_clients_by_state('NY');  -- Returns clients from New York

✔ Efficient data filtering, avoiding unnecessary conditions.





📌 4. Optimizing Queries Using IFNULL()
✔ Instead of using IF-ELSE, use IFNULL() in the WHERE clause.

📌 Updated Procedure Definition:
DROP PROCEDURE IF EXISTS get_clients_by_state;

DELIMITER $$

CREATE PROCEDURE get_clients_by_state(
    state CHAR(2) 
)
BEGIN 
    SELECT * FROM clients c
    WHERE c.state = IFNULL(state, c.state);  
END $$

DELIMITER ;

🚀 Effect: ✔ If state is NULL, it compares c.state = c.state (always true), returning all records. ✔ If state is specified, filters by state.

📌 Executing the Procedure:
CALL get_clients_by_state(NULL);  -- Returns all clients
CALL get_clients_by_state('TX');  -- Returns clients in Texas
✔ Efficient and structured filtering using a single query.





📌 5. Exercise: Creating a Flexible Payment Query
🚀 Task: 
✔ Define a stored procedure get_payments() with: 
 - client_id (INT) 
 - payment_method_id (TINYINT) 
✔ If both parameters are NULL, return all payments. 
✔ If only client_id is supplied, return payments for that client. 
✔ If both are supplied, return payments matching both criteria.

📌 Procedure Definition:
DROP PROCEDURE IF EXISTS get_payments;

DELIMITER $$

CREATE PROCEDURE get_payments(
    client_id INT,
    payment_method_id TINYINT
)
BEGIN 
    SELECT * FROM payments p
    WHERE 
        p.client_id = IFNULL(client_id, p.client_id) AND 
        p.payment_method = IFNULL(payment_method_id, p.payment_method);
END $$

DELIMITER ;

🚀 Effect: ✔ Handles different filtering cases dynamically.

📌 Executing the Procedure:
CALL get_payments(NULL, NULL);  -- Returns all payments
CALL get_payments(5, NULL);  -- Returns payments for client ID 5
CALL get_payments(NULL, 2);  -- Returns payments using method ID 2
CALL get_payments(5, 2);  -- Returns payments for client ID 5 using method 2

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ PaymentID │ ClientID  │ Amount    │ Method    │
├───────────┼───────────┼───────────┼───────────┤
│ 10        │ 5         │ 250.00    │ 2         │ ✅ Payment for Client 5 using Method 2
└───────────┴───────────┴───────────┴───────────┘

✔ Simplifies flexible payment queries using parameters with default values.





Queries and other notes in this discussion:
DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	IF state IS NULL THEN 
		SET state = 'CA';
	END IF; 
	
	SELECT * FROM clients c
	WHERE c.state = state; 
END $$

DELIMITER ;

CALL get_clients_by_state(NULL)


-- if you want to display all clients of all states 

DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	IF state IS NULL THEN 
		SELECT * FROM clients; 
	ELSE
		SELECT * FROM clients c
		WHERE c.state = state; 
	END IF; 

END $$

DELIMITER ;

CALL get_clients_by_state(NULL)



DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	SELECT * FROM clients c
	WHERE C.state = IFNULL(state, c.state);   -- if it is null, c.state = c.state, this condition is always true, returns all the rows

END $$

DELIMITER ;

CALL get_clients_by_state(NULL)



EXERCISE: 

-- Write a stored procedure called get_payments
-- with two parameters
--
-- client_id => INT
-- payment_method_id => TINYINT



DROP PROCEDURE IF EXISTS get_payments();

DELIMITER$$
CREATE PROCEDURE get_payments
(
	client_id INT,
	payment_method_id TINYINT
)
BEGIN 
	SELECT *
	FROM payments p
	WHERE 
		p.client_id = IFNULL(client_id, p.client_id) AND 
		p.payment_method  = IFNULL(payment_method_id, p.payment_method_id);

END $$

DELIMITER ;

CALL get_payments(NULL, NULL)

CALL get_payments(5, NULL)

CALL get_payments(NULL, 2)





📌 Summary
✔ Assign default values using IF NULL THEN SET, ensuring procedures execute when parameters are missing. 
✔ Use IFNULL() for dynamic filtering, preventing redundant queries. 
✔ Stored procedures allow flexible execution, enabling conditional data retrieval. 










Parameter Validation:
---------------------
🚀 Parameter Validation in MySQL Stored Procedures
Stored procedures can insert, update, and delete data, but without validation, they may store incorrect values. This guide covers parameter validation techniques to ensure data integrity and prevent errors.

📌 1. Why Validate Parameters in Stored Procedures?
✔ Prevents invalid data entry, ensuring only valid values are inserted or updated. 
✔ Improves data integrity, avoiding negative, out-of-range, or null values. 
✔ Ensures meaningful error handling, allowing procedures to return useful messages when validation fails.

📌 2. Creating a Stored Procedure with Parameter Validation
🚀 Scenario: ✔ Define a procedure make_payment() to update an invoice’s payment total and payment date. ✔ Ensure payment amount is valid (greater than 0).

📌 Initial Procedure Without Validation:
USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER $$

CREATE PROCEDURE make_payment(
    invoice_id INT,
    payment_amount DECIMAL(9,2),
    payment_date DATE
)
BEGIN 
    UPDATE invoices i
    SET 
        i.payment_total = payment_amount,
        i.payment_date = payment_date
    WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;

🚀 Effect: ✔ Updates payment details for a given invoice, but does not prevent negative amounts.


📌 Executing the Procedure:
CALL make_payment(2, 100, '2019-01-01');
🚀 Effect: ✔ Successfully updates invoice 2 with payment $100.


📌 Example Output:
InvoiceID | Payment Total | Payment Date
-----------------------------------------
2         | 100.00        | 2019-01-01
✔ Works correctly for valid payment amounts.





📌 3. Preventing Invalid Payments with Parameter Validation
✔ Ensure payment amount is greater than 0. ✔ Use SIGNAL to raise an error if invalid values are passed.

📌 Updating the Procedure with Validation:
USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER $$

CREATE PROCEDURE make_payment(
    invoice_id INT,
    payment_amount DECIMAL(9,2),
    payment_date DATE
)
BEGIN 
    IF payment_amount <= 0 THEN 
        SIGNAL SQLSTATE '22003' SET MESSAGE_TEXT = 'Invalid payment amount';
    END IF;

    UPDATE invoices i
    SET 
        i.payment_total = payment_amount,
        i.payment_date = payment_date
    WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;
🚀 Effect: ✔ Prevents invalid payments, ensuring only valid amounts are stored.


📌 Executing the Procedure with Invalid Payment:
CALL make_payment(2, -100, '2019-01-01');
🚀 Effect: ✔ Triggers an error:

ERROR 22003 (HY000): Invalid payment amount
✔ Prevents storing negative values in payment_total.


📌 Example: Refreshing Invoice Data
InvoiceID | Payment Total | Payment Date
-----------------------------------------
2        | 100.00        | 2019-01-01  ✅ Correct

✔ Data integrity is maintained—negative values are rejected.





📌 4. Understanding SQLSTATE Error Codes
✔ Error codes classify validation failures, ensuring standardized error handling. 
✔ 22003 is the SQL standard error code for "numeric value out of range".

📌 Finding SQL Error Codes ✔ Search for SQLSTATE error codes online to find standard errors. ✔ Use IBM’s formatted SQL error code list for clarity.





📌 5. Best Practices for Parameter Validation
✔ Validate critical inputs (payment amounts, IDs, required fields) to prevent bad data entry. 
✔ Use SIGNAL SQLSTATE to provide detailed error messages, improving troubleshooting. 
✔ Avoid excessive validation within stored procedures—validate inputs in the application layer where possible.

📌 Example: Application-Level Validation ✔ Before calling the procedure, check input values in Java/Python/PHP:

if payment_amount <= 0:
    raise ValueError("Invalid payment amount")

🚀 Effect: ✔ Catches errors before hitting the database, reducing query execution overhead.





Queries and other notes in this discussion:

USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER$$
CREATE PROCEDURE make_payment
(
	invoice_id INT,
	payment_amount DECIMAL(9,2),
	payment_date DATE
)
BEGIN 
	UPDATE invoices i
	SET 
		i.payment_total = payment_amount,
		i.payment_date = payment_date
	WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;

CALL make_payment(2, 100, '2019-01-01')




USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER$$
CREATE PROCEDURE make_payment
(
	invoice_id INT,
	payment_amount DECIMAL(9,2),
	payment_date DATE
)
BEGIN 
	IF payment_amount <=  0 THEN 
		SIGNAL SQLSTATE '22003' SET MESSAGE_TEXT = 'Invalid payment amount';
	END IF; 
	
	UPDATE invoices i
	SET 
		i.payment_total = payment_amount,
		i.payment_date = payment_date
	WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;

CALL make_payment(2, -100, '2019-01-01')



search for sqlstate errors 





📌 Summary
✔ Stored procedures allow inserting, updating, and deleting data, but require validation to prevent errors. 
✔ Use SIGNAL SQLSTATE to raise errors, ensuring invalid parameters are handled properly. 
✔ SQLSTATE error codes standardize validation messages, improving debugging and user feedback. 
✔ Keep validation minimal in stored procedures, relying on application-level checks where possible.













Output Parameters: 
------------------
🚀 Using Output Parameters in MySQL Stored Procedures
Stored procedures in MySQL can accept input parameters, but they can also return values using output parameters. This tutorial covers how to define and retrieve output parameters in stored procedures.

📌 1. What Are Output Parameters in Stored Procedures?
✔ Input parameters allow passing values to a procedure. 
✔ Output parameters allow returning values from a procedure. 
✔ Useful for returning multiple values, making stored procedures more versatile.





📌 2. Creating a Stored Procedure with Output Parameters
🚀 Scenario: 
✔ Define a procedure get_unpaid_invoices_for_client() to return: 
 - Total count of unpaid invoices (invoices_count) 
 - Sum of unpaid invoice amounts (invoices_total)

📌 Defining the Procedure:
DELIMITER $$

CREATE PROCEDURE get_unpaid_invoices_for_client(
    client_id INT,
    OUT invoices_count INT,    -- Output parameter for total count
    OUT invoices_total DECIMAL(9,2) -- Output parameter for total amount
)
BEGIN 
    SELECT COUNT(*), SUM(invoice_total)
    INTO invoices_count, invoices_total 
    FROM invoices i
    WHERE i.client_id = client_id AND payment_total = 0; 
END $$

DELIMITER ;
🚀 Effect: ✔ Stores calculated values in output parameters, ensuring dynamic result retrieval.


📌 Executing the Procedure:
CALL get_unpaid_invoices_for_client(3);

🚀 Effect: ✔ Returns total unpaid invoices and their sum.

📌 Example Output:
Invoices Count | Invoices Total
--------------------------------
2              | 286.00





📌 3. Retrieving Output Parameters Using Variables
✔ Output parameters do not directly return values in MySQL. 
✔ Use user-defined variables (@variable) to capture output parameter values.

📌 Defining Variables and Calling the Procedure:
SET @invoices_count = 0;
SET @invoices_total = 0;

CALL get_unpaid_invoices_for_client(3, @invoices_count, @invoices_total);

SELECT @invoices_count, @invoices_total;
🚀 Effect: ✔ Stores output values into user-defined variables, allowing retrieval.


📌 Example Output:
@invoices_count | @invoices_total
---------------------------------
2               | 286.00

✔ Variables hold returned values, making them accessible for further calculations.





📌 4. When to Use Output Parameters?
✔ Useful for returning multiple computed values. 
✔ Not necessary for simple queries—consider using SELECT instead. 
✔ Preferred when integrating stored procedures with external applications (Java, Python, etc.).

📌 Alternative Approach Using SELECT (Avoiding Output Parameters) ✔ Instead of using output parameters, directly return values.

SELECT COUNT(*) AS invoices_count, SUM(invoice_total) AS invoices_total
FROM invoices
WHERE client_id = 3 AND payment_total = 0;
🚀 Effect: ✔ Directly retrieves results without needing variables.

📌 Why Avoid Output Parameters? 
✔ Adds complexity—using SELECT is simpler for direct queries. 
✔ Requires extra steps (SET variables, CALL procedure, SELECT variables).






Queries and other notes in this discussion:

DELIMITER$$
CREATE PROCEDURE get_unpaid_invoices_for_client
(
	client_id INT
	OUT invoices_count INT
	OUT invoices_total DECIMAL(9,2)
)
BEGIN 
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total 
	FROM invoices i
	WHERE i.client_id = client_id AND payment_total = 0; 
	
END$$

DELIMITER ;


CALL get_unpaid_invoices_for_client(3); 


set @invoices_count = 0;
set @invoices_total = 0; 

CALL get_unpaid_invoices_for_client(3, @invoices_count, @invoices_total); 

select @invoices_count, @invoices_total;





📌 Summary
✔ Stored procedures can return values using output parameters, but require additional steps to retrieve them. 
✔ Use output parameters for complex procedures that need multiple values. 
✔ For simple queries, prefer SELECT instead of output parameters. 














Variables:
----------
🚀 Understanding Variables in MySQL Stored Procedures
MySQL supports two main types of variables: user (session) variables and local variables. These variables store values in memory, helping perform calculations and pass information within stored procedures.

📌 1. User (Session) Variables
✔ User variables persist throughout a session until the client disconnects. 
✔ They are prefixed with @ and defined using the SET statement. 
✔ Commonly used for retrieving values from stored procedures with output parameters.

📌 Example: Defining a User Variable
SET @invoices_count = 0;

🚀 Effect: ✔ Initializes @invoices_count with a value of 0, storing it for the session duration.


📌 Using User Variables in Stored Procedure Calls:
CALL get_unpaid_invoices_for_client(3, @invoices_count, @invoices_total);
SELECT @invoices_count, @invoices_total;

🚀 Effect: ✔ Stores output values in user variables, making them accessible across session queries.

📌 Example Output:
@invoices_count | @invoices_total
---------------------------------
2               | 286.00

✔ Used for retrieving procedure results dynamically.





📌 2. Local Variables
✔ Defined inside stored procedures using the DECLARE statement. 
✔ Exist only within the procedure—disappear after execution. 
✔ Often used for calculations, temporary storage, and transformations.

📌 Example: Declaring a Local Variable:
DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;

🚀 Effect: ✔ Creates a variable (risk_factor) for temporary calculations. ✔ Disappears after procedure execution.


📌 Data Types Used for Local Variables:
Type	        Usage
INT	            Whole numbers
DECIMAL(m, n)	Numbers with decimal points
VARCHAR(n)	    Text values
DATE	        Date storage





📌 3. Using Local Variables in a Stored Procedure
🚀 Scenario: ✔ Define a procedure get_risk_factor() to calculate a risk factor based on invoices.

📌 Procedure Definition:
CREATE PROCEDURE get_risk_factor()
BEGIN 
    -- Define local variables
    DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
    DECLARE invoices_total DECIMAL(9, 2); 
    DECLARE invoices_count INT; 
    
    -- Fetch invoice data
    SELECT COUNT(*), SUM(invoice_total)
    INTO invoices_count, invoices_total
    FROM invoices; 
    
    -- Compute risk factor
    SET risk_factor = invoices_total / invoices_count * 5; 

    -- Return result
    SELECT risk_factor;
END;

🚀 Effect: ✔ Calculates risk_factor dynamically, making use of local variables.


📌 Executing the Procedure:
CALL get_risk_factor();

🚀 Effect: ✔ Returns computed risk factor.


📌 Example Output
Risk Factor
-----------
777.75

✔ Ensures structured calculations within the procedure.





📌 4. Differences Between User and Local Variables
Variable Type	          Scope	                                 Prefix Used	                       Persistence
User (Session) Variable	  Exists throughout session	             @variable_name	                       Disappears upon disconnect
Local Variable	          Exists only inside stored procedures	 Declared with DECLARE (no prefix)	   Freed after procedure execution

📌 When to Use Each? 
✔ Use user variables (@var) for passing results between queries. 
✔ Use local variables (DECLARE var) for temporary calculations inside procedures.





Queries and other notes in this discussion:

-- user or session variables
SET @invoices_count = 0

-- Local variable

CREATE PROCEDURE get_risk_factor()
BEGIN 
-- risk_factor = invoices_total / invoices_count * 5
	DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
	DECLARE invoices_total DECIMAL(9, 2); 
	DECLARE invoices_count INT; 
	
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total
	FROM invoices; 
	
	SET risk_factor = invoices_total / invoices_count * 5; 

	SELECT risk_factor;
END 





📌 Summary
✔ User variables (@var) persist during a session, useful for storing output parameters. 
✔ Local variables (DECLARE var) exist only inside stored procedures, ideal for temporary calculations. 
✔ Stored procedures use variables to store, manipulate, and return results dynamically. 












Functions:
----------
🚀 Creating and Using Functions in MySQL
MySQL allows custom functions, enabling structured calculations within queries. Unlike stored procedures, functions return a single value, making them ideal for specific computations.

📌 1. What Are Functions in MySQL?
✔ Functions return a single value, unlike stored procedures that can return multiple rows/columns. 
✔ Useful for specific calculations, such as tax calculations, order totals, or risk assessments. 
✔ Can be used in SELECT statements, just like built-in MySQL functions (SUM(), COUNT(), ROUND()).





📌 2. Syntax for Creating Functions
✔ Functions use the CREATE FUNCTION statement, defining parameters, return type, and SQL logic.

📌 Basic Structure:
CREATE FUNCTION function_name(param1 datatype, param2 datatype) 
RETURNS return_datatype
DETERMINISTIC   -- Function behavior attribute
BEGIN
    -- Function logic here
    RETURN value;
END;

✔ Every function must return a value using RETURN.





📌 3. Creating a Function for Risk Factor Calculation
🚀 Scenario: ✔ Define a function get_risk_factor_for_client() to calculate risk factor based on invoices.

📌 Defining the Function:
CREATE FUNCTION get_risk_factor_for_client(client_id INT) 
RETURNS DECIMAL(9,2)
READS SQL DATA 
BEGIN
    -- Declare variables
    DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
    DECLARE invoices_total DECIMAL(9, 2); 
    DECLARE invoices_count INT; 
    
    -- Retrieve invoice details
    SELECT COUNT(*), SUM(invoice_total)
    INTO invoices_count, invoices_total
    FROM invoices i 
    WHERE i.client_id = client_id;
    
    -- Compute risk factor
    SET risk_factor = invoices_total / invoices_count * 5;
    
    -- Ensure NULL values default to 0
    RETURN IFNULL(risk_factor, 0);
END;

🚀 Effect: ✔ Stores logic for risk factor calculation within the function. ✔ Prevents NULL errors using IFNULL(), ensuring clean calculations.

📌 Attributes Used:
Attribute	        Usage
DETERMINISTIC	    Ensures consistent results for identical inputs
READS SQL DATA	    Allows function to fetch data from tables
MODIFIES SQL DATA	Allows function to modify tables (Not used here)

📌 Why Remove DETERMINISTIC? 
✔ The function reads dynamic data (invoices), meaning results can change. 
✔ A client's risk factor may update due to invoice changes, making it non-deterministic.





📌 4. Using the Function in a Query
✔ Functions integrate seamlessly into SELECT queries, just like built-in MySQL functions.

📌 Retrieving Risk Factors for Clients:
SELECT 
    client_id, 
    name, 
    get_risk_factor_for_client(client_id) AS risk_factor
FROM clients; 

🚀 Effect: ✔ Calculates risk factor dynamically for each client.

📌 Example Output:
ClientID | Name      | Risk Factor
----------------------------------
1        | ABC Corp  | 777.75
2        | Beta Ltd  | 0.00  -- No invoices

✔ Clients without invoices return 0 instead of NULL.





📌 5. Handling NULL Values in Calculations
✔ If a client has no invoices, SUM(invoice_total) returns NULL, affecting computations. ✔ Using IFNULL(value, default_value) ensures NULL values default to 0.

📌 Example Update:
SET risk_factor = IFNULL(invoices_total / invoices_count * 5, 0);

🚀 Effect: ✔ Prevents calculation errors, ensuring consistent results.





📌 6. Dropping a Function
✔ Functions can be removed using DROP FUNCTION.

📌 Deleting the Function:
DROP FUNCTION IF EXISTS get_risk_factor_for_client;

🚀 Effect: ✔ Removes the function from the database, allowing recreation or updates.





Queries and other notes in this discussion:

CREATE FUNCTION function_name(param1 datatype, param2 datatype) 
RETURNS return_datatype
DETERMINISTIC   -- Other attributes are READS SQL DATA, MODIFIES SQL DATA 
BEGIN
    -- Function logic here
    RETURN value;
END;


CREATE FUNCTION get_rist_factor_for_client(client_id INT) 
RETURNS INTEGER
READS SQL DATA 
BEGIN
	DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
	DECLARE invoices_total DECIMAL(9, 2); 
	DECLARE invoices_count INT; 
	
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total
	FROM invoices i 
	WHERE i.client_id = client_id;
	
	SET risk_factor = invoices_total / invoices_count * 5; 
    RETURN IFNULL(risk_factor, 0);
END;




SELECT 
	client_id, 
	name, 
	get_rist_factor_for_client(client_id) AS risk_factor
FROM clients; 


DROP FUNCTION IF EXISTS get_rist_factor_for_client; 





📌 Summary
✔ Functions return a single value, making them ideal for structured calculations. 
✔ Use RETURN to specify the result, ensuring seamless execution. 
✔ Functions integrate directly into queries, improving readability and efficiency. 
✔ Handling NULL values prevents computation errors, ensuring clean results. 











Other Conventions:
------------------
🚀 Naming Conventions in MySQL Development:
Every organization adopts different naming conventions for stored procedures, functions, and delimiters. There is no universally best convention—the key is consistency.

📌 1. Naming Conventions for Stored Procedures and Functions
✔ Different organizations follow different approaches for naming procedures and functions. 
✔ Some developers prefer prefixes like:
fn_ → Functions
proc_ → Stored procedures

✔ Camel Case vs. Underscore Naming:

Convention	                                Example
Prefix-based (procedures)	                proc_get_risk_factor
Prefix-based (functions)	                fn_calculate_tax
Camel Case (procedures)	                    procGetRiskFactor
Camel Case (functions)	                    getRiskFactor
Underscore-based (procedures/functions)	    get_risk_factor

🚀 Effect: 
✔ Some teams prefer proc_ or fn_ prefixes, while others omit them entirely. 
✔ Some prefer camel case, while others use underscores for readability.

📌 Advice: Stick to Your Team’s Existing Convention 
✔ If working on an existing project, follow the organization’s standard naming. 
✔ Do not introduce new conventions without consensus, as it can cause inconsistency.





📌 2. Conventions for Changing MySQL Delimiters
✔ Different teams use different delimiters to define stored procedures and functions. 
✔ Some commonly used delimiters include:

Delimiter Type	             Example Syntax
Double Dollar Signs ($$)	 DELIMITER $$ ... END $$ DELIMITER ;
Double Slashes (//)	D        ELIMITER // ... END // DELIMITER ;

🚀 Effect: ✔ Both work identically, but teams adopt different preferences.

📌 Advice: Use the Existing Convention in Your Organization ✔ If existing procedures use $$, stick with $$. ✔ If existing procedures use //, stick with //.





📌 3. Why Adopting Existing Conventions Matters
✔ Consistency across the project prevents unnecessary confusion. 
✔ Easier code readability—teams quickly recognize standard patterns. 
✔ Maintains uniformity in large applications, avoiding fragmented naming styles.

📌 Best Practice for New Projects 
✔ When starting a project from scratch, choose a convention that aligns with industry standards. 
✔ Ensure all developers agree on the naming standard before beginning development.




Queries and other notes in this discussion:

'fn_', 'proc_', 'procGetRiskFactor', 'getRiskFactor', 'get_risk_factor'

DELIMITER $$
DELIMITER //





📌 Summary
✔ Stored procedures and functions follow different naming conventions, based on organizational preferences. 
✔ Prefixes (proc_, fn_), camel case (getRiskFactor), or underscores (get_risk_factor) are all valid approaches. 
✔ Delimiters ($$ vs. //) vary, but consistency within a project is key. 
✔ Stick to the existing conventions in your organization, rather than arguing for changes. 




















Triggers and Events:
--------------------

Triggers:
---------
🚀 Understanding Triggers in MySQL
Triggers in MySQL are blocks of SQL code that automatically execute before or after an INSERT, UPDATE, or DELETE operation. They help maintain data integrity and automate database updates.

📌 1. What Are Triggers?
✔ Triggers execute automatically when specific database actions occur. 
✔ Common use cases include updating related tables or enforcing data consistency. 
✔ They fire for every row affected, ensuring consistent behavior across multiple records.

📌 Example Use Case 
✔ In the invoices table, payment_total should equal the sum of all payments in the payments table. 
✔ A trigger can ensure payment_total' updates automatically when new payments are added or removed.





📌 2. Creating a Trigger for Payments (INSERT)
🚀 Scenario: ✔ When inserting a new payment, update payment_total in invoices.

📌 Trigger Definition:
DELIMITER $$

CREATE TRIGGER payments_after_insert 
    AFTER INSERT ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total + NEW.amount 
    WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;

🚀 Effect: ✔ Whenever a payment is inserted into payments, this trigger automatically updates payment_total in invoices.

📌 Executing an Insert Operation:
INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2019-01-01', 10, 1);
🚀 Effect: ✔ Adds a $10 payment to Invoice ID 3.

📌 Verifying Invoice Update:
SELECT invoice_id, payment_total FROM invoices WHERE invoice_id = 3;


📌 Example Output:
InvoiceID | Payment Total
-------------------------
3        | 10.00 ✅ Updated!

✔ Ensures payment data updates automatically.

📌 Key Concepts 
✔ NEW.column_name retrieves values from the newly inserted row. 
✔ FOR EACH ROW ensures the trigger fires for every affected row. 
✔ Triggers execute SQL operations automatically, reducing manual updates.






📌 3. Creating a Trigger for Payments (DELETE)
🚀 Scenario: ✔ When deleting a payment, subtract its amount from payment_total in invoices.

📌 Trigger Definition:
DELIMITER $$

CREATE TRIGGER payments_after_delete 
    AFTER DELETE ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total - OLD.amount 
    WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;
🚀 Effect: ✔ Ensures invoice totals decrease automatically when payments are removed.


📌 Deleting a Payment:
DELETE FROM payments WHERE payment_id = 10;

🚀 Effect: ✔ Removes the payment for Invoice 3.

📌 Verifying Invoice Update:
SELECT invoice_id, payment_total FROM invoices WHERE invoice_id = 3;

📌 Example Output:
InvoiceID | Payment Total
-------------------------
3        | 0.00 ✅ Updated!

✔ Ensures payment total decreases when payments are deleted.

📌 Key Concepts 
✔ OLD.column_name retrieves values from the deleted row. 
✔ Triggers prevent manual corrections, maintaining data integrity automatically.





📌 4. Important Considerations for Triggers
✔ MySQL does not support table-level triggers—triggers fire for each row, not once per operation. 
✔ Avoid modifying the same table within its trigger, as this can cause infinite loops. 
✔ Ensure efficient indexing on affected tables, preventing performance issues in high-transaction environments.





Queries and other notes in this discussion:

A block of SQL code that automatically gets executed before or after an insert, update or delete statement. 

DELIMITER $$

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;
	
	
	
INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2019-01-01', 10, 1);



Exercise: 

-- Create a trigger that gets fired when we 
-- delete a payment. 	



DELIMITER $$

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;


DELETE 
FROM payments 
WHERE payment_id = 10; 






📌 Summary
✔ Triggers automate updates and enforce data integrity, eliminating manual changes. 
✔ Use NEW.column_name for inserted records and OLD.column_name for deleted records. 
✔ Ensure triggers do not modify their own table to prevent infinite loops. 
















Viewing Triggers:
-----------------
🚀 Viewing Triggers in MySQL:
Unlike tables, views, stored procedures, and functions, MySQL Workbench does not provide a visual representation for triggers. However, triggers can be viewed using SQL statements.

📌 1. Viewing All Triggers in the Current Database
✔ Use the SHOW TRIGGERS statement to retrieve a list of all triggers in the current database.

📌 Query to Display Triggers:
SHOW TRIGGERS;

🚀 Effect: ✔ Retrieves all triggers, displaying details such as:
Trigger Name
Event Type (INSERT, UPDATE, DELETE)
Associated Table
Trigger Code
Execution Timing (BEFORE, AFTER)
Creation Date & Time

📌 Example Output:
┌────────────────────────┬───────────┬────────────┬───────────┬─────────────────┐
│ Trigger Name           │ Event     │ Table      │ Timing    │ Statement       │
├────────────────────────┼───────────┼────────────┼───────────┼─────────────────┤
│ payments_after_insert  │ INSERT    │ payments   │ AFTER     │ UPDATE invoices │ ✅ Updates payment_total
│ payments_after_delete  │ DELETE    │ payments   │ AFTER     │ UPDATE invoices │ ✅ Reduces payment_total
└────────────────────────┴───────────┴────────────┴───────────┴─────────────────┘
✔ Allows users to verify triggers currently defined in the database.





📌 2. Filtering Triggers by Table Name:
✔ Use the LIKE operator to view triggers associated with a specific table.

📌 Query to Filter Triggers for Payments Table:
SHOW TRIGGERS LIKE 'payments%';
🚀 Effect: ✔ Retrieves only triggers related to the payments table.

📌 Example Output:
┌────────────────────────┬───────────┬────────────┬───────────┬─────────────────┐
│ Trigger Name           │ Event     │ Table      │ Timing    │ Statement       │
├────────────────────────┼───────────┼────────────┼───────────┼─────────────────┤
│ payments_after_insert  │ INSERT    │ payments   │ AFTER     │ UPDATE invoices │ ✅ Increases total payments
│ payments_after_delete  │ DELETE    │ payments   │ AFTER     │ UPDATE invoices │ ✅ Decreases total payments
└────────────────────────┴───────────┴────────────┴───────────┴─────────────────┘
✔ Enables precise lookup of triggers for specific tables.





📌 3. Standard Naming Convention for Triggers
✔ Naming triggers systematically makes filtering easier. ✔ A common convention includes: 1.Table Name (payments) 2.Execution Timing (before or after) 3.Event Type (insert, update, or delete)

📌 Example Naming Convention:
Trigger Name	           Associated Table	   Event Type	   Timing
payments_after_insert	   payments	           INSERT	       AFTER
payments_before_update	   payments	           UPDATE	       BEFORE
orders_after_delete	       orders	           DELETE	       AFTER

🚀 Effect: 
✔ Simplifies searching for triggers by table association. 
✔ Using SHOW TRIGGERS LIKE 'payments%' retrieves relevant triggers immediately.



Queries and other notes in this discussion:

SHOW TRIGGERS 

SHOW TRIGGERS LIKE 'payments%'

--table_after_insert    






📌 4. Summary
✔ MySQL Workbench does not visually display triggers, but they can be listed using SHOW TRIGGERS. 
✔ Use SHOW TRIGGERS LIKE 'table%' to filter triggers by table name. 
✔ Following a systematic naming convention makes triggers easier to locate and manage. 











Dropping Triggers:
------------------
🚀 Dropping Triggers in MySQL
Triggers automatically execute SQL statements before or after inserts, updates, or deletions. When modifications are required, triggers can be dropped and recreated.

📌 1. How to Drop a Trigger
✔ Use the DROP TRIGGER statement to remove a trigger from the database. 
✔ Best Practice: Use IF EXISTS to prevent errors when the trigger doesn’t exist.

📌 Dropping a Trigger:
DROP TRIGGER IF EXISTS payments_after_insert;
🚀 Effect: ✔ Removes the payments_after_insert trigger from the database.

📌 Avoiding Errors ✔ If the trigger does not exist, MySQL raises an error. ✔ Using IF EXISTS prevents errors, ensuring smooth execution.





📌 2. Best Practice: Storing Triggers in SQL Files
✔ Maintain trigger definitions in a source control repository (Git). 
✔ Include both DROP and CREATE statements in the same script file, ensuring consistent database deployment.

📌 Example SQL File Structure:
triggers/
   ├── payments_after_insert.sql
   ├── payments_after_delete.sql
   
🚀 Effect: ✔ Allows developers to recreate the database with all triggers consistently. ✔ Enables tracking history of changes to database triggers.






📌 3. Recreating a Trigger After Dropping
✔ After dropping a trigger, ensure it is correctly recreated. 
✔ Include the DROP TRIGGER statement before defining a new trigger.

📌 Recreating the Payments INSERT Trigger:
DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
    AFTER INSERT ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total + NEW.amount 
    WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;
🚀 Effect: ✔ Ensures payment totals update automatically when new payments are inserted.






📌 4. Exercise: Dropping and Recreating the Payments DELETE Trigger
🚀 Task: ✔ When a payment is deleted, subtract its amount from payment_total in invoices.

📌 Dropping and Recreating the DELETE Trigger:
DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
    AFTER DELETE ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total - OLD.amount 
    WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;
🚀 Effect: ✔ Ensures invoice payment totals reduce automatically when payments are deleted.

📌 Verifying Changes:
DELETE FROM payments WHERE payment_id = 10;
SELECT invoice_id, payment_total FROM invoices WHERE invoice_id = 3;
✔ Ensures payment removal reflects correctly in the invoices table.





Queries and other notes in this discussion:

DROP TRIGGER IF EXISTS payments_after_insert; 



DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;




DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;






📌 Summary
✔ Dropping triggers is similar to dropping stored procedures, ensuring proper database maintenance. 
✔ Always use IF EXISTS to avoid errors when dropping triggers. 
✔ Store trigger definitions in version control, ensuring consistency and historical tracking. 
✔ Include both DROP and CREATE statements in SQL files, enabling reliable database recreation. 
















Using Triggers for Auditing:
----------------------------

🚀 Using Triggers for Auditing in MySQL
Triggers in MySQL can log changes to a database, providing an audit trail for tracking insertions and deletions. This is particularly useful for security, compliance, and data integrity.

📌 1.Why Use Triggers for Auditing?
✔ Automatically record changes when rows are inserted, updated, or deleted. 
✔ Track who made what changes and when, helping with compliance. 
✔ Ensure historical records of deleted data, making rollback possible.

📌 Example Use Case ✔ When inserting or deleting records in the payments table, store details in payments_audit.





📌 2. Creating an Audit Table
✔ Audit tables store historical records of changes, including:
Client ID
Date
Payment Amount
Action Type (INSERT, DELETE)
Timestamp (NOW())

📌 Creating the Audit Table:

USE sql_invoicing; 

CREATE TABLE payments_audit
(
    client_id       INT             NOT NULL, 
    date            DATE            NOT NULL,
    amount          DECIMAL(9, 2)   NOT NULL,
    action_type     VARCHAR(50)     NOT NULL,
    action_date     DATETIME        NOT NULL
);
🚀 Effect: ✔ Stores historical payment changes, ensuring an accurate audit trail.

📌 Example Table Structure:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Date      │ Amount    │ ActionType│ ActionDate│
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 5         │ 2025-06-10│ 250.00    │ Insert    │ 2025-06-10│ ✅ New payment logged
│ 5         │ 2025-06-10│ 250.00    │ Delete    │ 2025-06-15│ ✅ Deleted payment tracked
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Provides a detailed record of payment modifications.






📌 3. Creating a Trigger for Payment Insertions
🚀 Scenario: ✔ When a new payment is added, log the change in payments_audit.

📌 Defining the INSERT Trigger:
DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
    AFTER INSERT ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total + NEW.amount 
    WHERE invoice_id = NEW.invoice_id; 

    INSERT INTO payments_audit 
    VALUES (NEW.client_id, NEW.date, NEW.amount, 'Insert', NOW());
END $$

DELIMITER ;

🚀 Effect: 
✔ Updates payment_total for the invoice. 
✔ Logs insert operation into payments_audit, ensuring a record of changes.

📌 Executing an Insert Operation:
INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2025-06-10', 250, 1);
🚀 Effect: ✔ Logs the new payment automatically in the payments_audit table.






📌 4. Creating a Trigger for Payment Deletions
🚀 Scenario: ✔ When a payment is deleted, log the change in payments_audit.

📌 Defining the DELETE Trigger:
DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
    AFTER DELETE ON payments 
    FOR EACH ROW 
BEGIN
    UPDATE invoices  
    SET payment_total = payment_total - OLD.amount 
    WHERE invoice_id = OLD.invoice_id; 
    
    INSERT INTO payments_audit 
    VALUES (OLD.client_id, OLD.date, OLD.amount, 'Delete', NOW());
END $$

DELIMITER ;
🚀 Effect: ✔ Reduces payment_total for the invoice. ✔ Logs the deletion operation into payments_audit, maintaining an audit trail.

📌 Executing a Deletion Operation:
DELETE FROM payments WHERE payment_id = 11;
🚀 Effect: ✔ Logs the deleted payment automatically in the payments_audit table.






📌 5. Viewing Audit Logs
✔ Retrieve audit records using a SELECT query.

📌 Querying the Audit Table:
SELECT * FROM payments_audit;
🚀 Effect: ✔ Displays insertions and deletions, providing a clear audit trail.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ ClientID  │ Date      │ Amount    │ ActionType│ ActionDate│
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 5         │ 2025-06-10│ 250.00    │ Insert    │ 2025-06-10│ ✅ Payment recorded
│ 5         │ 2025-06-10│ 250.00    │ Delete    │ 2025-06-15│ ✅ Payment removal tracked
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Provides structured historical tracking for database modifications.






Queries and notes in this discussion: 

USE sql_invoicing; 

CREATE TABLE payments_audit
(
	client_id 		INT 			NOT NULL, 
    date 			DATE 			NOT NULL,
    amount 			DECIMAL(9, 2) 	NOT NULL,
    action_type 	VARCHAR(50) 	NOT NULL,
    action_date 	DATETIME 		NOT NULL
)


DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 

	INSERT INTO payments_audit 
	VALUES (NEW.client_id, NEW.date, NEW.amount, 'Insert', NOW());
END $$

DELIMITER ;




DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
	
	INSERT INTO payments_audit 
	VALUES (OLD.client_id, OLD.date, OLD.amount, 'Delete', NOW());
END $$

DELIMITER ;


INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2019-01-01', 10, 1); 



DELETE 
FROM payments 
WHERE payment_id = 11; 







📌 Summary
✔ Triggers enforce data consistency and automate logging, ensuring accurate auditing. 
✔ Audit tables store all insertions, deletions, and changes, preventing data loss. 
✔ Use NEW.column_name for inserts and OLD.column_name for deletions, tracking database modifications dynamically. 


















Events:
-------

🚀 Understanding Events in MySQL
Events in MySQL allow scheduled execution of SQL tasks, automating database maintenance. This guide covers how to enable, create, and schedule events efficiently.

📌 1. What Are Events in MySQL?
✔ Events execute SQL tasks automatically based on a defined schedule. ✔ Common use cases include:
Deleting stale data
Archiving old records
Generating reports periodically ✔ Runs once or on a recurring schedule, ensuring automated database management.

📌 Example: Removing Old Audit Records ✔ Schedule an event to delete records older than one year.






📌 2. Checking and Enabling the MySQL Event Scheduler
✔ MySQL uses an event scheduler to track scheduled tasks. ✔ Check if the event scheduler is enabled.

📌 Checking the Event Scheduler Status:
SHOW VARIABLES LIKE 'event%';
🚀 Effect: ✔ Displays event-related system variables, including event_scheduler.

📌 Example Output:
Variable Name   | Value
----------------------
event_scheduler | ON ✅ Enabled

✔ If event_scheduler is OFF, enable it using SET GLOBAL:
SET GLOBAL event_scheduler = ON;

🚀 Effect: ✔ Ensures scheduled events execute automatically.

📌 Turning Off the Event Scheduler (Optional):
SET GLOBAL event_scheduler = OFF;

✔ Stops background event execution, saving system resources.






📌 3. Creating a Scheduled Event
🚀 Scenario: ✔ Delete audit records older than one year, ensuring clean database management.

📌 Creating the Event:
DELIMITER $$

CREATE EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
    EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
    DELETE FROM payments_audit
    WHERE action_date < NOW() - INTERVAL 1 YEAR; 
END $$

DELIMITER ;

🚀 Effect: ✔ Deletes audit records older than one year, ensuring data remains relevant.

📌 Alternative Ways to Calculate One Year Ago:
DELETE FROM payments_audit WHERE action_date < DATE_ADD(NOW(), INTERVAL -1 YEAR);
or

DELETE FROM payments_audit WHERE action_date < DATE_SUB(NOW(), INTERVAL 1 YEAR);
✔ All approaches produce the same result.

📌 Optional Start and End Time ✔ Define when the event starts and stops:
STARTS '2019-01-01' ENDS '2029-01-01'

🚀 Effect: ✔ Controls execution timeframe, preventing unnecessary future runs.






📌 4. Naming Conventions for Events
✔ Follow a standard naming format to organize events efficiently. 
✔ Prefix event names with their execution frequency:

Event Name	                   Execution Interval
hourly_clean_temp_data	       Every hour
daily_backup_users	           Every day
monthly_generate_report	       Every month
once_process_archive	       Executes once
🚀 Effect: ✔ Makes filtering events easier, simplifying management.

📌 Finding Events Based on Frequency:

SHOW EVENTS WHERE Name LIKE 'monthly%';
✔ Lists all monthly scheduled events.






Queries and other notes in this discussion:

A task (or block of SQL code) that gets executed according to a schedule

SHOW VARIABLES LIKE 'event%'; 


event_scheduler -- set it to 'ON'

SET GLOBAL event_scheduler = ON; 




DELIMITER $$

CREATE EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
	-- AT '2019-05-01'
	EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
	DELETE FROM payments_audit
	WHERE  action_date < NOW() - INTERVAL 1 YEAR;   -- or DATEADD(NOW(), INTERVAL -1 YEAR) or DATESUB(NOW(), INTERVAL 1 YEAR)
END $$

DELIMITER ;






📌 Summary
✔ Events automate database tasks, ensuring structured data maintenance. 
✔ Use SHOW VARIABLES LIKE 'event%' to check event scheduler status. 
✔ Enable scheduler with SET GLOBAL event_scheduler = ON to activate scheduled tasks. 
✔ Define events using CREATE EVENT with a scheduled execution time. 



















Viewing, Dropping and Altering Events:
--------------------------------------
🚀 Managing Events in MySQL: Viewing, Dropping, and Altering Events
Events in MySQL allow scheduled execution of SQL tasks, ensuring automated database maintenance. This tutorial covers how to view, drop, and modify events efficiently.

📌 1. Viewing Events in MySQL
✔ Use the SHOW EVENTS statement to retrieve all events in the current database. ✔ Provides details such as:
Event Name
Execution Interval (EVERY 1 YEAR, DAILY)
Start and End Time
Event Status (ENABLED or DISABLED)
SQL Code Executed by the Event

📌 Query to View All Events:
SHOW EVENTS;
🚀 Effect: ✔ Retrieves all scheduled events, displaying execution frequency and details.

📌 Filtering Events by Interval Using LIKE ✔ Naming events systematically allows filtering easily.
SHOW EVENTS LIKE 'yearly%';
🚀 Effect: ✔ Lists all yearly scheduled events.

📌 Example Output:
┌────────────────────────────────┬───────────┬────────────┬───────────┬───────────┐
│ Event Name                     │ Frequency │ Start Date │ End Date  │ Status    │
├────────────────────────────────┼───────────┼────────────┼───────────┼───────────┤
│ yearly_delete_stale_audit_rows │ YEARLY    │ 2019-01-01 │ 2029-01-01│ ENABLED   │ ✅ Scheduled
└────────────────────────────────┴───────────┴────────────┴───────────┴───────────┘
✔ Allows searching for specific event schedules efficiently.






📌 2. Dropping an Event
✔ Use the DROP EVENT statement to remove an event from the database. ✔ Always use IF EXISTS to prevent errors when the event doesn’t exist.

📌 Dropping an Event Safely:
DROP EVENT IF EXISTS yearly_delete_stale_audit_rows;
🚀 Effect: ✔ Removes the scheduled event, ensuring database cleanup.





📌 3. Altering an Event
✔ Use the ALTER EVENT statement to modify an existing event, instead of dropping and recreating it. 
✔ Change execution frequency or modify SQL logic.

📌 Example: Modifying Event Execution:
DELIMITER $$

ALTER EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
    EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
    DELETE FROM payments_audit
    WHERE action_date < NOW() - INTERVAL 1 YEAR;  
END $$

DELIMITER ;
🚀 Effect: ✔ Reschedules the event, ensuring data cleanup at the correct intervals.






📌 4. Enabling or Disabling an Event
✔ Temporarily deactivate or reactivate events using ALTER EVENT.

📌 Disabling an Event:
ALTER EVENT yearly_delete_stale_audit_rows DISABLE;
🚀 Effect: ✔ Prevents execution while maintaining the event definition.

📌 Reactivating an Event:
ALTER EVENT yearly_delete_stale_audit_rows ENABLE;
🚀 Effect: ✔ Resumes scheduled execution.

📌 Example Status Output:

Event Name                     | Status
------------------------------------------
yearly_delete_stale_audit_rows | DISABLED ❌ Paused
yearly_clean_temp_data         | ENABLED ✅ Active

✔ Ensures proper control over scheduled events.






Queries and other notes in this discussion:

SHOW EVENTS; 


SHOW EVENTS LIKE 'yearly%';

DROP EVENT IF EXISTS yearly_delete_stale_audit_rows;



DELIMITER $$

ALTER EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
	-- AT '2019-05-01'
	EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
	DELETE FROM payments_audit
	WHERE  action_date < NOW() - INTERVAL 1 YEAR;   -- or DATEADD(NOW(), INTERVAL -1 YEAR) or DATESUB(NOW(), INTERVAL 1 YEAR)
END $$

DELIMITER ;  



ALTER EVENT yearly_delete_stale_audit_rows DISABLE; 

ALTER EVENT yearly_delete_stale_audit_rows ENABLE; 






📌 Summary
✔ Use SHOW EVENTS to list scheduled database tasks, ensuring visibility. 
✔ Filter events efficiently using SHOW EVENTS LIKE 'interval%' (e.g., yearly%). 
✔ Use DROP EVENT IF EXISTS to safely remove events without errors. 
✔ Modify execution intervals and logic using ALTER EVENT, preventing unnecessary recreation. 
✔ Temporarily enable or disable events, ensuring flexible scheduling control.






















Transactions and Concurrency:
-----------------------------

Transactions:
-------------

🚀 Understanding Transactions in MySQL
Transactions in MySQL represent a single unit of work, ensuring multiple SQL operations succeed together or fail entirely. This guarantees data integrity and prevents inconsistencies.

📌 1. What Is a Transaction?
✔ A transaction is a group of SQL statements that must be executed together. 
✔ If all statements succeed, the transaction is committed. 
✔ If any statement fails, the transaction rolls back, ensuring database consistency.

📌 Example: Bank Transaction ✔ If transferring $10 from one account to another: 1.Deduct $10 from Account A  2.Add $10 to Account B

🚀 Effect: ✔ Either both operations succeed, or none should be executed, ensuring accurate financial records.

📌 Potential Failure Scenario 
✔ If deduction succeeds but addition fails (server crash, error, etc.), Account A loses money but Account B doesn’t gain it. 
✔ Transaction ensures rollback, preventing data inconsistencies.





📌 2. Why Are Transactions Important?
✔ Transactions ensure multiple related operations execute reliably. 
✔ Prevent database inconsistencies, like orders without items or incomplete financial records.

📌 Example: Order and Order Items ✔ When processing an order: 1.Insert order details (orders table) 2.Insert order items (order_items table)

🚀 Effect: ✔ If one step fails, the order is incomplete—transactions ensure rollback.





📌 3.ACID Properties of Transactions
✔ Transactions follow ACID properties to ensure data reliability.

📌 ACID Principles:
Property	 Description
Atomicity	 Ensures transactions execute as a single unit—either all succeed or none.
Consistency	 Maintains database integrity, preventing invalid states. or The database remains valid after transactions.
Isolation	 Transactions do not interfere with each other — locks prevent conflicts.
Durability	 Once committed, changes are permanent, even after system failures.

🚀 Effect: ✔ Transactions protect data from errors, failures, and concurrency issues.




Queries and other notes in this discussion:

A group of SQL statements that represent a single unit of work 


properties of Transactions:(ACID)

Atomicity 
Consistency
Isolation 
Durability




📌 Summary
✔ Transactions ensure multiple SQL operations succeed together or fail entirely. 
✔ Follow ACID principles, ensuring atomicity, consistency, isolation, and durability. 
✔ Prevent data inconsistencies, ensuring structured database execution. 
















Creating Transactions:
-----------------------
🚀 Creating Transactions in MySQL:
Transactions in MySQL ensure multiple SQL operations execute together, maintaining data integrity. This guide covers how to create transactions, rollback failures, and manage automatic commits.

📌 1. What Is a Transaction?
✔ A transaction is a set of SQL statements that must succeed or fail together. 
✔ Ensures consistency—either all operations complete, or none are applied.

📌 Example Use Case: 
Order Processing ✔ When creating an order: 1.Insert order details into the orders table 2. Insert order items into the order_items table

🚀 Effect: ✔ Prevents incomplete orders—ensuring order details and items are always stored together.





📌 2. Creating a Transaction
✔ Use START TRANSACTION to begin a transaction. 
✔ Use COMMIT to finalize changes, ensuring database updates. 
✔ If an error occurs, MySQL automatically rolls back unfinished changes.

📌 Example: Storing an Order:
USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (LAST_INSERT_ID(), 1, 1, 1);

COMMIT;

🚀 Effect: ✔ Creates an order and its item within the same transaction. ✔ Ensures both operations complete together.

📌 Verifying Data:
SELECT * FROM orders ORDER BY order_id DESC;
SELECT * FROM order_items ORDER BY order_id DESC;
✔ Confirms order and items were successfully committed.





📌 3. Simulating a Transaction Failure
✔ If a failure occurs before COMMIT, MySQL rolls back changes automatically. 
✔ To manually test rollback, disconnect before committing.

📌 Example: Breaking a Transaction 
1.Execute the INSERT INTO orders statement. 
2.Execute the INSERT INTO order_items statement. 
3.Disconnect the database BEFORE committing. 
4.Reconnect and check data.

🚀 Expected Behavior: ✔ Order was NOT stored, ensuring no incomplete data is saved.

📌 Verifying Transaction Status:
SELECT * FROM orders ORDER BY order_id DESC;
✔ The order should NOT appear, confirming rollback success.





📌 4. Using ROLLBACK to Undo Changes
✔ Instead of committing changes, use ROLLBACK to cancel the transaction.

📌 Example: Rolling Back a Transaction:
USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (LAST_INSERT_ID(), 1, 1, 1);

ROLLBACK;

🚀 Effect: ✔ Cancels order creation, removing partial updates.

📌 Verifying Rollback Success:
SELECT * FROM orders ORDER BY order_id DESC;
SELECT * FROM order_items ORDER BY order_id DESC;
✔ No new records should exist, confirming rollback success.





📌 5. Understanding Auto-Commit in MySQL
✔ By default, MySQL automatically commits every INSERT, UPDATE, or DELETE statement. 
✔ Controlled via autocommit system variable.

📌 Checking Auto-Commit Status:
SHOW VARIABLES LIKE 'autocommit';
🚀 Effect: ✔ Returns current auto-commit setting (usually ON).

📌 Example Output

Variable Name   | Value
----------------------
autocommit      | ON ✅ Auto-commit enabled

✔ If enabled, every single statement commits automatically.

📌 Disabling Auto-Commit for Manual Transactions:
SET autocommit = OFF;

🚀 Effect: ✔ Prevents automatic commits, requiring explicit COMMIT or ROLLBACK.






Queries and other notes in this discussion:

USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (Last_INSERT_ID(), 1, 1, 1);

COMMIT; 




USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (Last_INSERT_ID(), 1, 1, 1);

ROLLBACK;


difference between commit and rollback 

SHOW VARIABLES LIKE 'autocommit';  -- autocommit variable which is set to 'ON' 


Extra Notes: 



Difference Between COMMIT and ROLLBACK in Transactions

In SQL transactions, 'COMMIT' and 'ROLLBACK' are crucial commands that determine whether changes made during a transaction are permanently applied to the database or undone.


1. COMMIT
A 'COMMIT' statement is used to permanently save all changes made within a transaction to the database.


Key Characteristics:
- Ensures changes are applied and visible to other users.
- Cannot be undone once executed.
- Locks held during the transaction are released after commit.
- Improves consistency by transitioning the database to a stable state.



Example Usage:
'''sql
START TRANSACTION;

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (LAST_INSERT_ID(), 1, 1, 1);

COMMIT;  -- Saves changes permanently
'''
👉 After 'COMMIT', the inserted records remain in the database and cannot be undone.



2. ROLLBACK
A 'ROLLBACK' statement undoes all changes made within a transaction, returning the database to the state before the transaction started.

Key Characteristics:
- Used when an error occurs or when partial updates must be prevented.
- Ensures atomicity, meaning either all or none of the changes are applied.
- Helps maintain database integrity by avoiding inconsistencies.
- Locks held during the transaction are released after rollback.


Example Usage:
'''sql
START TRANSACTION;

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

-- Simulating an error
INSERT INTO order_items
VALUES (NULL, 1, 1, 1);  -- Fails due to NULL violation

ROLLBACK;  -- Undoes all changes
'''
👉 Since the second 'INSERT' fails, 'ROLLBACK' ensures none of the transaction changes persist.





Key Differences Between COMMIT and ROLLBACK:

| Feature                   | COMMIT                    | ROLLBACK                                  |
|---------------------------|---------------------------|-------------------------------------------|
| Effect                    | Saves changes permanently | Undoes changes made in the transaction    |
| Undo Possible?            | No                        | Yes, before COMMIT                        |
| Used When                 | Transaction is successful | Errors occur or data integrity is at risk |
| Locks Released            | Yes, after commit         | Yes, after rollback                       |
| Prevents Partial Updates? | No, changes persist       | Yes, all changes are reverted             |






📌 Summary:
✔ Transactions ensure multiple SQL operations succeed together, preventing partial updates. 
✔ Use START TRANSACTION and COMMIT to finalize successful operations. 
✔ Use ROLLBACK to cancel transactions when needed. 
✔ Auto-commit automatically commits each SQL statement—disable for full transaction control. 


















Concurrency and Locking:
------------------------

🚀 Understanding Concurrency and Locking in MySQL
In real-world applications, multiple users may access and modify the same data simultaneously, leading to potential concurrency issues. MySQL uses locking mechanisms to prevent conflicts, ensuring data integrity and consistency.

📌 1. What Is Concurrency in Databases?
✔ Concurrency occurs when multiple users or processes attempt to access or modify the same data simultaneously. 
✔ MySQL handles concurrency using locks, preventing data corruption or inconsistencies.

📌 Example Concurrency Issue: 
✔ Two users attempt to update customer points simultaneously: 
1.User 1 starts a transaction and increases points by 10. 
2.User 2 starts a transaction and tries to increase points by 10 at the same time. 
✔ Without locking, conflicts could occur—one user's update may override the other's.

🚀 Effect: ✔ MySQL prevents simultaneous updates by locking the row until the first transaction completes.





📌 2. Simulating Concurrency with Two Sessions
✔ Opening two separate database connections simulates multiple users modifying the same data.

📌 Step 1: Open Two Sessions in MySQL Workbench ✔ Each session represents a different user accessing the database.





📌 3. Testing Concurrency with Transactions
🚀 Scenario: ✔ Two users attempt to update points for Customer ID 1 simultaneously.

📌 Session 1: Start Transaction and Update Points

USE sql_store;
START TRANSACTION; 

UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;

COMMIT;
🚀 Effect: ✔ Updates points for Customer ID 1, locking the row until committed.


📌 Session 2: Start Another Transaction
USE sql_store;
START TRANSACTION; 

UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;

COMMIT;

🚀 Effect: ✔ Session 2 must wait for Session 1 to complete before modifying the row.





📌 4. Understanding Locking Behavior
✔ When Session 1 updates a row, MySQL locks it, preventing simultaneous modifications. 
✔ Session 2 attempts to update the same row, but it must wait until Session 1 commits or rolls back. 
✔ If Session 1 never commits, Session 2 times out, preventing deadlocks.

📌 Example of Timeout in Session 2
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
✔ This happens when Session 1 holds the lock for too long.

📌 Resolving Lock Timeout ✔ Session 1 should commit or rollback as soon as possible:
COMMIT;  -- Finalize changes

📌 Refreshing Data After Commit ✔ After both transactions complete, verify points were updated correctly:
SELECT customer_id, points FROM customers WHERE customer_id = 1;

🚀 Effect: ✔ Customer points increase by 20, confirming both updates were applied sequentially.

📌 Example Output:
Customer ID | Points
--------------------
1           | 2293 ✅ Updated correctly

✔ Ensures transactions are executed safely, without interference.





📌 5. MySQL’s Default Locking Behavior
✔ By default, MySQL automatically locks rows when transactions modify them. 
✔ Other transactions must wait until the lock is released. 
✔ This prevents concurrency problems in most cases.

📌 When Default Behavior Isn’t Enough 
✔ Some applications require customized transaction isolation levels. 
✔ Next steps: Exploring solutions to handle special concurrency scenarios.



Queries and other notes in this discussion:
connection 1:

USE sql_store;
START TRANSACTION; 
UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;
COMMIT; 


connection 2: 

USE sql_store;
START TRANSACTION; 
UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;
COMMIT; 





📌 Summary
✔ Concurrency occurs when multiple users modify the same data simultaneously. 
✔ MySQL prevents conflicts using row-level locks, ensuring data integrity. 
✔ Transactions lock rows until committed, preventing other modifications. 
✔ Use COMMIT or ROLLBACK to finalize changes quickly and avoid timeouts. 
✔ Next steps: Learning advanced isolation levels and concurrency handling techniques.

















Concurrency Problems: 
---------------------
🚀 Concurrency Problems in MySQL
Concurrency issues arise when multiple transactions access and modify the same data simultaneously. Without proper controls, such simultaneous actions can lead to data inconsistencies. Below is a detailed discussion of the common concurrency problems along with examples and solutions.

1. Lost Updates:
Definition: Lost updates occur when two transactions update the same data concurrently without proper locking. The later-committing transaction can overwrite the changes made by an earlier one, resulting in lost information.

Example Scenario: Imagine a customer record for John in New York with 10 points. Two transactions occur:
Transaction A: Updates the state for John.
Transaction B: Updates the points for John.

Both transactions read the same original record. If Transaction A and Transaction B run concurrently and Transaction B commits last, the changes made by Transaction A (e.g., updating the state) will be overwritten. Consequently, the update made by Transaction A is lost.

Solution: Use appropriate locking mechanisms. MySQL’s default behavior often locks the rows being updated, ensuring that such updates occur in sequence. This prevents lost updates as one transaction will wait for the other to complete before proceeding.





2. Dirty Reads
Definition: A dirty read happens when a transaction reads data that has been modified by another transaction but not yet committed. If the modifying transaction later rolls back, the data read is invalid.

Example Scenario:
Transaction A: Changes a customer's points from 10 to 20 but hasn't committed the change.
Transaction B: Reads the updated points (20) and, based on the new value, gives a $1 discount per point, thereby offering a $20 discount.

If Transaction A rolls back, Customer's points revert to 10, meaning that Transaction B’s discount was based on data that never actually existed.

Solution: Set the transaction isolation level to "Read Committed." With this setting, transactions only read committed data, preventing the occurrence of dirty reads.





3. Non-Repeatable Reads
Definition: Non-repeatable reads occur when a transaction reads the same row more than once and sees different values each time because another transaction modified the data between the reads.

Example Scenario:
Transaction A: Reads a customer's points and sees 10.
Transaction B: Updates the customer's points to 0 and commits.
Transaction A (again): Reads the customer's points a second time and now sees 0 instead of the original 10.

This inconsistency can lead to incorrect business decisions if Transaction A's operations assume a static snapshot of data.

Solution: Use the "Repeatable Read" isolation level to ensure that once data is read, it remains consistent throughout the transaction. Alternatively, in business scenarios where the most current data is preferred, accepting non-repeatable reads might be acceptable.






4. Phantom Reads
Definition: Phantom reads occur when a transaction retrieves a set of rows that match a condition and then re-queries the same condition within the same transaction, only to find additional (or missing) rows due to inserts or deletions by other transactions.

Example Scenario:
Transaction A: Selects all customers with more than 10 points to offer them a discount.
Transaction B: Updates a customer's points, making them now eligible for the discount after Transaction A’s query has executed.

As a result, Transaction A misses this customer, leading to a “phantom” read where data appears or disappears unexpectedly.

Solution: To guard against phantom reads, use the "Serializable" isolation level. This level ensures that transactions are completely isolated from changes made by other concurrent transactions, though it may reduce concurrent throughput and impact performance.




5. Summary & Best Practices:
Lost Updates: Prevent by using locks so that concurrent transactions update the same row in sequence.
Dirty Reads: Avoid by using an isolation level like Read Committed, ensuring only committed data is read.
Non-Repeatable Reads: Resolve with Repeatable Read isolation so that data snapshots remain consistent during the transaction.
Phantom Reads: Eliminate or minimize by using Serializable isolation—this can impact performance and should be reserved for critical operations.

Understanding and selecting the appropriate transaction isolation level (Read Committed, Repeatable Read, Serializable) based on the specific business requirements is vital to prevent these concurrency issues while balancing performance and consistency.


Additional Information:
Transaction Isolation Levels: The SQL standard defines four levels of transaction isolation. Familiarize yourself with them to choose the best level for your application:
Read Uncommitted
Read Committed
Repeatable Read
Serializable

Locking Mechanisms: MySQL automatically locks rows during updates. This default behavior plays a critical role in avoiding lost updates and ensuring that concurrent transactions are properly serialized.

Monitoring Concurrency: Always test your application under load and simulate concurrent transactions to ensure that the chosen isolation levels and locking mechanisms work as expected.

Common Concurrency Problems Recap:
Lost Updates
Dirty Reads
Non-Repeatable Reads
Phantom Reads


Queries and other notes in this discussion:

Some common concurrency problems:
Lost Updates 
Dirty Reads 
Non-repeating Reads 
Phantom Reads 















Transaction Isolation Levels:
-----------------------------

🚀 Transaction Isolation Levels in MySQL
Transactions ensure that a series of SQL statements execute as a single unit. To prevent concurrency issues when multiple transactions access or modify the same data, MySQL offers several transaction isolation levels. These levels determine how much one transaction is isolated from the changes made by other transactions.

1. Common Concurrency Problems:
Before reviewing the isolation levels, it’s important to understand the basic concurrency issues they aim to solve:
Lost Updates: Occurs when two transactions update the same row without proper locking. The transaction that commits last overwrites the earlier change, resulting in lost data.
Dirty Reads: Happen when a transaction reads data that has been modified by another transaction but not yet committed. If the modifying transaction rolls back, the reading transaction has based its logic on data that never became permanent.
Non-Repeatable Reads: Occur when a transaction reads the same row twice but sees different values because another transaction modified the data between the two reads.
Phantom Reads: Happen when a transaction re-executes a query that returns a set of rows and finds that the set has changed (rows have been added or removed) due to another transaction’s modifications.





2. Standard Transaction Isolation Levels:
MySQL supports four standard transaction isolation levels, each offering different guarantees and trade-offs:

a. Read Uncommitted
Behavior: No isolation—you can read uncommitted changes from other transactions.
Protection: None. It does not prevent dirty reads, lost updates, non-repeatable reads, or phantom reads.
Use Case: Rarely used because it offers high concurrency at the expense of accuracy.

b. Read Committed
Behavior: A transaction sees only data that has been committed. It prevents dirty reads.
Protection: Prevents dirty reads but still allows non-repeatable reads and phantom reads.
Use Case: Suitable when you need to exclude uncommitted data—for example, in bulk reporting scenarios where perfect repeatability isn’t critical.

c. Repeatable Reads (Default in MySQL)
Behavior: Once data is read, it remains consistent throughout the transaction. This prevents non-repeatable reads.
Protection: Prevents dirty reads and non-repeatable reads. However, phantom reads can still occur.
Use Case: The default level in MySQL since it offers a good balance between consistency and performance. It works well for most scenarios except where phantom reads need to be completely avoided.

d. Serializable
Behavior: The highest isolation level. Transactions are completely isolated from each other.
Protection: Prevents dirty reads, non-repeatable reads, and phantom reads. Ensures that transactions execute as if they were completely sequential.
Trade-Off: Introduces significant locking overhead which can reduce performance and scalability.
Use Case: Use only in critical situations where complete isolation is required, for example when phantom reads must be prevented.





3. Trade-Offs Between Isolation Levels:
Lower Isolation Levels (Read Uncommitted, Read Committed):
Pros: Higher concurrency and performance due to fewer locks.
Cons: Increased risk of inconsistency (dirty reads, non-repeatable reads, or phantom reads).

Higher Isolation Levels (Repeatable Reads, Serializable):
Pros: Better data consistency and integrity.
Cons: Reduced performance due to extensive locking and resource use. Serializable, in particular, can severely limit concurrency.
MySQL’s default is Repeatable Reads, which provides a good balance by preventing most concurrency problems while retaining relatively high performance. For scenarios where precise consistency is less critical—like bulk reporting—you might consider using Read Committed or even Read Uncommitted. Use Serializable only when necessary due to its performance cost.





4. Setting the Transaction Isolation Level
You can view and modify the transaction isolation level in MySQL:

a. Viewing the Current Isolation Level:
SHOW VARIABLES LIKE 'transaction_isolation';
Effect: Reveals the current isolation level (default is typically REPEATABLE-READ in MySQL).

b. Setting the Isolation Level for a Transaction
For the next transaction only:
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

For the current session:
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

Globally (new sessions):
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;

Note for Application Developers: Typically, you change the isolation level for a specific connection in your application just before executing a transaction. This local change does not affect other sessions or the global configuration.





Queries and other notes in this discussion:


SHOW VARIABLES LIKE 'transaction_isolation'; 

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;










5. Summary
Concurrency Problems:
Lost Updates, Dirty Reads, Non-Repeatable Reads, Phantom Reads.

Isolation Levels:
Read Uncommitted: No protections.
Read Committed: Prevents dirty reads.
Repeatable Reads: Prevents dirty and non-repeatable reads (default in MySQL).
Serializable: Prevents all, including phantom reads (at a performance cost).
Trade-Off: Lower isolation offers higher performance but less consistency, while higher isolation provides greater consistency at the expense of performance and scalability.
Setting Levels: Use appropriate SET TRANSACTION ISOLATION LEVEL statements to tailor isolation for individual transactions, sessions, or globally.









READ UNCOMMITTED Isolation Level: 
---------------------------------
🚀 Understanding READ UNCOMMITTED Isolation Level in MySQL
The READ UNCOMMITTED isolation level allows transactions to read uncommitted changes made by other transactions. This leads to dirty reads, where a transaction sees data that might never be committed, resulting in potential inconsistencies.

📌 1. Simulating READ UNCOMMITTED Isolation Level
🚀 Scenario: ✔ Two transactions interact with the customer points record: 
1.Session 1: Reads customer points before another transaction modifies it. 
2.Session 2: Starts a transaction, updates the points, but does not commit immediately.

📌 Expected Behavior Under READ UNCOMMITTED: ✔ Session 1 will read the uncommitted update. ✔ If Session 2 rolls back, Session 1’s read becomes invalid—this is a dirty read.





📌 2. Steps to Demonstrate Dirty Reads
🚀 Opening Two Sessions ✔ Open two MySQL connections to simulate multiple clients accessing the database.

📌 Session 1: Setting Isolation Level and Reading Data
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT points 
FROM customers 
WHERE customer_id = 1;
🚀 Effect: ✔ Reads uncommitted data that might change.


📌 Session 2: Updating Points Without Committing Immediately
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET points = 20
WHERE customer_id = 1;
🚀 Effect: ✔ Customer's points are now 20, but the transaction isn’t committed yet.

📌 Session 1: Reading Uncommitted Changes
SELECT points FROM customers WHERE customer_id = 1;
🚀 Effect: ✔ Session 1 sees 20 points, even though the update isn’t committed.

📌 Session 2: Rolling Back Instead of Committing
ROLLBACK;
🚀 Effect: ✔ The update is undone, restoring original points.

📌 Session 1’s Dirty Read Issue ✔ Session 1 made a decision based on 20 points, but that value never officially existed.





📌 3. Why READ UNCOMMITTED Is Risky?
✔ Allows reading temporary, uncommitted changes. 
✔ Data might roll back, leading to invalid business decisions. 
✔ Results in all concurrency problems, including lost updates, dirty reads, non-repeatable reads, and phantom reads.

📌 Typical Use Cases for READ UNCOMMITTED 
✔ Rarely used in production due to data inconsistencies. 
✔ Might be acceptable for bulk reporting where data precision isn’t critical.




Queries and other notes in this discussion:

connection 1:

USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT points 
FROM customers 
WHERE customer_id = 1; -- reads the uncommitted data which is points = 20


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
COMMIT; 


USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
ROLLBACK;   -- say if we rolls back for some reason, and connection 1 has read it as points as 20 which is not true now 






📌 Summary
✔ READ UNCOMMITTED is the lowest isolation level, allowing dirty reads. 
✔ Transactions read uncommitted changes, leading to potentially invalid decisions. 
✔ ROLLBACK in one session cancels changes, making previously read data incorrect. 
✔ Typically avoided in production, except in rare cases where consistency is less important.















READ COMMITTED Isolation Level: 
-------------------------------
🚀 Understanding READ COMMITTED Isolation Level in MySQL
The READ COMMITTED isolation level ensures that transactions only read data that has been committed by other transactions. This prevents dirty reads, ensuring that queries do not see uncommitted changes. However, non-repeatable reads can still occur, where a query returns different results when executed multiple times within the same transaction.

📌 1. Simulating READ COMMITTED Isolation Level
🚀 Scenario: ✔ Two transactions interact with customer points: 
1.Session 1: Reads customer points before and after another transaction modifies them. 
2.Session 2: Starts a transaction, updates the points, and commits the change.

📌 Expected Behavior Under READ COMMITTED: 
✔ Session 1 does not see uncommitted updates. 
✔ Once Session 2 commits, Session 1 sees the changes. 
✔ Non-repeatable reads can occur if data is updated mid-transaction.





📌 2. Steps to Demonstrate Read Committed Behavior
🚀 Opening Two Sessions ✔ Open two MySQL connections to simulate concurrent database access.

📌 Session 1: Setting Isolation Level and Reading Data
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

SELECT points 
FROM customers 
WHERE customer_id = 1;
🚀 Effect: ✔ Reads only committed changes.


📌 Session 2: Updating Points Without Committing Immediately
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET points = 20
WHERE customer_id = 1;
🚀 Effect: ✔ The update is made but not committed—Session 1 should not see this change.


📌 Session 1: Reading Committed Data
SELECT points FROM customers WHERE customer_id = 1;
🚀 Effect: ✔ Returns previously committed points instead of the uncommitted update.


📌 Session 2: Committing the Change
COMMIT;
🚀 Effect: ✔ The change becomes permanent, and now Session 1 will see the updated value.

📌 Session 1: Reading Updated Points
SELECT points FROM customers WHERE customer_id = 1;
🚀 Effect: ✔ Now returns 20, reflecting the committed update.





📌 3. Identifying Non-Repeatable Reads
✔ A transaction using READ COMMITTED may see different values when reading the same row multiple times.

📌 Session 1: Executing Two Consecutive Reads
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

SELECT points FROM customers WHERE customer_id = 1; -- Reads 20 initially


📌 Session 2: Updating the Same Record
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET points = 30
WHERE customer_id = 1;

COMMIT;
🚀 Effect: ✔ The update is committed, making Session 1’s previous read outdated.


📌 Session 1: Second Read Within the Same Transaction
SELECT points FROM customers WHERE customer_id = 1; -- Reads 30 now
COMMIT;
🚀 Effect: ✔ First read saw 20 points, second read saw 30—this is a non-repeatable read.





📌 4. Key Takeaways
✔ READ COMMITTED prevents dirty reads, ensuring queries see only committed changes. 
✔ Transactions may experience non-repeatable reads, meaning subsequent reads may return different values. 
✔ Best used when queries must read only finalized data but don’t require repeatable results.

📌 Use Cases ✔ Standard for most applications needing reliable reads (avoiding dirty data). ✔ Not ideal for situations requiring consistent snapshot reads (consider Repeatable Read instead).

📌 Next Steps: ✔ For repeatable reads, increase the isolation level to REPEATABLE READ to prevent inconsistencies.





Queries and other notes in this discussion:

connection 1:

USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT points 
FROM customers 
WHERE customer_id = 1; -- reads only the committed data 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
COMMIT; 



connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT points FROM customers WHERE customer_id = 1; -- reads 20
SELECT points FROM customers WHERE customer_id = 1; -- reads 30 after we updated the points and committed in connection 2
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 30
WHERE customer_id = 1; 
COMMIT; 





📌 Summary
✔ READ COMMITTED ensures transactions only see committed data, preventing dirty reads. 
✔ Transactions may experience non-repeatable reads, where the same row returns different values in different queries. 
✔ Suitable for applications requiring consistency without full transaction snapshots. 
✔ For higher data consistency, consider REPEATABLE READ isolation level.

















REPEATABLE READ Isolation Level:
--------------------------------

🚀 Understanding REPEATABLE READ Isolation Level in MySQL
The REPEATABLE READ isolation level ensures that data remains consistent throughout a transaction, preventing non-repeatable reads. However, phantom reads can still occur when new rows are inserted or updated by other transactions during execution.

📌 1. What Is REPEATABLE READ Isolation Level?
✔ Ensures consistent data retrieval—once a transaction reads a row, subsequent reads within the same transaction return the same value, even if other transactions modify it. 
✔ Prevents non-repeatable reads, meaning queries in a transaction consistently see the same snapshot of data. 
✔ Does not prevent phantom reads, where new rows appear or disappear due to updates in another transaction.





📌 2. Demonstrating REPEATABLE READ Behavior
🚀 Scenario: ✔ Two transactions interact with customer points: 
1.Session 1: Reads customer points before and after another transaction modifies them. 
2.Session 2: Starts a transaction, updates the points, and commits the change.

📌 Expected Behavior Under REPEATABLE READ: 
✔ Session 1 maintains consistent reads, even if Session 2 modifies data. 
✔ Session 1 does not see committed changes until it completes.





📌 3. Steps to Prevent Non-Repeatable Reads
🚀 Opening Two Sessions ✔ Open two MySQL connections to simulate concurrent transactions.

📌 Session 1: Setting Isolation Level and Reading Data Consistently
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT points FROM customers WHERE customer_id = 1; -- Reads 30 points
🚀 Effect: ✔ Establishes a consistent snapshot of data for the transaction.


📌 Session 2: Updating the Same Record
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET points = 40
WHERE customer_id = 1;

COMMIT;
🚀 Effect: ✔ The update is committed, but Session 1 will NOT see the change yet.


📌 Session 1: Second Read Within the Same Transaction
SELECT points FROM customers WHERE customer_id = 1; -- Still reads 30 points
COMMIT;
🚀 Effect: ✔ REPEATABLE READ maintains the original snapshot until the transaction completes.

📌 After Commit in Session 1
SELECT points FROM customers WHERE customer_id = 1; -- Now reads 40 points
🚀 Effect: ✔ Session 1 now sees updated values after committing.





📌 4. Identifying Phantom Reads
✔ Phantom reads occur when a query retrieves rows that change mid-transaction due to another transaction inserting or modifying data.

📌 Session 1: Selecting Customers in Virginia
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT * FROM customers WHERE state = 'VA';  -- Customer ID 1 not included
🚀 Effect: ✔ Session 1 captures a snapshot of customers in Virginia.


📌 Session 2: Updating Customer State
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET state = 'VA'
WHERE customer_id = 1;

COMMIT;
🚀 Effect: ✔ Now Customer ID 1 is in Virginia, but Session 1 does not see it yet.


📌 Session 1: Re-executing the Same Query
SELECT * FROM customers WHERE state = 'VA'; -- Still shows only the original snapshot
COMMIT;
🚀 Effect: ✔ Even after the state change, Session 1 does not see new rows during the transaction.


📌 After Commit in Session 1
SELECT * FROM customers WHERE state = 'VA'; -- Now shows Customer ID 1
🚀 Effect: ✔ Session 1 now includes the updated data after committing.






📌 5. Key Takeaways
✔ REPEATABLE READ ensures data consistency during a transaction, preventing non-repeatable reads. 
✔ Transactions maintain their initial snapshot until completion, ignoring updates from other transactions. 
✔ Does not prevent phantom reads, where new records appear or disappear between queries. 
✔ To prevent phantom reads, use the SERIALIZABLE isolation level.

📌 Use Cases ✔ Suitable for applications that require consistent snapshot reads during transactions. ✔ Recommended as the default isolation level in MySQL, balancing consistency and performance.

📌 Next Steps: ✔ For complete isolation, switch to SERIALIZABLE isolation level to prevent phantom reads.






Queries and other notes in this discussion:

connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT points FROM customers WHERE customer_id = 1; -- reads 30
SELECT points FROM customers WHERE customer_id = 1; -- reads 30, because our reads are repeatable and consistent 
COMMIT; 



connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 40
WHERE customer_id = 1; 
COMMIT; 



problem with phantom reads:
connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM customers WHERE state = 'VA';  -- we won't get to see the customer_id 1
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET state = 'VA'
WHERE customer_id = 1; 
COMMIT; 






📌 Summary
✔ REPEATABLE READ prevents non-repeatable reads, ensuring consistent data retrieval within a transaction. 
✔ Transactions do not see changes from other transactions until committed. 
✔ Phantom reads still occur, meaning inserts or updates may modify query results mid-transaction. 
✔ For complete consistency, SERIALIZABLE isolation level must be used.




















SERIALIZABLE Isolation Level:
-----------------------------

🚀 Understanding SERIALIZABLE Isolation Level in MySQL
The SERIALIZABLE isolation level ensures the highest level of data consistency by executing transactions in sequence, eliminating concurrency issues. Transactions do not overlap, behaving as if they were processed in a single-user system.

📌 1. What Is SERIALIZABLE Isolation Level?
✔ Transactions execute one after another, preventing interference. 
✔ Ensures strict data consistency, solving all concurrency problems:
Prevents lost updates
Eliminates dirty reads
Guarantees repeatable reads
Prevents phantom reads ✔ Transactions must wait for others to complete before executing, reducing concurrency.

📌 Expected Behavior Under SERIALIZABLE: 
✔ Transactions do not see changes made by other transactions until fully committed. 
✔ If a transaction is modifying data, other transactions must wait before reading or modifying the same data.





📌 2. Demonstrating SERIALIZABLE Isolation Level
🚀 Scenario: ✔ Two transactions interact with customer records in Virginia: 
1.Session 1: Reads customers in Virginia before another transaction modifies them. 
2.Session 2: Updates the state of a new customer to Virginia.

📌 Expected Behavior: 
✔ Session 1 waits for Session 2 to complete before executing its query. 
✔ Ensures accurate data retrieval without phantom reads.





📌 3. Steps to Prevent Phantom Reads
🚀 Opening Two Sessions ✔ Open two MySQL connections to simulate concurrent transactions.

📌 Session 1: Setting Isolation Level and Selecting Customers:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

SELECT * FROM customers WHERE state = 'VA'; -- Only existing Virginia customers seen
🚀 Effect: ✔ Establishes a snapshot of customers before new updates.


📌 Session 2: Updating a Customer’s State:
USE sql_store; 
START TRANSACTION;

UPDATE customers 
SET state = 'VA'
WHERE customer_id = 3;
🚀 Effect: ✔ Customer 3 is now located in Virginia, but changes are not yet committed.


📌 Session 1: Attempting to Read Customers
SELECT * FROM customers WHERE state = 'VA'; -- Transaction is blocked, waiting...
🚀 Effect: ✔ Session 1's transaction cannot proceed until Session 2 completes. ✔ Prevents phantom reads by ensuring updates finalize before queries execute.


📌 Session 2: Committing Changes
COMMIT;
🚀 Effect: ✔ Session 1 resumes execution, now including Customer 3 in results.


📌 Session 1: Query After Transaction Completion
COMMIT;
SELECT * FROM customers WHERE state = 'VA'; -- Now includes Customer 3
🚀 Effect: ✔ Ensures all customers in Virginia are correctly retrieved.





📌 4. Key Takeaways
✔ SERIALIZABLE completely eliminates concurrency issues, ensuring transactions execute sequentially. 
✔ Prevents phantom reads, guaranteeing that transactions see all changes affecting the query results. 
✔ Transactions must wait for others to complete before proceeding, potentially reducing system performance.

📌 Use Cases 
✔ Critical financial transactions where data consistency is mandatory. 
✔ Avoiding phantom reads when data integrity is crucial. 
✔ Not recommended for high-concurrency systems, as it limits performance.

📌 Next Steps: ✔ For improved concurrency, use REPEATABLE READ instead unless phantom reads must be prevented.





Queries and other notes in this discussion:

connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM customers WHERE state = 'VA';  -- this transaction should be waiting for the transaction to finish and then reads customers along with customer_id 3 
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET state = 'VA'
WHERE customer_id = 3; 
COMMIT; 





📌 Summary
✔ SERIALIZABLE ensures complete transaction isolation, solving all concurrency problems. 
✔ Transactions execute sequentially, removing interference from concurrent updates. 
✔ Prevents phantom reads, ensuring consistent query results. 
✔ Use sparingly, as it may reduce performance due to transaction blocking.



















Deadlocks:
----------
🚀 Understanding Deadlocks in MySQL
Deadlocks occur in databases when multiple transactions hold locks that the other transaction needs, preventing either from proceeding. Deadlocks can block execution indefinitely, requiring MySQL to resolve them by rolling back one transaction.

📌 1. What Is a Deadlock?
✔ A deadlock happens when two or more transactions wait for each other to release a lock, preventing completion. 
✔ Each transaction locks some records while waiting to access others, creating circular dependency.

📌 Example: Two Transactions 
✔ Transaction 1 locks customers, then tries to update orders. 
✔ Transaction 2 locks orders, then tries to update customers. 
✔ Each transaction waits for the other to complete, causing a deadlock.

🚀 Effect: ✔ Neither transaction can proceed, forcing MySQL to resolve the conflict by rolling back one of them.





📌 2. Simulating a Deadlock in MySQL
🚀 Opening Two Sessions ✔ Open two MySQL connections to simulate concurrent transactions.

📌 Session 1: Updating Customers First
USE sql_store; 
START TRANSACTION; 

UPDATE customers SET state = 'VA' WHERE customer_id = 1;
UPDATE orders SET status = 1 WHERE order_id = 1;

COMMIT;
🚀 Effect: ✔ Locks the customers record first, then tries to update orders.



📌 Session 2: Updating Orders First (Reverse Order)
USE sql_store; 
START TRANSACTION; 

UPDATE orders SET status = 1 WHERE order_id = 1;
UPDATE customers SET state = 'VA' WHERE customer_id = 1;

COMMIT;
🚀 Effect: ✔ Locks the orders record first, then tries to update customers.

📌 Deadlock Occurs When Both Transactions Execute ✔ Each transaction holds a lock on its first update and waits for the other. ✔ Neither can complete, causing MySQL to detect a deadlock.

📌 Expected Output (Session 1 or 2)
ERROR 1213 (40001): Deadlock found when trying to get lock
🚀 Effect: ✔ MySQL selects one transaction as the victim and rolls it back.





📌 3. How to Minimize Deadlocks?
✔ Follow consistent order when updating multiple records across transactions. 
✔ Keep transactions short to minimize lock duration. 
✔ Avoid long-running transactions on large tables, as these increase chances of collision. 
✔ Schedule large updates during non-peak hours to reduce contention.

📌 Best Practices ✔ If deadlocks happen frequently, review SQL execution order. ✔ If a transaction is rolled back due to a deadlock, the application should retry execution.





Queries and other notes in this discussion:


Session 1:
USE sql_store; 
START TRANSACTION; 
UPDATE customers SET state = 'VA' WHERE customer_id = 1; 
UPDATE orders SET status = 1 WHERE order_id = 1; 
COMMIT; 



Session 2:
USE sql_store; 
START TRANSACTION; 
UPDATE orders SET status = 1 WHERE order_id = 1; 
UPDATE customers SET state = 'VA' WHERE customer_id = 1; 
COMMIT; 






📌 Summary
✔ Deadlocks occur when transactions block each other, preventing execution. 
✔ MySQL resolves deadlocks by rolling back one transaction, allowing others to proceed. 
✔ Reduce deadlocks by following consistent execution order and minimizing transaction duration. 



















Data Types:
-----------

You have seen some of the data types supported by MySQL. It's really important for you to understand these data types and when to use which, because in the next section we're going to talk about designing databases, and that's where you're going to use these data types. So in this section, we're going to explore all these data types. In MySQL we have several categories of data types. We have String types, Numeric types, Date and Time types, Blob Types for storing binary data, and Spatial Types storing geometric or geographical values. Over the next few lectures, we're going to explore various data types in each category. So, let's get started.




String Types:
-------------

🚀 Understanding String Types in MySQL:
MySQL provides various string data types for handling textual data, each optimized for different use cases. Choosing the right type ensures efficient storage and indexing while maintaining data integrity.

📌 1. Common String Data Types:
✔ MySQL supports multiple string types, including:
CHAR(x) → Fixed-length strings.
VARCHAR(x) → Variable-length strings.
TEXT Variants (TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT) → Large text storage.

📌 Key Differences Between CHAR and VARCHAR

Type	    Description	                                                                           Max Storage
CHAR(x)	    Fixed-length string, ideal for short, constant-size text (e.g., abbreviations).	       Up to 255 bytes
VARCHAR(x)	Variable-length string, suitable for varying-sized data (e.g., usernames, emails).	   Up to 65,535 characters (~64KB)

🚀 Effect: 
✔ CHAR(x) always reserves memory for its length (e.g., CHAR(10) reserves 30 bytes for Chinese characters). 
✔ VARCHAR(x) saves space by using only the necessary storage for the string.

📌 When to Use CHAR vs. VARCHAR ✔ Use CHAR(x) for fixed-size text (state abbreviations, gender codes). ✔ Use VARCHAR(x) for dynamic-length text (names, passwords, emails).





📌 2. Choosing VARCHAR Lengths for Optimization
✔ Standardized lengths improve maintainability. ✔ Recommended choices:
VARCHAR(50) → For short strings (usernames, passwords).
VARCHAR(255) → For longer strings (emails, addresses).

📌 Why Stick to These Lengths? ✔ Consistency across tables simplifies maintenance. ✔ Prevents unnecessary storage allocation, reducing index size.





📌 3. Handling Large Text (TEXT Variants)
✔ When storing very large textual data, use TEXT types:

Type	    Max Storage	              Use Case
TINYTEXT	255 characters	          Short descriptions
TEXT	    64KB	                  Articles, summaries
MEDIUMTEXT	16MB	                  JSON objects, logs
LONGTEXT	4GB	                      Books, extensive logs

🚀 Effect: ✔ Allows storing large unstructured textual data while maintaining flexibility.

📌 Why Choose VARCHAR Over TEXT? ✔ Indexes work better with VARCHAR—TEXT types cannot be fully indexed. ✔ Use TEXT when data exceeds VARCHAR's 64KB limit.





📌 4. Handling International Characters
✔ MySQL allocates storage based on character encoding.

Language	                Storage per Character
English	                    1 byte
European, Middle Eastern	2 bytes
Asian (Chinese, Japanese)	3 bytes

🚀 Effect: ✔ If using CHAR(10) for Chinese characters, MySQL reserves 30 bytes, ensuring proper encoding storage.

📌 Why Consider Character Encoding? ✔ Use UTF-8 for global support. ✔ Choose VARCHAR wisely to avoid wasted storage.





Queries and other notes in this discussion:

CHAR(x) -- fixed length
VARCHAR(x) -- max: 65, 535 characters (~64KB)

VARCHAR(50) for short strings 
VARCHAR(255) for medium-length strings 

MEDIUMTEXT: max: 16MB
LONGTEXT: max: 4GB

TINYTEXT: max: 255 bytes 
TEXT: max: 64KB


Bytes: 
English = 1 byte, 
European, Middle-eastern = 2 bytes
Asian = 3 bytes 





📌 Summary
✔ Use CHAR(x) for fixed-length data and VARCHAR(x) for variable-length text. 
✔ Optimize VARCHAR usage by sticking to 50 or 255 characters where possible. 
✔ For large text storage, use TEXT, MEDIUMTEXT, or LONGTEXT, but be aware of indexing limitations. 
✔ International characters require more storage, so plan column types accordingly.
















Integer Types:
--------------
🚀 Understanding Integer Types in MySQL
Integer types in MySQL store whole numbers without decimal points, with different types providing varying storage sizes and ranges. Choosing the appropriate integer type ensures efficient storage and query performance.

📌 1. MySQL Integer Types and Their Ranges
✔ MySQL provides five integer types, each differing in storage size and range:

Type	    Storage Size    Signed Range	          Unsigned Range
TINYINT	    1 byte	        -128 to 127	              0 to 255
SMALLINT	2 bytes	        -32,768 to 32,767	      0 to 65,535
MEDIUMINT	3 bytes	        -8M to 8M	              0 to 16M
INT	        4 bytes	        -2B to 2B	              0 to 4B
BIGINT	    8 bytes	        -9Z to 9Z	              0 to 18Z

🚀 Effect: 
✔ Smaller types like TINYINT use less storage, improving performance in queries and indexing. 
✔ Use UNSIGNED for positive-only values, extending storage range.

📌 Use Cases 
✔ TINYINT UNSIGNED → Best for small positive values (age, ratings). 
✔ INT → Standard choice for primary keys and counters. 
✔ BIGINT → Used for huge numerical data (financial, large-scale indexing).





📌 2. Understanding Unsigned Values
✔ By default, integers in MySQL are signed, meaning they can store both negative and positive values. 
✔ Adding UNSIGNED limits values to positive-only, increasing storage capacity.

📌 Example: Using UNSIGNED for Age Storage
age TINYINT UNSIGNED
🚀 Effect: ✔ Prevents negative values, ensuring data integrity.

📌 When to Use UNSIGNED? ✔ Use for inherently positive values (age, counters). ✔ Avoid for values requiring negative ranges (temperature, balances).





📌 3. Handling Out-of-Range Values
✔ MySQL restricts values to column type ranges. 
✔ If an insert exceeds the type limit, MySQL throws an "Out of Range" error.

📌 Example:
INSERT INTO users (age) VALUES (300); -- ERROR: Value exceeds range of TINYINT UNSIGNED
🚀 Effect: ✔ Invalid values are rejected, preserving data integrity.

📌 Preventing Range Errors ✔ Choose appropriate data types during design. ✔ Use constraints or validations in applications.





📌 4. Using ZEROFILL for Padding Numbers
✔ ZEROFILL ensures numbers display with leading zeros. 
✔ This does not affect stored values—only presentation.

📌 Example:
account_number INT(4) ZEROFILL;
🚀 Effect: ✔ Displays 1 as 0001 while keeping actual value as 1.

📌 When to Use ZEROFILL? ✔ Used for formatting purposes (e.g., invoice numbers). ✔ Not recommended for mathematical operations.





📌 5. Best Practices
✔ Use the smallest data type that suits your needs for optimal performance. 
✔ Use UNSIGNED when values will never be negative, maximizing storage range. 
✔ Keep integer columns compact to improve query execution speed. 
✔ Optimize storage by avoiding unnecessary large types (BIGINT for small numbers).





Queries and other notes in this discussion:

TINYINT 1b   [-128, 127]
UNSIGNED TINYINT [0, 255]
SMALLINT 2b [-32K, 32K]
MEDIUMINT 3b [-8M, 8M]
INT 4b [-2B, 2B]
BIGINT  8b [-9Z, 9Z]

search for mysql integer types 


Zerofill --> INT(4) => 0001


Use the smallest data type that suits your needs. 





📌 Summary
✔ Integer types store whole numbers, ranging from TINYINT to BIGINT. 
✔ UNSIGNED increases positive range, preventing invalid negative values. 
✔ Avoid unnecessary large types—small data types improve performance. 
✔ ZEROFILL affects data presentation but not storage. 
✔ Choose wisely to enhance query efficiency and database scalability.
















Fixed-point and Floating-point Types:
-------------------------------------

🚀 Understanding Fixed-Point and Floating-Point Types in MySQL
MySQL provides three data types for storing numbers with decimal points. These are optimized for either precise calculations (e.g., currency) or scientific computations (e.g., approximations for extremely large or small numbers).

📌 1. Fixed-Point Numbers (DECIMAL)
✔ Used for exact values, such as monetary amounts. 
✔ Has a fixed number of decimal places, preventing rounding errors. 
✔ Requires specifying precision (p) and scale (s).

📌 Syntax:
DECIMAL(p, s)  
🚀 Effect: ✔ p (Precision) → Maximum number of digits (total). ✔ s (Scale) → Number of digits after the decimal point.

📌 Example:
DECIMAL(9, 2)  -->  1234567.89  ✅
✔ Stores up to 9 digits, with 2 decimal places (7 digits before the decimal point).

📌 Synonyms for DECIMAL ✔ DEC, NUMERIC, and FIXED are identical to DECIMAL—stick to DECIMAL for consistency.

📌 Use Case ✔ Best for currency, precise values requiring accurate representation.





📌 2. Floating-Point Numbers (FLOAT and DOUBLE)
✔ Used for scientific calculations, where exact precision is not required. 
✔ Stored as approximations, making them ideal for large or small numbers.

📌 Type Comparison:
Type	Storage Size	   Behavior
FLOAT	4 bytes	           Approximate storage, lower precision
DOUBLE	8 bytes	           Higher precision, can store larger numbers
🚀 Effect: ✔ FLOAT → Uses less storage, but values may round unpredictably. ✔ DOUBLE → More precise for scientific calculations requiring larger storage.



📌 Example Calculation Issue:
SELECT 0.1 + 0.2 = 0.3; -- May return FALSE due to floating-point rounding
🚀 Effect: ✔ Floating-point types may introduce small rounding errors in calculations.

📌 Use Case ✔ Best for scientific computations where exact precision isn’t necessary. ✔ Avoid for financial or monetary values—use DECIMAL instead.





📌 3. Choosing the Right Type
✔ Use DECIMAL for fixed precision (currency, accounting). 
✔ **Use FLOAT or DOUBLE when exact precision isn’t required (scientific data). 
✔ Avoid floating-point types for financial calculations due to rounding errors.

📌 Best Practices 
✔ Stick to DECIMAL when precision matters, ensuring reliable arithmetic. 
✔ Use floating-point types sparingly, knowing they store approximate values.





Queries and other notes in this discussion:

DECIMAL(p, s)     DECIMAL(9, 2) => 1234567.89
DEC
NUMERIC
FIXED 

FLOAT  4b
DOUBLE  8b





📌 Summary
✔ Fixed-point (DECIMAL) ensures accuracy, ideal for currency & financial applications. 
✔ Floating-point (FLOAT, DOUBLE) provides approximations, suitable for scientific calculations. 
✔ DECIMAL(p, s) defines total digits and precision, ensuring consistency in values. 
✔ Always use DECIMAL for monetary values, avoiding floating-point rounding errors.



















Boolean Types:
---------------
🚀 Understanding Boolean Types in MySQL
Boolean types store binary values, representing true/false conditions in a database. MySQL does not have a dedicated Boolean type but instead uses TINYINT(1) as a synonym.

📌 1. What Is a Boolean in MySQL?
✔ MySQL represents boolean values using TINYINT(1). 
✔ TRUE is stored as 1, and FALSE is stored as 0. 
✔ BOOLEAN or BOOL is simply an alias for TINYINT(1).

📌 Example Boolean Column Definition:
CREATE TABLE posts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    is_published BOOL
);
🚀 Effect: ✔ BOOL is stored as TINYINT(1), where TRUE = 1 and FALSE = 0.

📌 Alternative Representation ✔ Instead of TRUE and FALSE, 1 and 0 can be used directly:
UPDATE posts SET is_published = 1;  -- Equivalent to TRUE
UPDATE posts SET is_published = 0;  -- Equivalent to FALSE
🚀 Effect: ✔ Boolean values can be stored explicitly using 1 or 0.





📌 2. Using Boolean Conditions in Queries
✔ Boolean columns are useful in conditional checks.

📌 Example: Retrieving Published Posts:
SELECT * FROM posts WHERE is_published = TRUE;
🚀 Effect: ✔ Filters all posts where is_published = 1.

📌 Alternative: Using 1 for Clarity:
SELECT * FROM posts WHERE is_published = 1;
✔ Equivalent representation without using TRUE keyword.





📌 3. Boolean Type Limitations
✔ MySQL lacks a dedicated Boolean type—it treats it as TINYINT(1). ✔ Boolean columns accept any integer (not restricted to 0 or 1).

📌 Preventing Invalid Values ✔ Use a CHECK constraint to ensure only 0 or 1 values:
ALTER TABLE posts ADD CONSTRAINT chk_is_published CHECK (is_published IN (0,1));
🚀 Effect: ✔ Restricts the column to valid Boolean values only.





📌 4. Key Takeaways
✔ Boolean values are stored as TINYINT(1) (where TRUE=1 and FALSE=0). 
✔ MySQL does not enforce strict Boolean constraints—use checks for integrity. 
✔ Use BOOL or BOOLEAN for readability but understand they are aliases for TINYINT(1).

📌 Use Cases 
✔ Best for flags, status indicators, and yes/no values (is_active, is_deleted). 
✔ Use explicit constraints to prevent invalid entries.





Queries and other notes in this discussion:

BOOL 

BOOLEAN 

UPDATE posts
SET is_published = 1 





📌 Summary
✔ MySQL stores Boolean values using TINYINT(1)—no dedicated Boolean type exists. 
✔ TRUE is represented as 1, FALSE as 0, making queries straightforward. 
✔ Use BOOL or BOOLEAN for readability, but they function as TINYINT(1). 
✔ Add constraints to ensure data integrity when working with Boolean values.
















Enum and Set Types:
-------------------
🚀 Understanding ENUM and SET Types in MySQL
MySQL provides ENUM and SET types for restricting column values to predefined lists. While they offer some convenience, they also have significant drawbacks that make them less practical for scalable database designs.


📌 1. What Is the ENUM Type?
✔ ENUM restricts column values to a predefined list of strings, ensuring only valid values are inserted. ✔ Common use case: Storing fixed categories, such as clothing sizes (small, medium, large).

📌 Example: Defining an ENUM Column
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    size ENUM('small', 'medium', 'large')
);
🚀 Effect: ✔ Only "small", "medium", or "large" can be stored in the size column. ✔ Invalid entries will be rejected.


📌 Updating a Value
UPDATE products SET size = 'medium' WHERE id = 1;
✔ Works as expected, storing only predefined values.





📌 2. Why ENUM Is Problematic
While ENUM seems useful, it has significant drawbacks:

✔ Table Rebuilds Are Expensive
If you add, remove, or rename ENUM values, MySQL rebuilds the entire table.
This is costly for large datasets.

✔ Cannot Add Attributes to ENUM Members
What if "small" has specific measurements?
ENUM does not support additional attributes, making it inflexible.

✔ Not Easily Reusable
If another table needs the same values, ENUM must be manually redefined, creating duplication.
Any change must be applied across multiple tables manually, increasing maintenance efforts.

📌 Better Alternative: Lookup Tables ✔ Instead of using ENUM, create a separate table (sizes) for better scalability and reusability:
CREATE TABLE sizes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE,
    measurement VARCHAR(50) NOT NULL
);
🚀 Effect: ✔ Easy updates—no table rebuild needed. ✔ Can store additional attributes (e.g., "small" → "36 inches"). ✔ Reusable across multiple tables.





📌 3. What Is the SET Type?
✔ SET allows multiple values in one column, meaning it can store a list of predefined options. ✔ Example Use Case: A column called categories allowing multiple tags per product.

📌 Example: Defining a SET Column
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    categories SET('electronics', 'furniture', 'clothing')
);
🚀 Effect: ✔ Allows multiple predefined values per row ('electronics,furniture').


📌 Inserting Multiple SET Values
INSERT INTO products (name, categories) VALUES ('Laptop', 'electronics,furniture');
✔ Stores both values together.





📌 4. Why SET Is Problematic
✔ Like ENUM, modifying the list requires a table rebuild, making changes expensive. ✔ Data is stored as a comma-separated string, limiting relational integrity. ✔ Cannot easily query individual SET values—filtering specific options is cumbersome.

📌 Better Alternative: Join Tables ✔ Use a separate table for storing multiple categories per product, ensuring proper relational structure.
CREATE TABLE product_categories (
    product_id INT,
    category_id INT,
    PRIMARY KEY (product_id, category_id)
);
🚀 Effect: ✔ Supports flexible querying (find all products under "electronics"). ✔ Can add or remove categories easily.





Queries and other notes in this discussion: 
ENUM('small', 'medium', 'large')
SET(...)




📌 Summary
✔ ENUM restricts values to a predefined list but has severe update limitations. 
✔ SET allows multiple values but is not scalable or efficient for querying. 
✔ Better alternatives exist:
Use lookup tables instead of ENUM for flexible updates and attributes.
Use join tables instead of SET for efficient querying and relational integrity.














Date and Time Types:
--------------------
🚀 Understanding Date and Time Types in MySQL
MySQL provides several date and time data types for storing various timestamp values efficiently. Choosing the right type ensures accurate storage, retrieval, and indexing.

📌 1. Overview of Date and Time Data Types
✔ MySQL offers five primary date and time types:

Type	   Storage Size	            Usage
DATE	   3 bytes	                Stores only date, without a time component (YYYY-MM-DD).
TIME	   3 bytes	                Stores only time, without a date component (HH:MM:SS).
DATETIME   8 bytes	                Stores both date and time, valid beyond 2038 (YYYY-MM-DD HH:MM:SS).
TIMESTAMP  4 bytes	                Stores date and time, valid only up to 2038 (YYYY-MM-DD HH:MM:SS).
YEAR	   1 byte	                Stores only a four-digit year (YYYY).
🚀 Effect: ✔ Use TIMESTAMP for tracking row creation/modification timestamps, but it only works until 2038. ✔ For future-proofing, use DATETIME, which stores larger date ranges.





📌 2. Choosing Between DATETIME and TIMESTAMP
✔ DATETIME supports years beyond 2038, while TIMESTAMP is limited to 2038. 
✔ TIMESTAMP consumes less storage (4 bytes vs. 8 bytes) but has restrictions.

📌 Example: Storing Event Timestamps:
CREATE TABLE events (
    id INT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(255) NOT NULL,
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
🚀 Effect: ✔ Automatically stores the current timestamp upon insertion.

📌 Year 2038 Problem ✔ TIMESTAMP only supports dates up to 2038 due to internal storage limitations.





📌 3. Using DATE and TIME Separately
✔ If time and date don’t need to be stored together, using DATE and TIME separately saves storage.

📌 Example: Storing Birthdate and Login Time Separately
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    birth_date DATE NOT NULL,
    last_login TIME NOT NULL
);
🚀 Effect: ✔ Reduces storage usage, keeping data structured.





📌 4. Key Takeaways
✔ Use TIMESTAMP for tracking row insertion/updating, but beware of 2038 limitations. 
✔ Use DATETIME for flexibility and long-term storage beyond 2038. 
✔ Use DATE and TIME separately when exact timestamps are unnecessary. 
✔ Use YEAR only for storing standalone four-digit years.

📌 Use Cases 
✔ TIMESTAMP → Best for logging creation/update times. 
✔ DATETIME → Best for future-proofing large time-sensitive records. 
✔ DATE / TIME → Efficient when date/time tracking is needed separately.




Queries and other notes in this discussion: 
DATE
TIME
DATETIME  8b
TIMESTAMP 4b (up to 2038)
YEAR





📌 Summary
✔ DATE and TIME store independent values efficiently. 
✔ DATETIME provides long-term compatibility beyond 2038. 
✔ TIMESTAMP is lightweight but expires in 2038. 
✔ Use YEAR only for storing standalone years. 
✔ Choosing wisely improves query performance and database efficiency.



















Blob Types: 
-----------
🚀 Understanding BLOB Types in MySQL
MySQL provides Binary Large Object (BLOB) types for storing binary data, such as images, videos, PDFs, and other multimedia files. While BLOB types allow database storage for such files, storing binary data in a relational database is generally discouraged due to performance concerns.

📌 1. Overview of BLOB Types
✔ MySQL supports four BLOB types, each varying in maximum storage capacity:

Type	      Storage Size	             Use Case
TINYBLOB	  255 bytes	                 Small binary data (icons, thumbnails).
BLOB	      65 KB	                     Medium-sized documents (PDFs, audio snippets).
MEDIUMBLOB	  16 MB	                     Larger images or videos.
LONGBLOB	  4 GB	                     High-resolution images, large multimedia files.
🚀 Effect: ✔ Larger BLOB types allow more storage, but consume significant database space.





📌 2. Challenges of Storing Files in a Database
✔ While MySQL supports storing binary data, using databases for file storage has drawbacks.

📌 Problems with Database-Based File Storage 
✔ Increased database size → Large files inflate database storage, making backups slower. 
✔ Slower backups → Database backup and restoration take longer due to bulk storage. 
✔ Performance issues → Retrieving images from a database is slower than fetching from a file system. 
✔ Extra coding required → Reading and writing binary files requires additional logic in queries.

📌 Best Alternative ✔ Store files in a separate storage system (file server, cloud storage) and save file paths in the database. ✔ Example approach:
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    image_path VARCHAR(255) NOT NULL  -- Stores file path instead of binary data
);
🚀 Effect: ✔ Keeps database compact, allowing faster retrieval via file paths. ✔ Improves scalability, preventing unnecessary performance bottlenecks.





📌 3. When to Use BLOB Types?
✔ Only consider BLOB storage if database-level access is essential, such as:
Strict security requirements (where storing files separately is not viable).
Frequent transactions requiring file retrieval within queries.

📌 Use Cases Where BLOB Might Be Needed 
✔ Medical records requiring strict access control (X-ray images). 
✔ Financial institutions managing encrypted documents directly within a database.





📌 4. Key Takeaways
✔ MySQL offers four BLOB types for storing binary data (ranging from TINYBLOB to LONGBLOB). 
✔ Storing files in a database increases size, slows backups, and impacts performance. 
✔ Saving file paths instead of binary data is recommended for scalability. 
✔ Use BLOB types only when direct database storage is necessary.





Queries and other notes in this discussion: 


TINYBLOB      255b
BLOB          65KB
MEDIUM BLOB   16MB
LONGBLOB      4GB


Problems with storing files in database: 

Increased database size
Slower backups
Performance problems 
More code to read/write images




📌 Summary
✔ BLOB types store binary data, but using databases for file storage is often inefficient. 
✔ Save file paths in a database instead, fetching actual files from a separate storage system. 
✔ Only use BLOB types for highly secure, database-dependent storage. 
✔ Optimizing data storage ensures faster queries and efficient backups.











JSON Type:
----------

🚀 Working with JSON in MySQL
JSON (JavaScript Object Notation) is a lightweight format for storing and transferring structured data, commonly used in web and mobile applications. MySQL provides built-in JSON functions to efficiently store, manipulate, and query JSON data.

📌 1. Storing JSON Data in MySQL
✔ JSON is stored in MySQL using the JSON data type, allowing structured key-value storage.

📌 Example: Updating a Product's Properties (Standard JSON Format):
UPDATE products 
SET properties = '
{
    "dimensions": [1, 2, 3],
    "weight": 10,
    "manufacturer": { "name": "sony" }
}'
WHERE product_id = 1;
🚀 Effect: ✔ Stores dimensions as an array, weight as a number, and manufacturer as a nested object.


📌 Alternative Approach Using MySQL JSON Functions:
UPDATE products 
SET properties = JSON_OBJECT(
    'weight', 10, 
    'dimensions', JSON_ARRAY(1, 2, 3),
    'manufacturer', JSON_OBJECT('name', 'sony')
)
WHERE product_id = 1;
🚀 Effect: ✔ Uses MySQL JSON functions (JSON_OBJECT, JSON_ARRAY) for structured insertion.





📌 2. Querying JSON Data in MySQL
✔ Extract specific JSON values using JSON_EXTRACT() or column path operators (->, ->>).

📌 Retrieving a JSON Value (weight) Using JSON_EXTRACT:
SELECT product_id, JSON_EXTRACT(properties, '$.weight') AS weight
FROM products
WHERE product_id = 1;
🚀 Effect: ✔ Extracts the value of "weight" from the JSON column.


📌 Alternative Using Column Path Operator (->)
SELECT product_id, properties -> '$.weight' AS weight
FROM products
WHERE product_id = 1;
🚀 Effect: ✔ Equivalent to JSON_EXTRACT, but shorter syntax.


📌 Accessing Array Elements Inside JSON (dimensions[0])
SELECT product_id, properties -> '$.dimensions[0]'
FROM products
WHERE product_id = 1;
🚀 Effect: ✔ Retrieves the first element of the dimensions array.


📌 Retrieving Nested JSON Objects (manufacturer.name)
SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE product_id = 1;
🚀 Effect: ✔ Extracts manufacturer.name while removing surrounding double quotes.


📌 Filtering Data Based on JSON Properties
SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE properties ->> '$.manufacturer.name' = 'sony';
🚀 Effect: ✔ Filters products where manufacturer.name is "sony".





📌 3. Updating JSON Values in MySQL
✔ Use JSON_SET() to modify existing properties or add new values.

📌 Updating the weight Value and Adding age:
UPDATE products 
SET properties = JSON_SET(
    properties,
    '$.weight', 20,
    '$.age', 10
)
WHERE product_id = 1;
🚀 Effect: ✔ Updates weight to 20 and adds age = 10.





📌 4. Removing JSON Properties
✔ Use JSON_REMOVE() to delete a specific key from the JSON object.

📌 Removing the age Property:
UPDATE products 
SET properties = JSON_REMOVE(
    properties,
    '$.age'
)
WHERE product_id = 1;
🚀 Effect: ✔ Removes the age property while keeping other values unchanged.





📌 5. Key Takeaways
✔ Use MySQL JSON functions (JSON_OBJECT, JSON_ARRAY) for structured storage. 
✔ Extract JSON data using JSON_EXTRACT() or -> operators. 
✔ Modify JSON values using JSON_SET() and remove values with JSON_REMOVE(). 
✔ Indexing JSON fields improves query performance (covered in advanced techniques).




Queries and other notes in this discussion:

Lightweight format for storing and transferring data over the internet

json
{
 "key" : value
}



UPDATE products 
SET properties = '
{
	"dimensions" : [1, 2, 3],
	"weight": 10
	"manufacturer": { "name" : "sony"}
}
'
WHERE product_id = 1;


in MySQL:
UPDATE products 
SET properties = JSON_OBJECT(
	'weight', 10, 
	'dimensions', JSON_ARRAY(1, 2, 3),
	'manufacturer, JSON_OBJECT('name', 'sony')
)
WHERE product_id = 1;



SELECT product_id, JSON_EXTRACT(properties, '$.weight') AS weight
FROM products
WHERE product_id = 1; 

SELECT product_id, properties -> '$.weight' AS weight  -- '->' column pass operator
FROM products
WHERE product_id = 1; 


SELECT product_id, properties -> '$.dimensions[0]'
FROM products
WHERE product_id = 1; 

SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE product_id = 1; 


SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE properties ->> '$.manufacturer.name' = 'sony';




UPDATE products 
SET properties = JSON_SET(
	properties,
	'$.weight', 20
	'$.age', 10
)
WHERE product_id = 1;



UPDATE products 
SET properties = JSON_REMOVE(
	properties,
	'$.age'
)
WHERE product_id = 1;






📌 Summary
✔ MySQL supports structured JSON storage and efficient queries using built-in functions. 
✔ Use JSON_EXTRACT() or -> for retrieving values, JSON_SET() for updates, and JSON_REMOVE() for deletions. 
✔ JSON data structure ensures flexible storage without unnecessary table modifications. 
✔ Mastering MySQL JSON operations improves dynamic data management capabilities.
















Designing Databases:

So far we've been writing our queries against existing databases. But as a software engineer or database administrator, there are times when you will need to design a new database from scratch or add new tables to an existing database. And that's what you're going to learn in this section. I'm going to walk you through a simple step-by-step process to design well-structured databases. Remember, a well-designed database requires a bit of planning at the beginning and it may take a bit of time, but it plays a critical role in the success of your applications. If your database is designed properly, you can easily extend it to support new business requirements, you can easily query to extract useful information and your queries will execute quickly. A poorly designed database requires a lot of maintenance and the cost of maintaining it increases over time to the extent that it will eventually prevent you from supporting new business requirements. 
In one of the companies that I worked at, we had a poorly designed database and believe it or not, some of our stored procedures were almost a thousand lines of code because the structure of the database was overly complex. So extracting data was really difficult. Also, some of our queries took several minutes to execute. So in this section, I'm going to walk you through a systematic approach to design well-structured databases. Are you ready? Let's get started.




Data Modelling:
---------------
🚀 Understanding Data Modeling in MySQL
Data modeling is the process of designing the structure of data that will be stored in a database. It ensures efficient data storage, retrieval, and integrity. The process follows four key steps to refine raw business requirements into a structured database design.

📌 1. Steps in Data Modeling
✔ Data modeling involves four structured phases:

Step	                               Purpose
Understanding Requirements	           Identify business needs and data relationships.
Conceptual Model	                   Define entities and their relationships.
Logical Model	                       Structure tables, columns, and constraints, independent of technology.
Physical Model	                       Implement database-specific data types, primary keys, and stored procedures.

🚀 Effect: ✔ Ensures structured and optimized database design, preventing inefficient data storage.





📌 2. Step 1: Understanding Business Requirements
✔ Before designing tables, fully understand business objectives. ✔ Interview stakeholders, domain experts, and users to analyze existing records.

📌 Sources for Business Data Analysis ✔ Forms, documents, spreadsheets, applications, existing databases. ✔ Identifying business relationships and dependencies to ensure completeness.

🚀 Effect: ✔ Prevents incorrect database structuring, ensuring all essential data points are captured.





📌 3. Step 2: Building the Conceptual Model
✔ Defines business entities and relationships. 
✔ Visual representation used to communicate with stakeholders.

📌 Example Conceptual Model for an E-Commerce Database ✔ Entities:
Customers (id, name, email)
Orders (order_id, date, customer_id)
Products (product_id, name, price)

✔ Relationships:
A customer places multiple orders.
Each order contains multiple products.

🚀 Effect: ✔ Ensures logical structure, avoiding redundant or missing relationships.





📌 4. Step 3: Refining to a Logical Model
✔ Transforms conceptual model into structured tables and columns. ✔ Abstract data definition, independent of database technology.

📌 Example Logical Model

Table	          Column Definitions
Customers	      customer_id (PK), name, email
Orders	          order_id (PK), date, customer_id (FK)
Products	      product_id (PK), name, price

🚀 Effect: ✔ Lays the foundation for database implementation.





📌 5. Step 4: Creating the Physical Model
✔ Implements the logical model using database-specific details. 
✔ Defines exact data types, constraints, indexes, and relationships.

📌 Example Physical Model for MySQL:
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    date DATETIME NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10, 2) NOT NULL
);
🚀 Effect: ✔ Includes database-specific optimizations (primary keys, indexing). ✔ Ensures high performance and efficient querying.





📌 6. Key Takeaways
✔ Data modeling follows four steps: requirements analysis, conceptual model, logical model, and physical model. 
✔ Skipping requirement analysis leads to inefficient database designs. 
✔ Conceptual models visualize business entities and relationships before structuring tables. 
✔ Logical models define tables and columns independently of database technology. 
✔ Physical models specify database-specific details like primary keys, indexing, and optimization.





Queries and other notes in this discussion:

Understand the requirements 
Build a Conceptual Model 
Build a Logical Model 
Build a Physical Model 





📌 Summary
✔ Data modeling is critical for structuring databases efficiently. 
✔ Follow structured modeling steps to design a scalable, high-performance database. 
✔ Logical models serve as a bridge between conceptual ideas and technical implementations. 
✔ Mastering data modeling ensures robust and optimized data storage.











Conceptual Models:
------------------
🚀 Understanding Conceptual Models in MySQL Data Modeling
A conceptual model is the first step in data modeling, providing a high-level overview of business entities and their relationships. It helps business stakeholders and developers align on requirements before diving into technical implementation.

📌 1. What Is a Conceptual Model?
✔ Represents business entities and their relationships without focusing on technical details. ✔ Used to communicate with stakeholders and ensure clarity before designing tables. 
✔ Examples of entities:
People → Students, instructors.
Events → Course enrollments.
Locations → Online platforms.

🚀 Effect: ✔ Defines a visual structure to prevent misalignment in requirements.

📌 Benefits of Conceptual Modeling 
✔ Helps organize business rules and data flow. 
✔ Ensures agreement before investing in logical or physical models.





📌 2. Example: Conceptual Model for an Online Course Platform
✔ Users enroll in courses uploaded by instructors. 
✔ Courses have tags for categorization.

📌 Identified Entities ✔ Student → Has name, email, registration_date. ✔ Course → Has title, price, instructor, tags.

🚀 Effect: ✔ Entities define core objects in the system, ensuring structured relationships.





📌 3. Visualizing Conceptual Models
✔ Entity Relationship Diagrams (ERDs) and UML diagrams are common for visualization.

📌 Tools for Creating Diagrams ✔ Microsoft Visio (Windows). ✔ Draw.io / Lucidcharts (Web-based).

📌 Defining Relationships ✔ Use many-to-many relationships:

Student  -- enrolls -- Course

🚀 Effect: ✔ Defines how students interact with courses, ensuring proper structure.





📌 4. Conceptual Model vs. Logical & Physical Models
✔ Conceptual Model: High-level overview of entities and relationships. 
✔ Logical Model: Defines tables, attributes, and constraints. 
✔ Physical Model: Implements the structure within a specific database technology (MySQL).

🚀 Effect: ✔ Helps bridge business requirements into technical database solutions.





📌 5. Key Takeaways
✔ Conceptual models define business structure, ensuring alignment before database implementation. 
✔ Entities represent core business concepts, such as students, courses, and enrollments. 
✔ Relationships visualize interactions, guiding database design decisions. 
✔ Using ERDs or UML diagrams improves clarity and communication with stakeholders.





Queries and other notes in this discussion:

Conceptual Model: Represents the entities and their relationships 

Entity Relationship, UML - visually expressing the concepts 

conceptual model - identifying the entities or things or concepts in the business and their relationships with each other. A conceptual model is just a visual representation of these concepts that you use to communicate with the stakeholders so you know you're both on the same page.






📌 Summary
✔ Conceptual models help organize business data without technical complexities. 
✔ Identifying entities ensures structured relationships before defining tables. 
✔ Using ERDs or UML diagrams improves visualization and stakeholder communication. 
✔ Refining conceptual models leads to accurate logical and physical database designs.


















Logical Models:
---------------
🚀 Understanding Logical Models in MySQL Data Modeling
A logical model defines the structure of data in a database without being tied to a specific database technology. It refines a conceptual model by specifying attributes, data types, and relationships, preparing for actual implementation.

📌 1. What Is a Logical Model?
✔ Refines a conceptual model by specifying data types and relationships. 
✔ Independent of database technologies—focuses on abstract data modeling. 
✔ Provides a structured blueprint for tables before physical implementation.

📌 Logical Model vs. Conceptual Model

Feature	              Conceptual Model	                                   Logical Model
Focus	              High-level business entities and relationships	   Structured tables, attributes, and relationships
Technical Details	  No data types or constraints	                       Includes attributes, data types, relationships
Independence	      Business-level abstraction	                       Abstract database schema (not tech-specific)

🚀 Effect: ✔ Bridges business requirements to database implementation, ensuring clear structuring.





📌 2. Refining a Conceptual Model Into a Logical Model
✔ Step 1: Define Entity Attributes ✔ Step 2: Specify Data Types ✔ Step 3: Identify Relationships

📌 Example Logical Model for an Online Course Platform:
Entity	   Attributes
Student	   first_name (String), last_name (String), email (String), date_registered (Datetime)
Course	   title (String), price (Float), instructor (String), tags (String)

🚀 Effect: ✔ Precise attribute definition ensures structured data storage.

📌 Splitting Composite Attributes ✔ Breaking attributes into smaller fields ensures better querying:
Full Name  →  First Name + Last Name
Address    →  Street + City + Zip Code + Country

✔ Improves sorting, filtering, and indexing efficiency.





📌 3. Defining Relationships in a Logical Model
✔ Relationships define how entities interact.

📌 Three Primary Relationship Types:
Type	              Example
One-to-One	          A person has one passport.
One-to-Many	          A customer places multiple orders.
Many-to-Many	      A student enrolls in multiple courses.

📌 Handling Many-to-Many Relationships ✔ Students enroll in multiple courses. ✔ Courses have multiple students.

🚀 Effect: ✔ Direct many-to-many relationships complicate querying. ✔ Introducing an Enrollment Entity simplifies data storage.





📌 4. Resolving Many-to-Many Relationships Using an Intermediate Entity
✔ Step 1: Introduce an Enrollment entity. 
✔ Step 2: Define its attributes. 
✔ Step 3: Convert Many-to-Many into Two One-to-Many relationships.

📌 Updated Logical Model:
Entity	     Attributes
Student	     first_name, last_name, email, date_registered
Course	     title, price, instructor, tags
Enrollment	 date (Datetime), price (Float)


📌 Updated Relationships:
Student 1:M Enrollment 1:M Course

🚀 Effect: ✔ Converts Many-to-Many into two One-to-Many relationships, simplifying querying.

📌 Why Store Price in Enrollment? ✔ Courses may have varying prices over time. ✔ Price should reflect what the student paid during enrollment.





📌 5. Logical Model Attribute Refinement
✔ Ensure attributes align with structured data representation.

📌 Updated Course Attributes

Attribute	Data Type
Title	    String
Price	    Float
Instructor	String
Tags	    String
🚀 Effect: ✔ Tags stored as a comma-separated string (temporary approach). ✔ Normalization techniques will later refine tag storage.





📌 6. Key Takeaways
✔ Logical models refine conceptual models by specifying data types and structured relationships. 
✔ Splitting attributes improves query efficiency (e.g., first_name, last_name instead of name). 
✔ Introducing an intermediate entity (Enrollment) simplifies many-to-many relationships. 
✔ Logical models remain independent of database technologies, preparing for implementation.




Note: 
logical model is independent of database technologies




📌 Summary
✔ Logical models provide structured data modeling before technical implementation. 
✔ Clearly defining relationships ensures scalable database design. 
✔ Resolving many-to-many relationships using an intermediate entity enhances query efficiency. 
✔ Logical models serve as a blueprint for database creation.

















Physical Models:
----------------
🚀 Understanding Physical Models in MySQL Data Modeling
A physical model is the actual implementation of a logical model in a specific database technology (e.g., MySQL). It defines tables, columns, data types, constraints, and relationships, making the abstract model ready for real-world use.

📌 1. What Is a Physical Model?
✔ A physical model is the detailed implementation of a logical model in MySQL. 
✔ Includes exact MySQL data types, constraints (NOT NULL, DEFAULT values, PRIMARY KEY). 
✔ Defines how data will be stored and retrieved efficiently.

📌 Logical vs. Physical Model

Feature	                    Logical Model	                     Physical Model
Database-Independent?	    Yes	                                 No (specific to MySQL)
Attribute Data Types?	    General types (String, Float)	     MySQL-specific types (VARCHAR, DECIMAL)
Relationships?	            Abstract relationships	             Implemented using foreign keys
Primary Keys, Defaults?	    Not specified	                     Defined explicitly

🚀 Effect: ✔ Translates abstract design into actual database tables.





📌 2. Creating a Physical Model in MySQL Workbench
✔ Step 1: Open MySQL Workbench → File → New Model. 
✔ Step 2: Rename Database Schema → Default is mydb, change to school. 
✔ Step 3: Add Tables & Columns.

📌 Example: Creating the students Table

Column	        Data Type	     Constraints
student_id	    INT	             PRIMARY KEY, AUTO_INCREMENT
first_name	    VARCHAR(50)	     NOT NULL
last_name	    VARCHAR(50)	     NOT NULL
email	        VARCHAR(255)	 NOT NULL, UNIQUE
date_registered	DATETIME	     NOT NULL

🚀 Effect: ✔ Defines structured storage, ensuring efficient querying.

📌 Best Practices for Naming Conventions ✔ Use plural table names (students, courses). ✔ Use underscores (first_name) for column names instead of camelCase.





📌 3. Implementing Other Tables
✔ Define courses and enrollments tables based on logical model.

📌 Example: courses Table
Column	      Data Type	      Constraints
course_id	  INT	          PRIMARY KEY, AUTO_INCREMENT
title	      VARCHAR(255)	  NOT NULL
price	      DECIMAL(5,2)	  NOT NULL
instructor	  VARCHAR(255)	  NOT NULL
tags	      VARCHAR(255)	  NULLABLE (Normalization will later refine this)


📌 Example: enrollments Table:

Column	          Data Type	       Constraints
enrollment_id	  INT	           PRIMARY KEY, AUTO_INCREMENT
student_id	      INT	           FOREIGN KEY REFERENCES students(student_id)
course_id	      INT	           FOREIGN KEY REFERENCES courses(course_id)
date	          DATETIME	       NOT NULL
price	          DECIMAL(5,2)	   NOT NULL

🚀 Effect: ✔ Stores enrollment details, linking students to courses using foreign keys.

📌 Avoiding Redundant Column Naming ✔ Use date, not enrollment_date → Column already belongs to enrollments.





📌 4. Key Takeaways
✔ Physical models implement logical designs using database-specific details. 
✔ Use exact MySQL data types (VARCHAR, DECIMAL, DATETIME) for efficiency. 
✔ Define primary keys and foreign keys to establish relationships between tables. 
✔ Avoid redundant column names (date, price instead of enrollment_date, enrollment_price).

🚀 Next steps: Adding primary keys and defining relationships between tables.





📌 Summary
✔ Physical models translate abstract logical models into MySQL database tables. 
✔ Proper naming conventions enhance query efficiency and database clarity. 
✔ Using FOREIGN KEY constraints ensures referential integrity across tables. 
✔ Optimizing storage by choosing appropriate data types improves performance.



















Primary Keys:
-------------
🚀 Understanding Primary Keys in MySQL
A primary key uniquely identifies each record in a table, ensuring data integrity and preventing duplicate entries. Proper primary key selection is essential for efficient database relationships and indexing.




📌 1. What Is a Primary Key?
✔ A primary key is a unique identifier for each row in a table.  
✔ Must contain unique values and cannot be NULL.  
✔ Used to establish relationships between tables (via foreign keys).

🚀 Effect:  
✔ Ensures fast lookups and prevents duplicate records.





📌 2. Choosing the Right Primary Key
✔ The primary key should be a field that remains unchanged.  
✔ Avoid natural attributes that may change, such as:
   - First name + Last name → Not unique ('John Smith' can exist multiple times).
   - Email → Unique but changeable, making it unreliable.

📌 Best Approach: Using an 'ID' Column
✔ Introduce a dedicated 'id' column.
✔ Use an integer type ('INT') for efficiency.
✔ Enable 'AUTO_INCREMENT' to automatically generate unique values.

📌 Example: Adding Primary Key to 'students' Table:
CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    date_registered DATETIME NOT NULL
);

🚀 Effect:  
✔ Ensures each student has a unique identifier ('student_id').  
✔ Prevents duplication of lengthy text fields ('email') in related tables.





📌3. Defining a Primary Key in MySQL Workbench
✔ Step 1: Open MySQL Workbench → Table Design View.  
✔ Step 2: Add 'student_id' as the first column.  
✔ Step 3: Set 'INT' as the data type.  
✔ Step 4: Mark as 'PRIMARY KEY' and enable 'AUTO_INCREMENT'.

🚀 Effect:  
✔ MySQL automatically generates unique IDs, simplifying insertion.

📌 Ordering the Primary Key First
✔ Place primary keys at the top for clarity.  
✔ Use 'Move Up' option in MySQL Workbench to reorder.





📌 4. Adding Primary Keys to Other Tables
✔ Each table requires a primary key for data consistency.

📌 Example: 'courses' Table:

CREATE TABLE courses (
    course_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    price DECIMAL(5,2) NOT NULL,
    instructor VARCHAR(255) NOT NULL,
    tags VARCHAR(255)
);

🚀 Effect:  
✔ Ensures courses are uniquely identified using 'course_id', preventing duplicates.

📌 Example: 'enrollments' Table:
CREATE TABLE enrollments (
    enrollment_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    enrollment_date DATETIME NOT NULL,
    price DECIMAL(5,2) NOT NULL,
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

🚀 Effect:  
✔ Converts enrollment into a structured entity, ensuring unique course-student relations.





📌 5. Key Takeaways
✔ Always use dedicated 'id' columns as primary keys ('INT AUTO_INCREMENT').  
✔ Avoid using changeable attributes like 'email' as primary keys.  
✔ Place primary keys at the top of the table for clarity.  
✔ Each table should have a unique identifier for efficient relationships.  

🚀 Next steps: Defining foreign keys to establish table relationships.





📌 Summary
✔ Primary keys uniquely identify records, ensuring efficient indexing and lookups.  
✔ Using integer-based 'AUTO_INCREMENT' keys simplifies data management.  
✔ Avoid using fields that may change as primary keys ('name', 'email').  
✔ Defining structured primary keys lays the foundation for strong relational database design.


















Foreign Keys:
-------------
🚀 Understanding Foreign Keys in MySQL

Foreign keys establish relationships between tables, ensuring referential integrity. They connect records from one table to another, preventing orphaned data and improving query efficiency.



📌 1. What Is a Foreign Key?
✔ A foreign key is a column that references a primary key in another table.  
✔ Used to enforce relationships between tables, ensuring data consistency.  
✔ Parent Table ('Primary Key Table') → Contains the original unique records.  
✔ Child Table ('Foreign Key Table') → References the primary key from the parent table.

🚀 Effect:  
✔ Ensures valid relationships, preventing orphaned data.

📌 Example Foreign Key Relationship
✔ A student enrolls in multiple courses:
Student (Primary Table) 1:M Enrollment (Foreign Table)





📌 2. Creating Foreign Key Relationships in MySQL Workbench
✔ Step 1: Identify parent and child tables.  
✔ Step 2: Select foreign key table first, then the parent table.  
✔ Step 3: Ensure MySQL Workbench auto-generates the foreign key column.

📌 Adding Foreign Keys to 'Enrollments' Table
✔ Student ID ('student_id') → Links to 'students(student_id)'.  
✔ Course ID ('course_id') → Links to 'courses(course_id)'.

📌 Renaming Foreign Key Columns
✔ Default naming may be redundant ('students_student_id').  
✔ Rename to simpler format ('student_id', 'course_id').

🚀 Effect:  
✔ Improves readability, keeping naming conventions clean.





📌 3. Choosing a Primary Key for 'Enrollments' Table
✔ Two possible approaches:
1.Composite Primary Key ('student_id + course_id').  
2.Dedicated 'enrollment_id' column ('INT AUTO_INCREMENT').

📌 Using a Composite Primary Key ('student_id, course_id')
✔ Prevents duplicate enrollments (same student cannot enroll twice in the same course).  
✔ Ensures uniqueness in relationships.

📌 Using a Dedicated 'enrollment_id' Primary Key
✔ Simplifies future relationships—only 'enrollment_id' needs repetition in child tables.  
✔ More scalable if additional tables reference 'enrollments'.

🚀 Effect:  
✔ For the current design, a composite primary key is preferred (no child table exists yet).  
✔ Future changes can introduce 'enrollment_id' if needed.

📌 Final Structure
CREATE TABLE enrollments (
    student_id INT,
    course_id INT,
    enrollment_date DATETIME NOT NULL,
    price DECIMAL(5,2) NOT NULL,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

🚀 Effect:  
✔ Prevents duplicate enrollments, enforcing relational integrity.





📌 4. Key Takeaways
✔ Foreign keys reference primary keys in another table, ensuring relational integrity.  
✔ Using composite primary keys prevents duplicate enrollments.  
✔ Dedicated primary keys ('enrollment_id') offer better scalability for complex relationships.  
✔ Future design changes can adjust primary key strategy if required.  

🚀 Next steps: Implementing foreign key constraints and cascading options in MySQL.



Note: parent or the primary key table, child or the foreign key table 




📌 5.Summary
✔ Foreign keys enforce structured data relationships, linking tables efficiently.  
✔ A composite primary key ('student_id + course_id') ensures unique enrollments.  
✔ Alternative: Using 'enrollment_id' as a primary key for future flexibility.  
✔ Optimizing primary key selection improves database scalability and performance.
















Foreign Key Constraints:
------------------------
🚀 Understanding Foreign Key Constraints in MySQL:
Foreign key constraints ensure referential integrity by defining rules for updates and deletions in parent-child relationships. They prevent orphaned records and unintended data loss, making relational databases more reliable.



📌 1. What Are Foreign Key Constraints?
✔ Foreign key constraints define rules for handling updates and deletions in a referenced table.  
✔ Prevents corrupt or orphaned data by enforcing relational integrity.  
✔ Each foreign key must have a unique name within the database.

🚀 Effect:  
✔ Ensures structured data management, avoiding inconsistencies.

📌 Foreign Key Example
✔ 'student_id' in 'enrollments' references 'student_id' in 'students'.  
✔ 'course_id' in 'enrollments' references 'course_id' in 'courses'.



📌 2. Managing Foreign Key Constraints
✔ Define behavior when parent records change or are deleted.

📌 Handling Foreign Key Updates
✔ What if 'student_id' changes from '1' to '2' in 'students'?
   - CASCADE → Automatically updates 'student_id' in 'enrollments'.
   - RESTRICT / NO ACTION → Prevents changes to 'student_id'.
   - SET NULL → Sets 'student_id' to NULL (results in orphan records).

🚀 Effect:  
✔ Using 'CASCADE' ensures consistent references without manual updates.

📌 Handling Foreign Key Deletions
✔ What happens if a student is deleted?
   - CASCADE → Deletes related enrollments (not ideal for financial data).
   - RESTRICT / NO ACTION → Prevents student deletion if enrollments exist.
   - SET NULL → Makes 'student_id' NULL, creating orphan records.

🚀 Effect:  
✔ Prevent deletion ('RESTRICT / NO ACTION') when financial data exists.

📌 Example Foreign Key Constraints for 'enrollments'

ALTER TABLE enrollments 
ADD CONSTRAINT fk_enrollments_students 
FOREIGN KEY (student_id) REFERENCES students(student_id) 
ON UPDATE CASCADE 
ON DELETE RESTRICT;

ALTER TABLE enrollments 
ADD CONSTRAINT fk_enrollments_courses 
FOREIGN KEY (course_id) REFERENCES courses(course_id) 
ON UPDATE CASCADE 
ON DELETE NO ACTION;

🚀 Effect:  
✔ Ensures valid updates but prevents unwanted deletions.





📌 3. Business Considerations for Foreign Key Constraints
✔ Always align constraints with business needs.  
✔ For financial records, prevent automatic deletions to retain sales history.  
✔ For non-critical data (e.g., reminders), cascading deletions may be acceptable.

📌 Example Decision Scenarios
✔ Prevent course deletion if students enrolled → Use 'RESTRICT / NO ACTION'.  
✔ Auto-delete reminders when user deletes account → Use 'CASCADE'.

🚀 Effect:  
✔ Custom rules maintain business integrity while allowing structured data flow.





📌 4. Key Takeaways
✔ Foreign key constraints enforce data integrity and prevent inconsistencies.  
✔ Use 'CASCADE' for updates to maintain references automatically.  
✔ For financial records, prevent deletion to retain transaction history ('RESTRICT').  
✔ Align constraints with business rules for optimal database management.  

🚀 Next steps: Implementing foreign keys in table creation and MySQL Workbench.





📌 Summary
✔ Foreign keys establish relationships while constraints define update/delete behavior.  
✔ Using 'CASCADE' ensures synchronized updates across tables.  
✔ Prevent unintended deletions ('RESTRICT / NO ACTION') when necessary.  
✔ Choosing the right constraint avoids data loss while maintaining referential integrity.



















Normalization: 
--------------
🚀 Understanding Normalization in MySQL Data Modeling
Normalization is the process of optimizing database design to eliminate redundant data and ensure consistency. It minimizes storage usage, simplifies insert/update/delete operations, and prevents inconsistent records.




📌 1. Why Is Normalization Important?
✔ Reduces redundancy, making updates more efficient.  
✔ Ensures data integrity, preventing inconsistencies in reports.  
✔ Simplifies database structure, improving scalability.

📌 Example Problem Without Normalization
✔ A student's name is stored in multiple tables → If they change their name, multiple updates are needed, leading to possible inconsistencies.

🚀 Effect:  
✔ Maintaining a single source of truth ensures accuracy and efficiency.




📌 2. What Are Normal Forms?
✔ Normalization follows seven rules, known as "Normal Forms".  
✔ Each normal form builds upon the previous one.

📌 Key Normal Forms for Practical Applications
✔ First Normal Form (1NF) → Ensures atomicity, meaning each column should store a single value.  
✔ Second Normal Form (2NF) → Eliminates partial dependencies, ensuring each attribute depends entirely on the primary key.  
✔ Third Normal Form (3NF) → Removes transitive dependencies, meaning no column should depend on non-primary key attributes.

🚀 Effect:  
✔ Applying the first three normal forms solves 99% of real-world database issues.

📌 Beyond 3NF
✔ Higher normal forms (BCNF, 4NF, 5NF, etc.) handle complex relationships but are rarely needed in standard applications.





📌 3. Steps to Normalize a Database
✔ Step 1: Review the schema to identify redundant data.  
✔ Step 2: Apply the first three normal forms, ensuring structured relationships.  
✔ Step 3: Verify that data dependencies align with primary keys.  
✔ Step 4: Refactor tables when necessary, creating new entities for repeated attributes.

📌 Example Refinements
✔ If a student's name appears in multiple tables → Move names to a separate 'students' table and reference them via 'student_id'.  
✔ If courses have multiple tags stored in a single column → Create a separate 'course_tags' table instead of storing tags as a comma-separated string.

🚀 Effect:  
✔ Prevents duplication, enhances data integrity, and optimizes querying.





📌 4. Key Takeaways
✔ Normalization eliminates redundant data, ensuring consistency and efficiency.  
✔ The first three normal forms solve most real-world database issues.  
✔ Higher normal forms (4NF, 5NF) are rarely needed in standard applications.  
✔ Structured relationships prevent incorrect updates and unnecessary duplication.  

🚀 Next steps: Understanding First Normal Form (1NF) and how to implement it.





📌 Summary
✔ Normalization optimizes database design, ensuring structured, scalable data storage.  
✔ Applying 1NF, 2NF, and 3NF eliminates redundant data and improves integrity.  
✔ Refactoring tables prevents inconsistencies and simplifies data retrieval.  
✔ Mastering normalization ensures efficient database performance and maintainability.


















1NF-First Normal Form:
----------------------
🚀 First Normal Form (1NF) in MySQL Normalization:
First Normal Form (1NF) ensures that each cell in a table contains a single value and that columns are not duplicated. It eliminates data redundancy and ensures atomicity, making databases more scalable and easier to maintain.





📌 1. Understanding 1NF Rules
✔ Each column must store atomic values (no lists or multiple values).  
✔ Columns should not be repeated (e.g., 'tag_1', 'tag_2', 'tag_3').

🚀 Effect:  
✔ Prevents poor scalability, avoiding the need to modify table structure when new values are added.

📌 Example Violation in the 'courses' Table
✔ A 'tags' column storing multiple values separated by commas:
Tags → "frontend, backend, JavaScript"

🚀 Problem:  
✔ Hard to query and filter individual tags.  
✔ Cannot guarantee consistent formatting across records.  
✔ Adding a new tag requires modifying the schema.

📌 Alternative Poor Design: Using Multiple Columns:
Tag_1 → "frontend"
Tag_2 → "backend"
Tag_3 → "JavaScript"

🚀 Problem:  
✔ Limits flexibility—future additions require schema changes.  
✔ Hard to sort and filter efficiently.





📌 2. Fixing the 'tags' Column: Creating a Separate 'tags' Table
✔ Step 1: Remove the 'tags' column from 'courses'.  
✔ Step 2: Create a new table for 'tags'.  
✔ Step 3: Establish a many-to-many relationship between 'courses' and 'tags'.

📌 Creating the 'tags' Table:
CREATE TABLE tags (
    tag_id TINYINT PRIMARY KEY AUTO_INCREMENT,
    tag_name VARCHAR(50) NOT NULL
);


🚀 Effect:  
✔ Stores tags separately, making querying easier.  
✔ Allows dynamic growth without altering schema.

📌 Choosing the Right Data Type for 'tag_id'
✔ If tags are manually created by admins → Use 'TINYINT' (max ~255 values).  
✔ If tags are dynamically created by users → Use 'INT' (larger range).

🚀 Effect:  
✔ TINYINT conserves storage space, assuming 50-60 predefined tags.

📌 Handling Data Type Bugs in MySQL Workbench
✔ Sometimes, MySQL Workbench automatically changes 'TINYINT' back to 'INT'.  
✔ To fix this, manually set 'TINYINT' in the column properties, removing unnecessary parentheses.





📌 3. Creating a Many-to-Many Relationship Between 'courses' and 'tags'
✔ Step 1: Introduce a junction table ('course_tags').  
✔ Step 2: Reference 'course_id' from 'courses' and 'tag_id' from 'tags'.  

📌 Defining the 'course_tags' Table:

CREATE TABLE course_tags (
    course_id INT NOT NULL,
    tag_id TINYINT NOT NULL,
    PRIMARY KEY (course_id, tag_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id),
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id)
);


🚀 Effect:  
✔ Ensures each course can have multiple tags without duplication.  
✔ Allows filtering courses by tags efficiently.





📌 4. Key Takeaways
✔ First Normal Form (1NF) eliminates duplicate columns and ensures atomic values.  
✔ Storing multiple values in a single cell (comma-separated data) violates 1NF.  
✔ Moving related attributes into separate tables prevents redundancy.  
✔ Using a 'course_tags' table establishes a scalable many-to-many relationship.  

🚀 Next steps: Implementing a structured many-to-many relationship using foreign keys.





📌 Summary
✔ 1NF ensures that columns hold single values and prevents duplicate column names.  
✔ Replacing comma-separated data with structured tables optimizes queries and scalability.  
✔ Many-to-many relationships prevent data repetition while maintaining relational integrity.  
✔ Following 1NF prevents unnecessary schema modifications and inefficient queries.














Link Tables:
------------

🚀 Understanding Link Tables in MySQL Data Modeling
Since relational databases do not support direct many-to-many relationships, link tables (junction tables) act as intermediary tables to connect two entities via two one-to-many relationships.



📌 1. What Is a Link Table?
✔ Used to implement many-to-many relationships in relational databases.  
✔ Contains foreign keys referencing primary keys in both related tables.  
✔ Ensures structured data relationships without redundancy.

🚀 Effect:  
✔ Optimizes many-to-many relationships, making querying efficient.

📌 Example Many-to-Many Relationship: Courses & Tags
✔ A course can have multiple tags, and a tag can belong to multiple courses.
✔ Solution: Create a 'course_tags' table to manage the relationship.





📌 2. Implementing the Link Table ('course_tags')
✔ Step 1: Create 'course_tags' table.  
✔ Step 2: Define foreign keys ('course_id', 'tag_id').  
✔ Step 3: Establish two one-to-many relationships (Courses → CourseTags, Tags → CourseTags).  

📌 Creating the 'course_tags' Table:
CREATE TABLE course_tags (
    course_id INT NOT NULL,
    tag_id TINYINT NOT NULL,
    PRIMARY KEY (course_id, tag_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id),
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id)
);



🚀 Effect:  
✔ Prevents duplicate course-tag relationships via composite primary key.  
✔ Improves flexibility—courses can have unlimited tags without schema modifications.

📌 Defining Foreign Key Relationships
✔ Courses → CourseTags → A course can have multiple tags.  
✔ Tags → CourseTags → A tag can be assigned to multiple courses.

🚀 Effect:  
✔ Ensures valid references—deleting a course automatically removes its tags if 'CASCADE' is set.





📌 3. Removing Redundant Data
✔ Eliminate the 'tags' column from 'courses' (previously stored comma-separated values).  
✔ Refactor database to rely on 'course_tags' instead of manual tag storage.

📌 Deleting the 'tags' Column:
ALTER TABLE courses DROP COLUMN tags;

🚀 Effect:  
✔ Ensures proper normalization, preventing data duplication.

📌 Key Benefits of Using a Link Table
✔ Centralized management of tags → Modifications only require updating one row.  
✔ Prevents redundant storage → No need to repeat tag data in multiple places.  
✔ Optimizes updates → Changing a tag does not lock multiple course records.





📌 4. Key Takeaways:
✔ Link tables establish many-to-many relationships without redundancy.  
✔ Using a junction table ('course_tags') ensures structured tagging for courses.  
✔ Removing the 'tags' column from 'courses' improves scalability.  
✔ Applying link tables adheres to 'First Normal Form (1NF)', eliminating repeated data.  

🚀 Next steps: Implementing Second Normal Form (2NF) for further optimization.





📌 Summary
✔ Link tables serve as intermediary structures for managing many-to-many relationships.  
✔ Creating a 'course_tags' table prevents redundant tag storage and improves query efficiency.  
✔ Proper normalization ensures structured and scalable database design.  
✔ Following 1NF principles keeps databases efficient and free from repeated columns and values.















2NF-Second Normal Form:
-----------------------
🚀 Second Normal Form (2NF) in MySQL Normalization
Second Normal Form (2NF) ensures that each table has a single purpose and every column must describe the entity that the table represents. It eliminates partial dependencies, preventing unnecessary data duplication.



📌 1. Understanding 2NF Rules
✔ Tables must first satisfy First Normal Form (1NF) (atomic values, no duplicate columns).  
✔ Every column should directly relate to the table's primary entity.  
✔ Eliminate attributes that belong to a different entity, ensuring proper table separation.

🚀 Effect:  
✔ Reduces data redundancy, making updates simpler and more efficient.

📌 Example Violation: Courses Table
✔ The 'instructor' column exists in 'courses', but instructors can teach multiple courses.
✔ Duplicating instructor names leads to update issues (changing a name requires multiple updates).

📌 Example Violation: Orders Table
✔ Storing 'customer_name' in 'orders' violates 2NF.
✔ A customer may place multiple orders, leading to name duplication.

🚀 Solution:  
✔ Move 'instructor' to a separate 'instructors' table.  
✔ Move 'customer_name' to a separate 'customers' table.





📌 2. Implementing 2NF in MySQL
✔ Step 1: Create separate tables for related entities.  
✔ Step 2: Remove columns that do not belong.  
✔ Step 3: Establish one-to-many relationships using foreign keys.

📌 Creating the 'instructors' Table:
CREATE TABLE instructors (
    instructor_id SMALLINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);


🚀 Effect:  
✔ Stores instructor details in a single location, preventing duplication.

📌 Updating the 'courses' Table
✔ Remove 'instructor' column.
✔ Introduce 'instructor_id' as a foreign key.

ALTER TABLE courses DROP COLUMN instructor;

ALTER TABLE courses ADD COLUMN instructor_id SMALLINT NOT NULL;
ALTER TABLE courses ADD CONSTRAINT fk_courses_instructors 
FOREIGN KEY (instructor_id) REFERENCES instructors(instructor_id)
ON UPDATE CASCADE 
ON DELETE NO ACTION;


🚀 Effect:  
✔ Links courses to instructors via IDs, enabling scalable relationships.





📌 3. Establishing a One-to-Many Relationship
✔ Each instructor teaches multiple courses, but each course belongs to one instructor.

📌 Creating One-to-Many Relationship:
Instructor (Primary Table) 1:M Courses (Foreign Table)

✔ Courses reference 'instructor_id', ensuring data consistency.

🚀 Effect:  
✔ Prevents redundant instructor names across multiple courses.  
✔ Modifying an instructor’s name updates all associated records without duplication.





📌 4. Key Takeaways
✔ 2NF ensures each table stores only relevant attributes.  
✔ If an attribute belongs to another entity, create a separate table.  
✔ Introducing a foreign key maintains structured relationships.  
✔ Use cascading updates to ensure consistent records across relationships.  

🚀 Next steps: Implementing Third Normal Form (3NF) for further optimization.



📌 Summary
✔ Second Normal Form eliminates partial dependencies and organizes data efficiently.  
✔ Refactoring tables prevents unnecessary duplication.  
✔ Using foreign keys ensures structured entity relationships.  
✔ Applying 2NF improves database scalability and maintainability.
















3NF-Third Normal Form:
----------------------
🚀 Third Normal Form (3NF) in MySQL Normalization
Third Normal Form (3NF) ensures that no column in a table should be derived from other columns. It eliminates transitive dependencies, preventing unnecessary data duplication and ensuring consistency.



📌 1. Understanding 3NF Rules
✔ A table must first satisfy Second Normal Form (2NF) (attributes must belong directly to the entity).  
✔ No attribute should be dependent on a non-primary attribute (transitive dependency).  
✔ Remove calculable values and store only raw data.

🚀 Effect:  
✔ Eliminates inconsistent and redundant data, improving update reliability.

📌 Example Violation: Invoices Table
✔ The 'balance' column is derived from 'invoice_total - payment_total':
balance = invoice_total - payment_total

🚀 Problem:  
✔ If 'invoice_total' or 'payment_total' changes, 'balance' must be updated manually.  
✔ Forgetting to update 'balance' leads to inconsistent records.

📌 Solution: Remove 'balance' Column
✔ Balance should be calculated dynamically in queries instead of stored explicitly.
SELECT invoice_total - payment_total AS balance FROM invoices;


🚀 Effect:  
✔ Prevents inconsistent records and ensures real-time accuracy.





📌 2. Identifying Transitive Dependencies
✔ Transitive dependency: A column depends on another non-primary attribute, rather than directly on the primary key.

📌 Example Violation: Full Name in Customers Table
✔ If the 'customers' table contains 'first_name', 'last_name', and 'full_name':
full_name = CONCAT(first_name, ' ', last_name)

🚀 Problem:  
✔ Full name is derived from first and last name, creating unnecessary duplication.  
✔ Updating 'first_name' or 'last_name' requires updating 'full_name' manually.

📌 Solution: Remove 'full_name' and use dynamic queries:
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM customers;

🚀 Effect:  
✔ Reduces storage usage and ensures consistency.





📌 3. Applying 3NF Across Tables
✔ Remove any column that can be calculated using other columns.  
✔ Ensure all attributes depend only on the primary key, not other non-primary attributes.

📌 Common Fixes Using 3NF
✔ Remove computed values (e.g., balance, full name).  
✔ Ensure attributes belong directly to the entity's primary key.  
✔ Use queries instead of storing derivable data.

🚀 Effect:  
✔ Prevents redundant updates, ensures data consistency, and reduces storage usage.





📌 4. Key Takeaways
✔ 3NF eliminates transitive dependencies, ensuring structured data relationships.  
✔ Derived values should be removed and calculated dynamically in queries.  
✔ Removing redundant attributes improves database maintainability.  
✔ Applying 3NF prevents inconsistencies, ensuring accurate reporting.  

🚀 Next steps: Implementing best practices for indexing and optimizing MySQL queries.





📌 Summary
✔ Third Normal Form ensures that no column is dependent on non-primary attributes.  
✔ Transitive dependencies must be eliminated to prevent update issues.  
✔ Using dynamic queries rather than stored derived values optimizes accuracy and efficiency.  
✔ Applying 3NF improves database integrity and reduces unnecessary storage usage.
















My Pragmatic Advice:
--------------------
🚀 Pragmatic Approach to Normalization in MySQL
Normalization helps optimize databases by eliminating redundancy and ensuring structured relationships. However, memorizing normalization rules isn't necessary—the key is focusing on practical database design principles.



📌 1. Focus on Removing Redundancy
✔ Avoid worrying about specific normal forms (1NF, 2NF, 3NF, etc.)—instead,  
✔ Identify duplicate values that are not foreign keys and eliminate unnecessary repetition.  
✔ When redundant data appears, rethink table structure and logical relationships.

🚀 Effect:  
✔ Ensures efficient storage, faster queries, and simplified updates.





📌 2. Example: Fixing a Poorly Designed Customers Table
🚨 Problem: Storing Multiple Shipping Addresses in a Single Table
| Customer_ID  | Name   | Email           | Shipping_Address |
|--------------|--------|-----------------|------------------|
| 101          | Alice  | alice@email.com | 123 Main St      |
| 101          | Alice  | alice@email.com | 456 Elm St       |

🚀 Issue:  
✔ Customer data is duplicated whenever they have multiple shipping addresses.  
✔ Updating customer details (e.g., email) requires multiple changes.

📌 Solution: Split into 'customers' and 'addresses' tables
✔ Recognize logical entities → Customers and Addresses.  
✔ Define relationships → Customers can have multiple addresses (one-to-many relationship).

📌 Creating Separate Tables:
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE addresses (
    address_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    shipping_address VARCHAR(255) NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

🚀 Effect:  
✔ Prevents customer duplication, ensuring accurate and efficient updates.  
✔ Addresses are managed separately, avoiding redundant information storage.





📌 3. Start with Logical Entities, Not Normalization Rules
✔ Instead of memorizing normalization rules, focus on logical relationships.  
✔ Understand the real-world constraints before designing database tables.  
✔ Skipping proper entity identification leads to messy, inefficient designs.

📌 Logical Modeling Approach
✔ Identify core entities → Define what represents unique data points.  
✔ Establish relationships → Avoid forcing unnecessary data into a table.

🚀 Effect:  
✔ Results in a cleaner, scalable database schema without blindly following rules.





📌 4. Consider Business Requirements Before Applying Normalization
✔ Every design decision should align with business needs.  
✔ Some redundancy may be acceptable if requirements dictate it.  
✔ Don’t overcomplicate designs just to follow normalization blindly.

📌 Example: Supporting Multiple Shipping Addresses
✔ If required, use separate 'addresses' table.  
✔ If not needed, storing a single address per customer is acceptable.

🚀 Effect:  
✔ Database design should fit requirements, not arbitrary normalization rules.





📌 5. Key Takeaways
✔ Forget rigid normalization rules—focus on removing redundancy.  
✔ Recognizing logical entities ensures scalable database design.  
✔ Requirements dictate structure—don't model unnecessary complexity.  
✔ Efficient table relationships prevent duplicate data and optimize storage.  

🚀 Next steps: Avoiding overcomplication by not modeling unnecessary relationships.




📌Summary
✔ Eliminate duplicate data by understanding entity relationships instead of memorizing normalization forms.  
✔ Separate data into logical tables only when necessary based on business needs.  
✔ Always start with a conceptual model before defining tables.  
✔ Build databases that align with real-world applications, avoiding unnecessary complexity.
















Don't Model the Universe:
-------------------------
🚀 Avoid Overcomplicating Database Models – Don’t Model the Universe
One of the most common mistakes in database design is over-generalizing models to anticipate future requirements. While flexibility is important, creating overly complex structures based on hypothetical scenarios leads to inefficiency and unnecessary complexity.



📌 1. The Problem with Over-Generalized Models
✔ Many data modelers attempt to future-proof their designs, anticipating requirements that may never happen.  
✔ Instead of focusing on the current scope of the project, they create overly complex models, making maintenance difficult.  
✔ A complex, abstract database model can become nearly impossible to understand, leading to poor query performance.

🚀 Effect:  
✔ Designing for imaginary future use cases results in unnecessary complexity.  
✔ Projects become difficult to scale due to overcomplicated structures.





📌 2. The Consequences of Over-Engineering
✔ A real-world example of an overly complex data model:
- The architect designed a universal database with only three tables: 'entities', 'attributes', and 'values'.
- His argument: The system would be flexible enough to store any kind of data without requiring schema changes.

🚀 Result:  
✔ Queries were painfully slow—even simple lookups required multiple joins.  
✔ Stored procedures were excessively long, sometimes exceeding 1000 lines of code.  
✔ Basic operations took minutes, making real-time queries impractical.

📌 Lessons Learned
✔ Avoid abstracting database models beyond practical use.  
✔ A system that is “too flexible” often lacks efficiency and clarity.  
✔ A relational database should reflect structured real-world relationships, not attempt to replace them.



📌 3. Focus on Current Requirements, Not Hypotheticals
✔ Database models should be designed for today’s requirements, not hypothetical future needs.  
✔ Real-world data changes (e.g., customers move, change names), but handling this complexity should be based on business needs, not theoretical concerns.  

📌 Example Mistakes
✔ Adding unnecessary attributes like 'previous_name' for all customers, assuming users might legally change their names.  
✔ Supporting unlimited addresses when only the current address is needed.  

🚀 Effect:  
✔ Over-designing creates unnecessary maintenance burdens.  
✔ Complexity increases without adding meaningful business value.

📌 Practical Approach
✔ Model based on real-world requirements, not speculation.  
✔ Future changes will happen—adjustments to the database schema are inevitable.  
✔ Migrations can always be scripted when needed instead of making assumptions.





📌 4. Keep Database Models Simple and Understandable
✔ Complexity should be justified by actual business needs, not theoretical possibilities.  
✔ Design with clarity—your model should be easy for others to understand and maintain.  
✔ Performance and usability should take priority over excessive flexibility.

📌 Guiding Principles
✔ Simplicity is the ultimate sophistication.  
✔ Great design simplifies complexity rather than adding to it.  
✔ Structured models perform better and require less maintenance.

🚀 Effect:  
✔ Efficient queries, easy schema adjustments, and a model everyone can understand.  
✔ Future requirements can be integrated logically rather than anticipated blindly.





📌 5. Key Takeaways
✔ Don’t build for hypothetical scenarios—design for what’s needed today.  
✔ A database should reflect business needs, not abstract concepts.  
✔ Overcomplicated models lead to poor query performance and difficult maintenance.  
✔ Embrace change—database migration scripts allow for future adjustments when necessary.  

🚀 Next steps: Optimizing query performance and maintaining scalability without over-engineering.






📌 6. Summary
✔ Resist the temptation to create overly flexible database models—focus on practical implementation.  
✔ Structure your database around current business needs instead of hypothetical future changes.  
✔ Simplifying complexity improves database performance and maintainability.  
✔ Making informed adjustments when changes arise is far more effective than excessive anticipation.













Forward Engineering a Model:
----------------------------
🚀 Forward Engineering a Model in MySQL Workbench:
Forward engineering converts a physical data model into a real MySQL database. This process automatically generates SQL scripts to create tables, views, and other database objects.



📌 1. What Is Forward Engineering?
✔ It transforms a structured model into an actual database, eliminating manual table creation.  
✔ Uses MySQL Workbench’s built-in wizard to automate database deployment.  

🚀 Effect:  
✔ Ensures database structure aligns with the designed model while reducing human errors.




📌 2. Steps to Forward Engineer a Model
✔ Step 1: Open MySQL Workbench with your physical model.  
✔ Step 2: Click Database → Forward Engineer.  
✔ Step 3: Select your MySQL connection.

📌 Selecting a Connection
✔ By default, your active connection appears.  
✔ If not, manually select the correct database server.  
✔ Enter your password if required.

🚀 Effect:  
✔ Connects MySQL Workbench to the target database, ensuring proper schema creation.





📌 3. Configuring Forward Engineering Settings
✔ Leave default settings unless customization is needed.  
✔ Next step: Select database objects to include in the script.

📌 Choosing Objects to Forward Engineer
✔ Tables (mandatory).  
✔ Views (optional).  
✔ Stored procedures, triggers, and functions (optional).  
✔ Apply filters to exclude unnecessary tables.

🚀 Effect:  
✔ Ensures only relevant structures are generated in the SQL script.





📌 4. Reviewing Generated SQL Script
✔ MySQL Workbench generates the schema creation SQL code.  
✔ Typical commands include:

CREATE SCHEMA school;
CREATE TABLE students (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    date_registered DATETIME NOT NULL
);


📌 Options Available
✔ Save to File → Store script for version control.  
✔ Copy to Clipboard → Paste into MySQL Workbench manually.  
✔ Click Continue → Automatically create the database and tables.

🚀 Effect:  
✔ Allows manual verification before executing changes on the database.





📌 5. Finalizing Forward Engineering
✔ Step 1: Click Continue to execute the script.  
✔ Step 2: Refresh the Navigator Panel in MySQL Workbench.  
✔ Step 3: Verify that all tables now exist in the database.

📌 Verifying the Database
✔ Navigate to Local Instance → Expand Databases → Check for school database.  
✔ Ensure tables match the designed physical model.

🚀 Effect:  
✔ Database is successfully created, ready for data insertion and application integration.





📌 6. Key Takeaways
✔ Forward engineering automates database creation, reducing manual work.  
✔ Selecting the correct objects ensures accurate schema generation.  
✔ Generated SQL scripts can be stored in version control for tracking changes.  
✔ Refreshing the database navigator confirms successful table creation.  

🚀 Next steps: Populating tables with initial data and optimizing queries.




📌 Summary
✔ Forward engineering transforms a physical model into an actual MySQL database.  
✔ Using MySQL Workbench ensures structured table creation without manual intervention.  
✔ Saving generated scripts improves maintainability and version tracking.  
✔ Successful execution results in fully defined tables ready for data management.














Synchronizing a Model with a Database:
--------------------------------------

🚀 Synchronizing a Model with a Database in MySQL Workbench

Synchronization allows developers to update an existing database structure based on changes made to the physical data model. This process ensures consistency across environments (development, staging, testing, production) and eliminates manual table modifications.



📌 1. Why Is Synchronization Important?
✔ Ensures database structure remains aligned with changes in the model.  
✔ Prevents inconsistent schemas across environments (development, testing, production).  
✔ Automatically applies changes without manual intervention.

🚀 Effect:  
✔ Streamlines schema updates, making collaboration in teams more efficient.





📌 2. Making Changes to the Model
✔ Step 1: Open MySQL Workbench, select the physical model.  
✔ Step 2: Modify tables in the design mode (e.g., adding columns).  
✔ Step 3: Example—Adding a 'coupon' column in the 'enrollments' table:
ALTER TABLE enrollments ADD COLUMN coupon VARCHAR(50) NULL;

🚀 Effect:  
✔ Stores coupon codes for student enrollments, maintaining flexibility.

📌 Ensuring Nullable Values
✔ Set column as NULL → Not all students use coupons.  
✔ VARCHAR(50) → Consistent with other short string attributes.



📌 3. Synchronizing Model with the Database
✔ Step 1: Navigate to Database → Synchronize Model.  
✔ Step 2: Select the correct database connection:
   - Local for personal use.
   - Testing/Staging/Production for organization-wide synchronization.

📌 Selecting the Correct Environment
✔ Development → Local development database.  
✔ Testing → QA database where changes are tested.  
✔ Staging → Pre-production database used for final validation.  
✔ Production → Live application database (only after validation).

🚀 Effect:  
✔ Prevents accidental modifications to production databases.





📌 4. Detecting Affected Tables
✔ MySQL Workbench detects dependencies:
   - Enrollments table modified → Affects related 'courses' table.  
   - Courses table modified → Affects 'course_tags' due to relationships.

📌 Handling Foreign Key Dependencies
✔ MySQL temporarily drops foreign key constraints, then recreates them:
'''sql
ALTER TABLE courses DROP FOREIGN KEY fk_courses_enrollments;
ALTER TABLE enrollments ADD COLUMN coupon VARCHAR(50);
ALTER TABLE courses ADD CONSTRAINT fk_courses_enrollments FOREIGN KEY (course_id) REFERENCES enrollments(course_id);

🚀 Effect:  
✔ Ensures smooth schema updates without violating constraints.





📌 5. Reviewing and Executing the Synchronization
✔ MySQL Workbench generates an SQL script for all changes.  
✔ Options available:
   - Save to File → Keep a backup for version control (e.g., Git).  
   - Copy to Clipboard → Manually execute SQL in another environment.  
   - Execute Now → Apply changes immediately.

📌 Best Practice: Using Version Control
✔ Store scripts in Git repositories → Track database changes.  
✔ Allows replication of the same changes across multiple servers.

🚀 Effect:  
✔ Prevents undocumented schema changes, making updates repeatable and traceable.



📌 6. Finalizing Database Synchronization
✔ Step 1: Click Execute to apply changes.  
✔ Step 2: Refresh Navigator Panel to confirm updates.  
✔ Step 3: Verify that the new column 'coupon' appears in 'enrollments'.

📌 Verifying the Updated Schema
DESCRIBE enrollments;

🚀 Effect:  
✔ Confirms successful synchronization between model and database.





📌 7. Key Takeaways
✔ Synchronization automates schema updates across database environments.  
✔ Foreign key dependencies are managed to prevent schema conflicts.  
✔ Using version control (Git) ensures traceable and replicable changes.  
✔ Refreshing the navigator verifies successful updates.

🚀 Next steps: Populating updated tables with relevant data for validation.




📌 Summary
✔ Synchronizing a model ensures the database remains consistent with structural changes.  
✔ Automatically detecting dependencies simplifies schema modification.  
✔ Tracking schema updates using SQL scripts prevents accidental inconsistencies.  
✔ MySQL Workbench efficiently handles foreign key constraints during updates.











Reverse Engineering a Database:
-------------------------------
🚀 Reverse Engineering a Database in MySQL Workbench:
Reverse engineering allows developers to create a model from an existing database, making it easier to visualize relationships, identify design flaws, and apply future changes systematically.



📌 1. Why Reverse Engineer a Database?
✔ Some databases exist without a formal data model—reverse engineering generates one.  
✔ Helps understand existing database structures, especially when working with inherited systems.  
✔ Identifies missing relationships and schema inconsistencies, improving data integrity.

🚀 Effect:  
✔ Creates a structured model, making future modifications more manageable.




📌 2. Steps to Reverse Engineer a Database
✔ Step 1: Open MySQL Workbench, close any existing models.  
✔ Step 2: Navigate to Database → Reverse Engineer.  
✔ Step 3: Select the correct MySQL connection.  

📌 Why Close Existing Models?
✔ MySQL Workbench adds reverse-engineered databases to open models, which may cause unwanted merging.  
✔ Keeping separate models for different databases improves organization.

🚀 Effect:  
✔ Ensures clean database modeling, avoiding unintended mix-ups.





📌 3. Selecting the Target Database
✔ Step 1: Choose the correct database from available connections.  
✔ Step 2: If multiple databases exist, select only those that are highly related.  
✔ Step 3: Proceed to the next step.

📌 Handling Multiple Databases
✔ Selecting multiple databases is useful for related systems that share entities.  
✔ Unrelated databases should remain in separate models.

🚀 Effect:  
✔ Keeps models organized, preventing confusion when making changes.





📌 4. Importing Tables into the Model
✔ Step 1: MySQL Workbench detects all tables in the selected database.  
✔ Step 2: Filter tables if needed, or import everything.  
✔ Step 3: Execute the reverse engineering process.

📌 Filtering Tables
✔ Exclude tables that don’t need modeling to keep the model clean.  
✔ For comprehensive modeling, include all tables.

🚀 Effect:  
✔ Ensures complete visualization of database relationships and dependencies.





📌 5. Reviewing the Generated Diagram
✔ MySQL Workbench generates a full ER diagram, showing tables and their relationships.  
✔ Key benefits of the diagram:
   - Easily visualize entity connections (e.g., 'products' → 'order_items' one-to-many relationship).  
   - Detect missing relationships that may impact data integrity.  

📌 Example Issue: 'order_item_notes' Table
✔ This table lacks relationships, meaning 'order_id' values aren't validated.  
✔ Without foreign key constraints, invalid data can be inserted.

🚀 Effect:  
✔ Identifies missing constraints, ensuring proper referential integrity.





📌 6. Making Changes After Reverse Engineering
✔ Step 1: Modify the model using MySQL Workbench's design tools.  
✔ Step 2: Add missing relationships to enforce data consistency.  
✔ Step 3: Generate SQL scripts to apply changes across MySQL databases.

📌 Advantages of Reverse Engineering
✔ Improves schema understanding, making modifications easier.  
✔ Enforces relational integrity, preventing accidental data corruption.  
✔ Provides a clear roadmap for future optimizations.

🚀 Effect:  
✔ Database becomes structured, scalable, and easier to maintain.



📌 7. Key Takeaways
✔ Reverse engineering creates a model for databases that lack formal documentation.  
✔ Generated ER diagrams help visualize relationships and identify design flaws.  
✔ Missing foreign key constraints can be detected and corrected.  
✔ Changes can be scripted and executed across different environments.

🚀 Next steps: Synchronizing reverse-engineered models with live databases.



📌 Summary
✔ Reverse engineering simplifies database management, allowing structured visualization.  
✔ Generated diagrams help identify missing relationships and inconsistencies.  
✔ Fixing schema issues ensures referential integrity and prevents invalid data entry.  
✔ Reverse-engineered models facilitate future modifications in a systematic way.















Project: Flight Booking System
------------------------------

Alright, here's a project for you. I want you to design a database for a flight booking system. Download the PDF I've attached to this lecture. In this PDF, you can see an example of a ticket that this system should generate. Based on the information you see here, design a database for this system. You will see my solution next.


Details in the attached pdf: 
Flight Booking System.pdf:
Los Angeles, CA -> San Francisco, CA
San Francisco, CA -> Los Angeles, CA
Fri Apr 05 2019 -> Sun Apr 07 2019
2 Tickets


Airline Confirmation Numbers
Alaska Airline: TAEGKX


Passengers and Ticket Numbers:
John Smith
Ticket Number: 0177200658

Jennifer Smith
Ticket Number: 0178410326





Fri Apr 05
Los Angeles -> San Francisco
LAX -> SFO
08:20 AM - 09:35 AM
Alaska Airlines Flight 1490
1h 15m, 236 miles

Depart: Los Angeles Intl Airport (LAX)
Arrive: San Francisco Intl Airport (SFO)

Economy Class


Sun Apr 07
San Francisco -> Los Angeles
SFO -> LAX
02:00 PM - 03:15 PM
Alaska Airlines Flight 1473
1h 15m, 236 miles

Depart: San Francisco Intl Airport (SFO)
Arrive: Los Angeles Intl Airport (LAX)

Economy Class




Price Summary:
Traveler 1: $357.60
Traveler 2: $357.60
Total:      $756.20





🚀 Flight Booking System Database Design
A flight booking system manages flight details, passengers, bookings, tickets, and pricing. Based on the provided sample ticket, we need to design a structured relational database to capture key information efficiently.



📌 Identified Entities
✔ Flights → Stores flight details (departure, arrival, timing, airline).  
✔ Passengers → Stores traveler details (name, ticket number).  
✔ Bookings → Links passengers to flights via booking records.  
✔ Airports → Stores standardized airport details.  
✔ Pricing → Manages ticket costs associated with each passenger.  

🚀 Effect:  
✔ Organizes data logically, preventing duplication and ensuring consistency.



📌 2. Tables and Their Attributes
✔ Step 1: Define tables and attributes.  
✔ Step 2: Establish relationships via foreign keys.

📌 Creating the 'flights' Table

CREATE TABLE flights (
    flight_id INT PRIMARY KEY AUTO_INCREMENT,
    airline VARCHAR(100) NOT NULL,
    flight_number VARCHAR(10) NOT NULL UNIQUE,
    departure_airport_code VARCHAR(10) NOT NULL,
    arrival_airport_code VARCHAR(10) NOT NULL,
    departure_datetime DATETIME NOT NULL,
    arrival_datetime DATETIME NOT NULL,
    duration TIME NOT NULL,
    distance_miles INT NOT NULL,
    class VARCHAR(50) NOT NULL
);

🚀 Effect:  
✔ Stores flight details uniquely, making retrieval efficient.  

📌 Creating the 'passengers' Table

CREATE TABLE passengers (
    passenger_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    ticket_number VARCHAR(20) NOT NULL UNIQUE
);

🚀 Effect:  
✔ Eliminates passenger redundancy, tracking individual ticket numbers.

📌 Creating the 'bookings' Table

CREATE TABLE bookings (
    booking_id INT PRIMARY KEY AUTO_INCREMENT,
    passenger_id INT NOT NULL,
    flight_id INT NOT NULL,
    confirmation_number VARCHAR(10) NOT NULL UNIQUE,
    FOREIGN KEY (passenger_id) REFERENCES passengers(passenger_id),
    FOREIGN KEY (flight_id) REFERENCES flights(flight_id)
);

🚀 Effect:  
✔ Links passengers to flights, ensuring valid bookings.

📌 Creating the 'airports' Table
CREATE TABLE airports (
    airport_code VARCHAR(10) PRIMARY KEY,
    airport_name VARCHAR(100) NOT NULL,
    city VARCHAR(50) NOT NULL
);

🚀 Effect:  
✔ Standardizes airport information, preventing duplication.

📌 Creating the 'pricing' Table
CREATE TABLE pricing (
    price_id INT PRIMARY KEY AUTO_INCREMENT,
    booking_id INT NOT NULL,
    ticket_price DECIMAL(6,2) NOT NULL,
    FOREIGN KEY (booking_id) REFERENCES bookings(booking_id)
);

🚀 Effect:  
✔ Tracks financial records for individual travelers, preventing inconsistencies.




📌 3. Establishing Relationships
✔ Passengers book flights → Linked via 'bookings'.  
✔ Flights depart and arrive at airports → Referenced via airport codes.  
✔ Pricing depends on booking records → Ensures accurate costs.  

📌 Table Relationships Summary
| Entity       | Relation Type | Linked Entity |
|--------------|---------------|------------|
| 'passengers' | One-to-Many   | 'bookings' |
| 'flights'    | One-to-Many   | 'bookings' |
| 'bookings'   | One-to-One    | 'pricing' |
| 'flights'    | Many-to-One   | 'airports' |

🚀 Effect:  
✔ Ensures structured data access, avoiding duplication.



📌 4. Key Takeaways
✔ Structured database ensures logical flight booking data management.  
✔ Foreign keys establish relationships between passengers, flights, and pricing.  
✔ Airport codes standardize location references, ensuring accuracy.  
✔ Following normalization eliminates redundancy, simplifying updates.  

🚀 Next steps: Enhancing queries for efficient booking retrieval.




📌 Summary
✔ Flight booking systems require structured tables to store passengers, flights, bookings, airports, and pricing.  
✔ Using relational tables improves efficiency and data integrity.  
✔ Foreign keys establish relationships ensuring reliable queries.  
✔ Normalization prevents duplication, making retrieval seamless.
















Solution - Conceptual Model:
----------------------------
🚀 Conceptual Model for a Flight Booking System
A conceptual model defines the key entities and their relationships within a flight booking system. It provides a high-level overview of the system before transitioning to a more detailed logical model.



📌 1. Identified Entities
✔ Passenger → Represents travelers booking flights.  
✔ Flight → Defines flight details (departure, arrival, airline).  
✔ Airport → Stores airport codes and location details.  
✔ Booking → Tracks ticket purchases, prices, and flight classes.  

🚀 Effect:  
✔ Ensures structured relationships between flights, passengers, and bookings.



📌 2. Defining Entities and Attributes
✔ Step 1: Define entities and their key attributes.  
✔ Step 2: Establish relationships between them.

📌 Passenger Entity
| Attribute  | Description    |
|------------|----------------|
| Name       | Traveler’s full name (e.g., John Smith). |

🚀 Effect:  
✔ Stores basic passenger details needed for booking a flight.


📌 Flight Entity
| Attribute          | Description |
|--------------------|----------------|
| Flight Number      | Unique identifier for a flight (e.g., Flight 1490). |
| Departure DateTime | Scheduled departure time. |
| Arrival DateTime   | Scheduled arrival time. |
| Duration           | Flight duration (e.g., 1h 15m). |
| Distance           | Flight distance (e.g., 236 miles). |
| Airline            | Operator of the flight (e.g., Alaska Airlines). |

🚀 Effect:  
✔ Stores detailed flight attributes, ensuring structured tracking.


📌 Airport Entity
| Attribute  | Description |
|------------|----------------|
| IATA Code  | Three-letter airport code (e.g., LAX for Los Angeles Intl Airport). |
| Name       | Full airport name (e.g., Los Angeles Intl Airport). |
| City       | City where the airport is located. |
| State      | State where the airport is located. |

🚀 Effect:  
✔ Ensures airport standardization, avoiding duplication.


📌 Booking Entity
| Attribute           | Description |
|---------------------|----------------|
| Ticket Number       | Unique identifier per booking (e.g., 0177200658). |
| Price               | Amount paid by the passenger (e.g., $357.60). |
| Flight Class        | Cabin class (Economy, Business, First Class). |
| Confirmation Number | Airline-issued booking confirmation (e.g., TAEGKX). |

🚀 Effect:  
✔ Links passengers to flights, storing pricing and ticket details.





📌 3. Establishing Relationships
✔ Passengers purchase flight tickets, connecting bookings to travelers.  
✔ Flights depart and arrive at specific airports, ensuring accurate tracking.  
✔ Bookings are linked to both passengers and flights, maintaining structured reservations.

📌 Defining Relationships
| Entity | Relationship | Linked Entity |
|------------|---------------|------------|
| 'Passenger' | Purchases | 'Booking' |
| 'Booking' | Issued for | 'Flight' |
| 'Flight' | Departs/Arrives at | 'Airport' |

🚀 Effect:  
✔ Structured mapping enables efficient query execution.





📌 4. Key Takeaways
✔ Conceptual models define entities before transitioning to logical models.  
✔ Ensuring structured relationships prevents redundant attributes.  
✔ Airline, airport, and flight details must be stored independently for scalability.  
✔ Following a conceptual model makes database development systematic.  

🚀 Next steps: Refining this conceptual model into a logical model with normalized tables.



📌 Summary
✔ Flight booking systems require structured conceptual modeling.  
✔ Passengers, flights, bookings, and airports define essential entities.  
✔ Relationships ensure proper data structuring and avoid redundancy.  
✔ Conceptual modeling is the foundation for transitioning into logical database design.












Solution - Logical Model:
-------------------------
🚀 Logical Model for a Flight Booking System
A logical model refines the conceptual model by specifying relationships, data types, and entity attributes, preparing for physical database implementation.



📌 1. Refining Relationships
✔ Step 1: Adjust relationships for correct one-to-many structures.  
✔ Step 2: Ensure entities reflect logical associations.

📌 Updated Relationships
| Entity      | Relationship Type | Linked Entity |
|-------------|-------------------|------------|
| 'Passenger' | One-to-Many       | 'Ticket' |
| 'Ticket'    | One-to-Many       | 'Flight' |
| 'Flight'    | One-to-Many       | 'Airline' |
| 'Flight'    | Many-to-Many      | 'Airport' |
| 'Ticket'    | One-to-Many       | 'Flight Class' |

🚀 Effect:  
✔ Ensures passengers book multiple tickets while flights manage multiple passengers.



📌 2. Refining Attributes and Data Types
✔ Step 1: Assign correct data types for attributes.  
✔ Step 2: Enhance naming conventions for clarity.

📌 Entity Attributes
| Entity      | Attributes                               | Data Type |
|-------------|------------------------------------------|------------|
| Passenger   | 'first_name', 'last_name'                | 'VARCHAR(50)' |
| Ticket      | 'ticket_number'                          | 'VARCHAR(20)' |
| Booking     | 'confirmation_number'                    | 'VARCHAR(10)' |
| Flight      | 'flight_number'                          | 'VARCHAR(10)' |
| Flight      | 'departure_datetime', 'arrival_datetime' | 'DATETIME' |
| Flight      | 'duration_minutes'                       | 'INT' |
| Flight      | 'distance_miles'                         | 'INT' |
| Airline     | 'name'                                   | 'VARCHAR(100)' |
| Airport     | 'iata_code', 'name', 'city', 'state' | 'VARCHAR' |

🚀 Effect:  
✔ Proper data types enhance query efficiency and ensure structured data.





📌 3. Handling Normalization vs. Denormalization
✔ Step 1: Prevent excessive joins by denormalizing airport attributes.  
✔ Step 2: Ensure maintainability without unnecessary fragmentation.

📌 Why Denormalize?
✔ Joining multiple tables for airport lookups slows queries.  
✔ Few airports exist globally, so minor duplication isn't an issue.  
✔ Keeping 'city' and 'state' in 'airports' improves performance.

🚀 Effect:  
✔ Optimizes airport lookups without impacting database scalability.




📌 4. Adjusting Many-to-Many Relationships
✔ Step 1: Recognize relational database constraints—only one-to-one or one-to-many exist.  
✔ Step 2: Convert many-to-many (Flight & Airport) into two one-to-many relationships.

📌 Updated Flight-Airport Relationship
✔ Each flight involves exactly two airports (departure & arrival).  
✔ Using a link table allows unnecessary associations with multiple airports.

📌 Solution: Use Attributes Instead of a Link Table
ALTER TABLE flights ADD COLUMN departure_airport_id INT NOT NULL;
ALTER TABLE flights ADD COLUMN arrival_airport_id INT NOT NULL;

🚀 Effect:  
✔ Maintains correct logic—each flight has exactly two airports.




📌 5. Key Takeaways
✔ Logical models refine conceptual designs, ensuring optimized relationships.  
✔ Denormalization improves query performance when dealing with limited datasets.  
✔ Handling relational constraints requires breaking many-to-many relationships properly.  
✔ Each solution has trade-offs—database designs evolve based on business needs.  

🚀 Next steps: Building the physical model for actual implementation.




📌 Summary
✔ Logical models define structured table relationships, enhancing query efficiency.  
✔ Adjusting relationships ensures scalability while preventing redundant data storage.  
✔ Denormalization balances performance when excessive joins impact lookup speed.  
✔ Following correct relational structures ensures clarity and maintainability.











Project - Video Rental Application:
-----------------------------------
All right now let's work on a second project. Download the PDF I've attached below this video. In this PDF you can see the requirements for an application called Witley. This application is going to be used at a video rental store. If you have seen any of my other courses like my React course or Node or Ascepant EMC, you're definitely familiar with Witley. In all these courses we focused on building the actual application including the front end and the backend. But in none of these courses we spend time designing the database. So I thought to bring Vila in this course because it's a fantastic exercise for you. And quite honestly, this was a suggestion by one of my good students. Mohammad. He's very dedicated and has taken several of my courses and I believe with such dedication he's got a lot of success ahead of him. So Mohammad, if you're watching this, thank you for making this suggestion and I send you my best wishes. So download the PDF below this video, read the requirements and design a data model for this application. You will see my solution next. 



Vidly - Requirements:
We’re going to build a desktop application called Vidly. This application will be used at a video rental store. We need different levels of permissions for different users.
The store manager should be able to add/update/delete the list of movies. They will be in charge of setting the stock for each movie as well as the daily rental rate. Cashiers should have a read-only view of the list of movies. They should be able to manage the list of customers and the movies they rent. 

At check out, a customer brings one or more movies. The cashier looks up a customer by their phone number. If the customer is a first-time customer, the cashier asks their full name, email and phone number, and then registers them in the system. The cashier then scans the movies the customer has brought to check out and records them in the system. Each movie has a 10 digit barcode printed on the cover.


When the customer returns to the store, they’ll bring the movies they rented. If a movie is lost, the customer should be charged 5 times the daily rental rate of the movie. The cashier should mark the movie as lost and this will reduce the stock. There is no need to keep track of the lost movies. All we need to know is the the number of movies in stock and how much the customer was charged.


For other movies, the customer should be charged based on the number of days and the daily rental rate.

We issue discount coupons from time to time. The customer can bring a coupon when returning the movies.

It is possible that a customer returns the movies they’ve rented in multiple visits.

We need to be able to track the
- top movies
- top customers
- revenue per day, month and year





🚀 Designing a Data Model for Vidly – A Video Rental Application
Vidly is a desktop application for a video rental store, requiring structured customer management, movie rentals, pricing, and reporting. This data model ensures efficient operations and accurate tracking.



📌 1. Key Functional Requirements
✔ User Permissions
   - Store manager: Full access to manage movies (add/update/delete stock, set rental rate).
   - Cashier: Read-only access to movies, full access to customer and rental management.

✔ Customer Registration
   - Look up customers by phone number.
   - First-time customers must provide full name, email, and phone number.

✔ Movie Rentals
   - Each movie has a barcode (10-digit identifier).
   - Customers rent one or more movies at checkout.
   - Return process tracks charges based on rental duration or loss.

✔ Pricing and Lost Movies
   - Rental charge based on number of days rented and daily rental rate.
   - Lost movies incur 5x the daily rental rate.
   - Lost movies reduce stock but don’t need separate tracking.

✔ Discount Coupons
   - Customers can use coupons upon returning movies.

✔ Tracking & Reporting
   - Top movies rented.
   - Top customers based on rentals.
   - Revenue tracking per day, month, and year.




📌 2. Identified Entities
✔ Users → Manages permissions for store managers and cashiers.  
✔ Customers → Stores customer details.  
✔ Movies → Contains movie details (barcode, stock, rental rate).  
✔ Rentals → Tracks transactions when customers rent movies.  
✔ Returns → Stores return details, calculating rental charges.  
✔ Coupons → Stores issued discount coupons.  
✔ Reports → Tracks top movies, top customers, and revenue.

🚀 Effect:  
✔ Ensures structured data relationships, preventing redundant information.





📌 3. Tables and Their Attributes
✔ Step 1: Define tables and attributes.  
✔ Step 2: Establish relationships via foreign keys.

📌 Creating the 'users' Table
'''sql
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    full_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone VARCHAR(15) NOT NULL UNIQUE,
    role ENUM('manager', 'cashier') NOT NULL
);
'''
🚀 Effect:  
✔ Manages user roles, ensuring controlled access permissions.

📌 Creating the 'customers' Table
'''sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    full_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone VARCHAR(15) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Tracks customers efficiently, allowing lookup by phone number.

📌 Creating the 'movies' Table
'''sql
CREATE TABLE movies (
    movie_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    barcode VARCHAR(10) NOT NULL UNIQUE,
    stock INT NOT NULL DEFAULT 0,
    daily_rental_rate DECIMAL(5,2) NOT NULL
);
'''
🚀 Effect:  
✔ Manages available stock and pricing for rentals.

📌 Creating the 'rentals' Table
'''sql
CREATE TABLE rentals (
    rental_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    movie_id INT NOT NULL,
    rental_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expected_return_date DATETIME NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (movie_id) REFERENCES movies(movie_id)
);
'''
🚀 Effect:  
✔ Tracks active rentals, storing expected return dates.

📌 Creating the 'returns' Table
'''sql
CREATE TABLE returns (
    return_id INT PRIMARY KEY AUTO_INCREMENT,
    rental_id INT NOT NULL,
    actual_return_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    late_days INT NOT NULL DEFAULT 0,
    charge DECIMAL(6,2) NOT NULL,
    lost_movie BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (rental_id) REFERENCES rentals(rental_id)
);
'''
🚀 Effect:  
✔ Tracks return process, calculates late charges.

📌 Creating the 'coupons' Table
'''sql
CREATE TABLE coupons (
    coupon_id INT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) NOT NULL UNIQUE,
    discount_percentage DECIMAL(5,2) NOT NULL,
    valid_until DATE NOT NULL
);
'''
🚀 Effect:  
✔ Enables coupon-based discounts on movie rentals.

📌 Creating the 'reports' Table
'''sql
CREATE TABLE reports (
    report_id INT PRIMARY KEY AUTO_INCREMENT,
    report_type ENUM('top_movies', 'top_customers', 'revenue') NOT NULL,
    generated_on DATETIME DEFAULT CURRENT_TIMESTAMP
);
'''
🚀 Effect:  
✔ Stores statistical insights for business tracking.




📌 4. Establishing Relationships
✔ Customers rent multiple movies → Linked via 'rentals'.  
✔ Movies have rental histories → Ensured through 'rentals' and 'returns'.  
✔ Lost movies reduce stock → Updated in the 'returns' process.  
✔ Coupons apply discounts → Referenced during 'returns' processing.  
✔ Reports summarize revenue & rental data → Generated dynamically.

📌 Defining Relationships
| Entity | Relationship | Linked Entity |
|------------|---------------|------------|
| 'Customers' | One-to-Many | 'Rentals' |
| 'Rentals' | One-to-One | 'Returns' |
| 'Movies' | One-to-Many | 'Rentals' |
| 'Returns' | One-to-One | 'Coupons' (optional) |
| 'Reports' | Summarizes | 'Movies', 'Customers', 'Revenue' |

🚀 Effect:  
✔ Ensures scalable management of rentals and revenue tracking.




📌 5. Key Takeaways
✔ Structured relationships ensure accurate rental tracking.  
✔ Coupon discounts are applied during the return process.  
✔ Lost movie charges dynamically affect stock management.  
✔ Data reporting enables business insights into rentals and revenue trends.  

🚀 Next steps: Building the physical model for implementation.




📌 6. Summary
✔ Vidly’s database model efficiently tracks customers, movies, rentals, returns, and reports.  
✔ Establishing foreign key relationships ensures structured data retrieval.  
✔ Normalization optimizes stock management and rental transactions.  
✔ Reports provide insights into business performance and revenue trends.














Solution - Conceptual Model:
----------------------------
🚀 Conceptual Model for Vidly – A Video Rental Application
A conceptual model helps identify core entities and relationships in a video rental system, ensuring clarity before designing a logical database schema.





📌 1. Identified Entities
✔ User → Represents store employees (managers, cashiers).  
✔ Permission → Defines user access levels for managing movies and customers.  
✔ Customer → Stores customer details (name, email, phone).  
✔ Movie → Contains movie details (stock, barcode, rental rate).  
✔ Rental → Tracks customer transactions for renting movies.  
✔ Coupon → Allows discount application to rental transactions.

🚀 Effect:  
✔ Ensures structured relationships between users, movies, customers, and transactions.





📌 2. Establishing Entity Attributes
✔ Step 1: Define entities and their core attributes.  
✔ Step 2: Specify relationships without considering database constraints.

📌 User Entity
| Attribute | Description |
|------------|----------------|
| Username | Login identifier for authentication. |
| Password | Encrypted login credential. |

📌 Permission Entity
| Attribute | Description |
|------------|----------------|
| Description | Defines allowed actions (Add Movie, Update Movie, etc.). |

📌 Customer Entity
| Attribute | Description |
|------------|----------------|
| Name | Full name (first & last name). |
| Email | Unique email for communication. |
| Phone | Used for customer lookup during checkout. |

📌 Movie Entity
| Attribute | Description |
|------------|----------------|
| Barcode | 10-digit unique identifier for movies. |
| Stock | Number of available copies. |
| Daily Rental Rate | Fee charged per rental day. |

📌 Rental Entity
| Attribute | Description |
|------------|----------------|
| Number of Days | Tracks rental duration. |

📌 Coupon Entity
| Attribute | Description |
|------------|----------------|
| Code | Unique discount identifier. |
| Description | Optional text for coupon details. |
| Discount Value | Applied percentage or fixed amount reduction. |

🚀 Effect:  
✔ Defines essential attributes needed for rental processing.





📌 3. Establishing Relationships
✔ Users have assigned permissions → Many-to-Many relationship.  
✔ Customers rent multiple movies → Many-to-Many relationship via 'rental' entity.  
✔ Coupons apply to rental transactions → One-to-Many relationship.

📌 Defined Relationships
| Entity | Relationship | Linked Entity |
|------------|---------------|------------|
| 'User' | Has | 'Permissions' |
| 'Customer' | Rents | 'Movies' |
| 'Rental' | Applies to | 'Coupons' |

🚀 Effect:  
✔ Enforces structured rental tracking and coupon application.





📌 4. Key Takeaways
✔ Conceptual modeling helps visualize core entities and their relationships.  
✔ Structured rental tracking simplifies checkout and return processes.  
✔ Coupon integration ensures discount handling in rental transactions.  
✔ Permissions determine appropriate user access levels.  

🚀 Next steps: Refining the conceptual model into a logical database schema.





📌 Summary
✔ Vidly’s conceptual model organizes rentals, movies, users, and customers efficiently.  
✔ Identifying key relationships simplifies future database implementation.  
✔ Structured attributes ensure seamless rental processing.  
✔ Logical modeling will refine data types and relationships further.
















Solution - Logical Model:
-------------------------

🚀 Logical Model for Vidly – A Video Rental Application
A logical model refines the conceptual model by establishing relationships, data types, and optimized structures for efficient data storage and retrieval.



📌 1. Refining User & Role Management
✔ Step 1: Adjust user permissions for a simpler role-based system.  
✔ Step 2: Establish a one-to-many relationship between 'users' and 'roles'.  

📌 Why Remove the Permission Entity?
✔ Users are categorized into roles (e.g., store manager, cashier).  
✔ Permissions should be inferred from roles rather than managed individually.  
✔ Simplifies database structure while maintaining required access control.

📌 Updated Relationship
| Entity | Relationship Type | Linked Entity |
|------------|---------------|------------|
| 'User' | Belongs to One | 'Role' |
| 'Role' | Has Many | 'Users' |

🚀 Effect:  
✔ Avoids unnecessary permission complexity, ensuring consistent user access control.

📌 Table Structure for Roles
'''sql
CREATE TABLE roles (
    role_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL
);

CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role_id INT NOT NULL,
    FOREIGN KEY (role_id) REFERENCES roles(role_id)
);
'''



📌 2. Customer & Rental Management
✔ Step 1: Define customer attributes for rental tracking.  
✔ Step 2: Establish one-to-many relationship between customers and rentals.

📌 Customer Table
'''sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone VARCHAR(15) NOT NULL UNIQUE
);
'''

📌 Movie Table
'''sql
CREATE TABLE movies (
    movie_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    barcode VARCHAR(10) NOT NULL UNIQUE,
    stock TINYINT NOT NULL DEFAULT 0,
    daily_rental_rate DECIMAL(5,2) NOT NULL
);
'''
🚀 Effect:  
✔ Optimizes storage by using 'TINYINT' for stock instead of 'INT'.  
✔ Maintains efficient movie tracking through barcode identifiers.





📌 3. Rental Transactions
✔ Step 1: Replace rental duration tracking with 'rent_date' & 'return_date'.  
✔ Step 2: Enable structured revenue tracking per day, month, and year.  

📌 Updated Rental Table
'''sql
CREATE TABLE rentals (
    rental_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    movie_id INT NOT NULL,
    rent_date DATE NOT NULL,
    return_date DATE DEFAULT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (movie_id) REFERENCES movies(movie_id)
);
'''
🚀 Effect:  
✔ Simplifies rental tracking, allowing date-based revenue calculations.



📌 4. Handling Coupons
✔ Step 1: Link rentals to coupons (each rental can have at most one coupon).  
✔ Step 2: Ensure proper discount application.

📌 Coupon Table
'''sql
CREATE TABLE coupons (
    coupon_id INT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) NOT NULL UNIQUE,
    discount_percentage DECIMAL(5,2) NOT NULL,
    expiration_date DATE NOT NULL
);
'''

📌 Adjusting Rental Relationships
| Entity | Relationship Type | Linked Entity |
|------------|---------------|------------|
| 'Rental' | Zero or One | 'Coupon' |

🚀 Effect:  
✔ Avoids unnecessary coupon tracking for rentals without discounts.





📌 5. Establishing Relationships
✔ Rentals are assigned to specific movies → One-to-Many.  
✔ Customers rent multiple movies → One-to-Many.  
✔ Movies belong to specific rentals → One-to-One.  

📌 Updated Relationships
| Entity | Relationship Type | Linked Entity |
|------------|---------------|------------|
| 'Customer' | One-to-Many | 'Rentals' |
| 'Rental' | One-to-One | 'Movies' |
| 'Rental' | Zero or One | 'Coupon' |

🚀 Effect:  
✔ Optimized structured storage ensures efficiency and scalability.



📌 6. Key Takeaways
✔ Replacing fine-grained permissions with role-based access improves maintainability.  
✔ Storing rental durations as 'rent_date' and 'return_date' simplifies calculations.  
✔ Coupons apply discounts directly to rentals instead of creating unnecessary complexity.  
✔ Tables are optimized for efficient querying without excessive normalization.  

🚀 Next steps: Implementing the physical database schema in MySQL.





📌 Summary
✔ Vidly’s logical model ensures structured data tracking with minimal redundancy.  
✔ Proper table relationships prevent inconsistent data entry.  
✔ Replacing permissions with roles simplifies system access control.  
✔ Efficient design enhances query performance while preserving data integrity.  














Creating and Dropping Databases:
--------------------------------
🚀 Creating and Dropping Databases in MySQL
Understanding how to manually create and delete databases using SQL ensures full control over database management, which is essential for database administrators.



📌 1. Why Learn Manual Database Management?
✔ MySQL Workbench wizards simplify database creation, but understanding SQL scripts ensures precision and control.  
✔ Reviewing generated SQL scripts prevents accidental modifications.  
✔ Knowing manual commands allows database creation and management without relying on GUI tools.

🚀 Effect:  
✔ Increases proficiency in MySQL, making manual database management seamless.




📌 2. Creating a Database in MySQL
✔ Use the 'CREATE DATABASE' statement to generate a new database.

📌 Basic Database Creation
'''sql
CREATE DATABASE sql_store2;
'''
🚀 Effect:  
✔ Creates an empty database named 'sql_store2'.

📌 Handling Duplicate Database Errors
✔ If the 'CREATE DATABASE' command is executed twice, an error occurs.  
✔ Use 'IF NOT EXISTS' to prevent duplicate creation errors:
'''sql
CREATE DATABASE IF NOT EXISTS sql_store2;
'''
🚀 Effect:  
✔ Ensures execution without errors, even if the database already exists.



📌 3. Deleting a Database in MySQL
✔ Use the 'DROP DATABASE' statement to remove an existing database.

📌 Basic Database Deletion
'''sql
DROP DATABASE sql_store2;
'''
🚀 Effect:  
✔ Deletes 'sql_store2' completely, including all tables and data.

📌 Preventing Errors When Deleting Non-Existent Databases
✔ Use 'IF EXISTS' to avoid errors if the database does not exist:
'''sql
DROP DATABASE IF EXISTS sql_store2;
'''
🚀 Effect:  
✔ Avoids execution errors, ensuring safe removal.





📌 4. Best Practices for Database Management
✔ Always review SQL scripts before execution to prevent accidental modifications.  
✔ Use 'IF NOT EXISTS' and 'IF EXISTS' to handle errors gracefully.  
✔ Maintain version-controlled SQL scripts for tracking database changes.  
✔ Backup databases before executing 'DROP DATABASE' to avoid irreversible loss.

🚀 Effect:  
✔ Improves database safety and ensures structured management.





📌 5. Key Takeaways
✔ Creating a database with 'CREATE DATABASE' ensures structured management.  
✔ Using 'IF NOT EXISTS' prevents duplication errors during creation.  
✔ Deleting databases with 'DROP DATABASE' removes all associated data.  
✔ Using 'IF EXISTS' avoids unnecessary execution errors.  

🚀 Next steps: Learning table creation ('CREATE TABLE') for structuring data inside databases.




Queries and other notes in this discussion:

CREATE DATABASE sql_store2; 

CREATE DATABASE IF NOT EXISTS sql_store2; 

DROP DATABASE IF EXISTS sql_store2; 





📌 Summary
✔ MySQL supports manual database creation and deletion using SQL commands.  
✔ Using conditional statements ('IF NOT EXISTS' / 'IF EXISTS') prevents errors.  
✔ Proper execution safeguards data integrity and ensures efficient management.  
✔ Understanding these fundamentals prepares for structured database design and administration.















Creating Tables:
----------------
🚀 Creating Tables in MySQL
Creating tables in MySQL requires defining table structures, specifying column data types, and applying constraints to ensure data integrity.



📌 1. Steps to Create a Table
✔ Step 1: Select the target database using 'USE database_name'.  
✔ Step 2: Use 'CREATE TABLE' to define the table structure.  
✔ Step 3: Specify columns, data types, and constraints.  

📌 Basic Table Creation Example
'''sql
USE sql_store2;

CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Creates a structured 'customers' table, ensuring proper constraints.





📌 2. Understanding Column Attributes
✔ Primary Key ('PRIMARY KEY') → Uniquely identifies each row.  
✔ Auto Increment ('AUTO_INCREMENT') → Automatically generates unique values.  
✔ Not Null ('NOT NULL') → Ensures columns cannot store NULL values.  
✔ Default ('DEFAULT') → Assigns default values to columns.  
✔ Unique ('UNIQUE') → Ensures values in a column are distinct.

📌 Applying Constraints
'''sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Prevents duplicate 'email' entries, ensuring accurate customer identification.





📌 3. Handling Table Recreation
✔ Re-running 'CREATE TABLE' without checks causes errors if the table already exists.  
✔ Use 'DROP TABLE IF EXISTS' to remove the table before recreating it.

📌 Dropping an Existing Table Before Recreating
'''sql
DROP TABLE IF EXISTS customers;

CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Removes any existing 'customers' table, ensuring clean table creation.

📌 Alternative Approach: Using 'IF NOT EXISTS'
'''sql
CREATE TABLE IF NOT EXISTS customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Allows repeated execution without errors, creating the table only if it doesn’t already exist.





📌 4. Best Practices for Table Management
✔ Use 'AUTO_INCREMENT' for primary keys when handling unique records.  
✔ Apply constraints ('NOT NULL', 'UNIQUE', 'DEFAULT') to ensure data integrity.  
✔ Use 'IF NOT EXISTS' or 'DROP TABLE IF EXISTS' to prevent execution errors.  
✔ Review database structures before modifying schemas to avoid accidental data loss.

🚀 Effect:  
✔ Ensures smooth table creation and prevents duplicate structures.





📌 5. Key Takeaways
✔ Table creation requires defining columns, data types, and constraints.  
✔ Primary keys should be set for structured identification.  
✔ Using 'IF NOT EXISTS' prevents unnecessary errors.  
✔ Constraints improve data integrity and enforce validation rules.  

🚀 Next steps: Learning how to modify tables ('ALTER TABLE') for schema updates.




Queries and other notes in this discussion: 

CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS customers; 
CREATE TABLE customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);


or 


CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);








📌 Summary
✔ MySQL allows structured table creation using 'CREATE TABLE' commands.  
✔ Applying constraints prevents duplicate entries and ensures valid data storage.  
✔ Using conditional checks ('IF NOT EXISTS', 'DROP TABLE IF EXISTS') prevents errors.  
✔ Proper table management ensures long-term scalability and maintainability.













Altering Tables:
----------------
🚀 Altering Tables in MySQL
The 'ALTER TABLE' statement allows you to modify an existing table structure by adding, removing, or changing columns. This ensures databases remain adaptable to evolving requirements.



📌 1. Why Modify a Table?
✔ Adding missing columns (e.g., 'last_name').  
✔ Changing incorrect data types.  
✔ Setting default values and constraints.  
✔ Removing outdated or unnecessary columns.

🚀 Effect:  
✔ Keeps the database schema up to date without requiring full table recreation.





📌 2. Adding a Column
✔ Use 'ADD COLUMN' to insert new fields into a table.

📌 Example: Adding a 'last_name' Column
'''sql
ALTER TABLE customers 
    ADD last_name VARCHAR(50) NOT NULL AFTER first_name;
'''
🚀 Effect:  
✔ Adds the 'last_name' column right after 'first_name', maintaining logical order.

📌 Handling Spaces in Column Names
✔ Avoid spaces in column names, but if necessary:
'''sql
ALTER TABLE customers 
    ADD 'last name' VARCHAR(50) NOT NULL AFTER 'first name';
'''
🚀 Effect:  
✔ Uses backticks (') to handle spaces, but naming conventions should avoid spaces.





📌 3. Modifying Column Attributes
✔ Use 'MODIFY COLUMN' to update existing column properties.

📌 Example: Changing 'first_name' Data Type and Default Value
'''sql
ALTER TABLE customers 
    MODIFY COLUMN first_name VARCHAR(255) DEFAULT '';
'''
🚀 Effect:  
✔ Expands 'first_name' storage, ensuring a default empty string ('''') for new records.





📌 4. Removing a Column
✔ Use 'DROP COLUMN' to delete an unnecessary attribute.

📌 Example: Removing 'points' Column
'''sql
ALTER TABLE customers 
    DROP COLUMN points;
'''
🚀 Effect:  
✔ Removes the 'points' column completely, making schema cleaner.





📌 5. Executing Multiple Changes in One Statement
✔ Optimize table modification by combining multiple changes.

📌 Example: Adding, Modifying, and Dropping Columns
'''sql
ALTER TABLE customers 
    ADD last_name VARCHAR(50) NOT NULL AFTER first_name, 
    ADD city VARCHAR(50) NOT NULL, 
    MODIFY COLUMN first_name VARCHAR(255) DEFAULT '', 
    DROP COLUMN points;
'''
🚀 Effect:  
✔ Performs all updates efficiently in a single operation.





📌 6. Best Practices for Table Modification
✔ Always test changes in a development or test database before applying them to production.  
✔ Back up your database before executing 'ALTER TABLE' on critical systems.  
✔ Use constraints ('NOT NULL', 'DEFAULT', 'UNIQUE') wisely to maintain data integrity.  
✔ Avoid excessive alterations—plan schema updates strategically.

🚀 Effect:  
✔ Prevents data loss and ensures stability in production environments.





📌 7. Key Takeaways
✔ Use 'ADD COLUMN' to insert new fields.  
✔ Modify attributes using 'MODIFY COLUMN'.  
✔ Remove outdated fields with 'DROP COLUMN'.  
✔ Combine multiple changes in one 'ALTER TABLE' statement for efficiency.  

🚀 Next steps: Learning how to create relationships ('FOREIGN KEY') for structured database linking.




Queries and other notes in this discussion: 

ALTER TABLE customers 
	ADD last_name VARCHAR(50) NOT NULL AFTER first_name, -- if you have space in between 'first name'
	ADD city  VARHCAR(50) NOT NULL, 
	MODIFY COLUMN first_name VARCHAR(255) DEFAULT '', 
	DROP points;







📌 Summary
✔ Altering tables ensures adaptability to new requirements.  
✔ Executing multiple changes in one statement optimizes database management.  
✔ Using constraints prevents inconsistencies in stored data.  
✔ Best practices ensure safe schema updates without impacting production stability.















Creating Relationships:
-----------------------
🚀 Creating Relationships in MySQL
Foreign keys establish relationships between tables, ensuring referential integrity and preventing orphaned records.



📌 1. Steps to Create a Relationship
✔ Step 1: Ensure both tables exist before defining a foreign key.  
✔ Step 2: Use 'FOREIGN KEY' to create a relationship between a child and parent table.  
✔ Step 3: Specify 'ON UPDATE' and 'ON DELETE' rules to control data integrity.  

🚀 Effect:  
✔ Prevents inconsistent data and ensures valid relationships between tables.





📌 2. Creating the 'orders' Table & Establishing a Relationship
✔ Step 1: Drop 'orders' if it already exists.  
✔ Step 2: Create the table with a foreign key referencing 'customers'.  

📌 Table Structure
'''sql
CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;

DROP TABLE IF EXISTS orders;   -- Ensuring deletion of dependent table first
DROP TABLE IF EXISTS customers;

CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY, 
    customer_id INT NOT NULL,
    FOREIGN KEY fk_orders_customers (customer_id)
        REFERENCES customers(customer_id)
        ON UPDATE CASCADE
        ON DELETE NO ACTION
);
'''
🚀 Effect:  
✔ Ensures 'orders.customer_id' references an existing 'customers.customer_id' record.  
✔ Deleting a customer is prevented if orders exist ('NO ACTION').  
✔ Updates on 'customer_id' automatically cascade changes to 'orders' ('CASCADE').





📌 3. Understanding Foreign Key Constraints
✔ 'ON UPDATE CASCADE' → Automatically updates referenced foreign key when primary key changes.  
✔ 'ON DELETE NO ACTION' → Prevents deletion if related records exist in another table.  

📌 Why Use 'CASCADE' on Updates?
✔ Primary keys typically shouldn’t change, but unexpected scenarios may occur.  
✔ Cascading updates prevent orphaned references when a primary key is modified.

🚀 Effect:  
✔ Maintains data consistency without manual updates.

📌 Why Use 'NO ACTION' on Deletion?
✔ Prevents accidental removal of customer records with existing orders.  
✔ Deletion must be handled manually to ensure no loss of financial records.

🚀 Effect:  
✔ Protects critical order history from unintended deletion.





📌 4. Handling Table Deletion in Relationships
✔ MySQL prevents dropping a table if it has dependent foreign keys.  
✔ Drop child tables ('orders') before parent tables ('customers') to avoid errors.

📌 Reordering 'DROP TABLE' Commands
'''sql
DROP TABLE IF EXISTS orders;   -- Delete child table first
DROP TABLE IF EXISTS customers;
'''
🚀 Effect:  
✔ Prevents errors when attempting to remove tables with dependencies.





📌 5. Key Takeaways
✔ Foreign keys enforce relationships, ensuring referential integrity.  
✔ Using 'CASCADE' on updates prevents orphaned records.  
✔ 'NO ACTION' prevents accidental deletion of parent table entries.  
✔ Always drop child tables before parent tables to avoid relationship conflicts.  

🚀 Next steps: Expanding relationships with more foreign key constraints in multi-table joins.







Queries and other notes in this discussion:

CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS customers;
CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders
(
	order_id INT PRIMARY KEY, 
	customer_id INT NOT NULL,
	FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);



CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS orders;   -- Since customers table is having relationship with orders table, we are moving the statement before dropping customers table
DROP TABLE IF EXISTS customers;

CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE orders
(
	order_id INT PRIMARY KEY, 
	customer_id INT NOT NULL,
	FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);










📌 Summary
✔ Establishing relationships ensures structured data integrity and prevents inconsistencies.  
✔ Foreign key constraints enforce proper cascading updates and prevent unnecessary deletions.  
✔ Understanding dependency handling avoids errors when modifying tables.  
✔ Optimizing relationships improves database structure and maintainability.
















Altering Primary and Foreign Key Constraints:
---------------------------------------------
🚀 Altering Primary and Foreign Key Constraints in MySQL
The 'ALTER TABLE' statement allows modifying existing primary and foreign key constraints, ensuring data integrity and structured relationships.



📌 1. Why Modify Primary and Foreign Keys?
✔ To add missing constraints to an existing table.  
✔ To change relationships between tables.  
✔ To drop outdated constraints that no longer fit business logic.  

🚀 Effect:  
✔ Ensures proper referential integrity and prevents orphaned records.



📌 2. Dropping an Existing Foreign Key
✔ Use 'DROP FOREIGN KEY' to remove outdated constraints.  

📌 Example: Removing Foreign Key in the 'orders' Table
'''sql
ALTER TABLE orders 
    DROP FOREIGN KEY fk_orders_customers;
'''
🚀 Effect:  
✔ Removes the foreign key constraint linking 'orders.customer_id' to 'customers.customer_id'.





📌 3. Adding a Foreign Key Constraint
✔ Use 'ADD FOREIGN KEY' to establish relationships after table creation.  

📌 Example: Adding a Foreign Key Constraint
'''sql
ALTER TABLE orders 
    ADD FOREIGN KEY fk_orders_customers (customer_id)
        REFERENCES customers(customer_id)
        ON UPDATE CASCADE
        ON DELETE NO ACTION;
'''
🚀 Effect:  
✔ Enforces referential integrity, ensuring valid customer references.  
✔ Cascade updates allow seamless primary key changes across tables.  
✔ Prevents accidental deletion of a customer record with existing orders.





📌 4. Adding or Dropping Primary Keys
✔ Use 'ADD PRIMARY KEY' to ensure each row has a unique identifier.  
✔ Use 'DROP PRIMARY KEY' to remove an existing primary key constraint.

📌 Example: Adding a Primary Key
'''sql
ALTER TABLE orders 
    ADD PRIMARY KEY (order_id);
'''
🚀 Effect:  
✔ Ensures every order has a unique identifier.

📌 Example: Removing a Primary Key
'''sql
ALTER TABLE orders 
    DROP PRIMARY KEY;
'''
🚀 Effect:  
✔ Removes primary key enforcement on 'order_id', allowing duplicate values.

📌 Handling Composite Primary Keys
✔ Use multiple columns if needed:
'''sql
ALTER TABLE orders 
    ADD PRIMARY KEY (order_id, customer_id);
'''
🚀 Effect:  
✔ Ensures unique combinations of 'order_id' and 'customer_id' per record.





📌 5. Best Practices for Modifying Constraints
✔ Backup the database before altering constraints to prevent data loss.  
✔ Test modifications in a development database before applying changes to production.  
✔ Use cascading updates cautiously to prevent unintended data modifications.  
✔ Ensure primary keys are correctly defined before introducing foreign key constraints.  

🚀 Effect:  
✔ Maintains data consistency while allowing schema evolution.





📌 6. Key Takeaways
✔ Use 'ALTER TABLE' to add or remove primary and foreign keys dynamically.  
✔ 'CASCADE' ensures updates reflect across related tables automatically.  
✔ Using 'NO ACTION' prevents unintended data removal due to foreign key dependencies.  
✔ Structured relationships ensure smooth query execution and efficient database management.  

🚀 Next steps: Exploring more advanced indexing techniques for optimizing query performance.






Queries and other notes in this discussion: 


ALTER TABLE orders
	ADD PRIMARY KEY (order_id), 
	DROP PRIMARY KEY, 
	DROP FOREIGN KEY fk_orders_customers,
	ADD FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);






📌 Summary
✔ MySQL allows modifying primary and foreign keys using 'ALTER TABLE' commands.  
✔ Adding constraints enforces referential integrity and structured data relationships.  
✔ Removing primary or foreign keys should be done carefully to avoid orphaned data.  
✔ Best practices ensure safe schema evolution without affecting existing data workflows.













Character Sets and Collations:
------------------------------
🚀 Understanding Character Sets and Collations in MySQL
Character sets and collations define how text data is stored and sorted in a database. Choosing the right settings ensures proper language support and efficient storage.



📌 1. What Is a Character Set?
✔ A character set maps each character to a numeric representation.  
✔ Different character sets support different languages.  
✔ UTF-8 is the default MySQL character set (from version 5 and higher), supporting all international languages.

📌 Example Command: Viewing Supported Character Sets
'''sql
SHOW CHARSET;
'''
🚀 Effect:  
✔ Displays available character sets and their attributes.

📌 Common Character Sets in MySQL
| Character Set | Language Support | Max Bytes per Character |
|----------------|----------------|----------------|
| 'latin1' | Latin-based languages | 1 |
| 'utf8' | Almost all international languages | 3 |
| 'big5' | Traditional Chinese | 2 |
| 'sjis' | Japanese | 2 |

🚀 Effect:  
✔ Choosing a smaller byte-length character set reduces storage usage when supporting limited languages.





📌 2. Understanding Collations
✔ Collation defines sorting rules for characters.  
✔ Includes case sensitivity settings ('ci' means case-insensitive).  

📌 Example Collations for UTF-8
| Collation | Description |
|--------------|----------------|
| 'utf8_general_ci' | Case insensitive (default) |
| 'utf8_bin' | Case sensitive (binary comparison) |

🚀 Effect:  
✔ For most use cases, stick to 'utf8_general_ci' to sort text case-insensitively.





📌 3. Impact of Character Sets on Storage
✔ Each character requires different storage space based on its character set.  
✔ UTF-8 uses up to 3 bytes per character, whereas Latin1 uses 1 byte.

📌 Example Storage Calculation
✔ If a column is 'CHAR(10)', UTF-8 reserves 30 bytes per record ('10 × 3').  
✔ For 'latin1', the same column would only use 10 bytes ('10 × 1').  

🚀 Effect:  
✔ Choosing a smaller character set saves disk space for databases storing limited languages.





📌 4. Changing Character Sets in MySQL
✔ Character sets can be set at database, table, or column level.

📌 Setting Character Set When Creating a Database
'''sql
CREATE DATABASE db_name 
    CHARACTER SET latin1;
'''

📌 Modifying Character Set for an Existing Database
'''sql
ALTER DATABASE db_name 
    CHARACTER SET latin1;
'''

📌 Setting Character Set When Creating a Table
'''sql
CREATE TABLE table1 (
    column1 VARCHAR(50) 
) CHARACTER SET latin1;
'''

📌 Changing Character Set for an Existing Table
'''sql
ALTER TABLE table1 
    CHARACTER SET latin1;
'''

📌 Setting Character Set for a Specific Column
'''sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT, 
    first_name VARCHAR(50) CHARACTER SET latin1 NOT NULL,
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
);
'''
🚀 Effect:  
✔ Controls data storage and sorting rules at different database levels.





📌 5. Best Practices for Character Sets & Collations
✔ For multilingual applications, use 'utf8_general_ci' as the default collation.  
✔ For databases storing only Latin languages, consider using 'latin1' for space optimization.  
✔ Ensure consistency across database, table, and column level character set settings.  
✔ Avoid unnecessary changes to collations unless specific sorting rules are required.

🚀 Effect:  
✔ Improves query performance and maintains structured text storage.





📌 6. Key Takeaways
✔ Character sets define how MySQL stores text-based data.  
✔ UTF-8 supports almost all languages, while Latin1 is optimized for Latin-based languages.  
✔ Collation determines sorting rules, with 'ci' meaning case-insensitive.  
✔ Using the correct character set reduces unnecessary disk usage.  

🚀 Next steps: Learning how indexing improves search performance across different character sets.






Queries and other notes in this discussion: 

SHOW CHARSET 


CHAR(10) -> 10 x 3 = 30 x 1000000 = 30M



CREATE DATABASE db_name 
	CHARACTER SET latin1;


ALTER DATABASE db_name 
	CHARACTER SET latin1;
	
	
CREATE TABLE table1
(
)
CHARACTER SET latin1;


ALTER TABLE table1
CHARACTER SET latin1; 


CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) CHARACTER SET latin1 NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);







📌 7. Summary
✔ Choosing the right character set ensures proper language storage and retrieval.  
✔ Collations determine sorting behavior and text comparisons.  
✔ Optimizing character set selection improves storage efficiency for large-scale databases.  
✔ Applying best practices ensures consistent text handling across applications.












Storage Engines:
----------------

🚀 MySQL Storage Engines Overview
Storage engines in MySQL define how data is stored, retrieved, and managed, affecting performance and available features.



📌 1. What Are Storage Engines?
✔ Storage engines control how data is handled at the table level.  
✔ Each table can use a different storage engine within the same database.  
✔ Different engines support varying features like transactions and foreign keys.

📌 Viewing Available Storage Engines
'''sql
SHOW ENGINES;
'''
🚀 Effect:  
✔ Lists all storage engines supported by the current MySQL version.





📌 2. Commonly Used Storage Engines
✔ The two most commonly used storage engines are 'MyISAM' and 'InnoDB'.

📌 Comparison of MyISAM vs. InnoDB
| Storage Engine | Key Features | Use Case |
|----------------|------------------|-------------------|
| 'MyISAM' | Fast read performance, but lacks transactions & foreign keys | Deprecated, used in legacy databases |
| 'InnoDB' | Supports transactions, foreign keys, row-level locking | Default engine, best for modern applications |

🚀 Effect:  
✔ InnoDB is the recommended storage engine for modern MySQL databases.





📌 3. Why Upgrade from MyISAM to InnoDB?
✔ InnoDB supports transactions, ensuring data integrity.  
✔ Foreign keys enforce referential integrity, preventing orphaned records.  
✔ MyISAM lacks row-level locking, making it inefficient for concurrent writes.

📌 Changing the Storage Engine for an Existing Table
'''sql
ALTER TABLE customers 
    ENGINE = InnoDB;
'''
🚀 Effect:  
✔ Converts the 'customers' table to use InnoDB, enabling transactions and foreign keys.





📌 4. Considerations When Changing Storage Engines
✔ Converting tables can be an expensive operation, requiring a table rebuild.  
✔ During conversion, tables are locked, making them inaccessible until completion.  
✔ Never change storage engines in production without scheduled maintenance.

🚀 Effect:  
✔ Ensures smooth migration without downtime or data loss.





📌 5. Key Takeaways
✔ Storage engines determine database features and performance.  
✔ InnoDB is the superior choice for modern applications.  
✔ Upgrading from MyISAM allows transaction support and referential integrity.  
✔ Always test storage engine changes in a controlled environment before applying to production.  

🚀 Next steps: Exploring indexing strategies to optimize database performance.





Queries and other notes in this discussion: 

SHOW ENGINES

-- most commonly used storage engines are MyISAM and InnoDB


ALTER TABLE customers
ENGINE = InnoDB 





📌 6. Summary
✔ MySQL supports multiple storage engines with different features.  
✔ InnoDB is the recommended engine for databases requiring foreign keys and transactions.  
✔ Modifying storage engines impacts performance and availability.  
✔ Carefully plan storage engine changes to avoid production disruptions.

















Indexing for High Performance:
------------------------------

In this section we're going to look at indexing for high performance. Indexes are extremely important in large databases and high traffic websites because they can improve the performance of our queries dramatically. In this section you're going to learn all about indexes, how they work, and how we can create them to speed up our queries. This is a very important topic that every developer and database administrator must learn and understand. Now before we get started, I want you to download and execute the script I've attached to this lecture. With this script, we're going to populate our customers table with a thousand new records so we can see the impact of indexes on our queries. Alright, now let's get started.


use sql_store; 
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Ashlin', 'Bickerdyke', '1970-12-09', '79 Holmberg Parkway', 'Saint Louis', 'MO', 1278);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Mordecai', 'Barltrop', '1970-08-06', '59322 Northridge Street', 'Long Beach', 'CA', 838);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Karoline', 'Gookey', '1975-09-15', '180 Walton Pass', 'New York City', 'NY', 24);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Shelba', 'Pedden', '1956-10-28', '50 Troy Drive', 'Minneapolis', 'MN', 1937);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Leighton', 'Beeble', '1982-02-16', '2562 Northview Circle', 'Cleveland', 'OH', 1824);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Almeria', 'Biddlestone', '1985-04-17', '41 Sunfield Junction', 'Los Angeles', 'CA', 790);
.
.
.

and so on 



🚀 Indexing for High Performance in MySQL

Indexes play a crucial role in optimizing query performance, particularly for large databases and high-traffic applications. Understanding indexing ensures efficient data retrieval and improved overall database performance.



📌 1. What Are Indexes?
✔ Indexes store a reference to data, allowing MySQL to retrieve rows faster.  
✔ They significantly speed up 'SELECT' queries, reducing lookup time.  
✔ Indexes are essential for filtering, sorting, and joining operations in large datasets.

🚀 Effect:  
✔ Improves query performance by reducing disk I/O operations.



📌 2. Why Indexing Is Important
✔ Without indexes, MySQL scans the entire table to locate data, which is inefficient for large databases.  
✔ Indexes optimize searching by reducing the number of rows MySQL must process.  
✔ They enhance filtering on frequently used columns (e.g., customer searches by name, phone, email).

📌 Example Query Without Index
'''sql
SELECT * FROM customers WHERE last_name = 'Smith';
'''
🚀 Issue:  
✔ Without an index, MySQL scans every row in the 'customers' table, resulting in slow query execution.

📌 Example Query With Index
'''sql
CREATE INDEX idx_last_name ON customers (last_name);
 
SELECT * FROM customers WHERE last_name = 'Smith';
'''
🚀 Effect:  
✔ MySQL uses the index ('idx_last_name') to find matching rows quickly.





📌 3. Populating the 'customers' Table
✔ Adding a large dataset (1000+ records) to observe indexing impact.  

📌 Executing Bulk Inserts
'''sql
USE sql_store;

INSERT INTO customers (first_name, last_name, birth_date, address, city, state, points) 
VALUES ('Ashlin', 'Bickerdyke', '1970-12-09', '79 Holmberg Parkway', 'Saint Louis', 'MO', 1278),
       ('Mordecai', 'Barltrop', '1970-08-06', '59322 Northridge Street', 'Long Beach', 'CA', 838),
       ('Karoline', 'Gookey', '1975-09-15', '180 Walton Pass', 'New York City', 'NY', 24),
       ('Shelba', 'Pedden', '1956-10-28', '50 Troy Drive', 'Minneapolis', 'MN', 1937),
       ('Leighton', 'Beeble', '1982-02-16', '2562 Northview Circle', 'Cleveland', 'OH', 1824),
       ('Almeria', 'Biddlestone', '1985-04-17', '41 Sunfield Junction', 'Los Angeles', 'CA', 790);
'''
🚀 Effect:  
✔ Fills the 'customers' table with sample data for performance testing.





📌 4. Creating Indexes for Optimization
✔ Step 1: Identify frequently searched columns.  
✔ Step 2: Create indexes for those columns.

📌 Indexing Common Search Fields
'''sql
CREATE INDEX idx_last_name ON customers (last_name);
CREATE INDEX idx_email ON customers (email);
CREATE INDEX idx_city_state ON customers (city, state);
'''
🚀 Effect:  
✔ Speeds up queries filtering by last name, email, city, and state.



📌 Verifying Indexes
'''sql
SHOW INDEXES FROM customers;
'''
🚀 Effect:  
✔ Confirms which indexes exist and their effectiveness.






📌 5. Key Takeaways
✔ Indexes drastically improve query performance, especially for large datasets.  
✔ Choosing the right columns to index prevents slow table scans.  
✔ Bulk data insertion prepares tables for indexing impact analysis.  
✔ Query optimization helps reduce unnecessary computational overhead.  





📌 Summary
✔ Indexing enables fast data retrieval, reducing query execution time.  
✔ Creating indexes on frequently searched columns minimizes table scans.  
✔ Bulk inserts establish test cases for assessing performance improvements.  
✔ Proper indexing strategies optimize scalability for high-traffic applications.

















Indexes: 
--------
🚀 Understanding Indexes in MySQL
Indexes are data structures that optimize query performance by allowing MySQL to find records efficiently without scanning the entire table.



📌 1. What Are Indexes?
✔ Indexes function like a telephone directory, allowing fast data lookup.  
✔ Instead of scanning every row, MySQL uses an index to quickly locate data.  

📌 Example Query Without an Index
'''sql
SELECT * FROM customers WHERE state = 'CA';
'''
🚀 Issue:  
✔ Without an index, MySQL scans all records, slowing queries in large tables.

📌 Example Query With an Index
'''sql
CREATE INDEX idx_state ON customers (state);
SELECT * FROM customers WHERE state = 'CA';
'''
🚀 Effect:  
✔ MySQL quickly finds matching rows using the index, reducing query time.




📌 2. How Indexes Work
✔ Indexes store selected column values along with references to full records.  
✔ This allows MySQL to filter results efficiently instead of scanning the entire table.  

📌 Example Index Structure
| State     | Reference |
|-----------|-------------|
| CA        | Row 1001 |
| CA        | Row 1024 |
| NY        | Row 1503 |

🚀 Effect:  
✔ MySQL retrieves matching rows faster, improving query speed.



📌 3. The Trade-Offs of Indexing
✔ Pros:
   - Speeds up read queries, reducing table scans.  
   - Efficient memory usage—many indexes fit into RAM.  

✔ Cons:
   - Increases database size because indexes must be stored permanently.  
   - Slows write operations (INSERT, UPDATE, DELETE) since indexes must be updated.  

🚀 Effect:  
✔ Indexes improve read efficiency but impact database size and write performance.





📌 4. Best Practices for Using Indexes
✔ Create indexes based on query performance, NOT table design.  
✔ Avoid excessive indexing, which increases storage size and slows writes.  
✔ Use indexes selectively on frequently queried columns.

📌 Creating an Index Based on Queries
'''sql
CREATE INDEX idx_last_name ON customers (last_name);
CREATE INDEX idx_email ON customers (email);
'''
🚀 Effect:  
✔ Speeds up searches on 'last_name' and 'email' columns.

📌 Verifying Existing Indexes
'''sql
SHOW INDEXES FROM customers;
'''
🚀 Effect:  
✔ Displays all indexes present in the 'customers' table.




📌 5. Key Takeaways
✔ Indexes optimize query performance by reducing scan time.  
✔ They come with storage and update costs, requiring careful management.  
✔ Indexes should be created based on query needs, NOT table structure.  
✔ Too many indexes increase database size and impact write performance.  

🚀 Next steps: Learning different types of indexes for specific query optimization.



📌 Summary
✔ Indexes enable fast data retrieval, reducing query execution time.  
✔ Creating indexes on frequently queried columns prevents slow table scans.  
✔ Balancing indexing strategies ensures optimal performance.  
✔ Proper index management improves scalability for high-traffic applications.




















Creating Indexes:
-----------------
🚀 Creating Indexes in MySQL for Faster Queries
Indexes significantly improve query performance by reducing full table scans and allowing MySQL to quickly locate relevant rows.



📌 1. Why Use Indexes?
✔ Without indexes, MySQL scans the entire table, which slows queries for large datasets.  
✔ With indexes, MySQL retrieves data efficiently, improving query execution speed.  

🚀 Effect:  
✔ Speeds up filtering operations and enhances database responsiveness.

📌 Example Query Without an Index
'''sql
SELECT customer_id FROM customers WHERE state = 'CA';
'''
🚀 Issue:  
✔ MySQL scans all records, leading to slow execution for large tables.

📌 Using 'EXPLAIN' to Analyze Query Execution
'''sql
EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA';
'''
🚀 Effect:  
✔ Shows how MySQL processes queries, revealing whether a full table scan occurs.





📌 2. Creating an Index for Faster Searches
✔ Step 1: Identify columns frequently used for filtering ('WHERE' conditions).  
✔ Step 2: Create an index for those columns.

📌 Creating an Index on 'state' Column
'''sql
CREATE INDEX idx_state ON customers (state);
'''
🚀 Effect:  
✔ Optimizes searches for customers located in California ('WHERE state = 'CA'').

📌 Verifying Query Improvement
'''sql
EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA';
'''
🚀 Effect:  
✔ Reduces scanned rows significantly, improving query performance.






📌 3. Understanding 'EXPLAIN' Query Output
✔ Key Columns to Observe in Output:
   - 'type' → Shows if MySQL performs a full scan ('ALL') or uses an index ('RANGE').
   - 'rows' → Indicates the number of scanned records.
   - 'possible_keys' → Displays potential indexes MySQL may use.
   - 'key' → Shows the actual index used in execution.

🚀 Effect:  
✔ Confirms whether indexing has successfully optimized the query.






📌 4. Indexing Another Column: Optimizing Searches on 'points'
✔ Step 1: Query customers with more than 1000 points.  
✔ Step 2: Use 'EXPLAIN' to analyze execution.  
✔ Step 3: Create an index for faster filtering.

📌 Query Before Indexing
'''sql
EXPLAIN SELECT customer_id FROM customers WHERE points > 1000;
'''
🚀 Issue:  
✔ Full table scan ('ALL'), scanning all 1010 records.

📌 Creating an Index on 'points'
'''sql
CREATE INDEX idx_points ON customers (points);
'''
🚀 Effect:  
✔ Improves query speed when searching for high-point customers.

📌 Query After Indexing
'''sql
EXPLAIN SELECT customer_id FROM customers WHERE points > 1000;
'''
🚀 Result:  
✔ Type changed to 'RANGE', meaning MySQL scans only 500 records instead of 1010.  



📌 5. Viewing Existing Indexes on a Table
✔ Use 'SHOW INDEXES' to list all indexes available in a table.

📌 Checking Indexes
'''sql
SHOW INDEXES FROM customers;
'''
🚀 Effect:  
✔ Displays existing indexes, helping optimize database performance.



📌 6. Key Takeaways
✔ Indexes speed up queries by reducing scanned records.  
✔ Always create indexes based on query needs, not table design.  
✔ Use 'EXPLAIN' to analyze query execution before and after indexing.  
✔ Monitor indexes regularly using 'SHOW INDEXES' to maintain database efficiency.  



Queries and other notes in this discussion:

SELECT customer_id FROM customers WHERE state = 'CA';
EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA';


CREATE INDEX idx_state ON customers (state);


Exercise: 

-- Write a query to find customers with more than 1000 points 

EXPLAIN SELECT customer_id FROM customers WHERE points > 1000;

CREATE INDEX idx_points ON customers (points);




📌 Summary
✔ Creating indexes optimizes MySQL query execution, reducing scan time.  
✔ Using 'EXPLAIN' helps analyze the effectiveness of indexes.  
✔ Indexing frequently searched columns prevents performance bottlenecks.  
✔ Efficient index management ensures long-term database scalability.














Viewing Indexes:
----------------
🚀 Viewing Indexes in MySQL
Indexes play a crucial role in optimizing query performance, helping MySQL quickly locate records without scanning the entire table. Understanding how to view and analyze indexes ensures efficient database management.



📌 1. Viewing Indexes in a Table
✔ Use 'SHOW INDEXES' to list all indexes associated with a table.  
✔ Indexes include primary keys (clustered indexes) and additional secondary indexes.

📌 Example: Viewing Indexes in the 'customers' Table
'''sql
SHOW INDEXES IN customers;
'''
🚀 Effect:  
✔ Displays all indexes present in the 'customers' table, showing key attributes.





📌 2. Understanding Index Attributes
✔ 'Primary Key' → Automatically indexed (Clustered Index).  
✔ 'Secondary Index' → Created manually or automatically on foreign key columns.  
✔ 'Collation' → Defines sorting order ('A' for ascending, 'B' for descending).  
✔ 'Cardinality' → Estimated number of unique values in the index.

📌 Example Output Breakdown
| Index Name   | Column Name   | Type    | Cardinality |
|--------------|---------------|---------|---------------|
| 'PRIMARY'    | 'customer_id' | 'BTREE' | '1010' |
| 'idx_state'  | 'state'       | 'BTREE' | '50' |
| 'idx_points' | 'points'      | 'BTREE' | '500' |

🚀 Effect:  
✔ Shows indexed columns, their sorting order, and estimated uniqueness levels.





📌 3. Improving Cardinality Accuracy
✔ Cardinality estimates may become outdated due to database updates.  
✔ Use 'ANALYZE TABLE' to refresh index statistics.

📌 Regenerating Index Statistics
'''sql
ANALYZE TABLE customers;
'''
🚀 Effect:  
✔ Ensures accurate cardinality values for optimized query execution.





📌 4. Viewing Indexes in Related Tables
✔ Foreign key constraints automatically create secondary indexes.  

📌 Example: Viewing Indexes in the 'orders' Table
'''sql
SHOW INDEXES IN orders;
'''
🚀 Effect:  
✔ Reveals primary and foreign key indexes used for table relationships.

📌 Typical Indexes in a Foreign Key Table
| Index Name            | Column Name   | Type    |
|-----------------------|---------------|---------|
| 'PRIMARY'             | 'order_id'    | 'BTREE' |
| 'fk_orders_customers' | 'customer_id' | 'BTREE' |

🚀 Effect:  
✔ Ensures relational integrity by speeding up joins and lookups.



📌 5. Viewing Indexes in MySQL Workbench
✔ Indexes can be viewed in the Navigator Panel under the table structure.  
✔ Clicking an index reveals details like sorting type, uniqueness, and visibility.

📌 Navigator Panel Index Attributes
✔ Index Type ('BTREE', 'HASH').  
✔ Uniqueness ('Yes/No').  
✔ Column Placement (e.g., 'state', 'customer_id').  

🚀 Effect:  
✔ Provides a visual overview of indexed columns for easy management.





📌 6. Key Takeaways
✔ Use 'SHOW INDEXES' to check table indexing.  
✔ Primary keys automatically generate clustered indexes.  
✔ Foreign keys create secondary indexes for fast joins.  
✔ Refreshing index statistics with 'ANALYZE TABLE' ensures accurate query performance.  



Queries and other notes in this discussion:

SHOW INDEXES IN customers; 

Clustered Index -- having primary key as index 
Secondary Indexes 


ANALYZE TABLE customers; 




📌 Summary
✔ Viewing indexes helps optimize MySQL query execution and maintain database efficiency.  
✔ Understanding primary and secondary indexes ensures structured data retrieval.  
✔ Refreshing index statistics prevents outdated performance estimates.  
✔ Using MySQL Workbench provides additional insights into indexing structures.




Extra Notes:
------------
Explain clustered and non clustered indexes in sql:

Indexes in SQL help speed up data retrieval by organizing the way information is stored and accessed in a database. There are two main types: clustered and non-clustered indexes, each serving different purposes.

1. Clustered Index
- Determines the physical order of data in the table.
- There can be only one clustered index per table because the rows are physically sorted based on it.
- Improves retrieval speed for queries that require sorting or range-based searches.
- When you create a Primary Key, SQL automatically makes it a clustered index (unless specified otherwise).

Example:
'''sql
CREATE CLUSTERED INDEX idx_customer_id
ON Customers (CustomerID);
'''
This arranges rows in Customers table in order of CustomerID.



2. Non-Clustered Index
- Does not affect the physical order of data.
- Works like a pointer—stores index separately while keeping a reference to actual table rows.
- Multiple non-clustered indexes can exist on a table (unlike clustered indexes).
- Useful for faster lookups on specific columns without altering row order.

Example:
'''sql
CREATE NONCLUSTERED INDEX idx_lastname
ON Customers (LastName);
'''
This helps quickly search for customers by LastName without affecting the actual row arrangement.

Key Differences
| Feature              | Clustered Index                           | Non-Clustered Index                      |
|----------------------|-------------------------------------------|--------------------------------------|
| Storage Order        | Physically sorts data                     | Stores index separately          |
| Number Allowed       | Only one per table                        | Multiple indexes allowed        |
| Performance          | Faster for range queries, sorting         | Faster for lookups on specific columns |
| Example Use Case     | Sorting by 'OrderDate' in Orders          | Searching by 'EmailID' in Users  |

Since you're exploring SQL, clustered indexes might help with optimizing queries involving sorting or filtering large datasets, while non-clustered indexes can speed up specific lookups.







Can you give practical examples of using these indexes?

Absolutely! Let’s explore practical use cases for clustered and non-clustered indexes with real-world SQL queries.  

📌 Clustered Index Example – Efficient Ordering & Range Queries  
Imagine an Orders table storing customer purchases:  

'''sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATETIME,
    TotalAmount DECIMAL(10,2)
);
'''
Since OrderID is the Primary Key, SQL automatically creates a clustered index on it.  

# ✅ Use Case: Sorting & Fast Retrieval  
Now, if you want to quickly fetch recent orders (sorted by date), the clustered index speeds up this query:  

'''sql
SELECT * FROM Orders  
WHERE OrderDate BETWEEN '2025-06-01' AND '2025-06-10'  
ORDER BY OrderDate;
'''
Since the clustered index keeps rows physically ordered, range queries run faster than scanning unordered data.  





📌 Non-Clustered Index Example – Fast Lookups  
Consider a Customers table where users frequently search by EmailID, but the table is ordered by CustomerID (clustered index).  

'''sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY, -- Clustered Index
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    EmailID VARCHAR(100),
    PhoneNumber VARCHAR(15)
);
'''

Since 'CustomerID' is the clustered index, searching by EmailID without an index would require scanning all rows.

# ✅ Use Case: Faster Search by Email  
Creating a non-clustered index on 'EmailID' significantly speeds up lookups:  

'''sql
CREATE NONCLUSTERED INDEX idx_email  
ON Customers (EmailID);
'''

Now, searching for a specific email runs much faster:  

'''sql
SELECT * FROM Customers  
WHERE EmailID = 'sharath@example.com';
'''

Since the non-clustered index stores a separate lookup table, SQL finds the row quicker instead of scanning every record.



🔎 Summary: When to Use Each?  
- Use clustered indexes when sorting or filtering by Primary Key or Date (e.g., 'OrderDate', 'CustomerID').  
- Use non-clustered indexes when searching specific fields like 'EmailID', 'PhoneNumber', or 'ProductName'.  
- Having both on a table improves efficiency – clustered indexes for ordering, and non-clustered indexes for searching frequently used fields.




Indexing Strategies:
Indexes speed up lookups but may slow down inserts/updates. Some common strategies:
- Clustered Index: Stores data in order based on the index; one per table.
- Non-clustered Index: Maintains a separate structure to improve lookup speed.
- Covering Index: Includes all the columns required by a query, eliminating the need to access the main table.
- Partial Indexes: Indexes a subset of rows based on conditions to optimize specific queries.
- Composite Index: Indexes multiple columns together for queries that filter by multiple criteria.

Indexes play a crucial role in optimizing database performance, but each type has unique trade-offs. Let’s dive deeper into these and explore when they’re most useful.



Clustered Index
- Definition: Organizes the table rows physically in sorted order based on the indexed column.
- Characteristics:
  - Only one clustered index per table.
  - Makes range queries and sorting much faster since data is physically ordered.
  - Primary Keys automatically become clustered indexes unless specified otherwise.
- Example Use Case:  
  Suppose we have an 'Orders' table, and we want fast retrieval based on 'OrderDate'.

'''sql
CREATE CLUSTERED INDEX idx_orderdate  
ON Orders (OrderDate);
'''
Now, queries filtering by 'OrderDate' will be efficient.




Non-Clustered Index
- Definition: Maintains a separate lookup structure that refers to actual table rows, without changing the table’s physical order.
- Characteristics:
  - Multiple non-clustered indexes can exist on a table.
  - Useful for frequently queried columns where sorting is not needed.
- Example Use Case:  
Searching customers by EmailID in a table with a clustered index on 'CustomerID'.

'''sql
CREATE NONCLUSTERED INDEX idx_email  
ON Customers (EmailID);
'''
This makes searches faster without affecting the physical row order.




Covering Index
- Definition: Includes all columns needed for a query, eliminating extra table lookups.
- Characteristics:
  - Helps avoid additional disk I/O since all data is in the index.
  - Speeds up 'SELECT' queries that fetch multiple columns frequently.
- Example Use Case:  
Fetching CustomerName and PhoneNumber without scanning the table.

'''sql
CREATE NONCLUSTERED INDEX idx_covering  
ON Customers (CustomerID, FirstName, LastName, PhoneNumber) INCLUDE (EmailID);
'''
Now, queries requesting these columns run entirely within the index, avoiding table access.



Partial Index
- Definition: Indexes only a subset of table rows based on conditions.
- Characteristics:
  - Saves space and improves performance when indexing only relevant data.
  - Best for queries targeting specific ranges or frequently queried values.
- Example Use Case:  
Indexing only active customers instead of all users.

'''sql
CREATE INDEX idx_active_customers  
ON Customers (CustomerID)  
WHERE IsActive = 1;
'''
This optimizes queries for retrieving active customers without indexing unnecessary rows.





Composite Index
- Definition: Indexes multiple columns together, optimizing queries filtering by multiple conditions.
- Characteristics:
  - Helps when queries involve sorting, filtering, and joining by multiple columns.
  - Works best when queries use all indexed columns in the 'WHERE' clause.
- Example Use Case:  
Optimizing searches for Orders by CustomerID and OrderDate.

'''sql
CREATE INDEX idx_customer_order  
ON Orders (CustomerID, OrderDate);
'''
This significantly speeds up queries filtering by both 'CustomerID' and 'OrderDate'.



🛠 Choosing the Right Index
- Use Clustered Index for sorting and range queries (e.g., 'OrderDate').
- Use Non-Clustered Index for quick lookups (e.g., 'EmailID').
- Use Covering Index for queries accessing multiple columns frequently.
- Use Partial Index for specific subsets of data (e.g., active users).
- Use Composite Index for queries filtering by multiple columns.

Indexes accelerate reads but can slow inserts and updates, so careful planning is key.






What scenarios are best for each index type?

Each type of index shines in different scenarios based on how data is accessed. Here's a breakdown of when each index type is most effective:

Clustered Index – Best for Sorting & Range Queries  
Use Case:  
- When queries frequently sort or retrieve a range of values.  
- When indexing a Primary Key, as it naturally optimizes lookups.  
- Example: Retrieving recent transactions efficiently:  
  '''sql
  SELECT * FROM Orders WHERE OrderDate BETWEEN '2025-06-01' AND '2025-06-10' ORDER BY OrderDate;
  '''
Since data is physically sorted, range-based queries execute much faster.  



Non-Clustered Index – Best for Fast Lookups  
Use Case:  
- When searching for specific values frequently.  
- When indexing non-Primary Key columns used in WHERE clauses.  
- Example: Searching users by EmailID efficiently:  
  '''sql
  SELECT * FROM Customers WHERE EmailID = 'sharath@example.com';
  '''
Since EmailID isn’t the Primary Key, a non-clustered index boosts performance.  



Covering Index – Best for Reducing Table Scans  
Use Case:  
- When queries frequently access multiple columns together.  
- When avoiding extra disk reads for better efficiency.  
- Example: Retrieving customer details without scanning the full table:  
  '''sql
  CREATE INDEX idx_covering  
  ON Customers (CustomerID, FirstName, LastName) INCLUDE (EmailID, PhoneNumber);
  '''
The query reads directly from the index instead of the main table, improving performance.  



Partial Index – Best for Filtering Specific Data  
Use Case:  
- When indexing only relevant rows, reducing unnecessary storage.  
- Best for queries targeting filtered conditions.  
- Example: Indexing only active customers instead of all users:  
  '''sql
  CREATE INDEX idx_active_customers ON Customers (CustomerID) WHERE IsActive = 1;
  '''
This ensures queries retrieving active users run faster without indexing inactive ones.  



Composite Index – Best for Multi-Column Queries  
Use Case:  
- When queries filter multiple columns together.  
- When optimizing joins and filtering based on combined keys.  
- Example: Fast retrieval of Orders by CustomerID and OrderDate:  
  '''sql
  CREATE INDEX idx_customer_order ON Orders (CustomerID, OrderDate);
  '''
This speeds up queries filtering by both CustomerID & OrderDate, reducing scans.  



🚀 Choosing the Right Index
- Use Clustered when sorting or filtering large datasets.  
- Use Non-Clustered for search-heavy columns like EmailID or PhoneNumber.  
- Use Covering when queries need multiple fields frequently.  
- Use Partial to index specific subsets, like active users.  
- Use Composite when filtering by multiple related fields.  

Indexes speed up searches but increase storage & maintenance costs—so using them strategically is key. 














Prefix Indexes:
---------------
🚀 Optimizing String Indexing with Prefix Indexes in MySQL
Prefix indexes help reduce storage space while maintaining fast query performance when indexing string columns ('CHAR', 'VARCHAR', 'TEXT', 'BLOB'). By limiting the indexed portion to the first few characters, databases can increase efficiency without sacrificing search accuracy.



📌 1. Why Use Prefix Indexes?
✔ String columns consume large disk space when fully indexed.  
✔ Smaller indexes fit in memory, making searches faster.  
✔ Using a prefix index ensures fast lookups while keeping storage overhead low.

📌 Example: Creating an Index on 'last_name'
'''sql
CREATE INDEX idx_lastname ON customers (last_name(20));
'''
🚀 Effect:  
✔ Indexes only the first 20 characters of 'last_name', reducing disk usage.



📌 2. Finding the Optimal Prefix Length
✔ Choosing an index size requires analyzing data distribution.  
✔ The goal is to balance storage efficiency and query accuracy.  
✔ Short prefixes result in too many duplicate values, reducing indexing effectiveness.

📌 Checking Total Records in the Table
'''sql
SELECT COUNT(*) FROM customers;
'''
🚀 Effect:  
✔ Shows the total number of records in the table (e.g., '1010').

📌 Checking Unique Values for Different Prefix Lengths
'''sql
SELECT 
    COUNT(DISTINCT LEFT(last_name, 1)) AS unique_1,
    COUNT(DISTINCT LEFT(last_name, 5)) AS unique_5,
    COUNT(DISTINCT LEFT(last_name, 10)) AS unique_10
FROM customers;
'''
🚀 Effect:  
✔ Analyzes different prefix lengths to determine uniqueness.  
✔ Example Result:
   - 1-character prefix → Only '25' unique values (inefficient index).  
   - 5-character prefix → '966' unique values (high uniqueness, optimal index).  
   - 10-character prefix → '996' unique values (minimal improvement over 5-character index).  

📌 Choosing the Optimal Prefix Length
✔ A prefix length of '5' uniquely identifies most last names in the dataset.  
✔ Indexing '5' characters instead of '10' saves storage while maintaining performance.

🚀 Effect:  
✔ Efficient indexing without unnecessary space consumption.




📌 3. Creating the Optimal Prefix Index
✔ Use the best prefix length based on the uniqueness analysis.

📌 Final Index Creation
'''sql
CREATE INDEX idx_lastname ON customers (last_name(5));
'''
🚀 Effect:  
✔ Ensures fast queries while keeping the index lightweight.



📌 4. Key Takeaways
✔ Indexing the full column on large string fields wastes storage.  
✔ Prefix indexing improves efficiency without sacrificing search quality.  
✔ Analyzing unique values helps find the optimal prefix length.  
✔ Creating indexes based on query needs ensures the best performance.  

🚀 Next steps: Exploring full-text indexes for advanced text-based searches.




Queries and other notes in this discussion: 

CREATE INDEX idx_lastname ON customers (last_name(20));


To find the optimal prefix length:

SELECT COUNT(*) FROM customers; 

SELECT COUNT(DISTINCT LEFT(last_name, 1)) FROM customers; 



SELECT 
	COUNT(DISTINCT LEFT(last_name, 1)) 
	COUNT(DISTINCT LEFT(last_name, 5))
	COUNT(DISTINCT LEFT(last_name, 10)) 
FROM customers;
	



📌 Summary
✔ Prefix indexes reduce index size while maintaining fast query lookups.  
✔ Analyzing data distribution helps determine the ideal prefix length.  
✔ Choosing an optimal index length prevents excessive storage overhead.  
✔ Efficient indexing strategies improve database scalability for high-traffic applications.



	
	
	
	
	
	
	
	
	
	


Full-text Indexes:
------------------	


🚀 Full-Text Indexes in MySQL for Powerful Search Functionality
Full-text indexes enable fast and flexible text search capabilities, making them essential for implementing search engines in applications. Unlike standard indexes, full-text indexes analyze words and their relevance, improving search efficiency.



📌 1. What Is a Full-Text Index?
✔ Full-text indexes store words instead of exact values, allowing advanced search capabilities.  
✔ They optimize keyword searches by supporting relevance ranking, ignoring stop words, and allowing phrase-based queries.  
✔ Ideal for searching blog posts, product descriptions, news articles, and large text-based data.

🚀 Effect:  
✔ Enables Google-like search functionality within MySQL databases.




📌 2. Issues with Standard Text Search ('LIKE')
✔ Traditional text search using 'LIKE' is inefficient:
   - Requires scanning the entire table, making queries slow on large datasets.  
   - Matches exact phrases only, failing to find similar results.  
   - Does not support ranking results based on relevance.  

📌 Example Query Using 'LIKE'
'''sql
USE sql_blog;
SELECT * FROM posts 
WHERE title LIKE '%react redux%' 
   OR body LIKE '%react redux%';
'''
🚀 Issue:  
✔ Returns only exact matches, ignoring posts that contain related words separately.





📌 3. Creating a Full-Text Index
✔ Step 1: Create a new full-text index on searchable columns ('title' and 'body').  
✔ Step 2: Use 'MATCH()' and 'AGAINST()' for efficient searches.

📌 Creating Full-Text Index
'''sql
CREATE FULLTEXT INDEX idx_title_body ON posts (title, body);
'''
🚀 Effect:  
✔ Allows MySQL to store words in a structured index, improving search queries.

📌 Querying Using Full-Text Index
'''sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('react redux');
'''
🚀 Effect:  
✔ Returns posts that contain either 'react' or 'redux' in any order.  
✔ Finds documents where words are not necessarily adjacent.




📌 4. Enhancing Search with Relevance Ranking
✔ Full-text searches rank results based on word frequency and significance.  
✔ The relevance score helps sort results by importance.

📌 Retrieving Results with Relevance Score
'''sql
SELECT *, MATCH(title, body) AGAINST('react redux') AS relevance_score
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');
'''
🚀 Effect:  
✔ Displays results sorted by their relevance score (between '0' and '1').

📌 Example Output
| Post Title                 | Relevance Score |
|----------------------------|-----------------|
| 'Redux Vs. Mobx'           | '0.9'           |
| 'Handling a Form in React' | '0.1'           |

🚀 Effect:  
✔ Posts directly related to Redux score higher than loosely related ones.





📌 5. Using Boolean Mode for Advanced Search
✔ Boolean mode allows filtering results using special operators ('+', '-', '" "').

📌 Excluding Words from Search ('-')
'''sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('react -redux' IN BOOLEAN MODE);
'''
🚀 Effect:  
✔ Finds posts about 'react', excluding those mentioning 'redux'.

📌 Requiring Specific Keywords ('+')
'''sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('react -redux +form' IN BOOLEAN MODE);
'''
🚀 Effect:  
✔ Filters posts that must contain 'form', while ignoring those with 'redux'.

📌 Searching Exact Phrases ('""')
'''sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('"handling a form"' IN BOOLEAN MODE);
'''
🚀 Effect:  
✔ Finds posts containing the exact phrase 'handling a form'.



📌 6. Key Takeaways
✔ Full-text indexes enable fast, flexible searches, ideal for blogs and product descriptions.  
✔ Using 'MATCH()' and 'AGAINST()' improves performance over standard 'LIKE' queries.  
✔ Boolean mode supports advanced filtering, exclusions, and exact phrase searching.  
✔ Relevance scoring ensures accurate ranking of search results.  





Queries and other notes in this discussion: 


create-db-blog.sql:

DROP DATABASE IF EXISTS sql_blog;
CREATE DATABASE sql_blog;

USE sql_blog;

CREATE TABLE 'posts'
(
  'post_id' int
(11) NOT NULL AUTO_INCREMENT,
  'title' varchar
(255) NOT NULL,
  'body' text NOT NULL,
  'date_published' datetime DEFAULT NULL,
  PRIMARY KEY
('post_id')
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;


INSERT INTO posts
  (title, body, date_published)
VALUES
  ('Handling a Form in React', 'Web applications often need to send data from browser to the backend server. Certainly, the most used way of doing so is through a HTML form, by using text inputs, radio buttons, checkboxes, selects and so on. This remains true in React. Are you looking how to handle forms in React? If so, this article is a great fit for you. Have a good read.', '2019-01-01'),
  ('What JavaScript Framework You Should Learn to Get a Job in 2019?', 'Are you wondering what JavaScript framework or library you should use to land a job in 2019? In this post, I am going to go over a comparison of the most popular JavaScript frameworks that are available today. By the end of this post, you will be ready to pick the right framework to help you land a front-end developer job in 2019.', '2019-03-02'),
  ('Building an Accessible React Modal Component', 'Modal is an overlay on the web-page, but has some standards to follow. WAI-ARIA Authoring Practices are the standards set by W3C. This lets bots and screen-readers know that it is a modal. It is not within the regular flow of the page. We’ll create an awesome react modal using React components.', '2019-01-15'),
  ('Redux Vs. Mobx – What Should I Pick For My Web App?', 'State management is a hard problem to solve in large applications. Redux and Mobx are both external libraries that are popularly used to solve state management problems.', '2019-02-20'),
  ('Stateful and Stateless Components in React', 'Today, we’re going to review what stateful and stateless components are in React, how you can tell the difference, and the complex process of deciding whether to make components stateful or not.', '2019-03-29');





'react redux' -->
USE sql_blog;
SELECT *
FROM posts
WHERE title LIKE '%react redux%' OR
		body LIKE '%react redux%';
		
		
		
CREATE FULLTEXT INDEX idx_title_body ON posts (title, body);


SELECT *
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');


SELECT *, MATCH(title, body) AGAINST('react redux')  -- relevance score  
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux' IN BOOLEAN MODE);


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux +form' IN BOOLEAN MODE);


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('"handling a form"' IN BOOLEAN MODE);







📌 Summary
✔ Full-text indexes transform MySQL into a powerful search engine.  
✔ They outperform traditional 'LIKE' queries in efficiency and flexibility.  
✔ Advanced search techniques like Boolean mode and relevance ranking improve results.  
✔ Using full-text indexing ensures scalable and high-performance text searches.














Composite Indexes: 
------------------
🚀 Composite Indexes in MySQL for Optimized Query Performance
A composite index allows MySQL to index multiple columns, improving search efficiency for queries with multiple filtering conditions. Composite indexes help avoid unnecessary table scans and speed up complex searches.



📌 1. Why Use Composite Indexes?
✔ Single-column indexes only optimize part of a query, requiring table scans for additional filters.  
✔ Composite indexes optimize queries with multiple filtering conditions, reducing read time.  
✔ Efficient indexing ensures MySQL retrieves records without scanning unnecessary rows.

🚀 Effect:  
✔ Speeds up filtering on multiple criteria while minimizing storage overhead.

📌 Example Query Without a Composite Index
'''sql
EXPLAIN SELECT customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;
'''
🚀 Issue:  
✔ MySQL picks a single-column index ('state') but must scan all customers in California manually for 'points > 1000'.  
✔ Scanning 112 rows slows performance when dealing with large datasets.





📌 2. Creating a Composite Index
✔ Step 1: Identify frequently used filtering columns.  
✔ Step 2: Create a composite index on those columns.

📌 Creating a Composite Index on 'state' and 'points'
'''sql
CREATE INDEX idx_state_points ON customers (state, points);
'''
🚀 Effect:  
✔ Optimizes searches for customers located in a given state with specific points criteria.

📌 Verifying Query Improvement
'''sql
EXPLAIN SELECT customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;
'''
🚀 Result:  
✔ Reduces scanned rows from '112' to '58', improving efficiency.  





📌 3. Why Composite Indexes Are Better Than Single-Column Indexes
✔ MySQL picks only one index per query, ignoring other single-column indexes.  
✔ A composite index ensures MySQL optimally searches across multiple conditions instead of performing table scans.  
✔ Single-column indexes waste space when used redundantly, slowing write operations ('INSERT', 'UPDATE', 'DELETE').  

📌 Dropping Inefficient Single-Column Indexes
'''sql
DROP INDEX idx_state ON customers;
DROP INDEX idx_points ON customers;
'''
🚀 Effect:  
✔ Reduces storage usage while optimizing multi-filter queries.



📌 4. Determining the Optimal Number of Columns in a Composite Index
✔ MySQL supports up to '16' columns per composite index (highly excessive in most cases).  
✔ Best practice suggests '4–6 columns' for balanced performance and storage.  
✔ Always test composite indexes on real queries to determine effectiveness.

🚀 Effect:  
✔ Prevents unnecessary indexing while ensuring optimal search speeds.





📌 5. Key Takeaways
✔ Composite indexes optimize multi-condition queries, preventing slow table scans.  
✔ Dropping redundant single-column indexes improves storage efficiency.  
✔ Balancing the number of indexed columns prevents excessive overhead.  
✔ Always test indexes using 'EXPLAIN' to confirm improvements.  





Queries and other notes in this discussion: 


USE sql_store; 

SHOW INDEXES IN customers; 

EXPLAIN select customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;


CREATE INDEX idx_state_points ON customers (state, points);

EXPLAIN select customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;


DROP INDEX idx_state ON customers; 
DROP INDEX idx_points ON customers; 




📌 Summary
✔ Composite indexes outperform single-column indexes in multi-filter searches.  
✔ Using 'EXPLAIN' helps verify index effectiveness and query improvements.  
✔ Choosing an optimal number of indexed columns enhances search speed.  
✔ Efficient indexing strategies prevent performance bottlenecks in large databases.














Order of Columns in Composite Indexes:
--------------------------------------
🚀 Optimizing Column Order in Composite Indexes in MySQL
Composite indexes improve query efficiency, but the order of columns plays a crucial role in optimization. Choosing the right column order ensures faster filtering and minimal table scans.



📌 1. Guidelines for Column Order in Composite Indexes
✔ Frequently used columns should come first.  
✔ Columns with higher cardinality (more unique values) should be prioritized.  
✔ Always test indexes based on query performance rather than general rules.  

🚀 Effect:  
✔ Optimizes query execution by reducing unnecessary scans.




📌 2. Understanding Cardinality in Indexing
✔ Cardinality represents the number of unique values in an indexed column.  
✔ Higher cardinality means better filtering capabilities.  

📌 Checking Cardinality of Columns
'''sql
SELECT 
    COUNT(DISTINCT state) AS state_cardinality,
    COUNT(DISTINCT last_name) AS last_name_cardinality
FROM customers;
'''
🚀 Example Result:
| Column      | Unique Values (Cardinality) |
|-------------|----------------|
| 'state'     | '48' |
| 'last_name' | '996' |

🚀 Effect:  
✔ Although 'last_name' has higher cardinality, query patterns must be considered.





📌 3. Testing Composite Index Order
✔ First, create a composite index with 'last_name' first.

📌 Creating Composite Index ('last_name' → 'state')
'''sql
CREATE INDEX idx_lastname_state ON customers (last_name, state);
'''

📌 Evaluating Performance Using 'EXPLAIN'
'''sql
EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';
'''
🚀 Result:  
✔ MySQL scans '40' rows, filtering by 'last_name' first, then 'state'.

✔ Second, create a composite index with 'state' first.

📌 Creating Composite Index ('state' → 'last_name')
'''sql
CREATE INDEX idx_state_lastname ON customers (state, last_name);
'''

📌 Evaluating Performance Using 'EXPLAIN'
'''sql
EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';
'''
🚀 Result:  
✔ MySQL scans only '7' rows—better optimization.  

🚀 Effect:  
✔ Putting 'state' first reduced scans significantly, proving it is the better index for this query.  





📌 4. Forcing MySQL to Use a Specific Index
✔ Even though MySQL selects the most efficient index, users can force an alternative index.  

📌 Explicitly Selecting an Index
'''sql
EXPLAIN SELECT customer_id 
FROM customers
USE INDEX (idx_lastname_state)
WHERE state = 'NY' AND last_name LIKE 'A%';
'''
🚀 Effect:  
✔ Forces MySQL to use 'idx_lastname_state', even if another index is more optimal.  





📌 5. Handling Queries with Multiple Range Filters
✔ If a query includes a range filter ('LIKE', '<', '>'), column order can impact efficiency.  

📌 Example Query Using Two Range Filters
'''sql
EXPLAIN SELECT customer_id 
FROM customers
WHERE state LIKE 'A%' AND last_name LIKE 'A%';
'''
🚀 Result Comparison:
- Using 'idx_lastname_state' → Scans '40' rows.  
- Using 'idx_state_lastname' → Scans '51' rows.  

🚀 Effect:  
✔ For range-based queries, column order must be tested case-by-case.  
✔ However, range queries are rare in real-world applications, so focus indexing on most common queries.  






📌 6. Dropping Unnecessary Indexes
✔ After testing, drop inefficient indexes to free storage.

📌 Removing the Less Efficient Index
'''sql
DROP INDEX idx_lastname_state ON customers;
'''
🚀 Effect:  
✔ Keeps only the best-performing index for filtering customers efficiently.  





📌 7. Key Takeaways
✔ Column order in composite indexes affects query performance significantly.  
✔ Higher cardinality columns typically come first—but query logic matters more.  
✔ Always use 'EXPLAIN' to test query execution before finalizing an index order.  
✔ Removing redundant indexes prevents storage waste and optimizes MySQL performance.  





Queries and other notes in this discussion: 

order of columns: 
put the most frequently used columns first 
put the columns with a higher cardinality first 
Take your queries into account


cardinality represents the number of unique values in the index.

SELECT 
	COUNT(DISTINCT state),
	COUNT(DISTINCT last_name)
FROM customers; 


CREATE INDEX idx_lastname_state ON customers (last_name, state);

EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';  -- 40 rows scanned


CREATE INDEX idx_state_lastname ON customers (state, last_name);

EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%'; -- 7 rows scanned 


EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'NY' AND last_name LIKE 'A%';


EXPLAIN SELECT customer_id 
FROM customers
USE INDEX (idx_lastname_state)  -- forcing MySQL to use the mentioned index 
WHERE state = 'NY' AND last_name LIKE 'A%';


EXPLAIN SELECT customer_id 
FROM customers
USE INDEX (idx_lasname_state)    -- mysql had to scan 40 records
WHERE state LIKE 'A%' AND last_name LIKE 'A%';


EXPLAIN SELECT customer_id 
FROM customers
USE INDEX (idx_state_lastname)   -- mysql had to scan 51 records 
WHERE state LIKE 'A%' AND last_name LIKE 'A%';



DROP INDEX idx_lastname_state ON customers;







📌 Summary
✔ Composite index order should be based on query logic, NOT just cardinality.  
✔ Query analysis using 'EXPLAIN' helps determine the most efficient index order.  
✔ Dropping redundant indexes improves storage efficiency.  
✔ Optimized composite indexing ensures high-speed query execution for large datasets.



















When Indexes are Ignored:
-------------------------
🚀 When Indexes Are Ignored in MySQL Queries
Indexes significantly enhance query performance, but there are scenarios where indexes may be ignored or fail to optimize queries. Understanding these cases helps refine query execution strategies.



📌 1. Why Indexes Might Be Ignored
✔ Using 'OR' Conditions prevents optimal index utilization.  
✔ Columns inside expressions limit MySQL's ability to use indexes efficiently.  
✔ Poor index selection leads to full index scans instead of filtered lookups.

🚀 Effect:  
✔ May cause MySQL to perform unnecessary scans, slowing query execution.



📌 2. Case 1: Index Ignored Due to 'OR' Conditions
✔ Query using 'OR' forces MySQL to scan the entire index, impacting performance.  

📌 Query With 'OR' Operator
'''sql
EXPLAIN SELECT customer_id FROM customers 
WHERE state = 'CA' OR points > 1000;
'''
🚀 Issue:  
✔ MySQL performs a full index scan, scanning '1010' rows instead of filtering efficiently.  

📌 Optimizing with 'UNION' Instead of 'OR'
✔ Break the query into two separate selections and combine using 'UNION'.  

'''sql
CREATE INDEX idx_points ON customers (points);

EXPLAIN
SELECT customer_id FROM customers 
WHERE state = 'CA' 
UNION 
SELECT customer_id FROM customers 
WHERE points > 1000;
'''
🚀 Effect:  
✔ Breaks the query into smaller searches, utilizing appropriate indexes efficiently.  
✔ Reduces scanned rows from '1010' to '640' for improved performance.





📌 3. Case 2: Index Ignored Due to Column Inside an Expression
✔ Using arithmetic operations in a 'WHERE' clause prevents index utilization.  

📌 Inefficient Query
'''sql
EXPLAIN SELECT customer_id FROM customers 
WHERE points + 10 > 2010;
'''
🚀 Issue:  
✔ MySQL scans all '1010' rows despite having an index on 'points'.  

📌 Optimizing by Isolating the Column
✔ Rewrite the query to remove the arithmetic operation inside the condition.  

'''sql
EXPLAIN SELECT customer_id FROM customers 
WHERE points > 2000;
'''
🚀 Effect:  
✔ Reduces scanned rows from '1010' to '3', enabling MySQL to use the index optimally.  





📌 4. Best Practices to Ensure Index Utilization
✔ Avoid placing indexed columns inside expressions ('points + 10 > X').  
✔ Rewrite 'OR' conditions as 'UNION' queries to optimize filtering with multiple indexes.  
✔ Use 'EXPLAIN' to analyze query execution and confirm index usage.  
✔ Ensure indexes align with query logic rather than general assumptions.  

🚀 Effect:  
✔ Guarantees efficient index usage, minimizing database resource consumption.





📌 5. Key Takeaways
✔ Indexes improve query performance but can be ignored under certain conditions.  
✔ Using 'OR' conditions prevents efficient index utilization—use 'UNION' instead.  
✔ Columns inside expressions disable index filtering—rewrite queries to isolate columns.  
✔ Optimized query structure reduces unnecessary index scans, improving performance.  





Queries and other notes in this discussion: 


EXPLAIN SELECT customer_id FROM customers 
WHERE state = 'CA' OR points > 1000;


CREATE INDEX idx_points ON customers (points);
EXPLAIN
	SELECT customer_id FROM customers 
	WHERE state = 'CA' 
	UNION 
	SELECT customer_id FROM customers 
	WHERE points > 1000


EXPLAIN SELECT customer_id FROM customers
WHERE points + 10 > 2010;


EXPLAIN SELECT customer_id FROM customers
WHERE points > 2000;








📌 6. Summary
✔ MySQL indexes can be ignored due to certain query conditions (like 'OR' or expressions).  
✔ Breaking queries into optimized structures ensures efficient index utilization.  
✔ Using 'EXPLAIN' helps diagnose indexing problems and refine queries.  
✔ Proper query design ensures fast and scalable database performance.





















Using Indexes for Sorting:
--------------------------
🚀 Using Indexes for Sorting in MySQL
Indexes not only speed up filtering queries but can also significantly improve sorting performance. Proper indexing strategies help avoid costly sorting operations and enhance database efficiency.



📌 1. How Indexes Help with Sorting
✔ MySQL automatically stores indexed column values in sorted order.  
✔ If a query orders data based on an indexed column, MySQL retrieves the records directly without extra sorting.  
✔ Sorting using indexes avoids expensive 'filesort' operations, improving efficiency.

🚀 Effect:  
✔ Enhances query speed by eliminating unnecessary computation costs.

📌 Example Query: Sorting by an Indexed Column ('state')
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state;
'''
🚀 Result:  
✔ Uses an index scan ('Using index'), efficiently sorting the data.  

📌 Example Query: Sorting by a Non-Indexed Column ('first_name')
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY first_name;
'''
🚀 Issue:  
✔ Triggers a full table scan ('Using filesort'), making the operation costly.  





📌 2. Analyzing Query Cost Using 'SHOW STATUS'
✔ Use 'SHOW STATUS LIKE 'last_query_cost'' to measure query execution cost.  
✔ Sorting on indexed columns costs significantly less than sorting using 'filesort'.

📌 Measuring Query Cost
'''sql
SHOW STATUS LIKE 'last_query_cost';
'''
🚀 Example Cost Comparison:
- Sorting by 'state' (indexed) → Query cost ~'100'
- Sorting by 'first_name' (non-indexed) → Query cost ~'1112'

🚀 Effect:  
✔ Sorting using indexes is ~10x more efficient than using 'filesort' on large tables.  





📌 3. Sorting Multiple Columns Using a Composite Index
✔ Sorting works best when index columns match the 'ORDER BY' clause exactly.  

📌 Sorting by 'state' and 'points' (matching composite index)
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state, points;
'''
🚀 Result:  
✔ Uses index scan ('Using index'), ensuring efficient sorting.  

📌 Adding an unrelated column ('first_name') into sorting
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state, first_name, points;
'''
🚀 Issue:  
✔ Triggers a full table scan ('Using filesort'), reducing efficiency.  





📌 4. Sorting in Different Directions
✔ Sorting mixed directions ('ASC' and 'DESC') prevents full index usage, forcing MySQL to use 'filesort'.  

📌 Sorting by 'state' and 'points' in descending order
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state DESC, points DESC;
'''
🚀 Result:  
✔ Uses backward index scan ('Using index'), maintaining efficiency.  

📌 Sorting by 'state ASC, points DESC' (mixing directions)
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state ASC, points DESC;
'''
🚀 Issue:  
✔ Triggers 'filesort', making query costly.  

🚀 Rule:  
✔ Indexes work for sorting when both columns use the same direction ('ASC' or 'DESC').  





📌 5. Sorting the Second Column of an Index
✔ Sorting by a second column ('points') alone without filtering by the first column ('state') forces MySQL to perform a 'filesort'.  

📌 Sorting by 'points' alone
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY points;
'''
🚀 Issue:  
✔ Uses 'filesort', making query expensive.  

📌 Optimizing by filtering the first column ('state')
'''sql
EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA' ORDER BY points;
'''
🚀 Result:  
✔ No 'filesort' needed—MySQL retrieves pre-sorted data efficiently.  

🚀 Rule:  
✔ Sorting by a second column within a specific first-column filter allows index usage.  





📌 6. Best Practices for Index-Based Sorting
✔ Avoid sorting unless necessary—sorting is computationally expensive.  
✔ Ensure sorting columns match an existing composite index to prevent 'filesort' operations.  
✔ When filtering, include the first indexed column to allow sorting optimization.  
✔ Use 'EXPLAIN' to check whether an index is being used for sorting.  

🚀 Effect:  
✔ Prevents unnecessary full table scans and improves query speed.  





📌 7. Key Takeaways
✔ Indexes help MySQL sort data efficiently without performing costly 'filesort' operations.  
✔ Queries should match index column order to avoid performance degradation.  
✔ Sorting mixed directions ('ASC', 'DESC') can force MySQL to ignore indexes.  
✔ Filtering the first column in a composite index allows optimized sorting for the second column.  




Queries and other notes in this discussion: 

EXPLAIN SELECT customer_id FROM customers ORDER BY state; 

EXPLAIN SELECT customer_id FROM customers ORDER BY first_name;

SHOW STATUS LIKE 'last_query_cost'; -- Last_query_cost 1112.749000

EXPLAIN SELECT customer_id FROM customers ORDER BY state, points DESC -- Using index 

EXPLAIN SELECT customer_id FROM customers ORDER BY state, points DESC; --Using index, Using filesort

EXPLAIN SELECT customer_id FROM customers ORDER BY state DESC, points DESC;  -- Backward index scan, using index 


EXPLAIN SELECT customer_id FROM customers ORDER BY points;  -- Using index, Using filsort

EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA' ORDER BY points; -- using where, using index 


-- (a, b)
-- a
-- a, b
-- a DESC, b DESC

-- a, c, b (results in full table scan)
-- b (results in full scan








📌 Summary
✔ Using indexes for sorting improves efficiency and prevents resource-intensive table scans.  
✔ Matching index order with sorting columns ensures optimal performance.  
✔ Sorting operations should be carefully structured to avoid unnecessary computation costs.  
✔ Strategic index design enhances scalability for complex database queries.  











Covering Indexes:
-----------------
🚀 Covering Indexes in MySQL for Optimal Query Performance
A covering index is an index that contains all columns required to satisfy a query, allowing MySQL to retrieve data solely from the index without accessing the full table.



📌 1. What Is a Covering Index?
✔ A covering index includes all necessary columns for filtering, sorting, and selection.  
✔ Queries using a covering index execute entirely within the index, avoiding costly table scans.  
✔ These indexes improve performance by reducing disk I/O operations.

🚀 Effect:  
✔ Fastest possible query execution since MySQL does not access the full table.




📌 2. Example Query Using a Covering Index
✔ Selecting 'customer_id' while sorting by 'state' allows MySQL to use an index efficiently.

📌 Using 'EXPLAIN' to Analyze the Query
'''sql
EXPLAIN SELECT customer_id FROM customers ORDER BY state;
'''
🚀 Result:  
✔ MySQL performs an index scan ('Using index'), meaning no table access is needed.  

📌 Checking Query Execution Cost
'''sql
SHOW STATUS LIKE 'last_query_cost';
'''
🚀 Effect:  
✔ Low query cost confirms efficient execution.





📌 3. Issue with Selecting All Columns ('SELECT *')
✔ Selecting all columns forces MySQL to read the entire table, invalidating the covering index.  
✔ Even though an index exists for 'state', MySQL cannot use it to retrieve all columns efficiently.

📌 Query That Causes a Full Table Scan
'''sql
EXPLAIN SELECT * FROM customers ORDER BY state;
'''
🚀 Issue:  
✔ Triggers a full table scan ('Using filesort'), increasing query cost dramatically.  





📌 4. Components of a Covering Index
✔ Primary key ('customer_id') → Automatically included in secondary indexes.  
✔ Filtering columns ('WHERE' conditions) → Helps narrow down search results.  
✔ Sorting columns ('ORDER BY' conditions) → Allows efficient sorting within the index.  
✔ Selected columns ('SELECT clause') → Must be included for a true covering index.

🚀 Effect:  
✔ Enables MySQL to fully satisfy the query from the index without reading the table.





📌 5. Best Practices for Designing Covering Indexes
✔ Ensure filtering columns are included in the index to optimize searches.  
✔ Sort data using indexed columns to avoid expensive 'filesort' operations.  
✔ Include necessary selection columns in the index to create a covering index.  
✔ Use 'EXPLAIN' to validate whether an index fully satisfies a query.  

🚀 Effect:  
✔ Balances performance optimization and storage efficiency.





📌 6. Key Takeaways
✔ Covering indexes prevent unnecessary table access, improving query performance.  
✔ Using 'SELECT *' forces MySQL to scan the full table, negating index benefits.  
✔ Filtering, sorting, and selecting indexed columns ensure efficient query execution.  
✔ Checking query cost ('SHOW STATUS') confirms index optimization success.  




Queries and other notes in this discussion:


EXPLAIN SELECT customer_id FROM customers ORDER BY state; 

SHOW STATUS LIKE 'last_query_cost';

EXPLAIN SELECT * FROM customers ORDER BY state; -- full table scan





📌 Summary
✔ Covering indexes enable efficient query execution by eliminating table access.  
✔ Strategic index design improves filtering, sorting, and data retrieval.  
✔ Avoiding unnecessary full table scans enhances database speed and scalability.  
✔ Proper index management ensures sustainable performance across large datasets.  










Index Maintenance:
------------------
🚀 Index Maintenance in MySQL: Managing Duplicate and Redundant Indexes
Indexes significantly improve query performance, but too many or improperly managed indexes can lead to unnecessary storage usage and slow write operations. Duplicate and redundant indexes should be eliminated for optimal database efficiency.



📌 1. What Are Duplicate Indexes?
✔ Duplicate indexes occur when two indexes have the exact same columns in the same order.  
✔ MySQL does not prevent duplicate indexes, causing wasted storage and unnecessary maintenance.  

📌 Example of Duplicate Indexes
| Index Name   | Column Order | Duplicate? |
|--------------|----------------|----------------|
| 'idx_abc'    | ('A, B, C') | ❌ No |
| 'idx_duplicate' | ('A, B, C') | ✅ Yes |

🚀 Effect:  
✔ Duplicate indexes consume storage unnecessarily and slow database performance.

📌 Best Practice:  
✔ Check existing indexes before creating new ones to avoid duplication.





📌 2. What Are Redundant Indexes?
✔ Redundant indexes happen when an index contains all columns of another index in the same order.  
✔ If an index exists on ('A, B'), a separate index on 'A' is redundant because the composite index covers queries on 'A'.  

📌 Example of Redundant Indexes
| Index Name | Column Order | Redundant? |
|------------|-------------|------------|
| 'idx_ab' | ('A, B') | ❌ No |
| 'idx_a' | ('A') | ✅ Yes (redundant) |
| 'idx_ba' | ('B, A') | ❌ No |
| 'idx_b' | ('B') | ❌ No |

🚀 Effect:  
✔ Creates unnecessary index maintenance overhead, impacting write operations.  

📌 Best Practice:  
✔ Extend existing indexes instead of creating redundant ones.  





📌 3. Index Maintenance Best Practices
✔ Regularly review indexes using 'SHOW INDEXES'.  
✔ Eliminate duplicate indexes to save storage and improve performance.  
✔ Remove redundant indexes and consolidate where possible.  
✔ Monitor unused indexes—drop them if they no longer serve query optimization.  

📌 Checking Existing Indexes
'''sql
SHOW INDEXES FROM customers;
'''
🚀 Effect:  
✔ Provides insight into existing indexes, helping eliminate unnecessary duplicates.  





📌 4. Key Takeaways
✔ Duplicate indexes waste space and should be removed.  
✔ Redundant indexes slow updates and should be consolidated.  
✔ Always check existing indexes before creating new ones.  
✔ Optimizing index maintenance improves MySQL performance and reduces storage overhead.  





Queries and other notes in this discussion:


Duplicate indexes:

(A, B, C)
(A, B, C) --duplicate

Redundant Indexes: 
(A, B)
(A) --  redundant 
(B, A) -- not redundant
(B)   -- not redundant




📌 Summary
✔ Proper index management ensures a fast and efficient database.  
✔ Duplicate indexes should be avoided to prevent unnecessary maintenance.  
✔ Redundant indexes should be consolidated to reduce storage consumption.  
✔ Regular index analysis improves query execution and database health.  









Performance Best Pratices:
--------------------------
Here is a summary of all the performance best practices we discussed in this
course. This list is not complete by any means, but it contains guidelines that can
help solve a lot of performance problems. If you’re interested in learning more
about this topic, take a look at the additional resources later in this document.

1. Smaller tables perform better. Don’t store the data you don’t need. Solve today’s
problems, not tomorrow’s future problems that may never happen.
2. Use the smallest data types possible. If you need to store people’s age, a
TINYINT is sufficient. No need to use an INT. Saving a few bytes is not a big
deal in a small table, but has a significant impact in a table with millions of
records.
3. Every table must have a primary key.
4. Primary keys should be short. Prefer TINYINT to INT if you only need to store a
hundred records.
5. Prefer numeric types to strings for primary keys. This makes looking up records
by the primary key faster.
6. Avoid BLOBs. They increase the size of your database and have a negative
impact on the performance. Store your files on disk if you can.
7. If a table has too many columns, consider splitting it into two related tables
using a one-to-one relationship. This is called vertical partitioning. For
example, you may have a customers table with columns for storing their
address. If these columns don’t get read often, split the table into two tables
(users and user_addresses).
8. In contrast, if you have several joins in your queries due to data fragmentation,
you may want to consider denormalizing data. Denormalizing is the opposite of
normalization. It involves duplicating a column from one table in another table
(to reduce the number of joins) required
9. Consider creating summary/cache tables for expensive queries. For example, if
the query to fetch the list of forums and the number of posts in each forum is
expensive, create a table called forums_summary that contains the list of
forums and the number of posts in them. You can use events to regularly refresh
the data in this table. You may also use triggers to update the counts every time
there is a new post.
10.Full table scans are a major cause of slow queries. Use the EXPLAIN statement
and look for queries with type = ALL. These are full table scans. Use indexes to
optimize these queries.
11. When designing indexes, look at the columns in your WHERE clauses first.
Those are the first candidates because they help narrow down the searches.
Next, look at the columns used in the ORDER BY clauses. If they exist in the
index, MySQL can scan your index to return ordered data without having to
perform a sort operation (filesort). Finally, consider adding the columns in the
SELECT clause to your indexes. This gives you a covering index that covers
everything your query needs. MySQL doesn’t need to retrieve anything from
your tables.
12.Prefer composite indexes to several single-column index.
13. The order of columns in indexes matter. Put the most frequently used columns
and the columns with a higher cardinality first, but always take your queries
into account.
14.Remove duplicate, redundant and unused indexes. Duplicate indexes are the
indexes on the same set of columns with the same order. Redundant indexes are
unnecessary indexes that can be replaced with the existing indexes. For
example, if you have an index on columns (A, B) and create another index on
column (A), the latter is redundant because the former index can help.
15. Don’t create a new index before analyzing the existing ones.
16. Isolate your columns in your queries so MySQL can use your indexes.
17. Avoid SELECT *. Most of the time, selecting all columns ignores your indexes
and returns unnecessary columns you may not need. This puts an extra load on
your database server.
18.Return only the rows you need. Use the LIMIT clause to limit the number of
rows returned.
19.Avoid LIKE expressions with a leading wildcard (eg LIKE ‘%name’).
20.If you have a slow query that uses the OR operator, consider chopping up the
query into two queries that utilize separate indexes and combine them using the
UNION operator.














Securing Databases:
-------------------

Throughout this course, we have been using MySQL on our own computer. And for this very reason, we didn't have to worry about security in terms of who can access our data and how much access they should have. However, in a real world scenario, you typically have a database somewhere on a server, and if you don't take security seriously, people can access and misuse your data. So in this section, we're going to talk about user accounts and privileges for securing databases. Are you ready? Let's get started.





Creating a User:
----------------
🚀 Creating a User in MySQL
Creating user accounts in MySQL allows controlled database access, ensuring security and privilege management in production environments.



📌 1. Why Create Additional Users?
✔ Limit access for applications → Prevent altering the database structure.  
✔ Grant administrative privileges → Allow database management for authorized users.  
✔ Restrict connections → Ensure users can only access MySQL from specific locations.  

🚀 Effect:  
✔ Enhances security by preventing unauthorized modifications to the database.  





📌 2. Creating a User
✔ Use the 'CREATE USER' statement to define a new MySQL user.  
✔ Specify optional connection restrictions based on IP or hostname.  
✔ Set strong passwords for security (avoid simple passwords like '1234').  

📌 Creating a User
'''sql
CREATE USER john IDENTIFIED BY 'SecurePassword123!';
'''
🚀 Effect:  
✔ Creates 'john' with a secure password, allowing unrestricted access from any location.  






📌 3. Restricting User Connections
✔ Limit access to a specific IP address ('127.0.0.1') → Ensures local connections only.  
✔ Use 'localhost' to restrict access to the same machine.  
✔ Specify a domain to allow access from multiple locations within an organization.  

📌 Examples of User Restrictions
'''sql
CREATE USER john@127.0.0.1 IDENTIFIED BY 'SecurePassword123!';
CREATE USER john@localhost IDENTIFIED BY 'SecurePassword123!';
CREATE USER john@'codewithmosh.com' IDENTIFIED BY 'SecurePassword123!';
CREATE USER john@'%.codewithmosh.com' IDENTIFIED BY 'SecurePassword123!';
'''
🚀 Effect:  
✔ Controls where 'john' can connect from, preventing unauthorized remote access.  





📌 4. Best Practices for User Management
✔ Use strong passwords to prevent unauthorized logins.  
✔ Regularly review user permissions to ensure proper access levels.  
✔ Restrict connections to trusted IPs or domains for enhanced security.  
✔ Check existing users before creating new ones to prevent unnecessary duplication.  

🚀 Effect:  
✔ Ensures proper security measures while maintaining database integrity.  





📌 5. Key Takeaways
✔ Creating MySQL users allows controlled access management.  
✔ Restricting connections prevents unauthorized database interactions.  
✔ Strong passwords and privilege management enhance security.  
✔ Always verify existing users before adding new accounts.  





Queries and other notes in this discussion: 

CREATE USER john@127.0.0.1

CREATE USER john@localhost

CREATE USER john@codewithmosh.com

CREATE USER john@'%.codewithmosh.com'

CREATE USER john

CREATE USER john IDENTIFIED BY '1234';





📌 Summary
✔ Adding user accounts prevents direct access with the root user.  
✔ Restricting connections improves security by limiting access points.  
✔ Implementing strong passwords prevents unauthorized logins.  
✔ Managing MySQL users ensures database protection and controlled interactions.  



















Viewing Users:
--------------
🚀 Viewing Users in MySQL
Understanding how to list MySQL user accounts ensures proper access control and user management within the database server.



📌 1. Methods to View Users in MySQL
✔ Option 1: Query the 'mysql.user' table for a complete list of users.  
✔ Option 2: Use MySQL Workbench's Administration Panel for visual user management.  

🚀 Effect:  
✔ Ensures visibility into database users and their connection permissions.  





📌 2. Listing Users with SQL
✔ MySQL stores user account details in the 'mysql.user' system table.  

📌 Querying User Accounts
'''sql
SELECT * FROM mysql.user;
'''
🚀 Effect:  
✔ Displays all existing user accounts, including their host restrictions and privileges.  

📌 Understanding Key Columns in 'mysql.user'
| Column | Description |
|------------|----------------|
| 'user' | The MySQL username. |
| 'host' | Specifies where the user can connect from. |
| 'authentication_string' | Stores the user's password hash. |
| Various permission columns | Determine database privileges. |

🚀 Effect:  
✔ Helps identify user access levels and security configurations.  





📌 3. Host Restrictions in MySQL Users
✔ Users can be restricted to connect only from certain IPs or hosts.  
✔ Wildcards ('%') allow unrestricted access from any location.  

📌 Example: Viewing Host Restrictions
| User | Host | Access Scope |
|-----------|-----------|----------------|
| 'john' | '%' | Can connect from any location. |
| 'root' | 'localhost' | Can only connect from this computer. |

🚀 Effect:  
✔ Prevents unauthorized remote access for sensitive user accounts like 'root'.  





📌 4. Viewing Users in MySQL Workbench
✔ Step 1: Open the Administration Panel.  
✔ Step 2: Navigate to Users and Privileges.  
✔ Step 3: View and manage user accounts visually.  

🚀 Effect:  
✔ Allows easy management of user accounts without running SQL queries.  





📌 5. Best Practices for Managing MySQL Users
✔ Regularly review user accounts to ensure security.  
✔ Restrict the 'root' user to localhost for better protection.  
✔ Assign specific privileges instead of full administrative access.  
✔ Avoid using '%' (wildcard) unless necessary for application access.  

🚀 Effect:  
✔ Improves database security and minimizes risks of unauthorized access.  





📌 6. Key Takeaways
✔ Use 'SELECT * FROM mysql.user;' to list all MySQL users.  
✔ Check host restrictions to control where users can connect from.  
✔ MySQL Workbench provides an intuitive interface for user management.  
✔ Ensuring proper user access improves overall database security.  




Queries and other notes in this discussion:

SELECT * FROM mysql.user; 





📌 7. Summary
✔ Viewing MySQL users helps manage database access and security.  
✔ Using the 'mysql.user' table or Workbench allows structured user auditing.  
✔ Host restrictions prevent unauthorized remote connections.  
✔ Proper user management ensures database integrity and scalability.  














Dropping Users:
---------------

🚀 Dropping Users in MySQL for Access Management
As individuals leave an organization or their access becomes unnecessary, removing their user accounts ensures database security and prevents unauthorized access.



📌 1. Why Drop Unused User Accounts?
✔ Prevents former employees from accessing the database.  
✔ Reduces security vulnerabilities by limiting active accounts.  
✔ Keeps MySQL user management clean and efficient.  

🚀 Effect:  
✔ Strengthens security by ensuring only authorized users have access.  




📌 2. Creating a User (Before Dropping)
✔ Use the 'CREATE USER' statement to add a new user.  

📌 Example: Creating a User ('bob@codewithmosh.com')
'''sql
CREATE USER bob@codewithmosh.com IDENTIFIED BY 'SecurePassword123!';
'''
🚀 Effect:  
✔ Adds 'bob' as an authorized user with access from 'codewithmosh.com'.  





📌 3. Dropping a User
✔ Use 'DROP USER' to remove accounts when they are no longer needed.  
✔ Specify the exact host to ensure correct user removal.  

📌 Example: Removing 'bob@codewithmosh.com'
'''sql
DROP USER bob@codewithmosh.com;
'''
🚀 Effect:  
✔ Ensures 'bob' can no longer access the MySQL server from 'codewithmosh.com'.  



📌 4. Best Practices for User Management
✔ Periodically audit user accounts to remove unnecessary access.  
✔ Restrict user privileges to the minimum required for their role.  
✔ Review login permissions to ensure compliance with security policies.  
✔ Ensure that critical accounts (e.g., 'root') are protected against unauthorized modifications.  

🚀 Effect:  
✔ Maintains database integrity while enforcing strong security controls.  



📌 5. Key Takeaways
✔ Dropping users is essential for managing access and protecting sensitive data.  
✔ Always specify the correct host when removing a user to avoid unintended deletion.  
✔ Regularly review active users to prevent unauthorized access.  
✔ Proper user management enhances overall MySQL database security.  





Queries and other notes in this discussion:

CREATE USER bob@codewithmosh.com IDENTIFIED BY '1234';

DROP USER bob@codewithmosh.com;





📌 Summary
✔ Removing inactive users prevents unauthorized access.  
✔ Proper user maintenance ensures database security and organization efficiency.  
✔ Executing 'DROP USER' removes unnecessary accounts, reducing security risks.  
✔ Regular audits help keep user access tightly controlled.  














Changing Passwords:
-------------------
🚀 Changing Passwords in MySQL for User Security
Managing passwords in MySQL is crucial for ensuring secure access to the database. Users may forget their passwords, requiring administrators to reset credentials or enforce password changes.



📌 1. Why Change MySQL Passwords?
✔ Reset passwords for users who forget them.  
✔ Enhance security by updating weak or compromised passwords.  
✔ Force password changes upon login to ensure fresh credentials.  

🚀 Effect:  
✔ Maintains strict security protocols for database access.  





📌 2. Changing a User's Password (Admin Reset)
✔ Use the 'SET PASSWORD' statement to update credentials.  
✔ Specify the user whose password is being modified.  

📌 Example: Updating 'john''s Password
'''sql
SET PASSWORD FOR john = 'SecurePassword123!';
'''
🚀 Effect:  
✔ Immediately updates John’s password, allowing secure login.  





📌 3. Changing Your Own Password
✔ Administrators or users can change their own passwords without specifying a username.  
✔ No need for the 'FOR' clause—modifies the password for the currently logged-in user.  

📌 Example: Changing Your Own Password
'''sql
SET PASSWORD = 'NewSecurePassword!';
'''
🚀 Effect:  
✔ Modifies the password of the active user session securely.  





📌 4. Changing Passwords via MySQL Workbench
✔ Step 1: Open the Administration Panel.  
✔ Step 2: Navigate to Users and Privileges.  
✔ Step 3: Select a user and update their password in the designated field.  
✔ Step 4: Click Apply to confirm changes.  

🚀 Effect:  
✔ Provides a visual approach for managing password security.  

📌 Additional Security Features:
✔ Expiring a password forces the user to change their password on the next login.  





📌 5. Best Practices for Password Management
✔ Use strong passwords—avoid simple credentials like '1234'.  
✔ Regularly update passwords to prevent unauthorized access.  
✔ Restrict access to administrative accounts to trusted personnel.  
✔ Audit user credentials periodically to ensure compliance.  

🚀 Effect:  
✔ Improves overall database security while maintaining operational control.  





📌 6. Key Takeaways
✔ Changing passwords is essential for maintaining database security.  
✔ Use 'SET PASSWORD' to update credentials for any MySQL user.  
✔ Admins can change passwords via SQL or MySQL Workbench.  
✔ Expiring passwords forces users to update them upon login.  





Queries and other notes in this discussion:

SET PASSWORD FOR john = '1234';

SET PASSWORD = '1234';




📌 Summary
✔ Password updates ensure controlled access and secure authentication.  
✔ Using SQL statements or MySQL Workbench provides flexibility in credential management.  
✔ Strict password policies help mitigate potential security risks.  
✔ Monitoring and updating user credentials improves long-term database protection.  








Granting Privileges:
--------------------
🚀 Granting Privileges in MySQL
Assigning privileges in MySQL ensures controlled database access, allowing users or applications to interact securely without unnecessary permissions.



📌 1. Why Grant Privileges?
✔ Limit database access for applications → Prevent structure modifications.  
✔ Provide administrative privileges for DB admins → Allow full management of databases.  
✔ Restrict user actions based on role → Ensure security and controlled access.  

🚀 Effect:  
✔ Protects databases from unauthorized modifications and security risks.  





📌 2. Scenario 1: Granting Privileges to an Application
✔ Applications should only have permissions to read and write data (not modify tables).  
✔ Use 'GRANT' to assign necessary privileges to specific databases or tables.  

📌 Step 1: Create an Application User
'''sql
CREATE USER moon_app IDENTIFIED BY 'SecurePassword123!';
'''
🚀 Effect:  
✔ Creates a user ('moon_app') with a secure password for database access.  

📌 Step 2: Assign Limited Privileges for Data Operations
'''sql
GRANT SELECT, INSERT, UPDATE, DELETE, EXECUTE 
ON sql_store.*
TO moon_app;
'''
🚀 Effect:  
✔ Allows 'moon_app' to perform read/write operations in 'sql_store', but prevents table modifications.  





📌 3. Testing Access for 'moon_app'
✔ Step 1: Create a new connection using 'moon_app' credentials.  
✔ Step 2: Connect and run queries in the 'sql_store' database.  
✔ Step 3: Attempt accessing another database ('sql_blog') → Should return an access denied error.  

🚀 Effect:  
✔ Confirms that 'moon_app' has restricted access only to authorized databases.  





📌 4. Scenario 2: Granting Administrative Privileges
✔ Admins require broader privileges to manage databases and create objects.  
✔ Assigning 'ALL PRIVILEGES' provides full access to database management.  

📌 Granting Full Privileges to an Admin ('john')
'''sql
GRANT ALL 
ON *.*
TO john;
'''
🚀 Effect:  
✔ Provides 'john' full administrative access across all databases and tables.  

📌 Restricting Admin Access to a Specific Database
'''sql
GRANT ALL 
ON sql_store.*
TO john;
'''
🚀 Effect:  
✔ Limits 'john''s administrative control to only the 'sql_store' database.  





📌 5. Checking MySQL Privileges
✔ Use MySQL's reference manual to review supported privileges ('CREATE TABLE', 'ALTER TABLE', 'EXECUTE', etc.).  
✔ Verify user permissions using SQL queries or MySQL Workbench.  

🚀 Effect:  
✔ Ensures proper role management and database security policies.  





📌 6. Best Practices for Privilege Management
✔ Limit privileges to the minimum necessary for each user.  
✔ Avoid granting 'ALL PRIVILEGES' unless required for an admin.  
✔ Regularly audit user permissions to maintain security.  
✔ Use strong passwords to prevent unauthorized access.  

🚀 Effect:  
✔ Prevents accidental or malicious database modifications while maintaining functionality.  





📌 7. Key Takeaways
✔ Use 'GRANT' to control user access to databases and tables.  
✔ Applications should only have read/write permissions—not table modification rights.  
✔ Admins can receive full privileges using 'GRANT ALL ON *.*'.  
✔ Checking and managing privileges regularly improves security and database integrity.  




Queries and other notes in this discussion:

-- 1. web/desktop application

CREATE USER moon_app IDENTIFIED BY '1234';

GRANT SELECT, INSERT, UPDATE, DELETE, EXECUTE 
ON sql_store.*
TO moon_app;

-- 2. admin 

GRANT ALL 
ON *.*
TO john;






📌 Summary
✔ Granting privileges ensures users have only the necessary permissions to interact with databases.  
✔ Application accounts should be restricted to read/write operations for security.  
✔ Admin users can be granted 'ALL PRIVILEGES' for complete management control.  
✔ Regular privilege reviews help prevent unauthorized database access.  
















Viewing Privileges:
-------------------
🚀 Viewing User Privileges in MySQL
Checking assigned privileges in MySQL helps ensure users have appropriate access rights and prevents unauthorized modifications.



📌 1. Why View User Privileges?
✔ Verify access levels before modifying permissions.  
✔ Ensure users have the correct database privileges for their roles.  
✔ Audit access controls for security compliance.  

🚀 Effect:  
✔ Helps maintain structured and secure database access.  





📌 2. Viewing User Privileges with SQL
✔ Use 'SHOW GRANTS FOR' to check privileges for a specific user.  
✔ Omitting the user name displays privileges for the currently logged-in account.  

📌 Checking Privileges for a User ('john')
'''sql
SHOW GRANTS FOR john;
'''
🚀 Effect:  
✔ Displays assigned privileges for 'john', including SELECT, INSERT, UPDATE, DELETE, and admin controls.  

📌 Checking Privileges for the Current User
'''sql
SHOW GRANTS;
'''
🚀 Effect:  
✔ Returns permissions for the logged-in user (e.g., root user).  





📌 3. Viewing User Privileges in MySQL Workbench
✔ Step 1: Open the Administration Panel.  
✔ Step 2: Navigate to Users and Privileges.  
✔ Step 3: Select the desired user to view assigned roles.  
✔ Step 4: Under Schema Privileges, check database-specific permissions.  

🚀 Effect:  
✔ Provides a visual way to manage user privileges without writing SQL queries.  

📌 Example: Admin ('john') vs Application User ('moon_app')
| User | Access Scope | Privileges |
|------------|-------------|----------------|
| 'john' | All databases | Full administrative privileges |
| 'moon_app' | 'sql_store' database | Limited access (SELECT, INSERT, UPDATE, DELETE) |

🚀 Effect:  
✔ Ensures 'moon_app' can only interact with 'sql_store', while 'john' has broader access.  






📌 4. Editing Privileges in MySQL Workbench
✔ Step 1: Select a user in Users and Privileges.  
✔ Step 2: Modify roles and permissions under the respective tabs.  
✔ Step 3: Click Apply to save changes.  

🚀 Effect:  
✔ Allows easy privilege adjustments without executing SQL manually.  





📌 5. Best Practices for User Privilege Management
✔ Regularly audit user privileges to prevent unauthorized access.  
✔ Assign the minimum necessary privileges to application users.  
✔ Limit administrative access to trusted personnel.  
✔ Use 'SHOW GRANTS' before making privilege modifications.  

🚀 Effect:  
✔ Ensures MySQL security while maintaining structured user access.  





📌 6. Key Takeaways
✔ Use 'SHOW GRANTS' to verify user privileges.  
✔ MySQL Workbench provides a visual tool for privilege management.  
✔ Ensuring correct user roles prevents security vulnerabilities.  
✔ Modifying privileges requires careful auditing to maintain system integrity.  





Queries and other notes in this discussion: 

SHOW GRANTS FOR john; 

SHOW GRANTS; -- current user 







📌 Summary
✔ Viewing privileges helps maintain secure database access.  
✔ Using SQL or Workbench ensures effective user privilege management.  
✔ Auditing access rights prevents unauthorized modifications.  
✔ Proper privilege assignments optimize MySQL security and performance.  


















Revoking Privileges:
--------------------
🚀 Revoking Privileges in MySQL for Secure User Access
After granting privileges in MySQL, you may need to revoke access due to errors, security risks, or improper permissions. Removing unnecessary privileges ensures controlled database security and prevents unauthorized actions.



📌 1. Why Revoke Privileges?
✔ Correct mistakes when granting privileges.  
✔ Prevent users from abusing excessive access rights.  
✔ Improve security by restricting unnecessary privileges.  

🚀 Effect:  
✔ Ensures users only have permissions essential for their roles.  




📌 2. Revoking Privileges in MySQL
✔ Use 'REVOKE' instead of 'GRANT' to remove privileges.  
✔ Modify privileges based on changing security or role requirements.  

📌 Example: Removing 'CREATE VIEW' Privilege for 'moon_app'
'''sql
REVOKE CREATE VIEW 
ON sql_store.*
FROM moon_app;
'''
🚀 Effect:  
✔ Removes 'moon_app''s ability to create views in the 'sql_store' database.  

📌 Granting the Privilege Before Revoking
'''sql
GRANT CREATE VIEW 
ON sql_store.*
TO moon_app;
'''
🚀 Effect:  
✔ Allows 'moon_app' to create views before the privilege is revoked.  





📌 3. Best Practices for Privilege Management
✔ Grant the minimum necessary privileges to each user—avoid excessive access.  
✔ Regularly review privileges to prevent misuse or security risks.  
✔ Restrict administrative actions to trusted personnel only.  
✔ Use 'SHOW GRANTS FOR username;' to verify privileges before revoking.  

🚀 Effect:  
✔ Maintains database integrity while reinforcing security protocols.  





📌 4. Key Takeaways
✔ Revoking privileges is essential for maintaining proper access control.  
✔ Always verify granted privileges before modifying user permissions.  
✔ Minimizing unnecessary privileges strengthens overall MySQL security.  
✔ Regular privilege audits prevent security vulnerabilities.  





Queries and other notes in this discussion: 

GRANT CREATE VIEW 
ON sql_store.*
TO moon_app;


REVOKE CREATE VIEW 
ON sql_store.*
FROM moon_app;



📌 Summary
✔ Revoking privileges prevents unauthorized modifications and accidental access.  
✔ Using 'REVOKE' ensures users only have the necessary permissions.  
✔ Security-focused privilege management prevents data breaches.  
✔ Proper user role configuration optimizes MySQL security and performance.  

