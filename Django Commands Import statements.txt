

To Learn:
---------
Jinja templating, django default templating

Django data models

Django field types -> https://docs.djangoproject.com/en/5.0/ref/models/fields/
https://www.geeksforgeeks.org/django-model-data-types-and-fields-list/

date time field (auto_now_add, auto_now)

in field option --> choice field


one-to-one relationship --> in the child class --> the column value key field from parent class should be set 'primary_key = True'

related_name, reverse relationship
related_name = '+' --> tells django not to create the reverse relationship

circular dependency or circular relationship and how to solve them

ContentType

 content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
 object_id = models.PositiveIntegerField()
 content_object = GenericForeignKey()
 
 
Inner class Meta --> class Meta (explore)

django model metadata  --> https://docs.djangoproject.com/en/5.0/ref/models/options/




Django ORM --> learn about Managers and QuerySets
.Objects. --> manager --> interface 

queryset get evaluated --> iterate, converting it in to list, accessing a single element  --> lazily evaluated

Learn Building complex query using Django ORM

queryset api  --> https://docs.djangoproject.com/en/5.0/ref/models/querysets/



Learn select_related, prefetch_related very well
also learn chaining select_related with prefetch_related



django database functions -->  https://docs.djangoproject.com/en/5.0/ref/models/database-functions/


learn about contentTypes in django


Django ModelAdmin --> https://docs.djangoproject.com/en/5.0/ref/contrib/admin/  --> ModelAdmin options


Django validators --> https://docs.djangoproject.com/en/5.0/ref/validators/ 


url conf in django


resource -- object -- model -- entity 


https://www.django-rest-framework.org/  
  apiguide --> serializer fields
               Generic Views



change detection mechanism doesn't work sometimes. you need to restart the server. 

httpstatuses

nested routers --> https://github.com/alanjds/drf-nested-routers

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Django import statements:
---------------------------

from django.shortcuts import render (default - Views.py - to render html)
  eg: return render(request, 'hello.html')
  eg: return render(request, 'hello.html', {'name': 'Mosh'})
from django.http import HttpResponse (Views.py)  
  eg: return HttpResponse('Hello World')
  
from django.urls import path (in apps urls.py)
from django.urls import path, include (in project urls.py)

from django.db import models (default - models.py)


from django.contrib.contenttypes.models import ContentType ( models.py - to define generic relationship, to find the content_type)
from django.contrib.contenttypes.fields import GenericForeignKey

from django.contrib.auth.models import User

from django.core.exceptions import ObjectDoesNotExist(views.py --> queryset,if we don't get the object we're looking for)

from django.db.models import Q, F, Func, ExpressionWrapper (Q - to combine the conditions using OR Operator, F - to represent a particular field)


from django.db.models.aggregates import Count, Max, Min

from django.db.models import Value 

from django.db.models.functions import Concat

from django.contrib.contenttypes.models import ContentType (in views.py)
from store.models import Product
from tags.model import taggedItem 


from django.db import transaction
from django.db import connection


from django.utils.html import format_html, urlencode ( in admin.py)
from django.urls import reverse( in admin.py)

from django.contrib import admin, messages


from django.core.validators import MinValueValidator

from django.contrib.contenttypes.admin import GenericTabularInline, GenericStackedInline



#rest_framework
from rest_framework.decorators import api_view
from rest_framework.response import Response

from rest_framework import serializers
from rest_framework import status

from django.shortcuts import get_object_or_404

from decimal import Decimal

from rest_framework.views import APIView
from rest_framework.mixins import ListModelMixin, CreateModelMixin

from rest_framework.viewsets import ModelViewSet

from rest_framework.routers import SimpleRouter

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter

from rest_framework.pagination import PageNumberPagination










from django.contrib.auth.models import AbstractUser




Django Commands:
----------------

pip install django / pipenv install django(if you want to use pipenv)
django-admin startproject my_proj   / django-admin startproject my_proj . (tells django to use current directory as project Directory)
cd my_proj



pipenv --venv ( to check python interpreter in the local venv)


python manage.py startapp app_name ( to create an app)
Note : register the app in the 'INSTALLED_APPS' in the project settings folder



apps --> urls.py	
	
urlpatterns = [
    path('hello/', views.say_hello)
 ]	
	
	
projects --> urls.py

urlpatterns = [
   path('admin/', admin.site.urls),
   path('playground/', include('playground.urls'))
  ]
	



python manage.py makemigrations   ---> generates migrations py file 

   --> makemigrations basically generates the SQL commands for preinstalled apps (which can be viewed in installed apps in settings.py) and your newly created appâ€™s model which you add in installed apps 
   
 Note: remember to add all apps to 'INSTALLED_APPS', or else django wouldn't detect any changes 
 
python manage.py migrate  ----> run those migration.py file and create table in database

    -->migrate executes those SQL commands in the database file. 
	
	
python manage.py migrate store 003 (migrate to a specific migration)
  but the proper way is to delete the unwanted migration file and erase all respective changes in the code 	
	
	
python manage.py makemigrations store --empty

python manage.py sqlmigrate store 0003  --> to see the actual sql code that is sent to our database at runtime.



install mysql

install any mysql clients and connect with it 

The next step is to connect our Django project to MySQL --> to do that we need to install a package --> pipenv install mysqlclient


change in the settings:
DATABASES = {
 'default' : 'django.db.backends.mqsql',
 'NAME' : 'storefront',
 'HOST' : 'localhost',
 'USER' : 'root',
 'PASSWORD' : 'Mypassword'
  }
 }


Generating Dummy Data --> mockaroo.com







Django ORM:
-----------

product = Product.objects.filter(pk =0).first() #if the product doesn't exist, we would get None, we are not gonna get exception
exists = Product.objects.filter(pk =0).exists() # we get a boolean value


Learning filtering objects in Django orm 
Also learn keyword arguments

queryset = Product.objects.filter(unit_price__gt=20)



queryset = Product.objects.filters(collection_id__range=(1, 2, 3))

queryset = Product.objects.filters(title__icontains='coffee')

queryset = Product.objects.filters(last_update__year=2021)

	
queryset = Product.objects.filters(Q(inventory__lt=10) | Q(unit_price__lt=20))	

queryset = Product.objects.filters(inventory = F('unit_price'))

queryset = Product.objects.filters(inventory = F('collection__id'))



queryset = Product.objects.order_by('title')  des -> '-title'

queryset = Product.objects.order_by('unit_price', '-title')

check queryset api reference 

product = Product.objects.order_by('unit_price')[0]
product = Product.objects.earliest('unit_price')
product = Product.objects.latest('unit_price')



queryset = Product.objects.all()[:5]

see this sql statement:
select * from store.product limit 5 offset 5



queryset = Product.objects.values('id', 'title')
queryset = Product.objects.values('id', 'title', 'collection_title')  -->
Note: in this case we don't get product instances/ object . we do get dictionaries

queryset = Product.objects.values_list ('id', 'title', 'collection_title') -->
 Here we get tuples instead of dictionary

select store_product.id, store_product.title, store_collection.title from store_product inner join store_collection on 
(store_product.collection_id = store_collection.id) 

	

queryset = OrderItem.object.values('product_id') --> we can give this instead of (product__id) because django will create the reverse relationship during runtime
	
queryset =  Product.objects.filter(id__in = OrderItem.object.values('product_id').distinct())  --> we get Product instance


queryset = Product.objects.only('id', 'title')  --> we get instance of Product, whereas with 'values' we get dictionary 

queryset = Product.objects.defer('description')


to query the related tables -->
queryset = Product.objects.select_related('collection').all()


select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, 
store_collection.id, store_collection.title, store_collection.featured_product_id from store_product inner join store_collection on 
(store_product.collection_id = store_collection.id)


#select_related(1) --> other end of the relationship has one instance (product - collection)
#prefetch_related(N) when other end of the relationship has many objects (product - promotion)



#prefetch_related
queryset = Product.objects.prefetch_related('promotions').all()

select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price from store_product

select (store_product_promotions.product_id) as _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount
from store_promotion inner join store_product_promotions on (store_promotion.id = store_product_promotions.promotion_id) where store_product_promotions.product_id in (1,2,3,4,5,6,7,8,9,10...)



result = Product.objects.aggregage(Count('id')) --> {id__count : 1000}
result = Product.objects.aggregage(count = Count('id')) 
	
	
queryset = Customer.objects.annotate(is_new = Value(True))
	

queryset = Customer.objects.annotate(full_name = F(('first_name'), Value(' '), F('last_name'), function = 'CONCAT')
 #Here concat is the concat function database engine


                                   or  by Concat function

                                   full_name = Concat('first_name', Value(' '), 'last_name')



ExpressionWrapper:
dicounted_price = ExpressionWrapper(F('unit_price') * 0.8, output_field = DecimalField())
queryset = Product.objects.annotate(dicounted_price = discounted_price)



content_type = ContentType.objects.get_for_model(Product)

TaggedItem.objects.select_related('tag').filter(
   content_type= content_type,
   object_id = 1)     
   # this object_id is calculated dynamically eg., depending on the product that the user is looking for, we're going get the product id from the url



collection = Collection()
collection.title = 'Video Games'
collection.featured_product = Product(pk=1) or collection.featured_product_id = 1

 or 
 
collection = Collection(title='Video Games') --> this approach won't give IntelliSense
collection.save()


collection = Collection.objects.create(name = 'a', featured_product_id = 1)



collection = Collection(pk=11) #for updating # but this causes data loss if want to update a particular field
collection = Collection.objects.get(pk=11)
collection.title = 'Games'
collection.featured_product = None 
collection.save()

or

collection.objects.filter(pk=11).update(featured_product=None)      --> use only if you face performance problem


collection = Collection(pk=11)
collection.delete()


to delete queryset:
Collection.objects.filter(id__gt=5).delete()



@transaction.atomic()  as a decorator

or by context manager 
with transaction.atomic():



queryset = Product.objects.raw('SELECT * FROM store_product')  #the queryset we get here is completely different

	
cursor = connection.cursor()
cursor.execute('your sql statement')
cursor.close()

cursor.callproc('get_customers',[1,2])   used for writing stored procedures

Note: use the cursor statement inside the context manager (with)	
	
	



The Admin Site:
---------------

python manage.py createsuperuser

Everytime you add an app to INSTALLED_APPS, you need to run the migrate commands

python manage.py changepassword admin


admin.site.site_header = 'Storefront Admin'
admin.site.index_title = 'Admin'


To Register our models in the admin site: 
admin.site.register(models.Collection)     (admin.py of the respective app)


To override the default implementation of __str__:

def __str__(self):
   return self.title
   
   
   
Class Meta:
    ordering = ['title']
   


customizing the list page:

@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price']
	
or
admin.site.register(models.Product, ProductAdmin)


list_editable = ['unit_price'] #the fields that you want to edit on the admin page
list_per_page = 10 #10 items per page, also you get pagination at the bottom
ordering = ['first_name', 'last_name']



adding computed columns:

list_display = ['title', 'unit_price', 'inventory_status']

@admin.display(ordering='inventory')  # in list page to display in order
def inventory_status(self, product):
    if product.inventory < 10:
		return 'low'
	return 'ok'




Selecting Related Objects:

list_display = ['title', 'unit_price', 'inventory_status', 'collection']


To represent the particular field in the Collection:
list_select_related = ['collection']

list_display = ['title', 'unit_price', 'inventory_status', 'collection_title']


def collection_title(self, product):
	return product.collection.title





Overriding the Base QuerySet:

@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']
	
	@admin.display(ordering='products_count')
	def products_count(self,collection):
		return collection.products_count
	
	
	def get_queryset(self, request):
	    return super().get_queryset(request).annotate(
		    products_count=Count('product')
		)



Providing Links to Other Pages:

@admin.display(ordering='products_count')
def products_count(self, collection):
	url = reverse('admin:store_product_changelist')           #reverse('admin:app_model_page')
	return format_html('<a href="{}">{}</a>', url, collection.products_count)




To apply a filter, we need append a query string to the URL 

like this: ?collection__id=1


in code:

url = (reverse('admin:store_product_changelist') 
        + '?'
		+ urlencode({'collection__id' : str(collection.id)})
		)



Adding Search to the List Page:

search_fields = ['first_name', 'last_name']
search_fields = ['first_name__startswith', 'last_name__startswith']
search_fields = ['first_name__istartswith', 'last_name__istartswith']



Adding Filtering to the List Page:

list_filter = ['collection', 'last_update']


you can also create your own custom filter:

class InventoryFilter(admin.SimpleListFilter):
	title = 'inventory'
	parameter_name = 'inventory'
	
	def lookups(self, request, model_admin):
	    return[
		    ('<10', 'Low')
			]
			
	def queryset(self, request, querset):
		if self.value() == '10':
		    return queryset.filter(inventory__lt=10)
			
			
list_filter = ['collection', 'last_update', InventoryFilter]




Creating Custom Actions:

let's say to define a custom action for clearing the inventory of a bunch of products in one go. so we want set their inventory to zero.

@admin.action(description='Clear inventory')
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)
	self.message_user(
	    request,
		f'{updated_count} products were successfully updated.',
		messages.ERROR
		)


actions = ['clear_inventory']
	



Customizing Forms:

fields = ['title', 'slug']

exclude --> opposite of fields

exclude = ['promotions']

read_only = []


prepopulated_fields = {
   'slug': ['title']   
}

autocomplete_fields = ['collection']




Adding Data Validation:

in the model class -->

description = models.TextField(null=True)

we do still get after the above statement, to make this field optional in the admin interface 

description = models.TextField(null=True, blank=True)     


unit_price = models.DecimalField(
    max_digits=6,
	decimal_places=2,
	validators=[MinValueValidator(1)]
	)




Editing Children Using Inlines:

class OrderItemInline(admin.TabularInline):   or StackedInline
	model = models.OrderItem
	extra = 0
	min_num = 1
	max_ num = 10
	

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
	autocomplete_fields = ['customer']
	inlines = [OrderItemInline]
	list_display = ['id', 'placed_at', 'customer']
 




Using Generic Relations:

class TagInLine(GenericTabularInline)
    autocomplete_fields = ['tag']
	model = TaggedItem
	
	
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
	inline=[TagInline]




Extending Pluggable Apps:


create a new store_custom app
register it in INSTALLED_APPS

from django.contrib import admin
from store.admin import ProductAdmin
from tags.models import TaggedItem
from django.contrib.contenttypes.admin import GenericTabularInline

class TagInline(GenericTabularInline):
	autocomplete_fields = ['tag']
	model = TaggedItem
	
class CustomProductAdmin(ProductAdmin);
	inlines = [TagInLine]
	
	
admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)

	
	
	
	
	
Django REST Framework:
----------------------

pipenv install djangorestframework

after installing --> register it in setting.py file of your project folder (note: put it before all the apps)

INSTALLED_APPS = [
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.contenttypes',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
	'rest_framework', 
]



@api_view()
def product_list(request):     --> replaces the request object that comes with django with the restframework request object 
    return Response('ok')



#URLConf
urlpatterns = [
    path('products/', views.product_list),
	path('products/<int:id>/', views.product_detail),
]

@api_view()
def product_detail(request, id):
	return Response(id)




Serializing: 

model --> python dictionary(serializing helps us to convert model into dictionary) --> JSONRenderer(cls) render(dict) --> JSON Object

#serializers.py
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)        # apiguide --> serializer fields in django-rest-framework.org


#views.py
import the respective model class from models.py
import the respective serializer class from from serializers.py

@api_view()
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	serializer = ProductSerializer(product)  ---> serializer.data(python dictionary)
	return Response(serializer.data)  --> under the hood -- at some point, Django is going to create a JSON render object and give this dictionary, the JSON 
	                                       renderer will convert that dictionary to a JSON object and that JSON Object will end up in the response
										   
										   
										   
to avoid decimal to string in the response, in the settings.py
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
}	 


product doesnotexist:

except Product.DoesNotExist:
	return Response(status=status.HTTP_404_NOT_FOUND) 


	
instead of try and except block --> use get_object_or_404:

product = get_object_or_404(Product, pk=id)



we can also pass queryset to the serializer:

queryset = Product.objects.all()
serializer = ProductSerializer(queryset, many=True)


creating custom serializer fields:
price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')


def calculate_tax(self, product: Product):
	return product.unit_price * Decimal(1.1)



if you want rename the field in the serializer class which is different from the model:
price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



serializing Relationships:
1. Primary key
2. String
3. Nested object
4. Hyperlink


way 1 -->
in the serializer class:
collection = serializers.PrimaryKeyRelatedField(
	queryset = Collection.objects.all()
)

way 2 -->
collection. serializers.StringRelatedField()   --> remember to use select_related/prefetch_related if necessary or else you'll end with more queries


way 3 --> as a nested object

#define the respective serializer of the nested object
class CollectionSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length = 255)


#in ProductSerializer class:
collection = CollectionSerializer()


way 4 --> hyperlink to an endpoint for viewing that object 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

urls.py -->
path('collections/<int:pk>/', views.collection_detail, name='collection-detail')


views.py -->
@api_view
def collection_detail(request, pk):
    return Response('ok')


in ProductSerializer class:
serializer = ProductSerializer(queryset, many=True, context={'request': request}) 





Model serializers:  two places, in model and serializer, so a better way)

class ProductSerializer(serializer.ModelSerializer):
	class Meta:
		model = Product
		fields = ['id', 'title', 'unit_price', 'collection', 'price_with_tax']
	
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)
		
		

By default ModelSerializers use primary key related fields, if you don't want it. you can override it easily

example, in the same class above, define 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

also for custom serializers you can override it. 
    fields = ['id', 'title', 'price', 'collection']

price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



Deserializing Objects:

@api_view(['GET', 'POST'])
def product_list(request):
	if request.method == 'GET':
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)
	elif request.method == 'POST':
		serializer = ProductSerializer(data=request.data)  #the deserialized data will be available at serializer.validated_data, but before that we need to  validate the data
		


Data Validation:

if serializer.is_valid():
    serializer.validated_data
	return Response('ok')
else:
	return Reponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


or by cleaner way
serializer.is_valid(raise_exception=True)  ---> we don't need if else block
serializer.validated_data   --> ordereddict



by default, validation rules comes from the definition of model fields. So, if we need anything extra, 
we need to override the validate method in our serializer


So, in our serializer class:
def validate(self, data):
	if data['password'] != data['confirm_password']:
		return serializers.ValidationError('Passwords do not match')
	return data




Saving Objects:

our Model serializer has save method ( used for creating or updating)

right after validating the data
serializer.save() and we don't need serializer.validated_data after this\


Now there are situations where we want to override how a product is created

in serializer class:

def create(self, validated_data):
	product = Product(**validated_data)
	product.other = 1
	product.save()
	return product
	
we can override the update method:

def update(self, instance, validated_data):
	instance.unit_price = validated_data.get('unit_price')
	instance.save()
	return instance


The save method will call one of the above methods depending on the state of the serializer.



For updating:

@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)




Deleting Objects:

@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
	elif request.method == 'DELETE':
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)



Note: for query optimization: 
queryset in view function --> annotate 
queryset in the Model class.
in the admin_model also --> get_queryset





Advanced API Concepts:

class Based Views:

Django provides more features over class based views


from rest_framework.views import APIView

class ProductList(APIView):
	def get(self, request):
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)

	def post(self, request):
		serializer = ProductSerializer(data=request.data) 
        serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
		
				
in urls.py:

path('products/', views.ProductList.as_view()),

			
			
class productDetail(APIView):
	def get(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product)
		return Response(serializer.data)
		
	def put(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data) 
		
	def delete(self, request, id):
		product = get_object_or_404(Product, pk=id)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in urls.py:

path('products/<int:id>/', views.ProductDetail.as_view()),

		
			
ModelSerializer and HyperLinkedModelSerialzer.



cs
# import serializer from rest_framework
from rest_framework import serializers

# create a serializer
class CommentSerializer(serializers.Serializer):
	# initialize fields
	email = serializers.EmailField()
	content = serializers.CharField(max_length = 200)
	created = serializers.DateTimeField()



Mixins:
from rest_framework.mixins import ListModelMixin, CreateModelMixin




Generic Views:

you dont't use mixins directly most of the time, instead you use them with concrete classes that combines one or more mixins, we call these classes Generic views.
ListCreateView
ListAPIView
RetrieveAPIView
etc.


class ProductList(ListCreateAPIView):

	queryset = Product.objects.select_related('collection').all()
	serializer_class = ProductSerializer
		
	 or

#if there's any logic you can define a method
	def get_queryset(self):
		return Product.objects.select_related('collection').all()
		
	def get_serializer_class(self):
		return ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}

from rest_framework.generics import ListCreateView

Another advantage of using generic view is that in the web, you get the sample json format



Customizing Generic Views:

class ProductDetail(RetrieveUpdateDestroyAPIView):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def delete(self, request, pk):
		product = get_object_or_404(Product, pk=pk)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in the above delete function 'id' is changed to 'pk', since Generic views expects pk parameter and uses it internally  
in the urlpatterns --> path('products/<int:pk>/', views.ProductDetail.as_view())





ViewSets:
Using a view set, we can combine the logic for multiple related views inside a single class. 


from rest_framework.viewsets import ModelViewSet


class ProductViewSet(ModelViewSet):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}
	
	def destroy(self, request, pk):      #note modelViewSet has destroy method not delete method
		if OrderItem.objects.filter(product_id=kwargs['pk']).count > 0   (changing the logic, since self. fetching product already)
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		return super().destroy(request, *args, **kwargs)


Check for ReadOnlyModelViewSet and other viewset



Routers:
from rest-framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

Now the urls will be available at --> router.urls


so, 
#URLCONF
urlpatterns = router.urls

if you have other urls

urlpatterns = [
 path('', include(router.urls)),
]


from rest-framework.routers import DefaultRouter




Building the Reviews API:

Building the Model:
create a model model class
create a migration
apply a migration


Building the API:
create a serializer
create a view
register a route



Nested Routers:

nested routers --> https://github.com/alanjds/drf-nested-routers


Note: if you want pass anything from the request(from the user) in viewset to the serializer, we use context 


class ReviewViewSet(ModelViewSet):
	serializer_class = ReviewSerializer
	
	def get_queryset(self):
		return Review.objects.filter(product_id=self.kwargs['product_pk'])
	
	def get_serializer_context(self):
		return{'product_id': self.kwargs['product_pk']}

		
class ReviewSerializer(serializer.ModelSerializer):
	class Meta:
		model = Review
		fields = ['id', 
		
	def create(self, validated_data):
	    product_id = self.context['product_id']
		return Review.objects.create(product_id=product_id, **validated_data) 






Filtering:

/products?collection_id=1

in the ProductViewSet:

overriding the get_queryset function:

def get_queryset(self):
	queryset= Product.objects.all()
	collection_id = self.request.query_params.get('collection_id')
	if collection_id is not None:
		queryset = queryset.filter(collection_id=collection_id)
	
	return queryset  


also remember to add basename to the respective router since we overridden the get_queryset, django will unable to set the basename

in urls.py --> router.register('products', views.ProductViewSet, basename='products')







Generic Filtering:

pipenv install django-filter

add it in the list of installed apps, remember while adding, it is 'django_filters'

from django_filters.rest_framework import DjangoFilterBackend


in ProductViewSet -->

filter_backends = [DjangoFilterBackend]
filterset_fields = ['collection_id']

and bring back the queryset to 
queryset = Product.objects.all()

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Searching:
from rest_framework.filters import SearchFilter

in ProductViewSet -->

filter_backends = [DjangoFilterBackend, SearchFilter]
search_fields = ['title', 'description'] also we can reference fields in related classes 'collection__title'



Sorting:

from rest_framework.filters import SearchFilter, OrderingFilter


filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]

ordering_fields = ['unit_price', 'last_update']



Pagination:
from rest_framework.pagination import PageNumberPagination


in the ProductViewSet class:
pagination_class = PageNumberPagination

To specify the pagesize:
in the settings.py -->
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.pagination.PageNumberPagination',  #pagination applied to all endpoints
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.LimitOffsetPagination',  #if you want limit and offset type pagination instead of page number
	 'PAGE_SIZE': 10
}	 


to surpass the error: mention page_size but not mentioned default_pagination_class

pagination.py
-------------
from rest_framework.pagination import PageNumberPagination


class DefaultPagination(PageNumberPagination):
	page_size = 10
	
	
and now you can remove the PAGE_SIZE in the settings.py
 and in the ProductViewSet --> pagination_class = DefaultPagination




Designing and Implementing a Shopping Cart API:

from uuid import uuid4
id = models.UUIDField(primary_key=True, default=uuid4)










Django Authentication System:
------------------------------

INSTALLED_APPS -->	'django.contrib.auth' -->  contains this

tables --> auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions

MIDDLEWARE --> "django.contrib.auth.middleware.AuthenticationMiddleware" -->


customizing the user model:

extending the user model 
have a profile model and that model will be having one to one link to user model 


use 2nd approach --> 
1st type --> use only for authentication (For storing attributes related to authentication)
2nd type --> for storing non-auth related attributes


Extending the User Model:


#class User(AbstractUser):
	email = models.EmailField(unique=True)
	
	
in the settings.py:
	
AUTH_USER_MODEL = 'core.User'




if other apps depends on this user class:
from django.conf import settings
user = models.ForeignKey(settings.AUTH_USER_MODEL,...) 	



to register the custom user model:

from django.contrib.auth.admin import UserAdmin as BaseUserAdmin

@admin.regis(User)
class UserAdmin(BaseUserAdmin):
	pass