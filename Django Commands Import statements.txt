To Learn:
---------


Learn what is schema

learn env, venv, pipenv

Jinja templating, django default templating

Django data models

Django field types -> https://docs.djangoproject.com/en/5.0/ref/models/fields/
https://www.geeksforgeeks.org/django-model-data-types-and-fields-list/

date time field (auto_now_add, auto_now)

in field option --> choice field

one-to-one relationship --> in the child class --> the column value key field from parent class should be set 'primary_key = True'

related_name, reverse relationship
related_name = '+' --> tells django not to create the reverse relationship

circular dependency or circular relationship and how to solve them

ContentType

 content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
 object_id = models.PositiveIntegerField()
 content_object = GenericForeignKey()
 
 
Inner class Meta --> class Meta (explore)

django model metadata  --> https://docs.djangoproject.com/en/5.0/ref/models/options/




Django ORM --> learn about Managers and QuerySets
.Objects. --> manager --> interface 

queryset get evaluated --> iterate, converting it in to list, accessing a single element  --> lazily evaluated

Learn Building complex query using Django ORM

queryset api  --> https://docs.djangoproject.com/en/5.0/ref/models/querysets/



Learn select_related, prefetch_related very well
also learn chaining select_related with prefetch_related



django database functions -->  https://docs.djangoproject.com/en/5.0/ref/models/database-functions/


learn about contentTypes in django


Django ModelAdmin --> https://docs.djangoproject.com/en/5.0/ref/contrib/admin/  --> ModelAdmin options


Django validators --> https://docs.djangoproject.com/en/5.0/ref/validators/ 


url conf in django


resource -- object -- model -- entity 


https://www.django-rest-framework.org/  
  apiguide --> serializer fields
               Generic Views



change detection mechanism doesn't work sometimes. you need to restart the server. 

httpstatuses

nested routers --> https://github.com/alanjds/drf-nested-routers

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Django import statements:
---------------------------

from django.shortcuts import render (default - Views.py - to render html)
  eg: return render(request, 'hello.html')
  eg: return render(request, 'hello.html', {'name': 'Mosh'})
from django.http import HttpResponse (Views.py)  
  eg: return HttpResponse('Hello World')
  
from django.urls import path (in apps urls.py)
from django.urls import path, include (in project urls.py)

from django.db import models (default - models.py)


from django.contrib.contenttypes.models import ContentType ( models.py - to define generic relationship, to find the content_type)
from django.contrib.contenttypes.fields import GenericForeignKey

from django.contrib.auth.models import User

from django.core.exceptions import ObjectDoesNotExist(views.py --> queryset,if we don't get the object we're looking for)

from django.db.models import Q, F, Func, ExpressionWrapper (Q - to combine the conditions using OR Operator, F - to represent a particular field)


from django.db.models.aggregates import Count, Max, Min

from django.db.models import Value 

from django.db.models.functions import Concat

from django.contrib.contenttypes.models import ContentType (in views.py)
from store.models import Product
from tags.model import taggedItem 


from django.db import transaction
from django.db import connection


from django.utils.html import format_html, urlencode ( in admin.py)
from django.urls import reverse( in admin.py)

from django.contrib import admin, messages


from django.core.validators import MinValueValidator

from django.contrib.contenttypes.admin import GenericTabularInline, GenericStackedInline



#rest_framework
from rest_framework.decorators import api_view
from rest_framework.response import Response

from rest_framework import serializers
from rest_framework import status

from django.shortcuts import get_object_or_404

from decimal import Decimal

from rest_framework.views import APIView
from rest_framework.mixins import ListModelMixin, CreateModelMixin

from rest_framework.viewsets import ModelViewSet

from rest_framework.routers import SimpleRouter

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter

from rest_framework.pagination import PageNumberPagination









 
from django.contrib.auth.models import AbstractUser


======================================================================================================================================================================================

Django :
---------

pip install django / pipenv install django(if you want to use pipenv)

django-admin startproject my_proj   / django-admin startproject my_proj . (tells django to use current directory as project Directory)
cd my_proj

manage.py --> wrapper of Django-admin

python manage.py runserver 9000 (optionally, we can supply the port number, by default it will take port 8000)

pipenv --venv ( to check python interpreter in the local venv)








To create a new app:
-------------------
python manage.py startapp app_name

Note : Once you created a new app, you have to register the app in the 'INSTALLED_APPS' in the project settings folder

for example:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]







views.py and urls.py:
-------------------
HTTP is a request response protocol. So, every data exchange involves a request and a response. Every app has view.py and this is where we define our views or view functions. A view function is a function that takes a request and returns a response. So more accurately, it's a request handler. In some frameworks, it's called an action. In Django, it's called a view. But I don't agree with this name because from an architectural point of view, a view is often associated with something that the user sees. That part in Django is called a template. 



from django.http import HttpResponse

def say_hello(request):
	return HttpResponse('Hello World')



Now in this function, we can do anything we want. In a real-world scenario we can pull data from a database, we can transform data, we can send emails and so on. Learn the functionalities of views.py.

Now we need to map this view to url, so when we get a request at that url, this function will be called.

apps --> urls.py:	
	
from django.urls import path
from . import views

#URLConf
urlpatterns = [
    path('hello/', views.say_hello)
 ]	
	

Note: we have 'urlpatterns' variable(all in lower case), which is an array of url pattern objects, we use path() function to create a url patter object

The parameters of path function --> (route: str, view: (*args: Any, **kwargs: Any) -> HttpResponse, kwargs: Dict[str, Any] = ...) -> URLPattern

Now, what we have here is URLConf module, which basically means URL Configuration. So, every app can have its own URL Configuration. But now we need to import this URL Configuration into the main URL Configuration for this project
	
projects --> urls.py:

use the include function from django.urls

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
   path('admin/', admin.site.urls),
   path('playground/', include('playground.urls'))
  ]

So, if the user sends the request to playground/hello, Django knows that all requests that start with playground should be handled by the playground app. So it's going to chop off the first part of this URL 'playground/' and Pass the rest 'hello' to the URL configuration module in the playground app. 




Using Templates:
----------------
So I told you that views in Django are not really views. They're more like request handlers or actions. What we often call a view in other frameworks is called a template in Django.

Add templates folder in any app and then html file inside (say templates/hello.html)

Then in views.py:

from django.shortcuts import render

def say_hello(request):
	return render(request, 'hello.html') 
	

or we can also dynamically render the content, just we need to add another parameter which provides the context 
return render(request, 'hello.html', {'name': 'Mosh'})  --> now you have name parameter in the html content. For more details learn jinja template engine or django template engine




Django Debug toolbar:
---------------------
https://django-debug-toolbar.readthedocs.io/en/latest/

Follow the instruction in the Installation page:

python -m pip install django-debug-toolbar 

of if you're inside virtual env --> pipenv install django-debug-toolbar

Then as said follow the instructions in the Installation page









Data Model: 
-----------
The first step in every Django project is figuring out the pieces of data we want to store. So, what entities or concepts do we have in an application? we need analyze and have a separate chart for that.

eg: product, collection, cart, etc

learn to how to organize models in apps (monolith, self contained, each individual)


models.py:
---------

django field types: https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field types, Field Options

from django.db import models

class Product(models.Model):
	title = models.charField(max_length=255) #varchar(255)
	description = models.TextField() 
	price = models.DecimalField(max_digits=6, decimal_places=2) # floatfield has round issues, so for monetary values always use decimal field  #9999.99
	inventory = models.IntegerField()
	last_update = models.DateTimeField(auto_now=True)
	
Now when we finished writing models for each entities, we need to migrate, then you will see that we can generate our database tables based on the definition of this model. So then we're going to have a table called 'product' and in that table we're going to have a column called 'title' and the type of that column is going to be varchar of 255. 


we want some random field to be primary key instead of one generated by django itself,
sku = models.CharField(max_length=10, primary_key=True)
With this Django is not going to create an ID field and make it the primary key. So, 'sku' is going to be our primary key. 


Choices in Field Options:  
-------------------------

https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field Options --> Choices


class Customer(models.Model):
	MEMBERSHIP_BRONZE = 'B'
	MEMBERSHIP_SILVER = 'S'
	MEMBERSHIP_GOLD = 'G'
	
	MEMBERSHIP_CHOICES = [
		(MEMBERSHIP_BRONZE, 'Bronze'), 
		(MEMBERSHIP_SILVER, 'Silver'), 
		(MEMBERSHIP_GOLD, 'Gold'),
	]
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)
	membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
	

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)




Defining relationships between models:
-------------------------------------

Defining one-to-one Relationships:
---------------------------------
Assume that every customer should have one and only one address, and each address should belong to one and only one customer. So here we have a one-to-one relationship between customers and addresses.

As you probably know, a database relationship has two ends, a parent and a child. The parent should exist before we can store the child, So, we need to define cutomer model first and then address model and then we can create relationship between these two in the child model. 


class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.OnetoOneField(Customer, on_delete=models.CASCADE, primary_key=True)




The argument 'on_delete' specifies the delete behavior. What should happen when we delete a customer or a parent field. So, if we put on_delete to 'models.CASCADE', when we delete a customer the associated address will also be deleted. 
This is called the cascade behavior. Alternatively if this field accepts null values we can use set null(models.SET_NULL). So, when we delete a customer or the parent record, the child record(or the address in this case) is not going to get deleted. It's going to stay in the database and the customer field or the customer column is going to get set to null. Alternatively, we can use 'models.SET_DEFAULT;. So this field will be set to its default value. And one other option we have is models.PROTECT. And with this, we can prevent the deletion. So, if there is a child associated with this parent, we cannot delete that parent, we have to delete the child first.

Now, which value we use really depends on the requirements. There is no one size fits all. In this case, I believe we should use cascade. Because if we delete a customer, the associated address should also be deleted.

Now there is one more argument we need to set is 'primary_key=True'. If we don't set this, Django will create another field here called ID. So, every address is going to have an ID. And that means we're going to end up with a one-to-many relationship between customers and addresses, because we can have many addresses with the same customer. But if we make the customer field as a primary key, we can only have one address for each customer, because primary keys don't allow duplicate values, right? 
So this is how we can implement a one-to-one relationship between two models. Now, you might be wondering if we should define the reverse relationship in the customer class. In other words, do we have to go to the customer class and add a new field called 'address' for the reverse relationship. No, we don't have to do that because Django will automatically creates this for us. 




Defining a one-to-many Relationship:
-----------------------------------

Now let's assume that a customer can have multiple addresses. So we want to change this one-to-one relationship to one-to-many relationship. How can we do this? Really easy. First we need to change the type of the field to foreign key. So we're telling Django that customer is a foreign key in the address table. Okay? Next we need to remove field option 'primary_key=true'. Because we want to have multiple addresses for the same customer. So, we want to allow duplicate values in the customer column. This is how we can define a one-to-many relationship between two models. 

class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)


Other examples as follows:
Collection - Product
Customer - Order
Order - Item
Cart - Item


class Collection(models.Model):
    title = models.CharField(max_length=255)
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
	
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()
	
	
	

Defining Many-to-Many Relationships:
-----------------------------------

Let's talk about many-to-many relationships. So, I'm going to introduce a new class called Promotion and define a many-to-many relationship between promotions and products.

class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()


Now we can define the relationship in either of these classes. And as i said earlier, Django will automatically create the reverse relationship. Now in this particular case, it makes more sense to define the relationship in the product class because we might have a product that we're showing to the user and at the same time, we want to show all the promotions apply to that product.
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

Now with this implementation, Django is going to create the reverse relationship in the Promotion class. So, in the Promotion class, we're going to have a field called 'Product_set' that returns all the products that a particular promotion is applied to, if you don't like the name You can always change it. So, in our product class, we can supply a keyword argument related_name='products'. Django will use this name as the name of the field in the promotion class. So instead of 'product_set' we're gonna have a 'products'. 

Just remember, if you change the default convention in Django, it's best to change it consistently everywhere, otherwise in some classes you're going to have a field 'products', and in some other classes you're going to have a field 'product_set', and this makes your code really ugly.





Resolving Circular Relationships:
--------------------------------

I told you that sometimes we can have multiple relationships between two models. So, here we have two relationships between collection and product (relationship between Collection and product - one to many, collection and featured_product - zero to one) 

Now, out of the two, You have only implemented the one-to-many relationship. Now, as part of implementing the other relationship, we're going to face a situation called a circular dependency, which is something we should avoid. A Circular dependency happens when two classes depend on each other at the same time. So the product class is going to be dependent on the collection class and And at the same time, the collection class is gonna be dependent on the product class.

Before in the product class, we have a field called 'collection', which is a foreign key to the collection class. So, we had a dependency from the product class towards the collection class(product -> collection). Now, to implement the other relationship, we have to go to the collection class and add a new field featured_product. But while mentioning the 'Product' class name, it will throw an error. We are seeing this error, because the product class is defined after the collection class. 
Now this is where we have a circular dependency. So, in the Product class, we have a dependency to the Collection class. And that's why we define the Collection class before the product class. However, because of the circular dependency, now the Collection class also needs to be dependent on the Product class, which is not possible. To solve this problem, We need to wrap the 'Product' class argument in quotes. However, this introduces a new kind of problem. If tomorrow we decide to rename this Product class to something else, the string that we passed is not going to get updated.

One more error, we might get is reverse query name for featured_product clashes with field name 'collection'. So, in the Collection class we have a field called featured_product, right? Now as you know Django is going to automatically create the reverse relationship for us. So that means, in the product class, we're going to have a field called collection, which represents the other end of the relationship. And this is exactly where the problem happens. Because in the product class, we already have a field called collection. 
So, Django cannot create the reverse relationship because of the name clash. So here we have two choices. One solution is to set related name to something other than collection, or if we don't care about the reverse relationship, we can simply pass a plus sign '+'. This tells Django not to create that reverse relationship.

Also, we're going to set on_delete=models.SET_NULL, because if we delete a product and that product happens to be the featured product for a collection, we want to set the field to null. And that means we can make this field nullable. Also, we can pass another keyword argument 'null=True'. 

class Collection(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey(
        'Product', on_delete=models.SET_NULL, null=True, related_name='+')


class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)






Generic Relationships:
----------------------

So, I told you that we want to design the tags app such that we can reuse it in any projects. Anywhere we want to have the ability to tag items. That's why we have two models(entities) in this app. Tag, which represents an actual tag, and TaggedItem, which represents a tag applied to a particular item, which can be a product, a video, an article, literally anything. So let's see how we can implement these models. 

from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class Tag(models.Model):
    label = models.CharField(max_length=255)


class TaggedItem(models.Model):
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()



INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]




The first model is Tag, we simply do it as usual, nothing special about it. The second model, is bit tricky, first we can have the attribute tag and it's a foreign key to the Tag class. Again, nothing new so far. Now, the interesting part is identifying the object that a particular tag is applied to. The poor way of implementing is adding a field called product, then settingit to a foreign key to the Product class. Now with this implementation, we have to import the Product class on the top and that means the tags app is going to be dependent on the store app. What if tomorrow we want to tag articles or videos? These are completely different apps. So, the tags app should know nothing about these models. 

What we need here is a generic way to identify an object. To do that, we need two pieces of information. The first one is the type of an object, which can be product, video, article, whatever. The second attribute is the id of that object. Using these two pieces of information, we can identify the objects in our application, or in Database terms, we can identify any record in any tables. 

Because using the type, we can find the table, and using the ID, we can find the record, right? So instead of using a concrete model like product, we should use an abstract model called ContentType, which comes with Django.
So earlier, we talked about the list of installed apps in the settings module. There we have an app called Contenttypes. Using this Contenttypes, we can create generic relationships within our models. So ContentType is a model that represents the type of an object in our application. Now, we need to import this on the top --> 'from django.contrib.contenttypes.models import ContentType'  So, this is a model just like any model that we have in our application. But this model is specifically made for allowing generic relationships. Also setting the on_delete to cascade because if that object type is removed we want to remove all the associated tags. 


Now, the second attribute we need here is the id of the target object. So, we can set the field object_id. And this has to be a positive integer field. Because we're assuming that every table is going to have a primary key. And all primary keys are positive integers. Now what if in a particular table, our primary key is not an integer, let's say it's a GUID. Well, in that particular case, this solution is not going to work. So this is the limitation of this solution. So now, with these two pieces of information, we can identify any object in our application. 


Now, one last thing. When querying data, We might want to get the actual object that this tag is applied to, like the actual product. To do that We're gonna add another field called content_object and set this to a particular type of field called GenericForeignKey (imported on the top). Now, using this field, content object, we can read the actual object that a particular tag is applied to. So, let's quickly recap. To define a generic relationship, there are three fields we need to define. content_type, object_id, and content_object.

exercise:

I want you to create an app called likes for tracking the objects that a user likes. So in this app, we're going to have a model called LikedItem. And using an instance of this model, we can tell what user likes what object. So here we need a field called user, which is going to be a foreign key to the user class defined in the model django.contrib.auth.models. So auth is another app that is automatically installed in every Django project. And using this app, we can authenticate and authorize users. 


App: Likes

LikedItem
 -what user likes what object
 -user: ForeignKey to User(django.contrib.auth.models)


likes/model.py:

from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()


So, We have created a new app called likes. And in this app, we have a new model called LikedItem. Now here we have four fields. We have user, which is a foreign key to the User class defined in django.contrib.auth.models. Now here for on_delete, I've used cascade. so if a user is deleted, we want all the objects that the user has liked to be deleted as well. Then we have three fields exactly like before, no changes. We have content_type for identifying the type of an object that the user likes, we have object_id for referencing that particular object, and content_object for reading an actual object. 





Setting up the database and Django Migrations:
----------------------------------------------
Django supports many database management systems. The most basic one that is set up by default is SQLite, which is a very basic, lightweight database engine. You should use it only for development or for low-traffic websites, nothing serious than that. For any serious projects, you should use PostgreSQL, MySQL, MariaDB, or Oracle. These database engines are officially supported by Django, but they're also third-party libraries for other database engines like Microsoft SQL Server. Now, out of all these options, Postgres and MySQL are the two most common database backends used in the Django community. In this section, we'll start off by having a quick look at SQLite, and then shortly after, we'll switch to MySQL for the rest of the course. Now, don't worry if you have never worked with MySQL, we're not going to use any fancy MySQL features. 
All you have to do is install MySQL. Now, if you don't want to use MySQL and prefer a different database engine like Postgres, that's totally fine with me. But I'm not going to cover connecting the project to Postgres. You need to research it on your own. So next, we're going to talk about creating migrations.


In Django, we use migrations to create or update our database tables based off of the models we have in our project. So, in django projects, we're not going to manually create or modify our database tables. We're going to let django take care of that.

Once you run, 

python manage.py makemigrations 

Django looked at all the installed apps in our project, and for each app, it created a new migration file.

makemigrations basically generates the SQL commands for preinstalled apps (which can be viewed in INSTALLED_APPS in settings.py) and the newly created apps which you add in INSTALLED_APPS
   
Note: remember to add all apps to 'INSTALLED_APPS', or else django wouldn't detect any changes 

Note: slug --> slug is when you go to the stack overflow and if you search for a question in the address bar you can see the id of the question and the actual question itself(https://stackoverflow.com/questions/4492979/error-git-is-not-recognized-as-an-internal-or-external-command), what you see there is called a slug.  Slug can only contain letters, numbers, underscores and hyphens. So, any other characters other than these is going to be replaced by any special character like hypens or even removed. Now the whole point of adding a slug here is to make it easier for search engines to find our content. So this is a search engine optimization technique. 
 
 
 
 
 
 
we have a bunch of migrations at this point where each migration describes a set of changes. So each migration is like a commit in a version control system like GIT, right? Now we're going to run these migrations to generate our database schema. 

So, in the terminal, 
python manage.py migrate  ----> Django will go through all the installed apps and executed all the pending migrations. 


Now, where is our database? Well, if you look at the Explorer panel, you can see a file called db.sqlite3. So, this is our SQLite database, which is a very lightweight database you should only use for development or very small websites. Now, in thevVS Code, we have an extension called SQLite, which we can use. for opening a SQLite database. 
 
There are also other tools like there is a tool called DB Browser for SQLite which you get it from sqlitebrowser.org. It's a free but crappy application, but it gets the job done.  
 
Shift + ctrl + P --> SQLite: Open Database --> you can select the database in the list --> open the explorer panel --> SQLITE EXPLORER 
 
For betterment, switch to mysql
 
Now here you can see our database as well as all the tables we have in the database. So, we have a bunch of tables that belong to the auth app. These tables are used for authenticating and authorizing users. We'll talk about them later in the course. Then we have three tables that are used by Django to do its job. 

django_migrations -->  This table keeps track of the migrations that have been applied to this database.






Customizing Database Schema:
----------------------------

Sometimes you need more control over the database schema. For example, you may want to overwrite the name of a table or you may want to add an index to a couple of columns and so on. For that you need to add meta class inside the model class and information about the these meta class you can go search for 
django model metadata --> https://docs.djangoproject.com/en/5.1/ref/models/options/


class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
		
	
	class Meta: 
		db_table = 'store_customer'
		indexes = [
				models.Index(fields=['last_name', 'first_name'])
		]
		

once after you have done some changes in model classes, you have to do migrations. 

For better naming to come up in migrations file, write a bit of code to solve a specific problem, create a migration, and then move on to the next problem. Or else you would get some random name. 




Reverting Migrations:
---------------------

python manage.py migrate store 003 (migrate to a specific migration)

Once you done this step, the changes would be reflected in both django_migrations table and in the database. But the changes are still in the code and migration file specific to that changes will be still available in the migrations folder. so, the next time you run python manage.py migrate, these changes will be applied. So, the proper way is to delete the unwanted migration file and erase all respective changes in the code 	

Hence this is where we use version control systems like git. Undoing code using a version control system like git is a lot easier than manually removing code from different places.  
  
git log --oneline  --> This shows the list of commits you've made so far

git reset --hard HEAD~1   --> to move the head pointer one step back i.e. to the previous commit
	






install mysql

install any mysql clients and connect with it 

mysql clients:
Mysql workbench(free)
TablePlus
DataGrip

We have to create the database first before we can connect with it using Django. So even if you're not using DataGrip, let's say if you're using MySQL Workbench, you need to create a database called storefront or whatever you want to call it.

to check mysql connection is proper:
mysql -u root -p

if you you get an error:
it might be due to MySQL not installed properly
MySQL is not in the path

The next step is to connect our Django project to MySQL --> to do that we need to install a package --> pipenv install mysqlclient



The next is to change the database settings:
go to the settings.py in the project directory , shift + ctrl + o (Go to symbol in the current working file, type 'DATABASES')

DATABASES = {
 'default' : 'django.db.backends.mqsql',
 'NAME' : 'storefront',
 'HOST' : 'localhost',
 'USER' : 'root',
 'PASSWORD' : 'Mypassword'
  }
 }



You should not get any errors at this point. So your server should be still up and running. If you get any errors, then you have to stop and troubleshoot. Otherwise, you should run the migrations. So, all the tables are created in our MySQL database. So let's open a new terminal window and run Python manage.py migrate.


	
python manage.py makemigrations store --empty

class Migration(migrations.Migration):

	dependencies = [
		('store', '003_add_slug_to_product'),
	]
		
	operations = [
		migrations.RunSQL('''
			INSERT INTO store_collection (title)
			VALUES('collection1')
        ''', '''DELETE FROM store_collection
				WHERE title='collection1'
		'''
	]

The first one is for upgrading our database. The second one is for downgrading. 

python manage.py sqlmigrate store 0003  --> to see the actual sql code that is sent to our database at runtime.


Generating Dummy Data --> mockaroo.com









Django ORM:
-----------

We can query and manipulate data using Django ORM or Object Relational Mapper. we can also filter, sort and group data and much much more. 

Let's start off this section by a quick overview of object relational mappers and the problem they try to solve. So, you know that in relational databases, data is stored as rows in tables. So when pulling up data from a relational database, we need to map these rows into objects. In the past, we used to do this by hand and this was pretty repetitive and time consuming. So, we would have to write a SQL query, send it to the database, read the result, and map it to a bunch of objects. So for each record, you'll have to create a new object and set its attributes. This is where an object relational mapper comes into the picture. An object relational mapper, as the name implies, maps objects to relational records, and that frees us from writing a lot of repetitive code. 

So, using an object relational mapper, we don't have to write SQL code to query or manipulate data. We can code in an object-oriented programming language like Python. The URL will then translate our Python code into SQL code at runtime. So, does it mean we never need to write SQL? No. When dealing with complex problems, ORMs can't produce efficient SQL queries. So that's when we need to jump in and write optimized SQL queries by hand. But overall, ORMs help us reduce complexity in our code, make it more understandable, and get more done in less time. A good example of that is Django migrations. Using these migrations, we generate our database tables almost instantly. We don't have to write any sequel code or use a tool like data grip to create our tables add relationships indexes and so, Django migrations take care of all of that for us. 

So, migrations are part of Django ORM. Also all the model classes we have created so far inherit from the model class in Django. This model class is also part of Django ORM. So, as you will see in this section all our model classes inherit the functionality to query or manipulate data from the base model.Model class. Now, once in a while, you see someone like our popular John Smith, who hates ORMs and prefers to write every bit of code by hand because he believes ORMs are slow. What John is missing here is that he doesn't understand that the more code he writes, the more bugs he or someone else has to fix in the future. There is an old saying that says, the best code is no code. 

Writing and maintaining all that extra code costs time and money. Someone is paying for it, your employer or your client. If you were that person, you wouldn't want someone else wasting your money writing code that was unnecessary, right? Throughout my career, I've seen so many projects over-engineered by people like John that never made it into production. In my opinion, a good software engineer is one who delivers working software in time. Building the best, most optimized solution that will never make it to production is not something to be proud of. So use the right tool for the job. As I said, ORMs don't perform well when dealing with complex queries, but that doesn't mean we should never use our apps We can use them in a lot of cases, perhaps for the most part. 
Remember the old saying, premature optimization is the root of all evils. So don't optimize your code unless you have proof that is slow. So that's it for the Django. Orm. Let's move on to the next lesson.




Managers and Querysets:
-----------------------

Alright, the first thing you need to understand about Django ORM is the concept of managers and query sets. Every model in django has an attribute called objects. And this returns a manager object. A manager is an interface to the database. It's like a remote control with a bunch of buttons that we can use to talk to our database. 

product.objects.

So here we have a bunch of methods for querying or updating data. For example, we have 'all' for pulling out all the objects in the products table. We also have 'get' for getting a single object. We have filter for filtering data and so on. Now, most of these methods, like the 'all' method, returns a query set. So when we call this method, we don't get a list of products. We get a query set object. A query set is an object that encapsulates a query. So at some point, Django is going to evaluate this query set and this is when Django will generate the right SQL statement to send to our database. But when will this happen? Well, under a few scenarios. One scenario is when we iterate over a query set.

query_set = Product.objects.all()

for product in query_set:
	print(product)
	
	
	
list(query_set)

query_set[0]/ query_set[0:5]


query_set = Product.objects.all()
query_set.filter().filter().order_by()


query_set = Product.objects.count()
 
So if you write 'for product in query set', at this moment, Django will evaluate this query set and get the result from the database. So, one scenario where a query set is evaluated is when we iterate over it. Another scenario is when we convert it to a list. So if we call the list function and give it a query set, the query set will be evaluated. Another scenario is when we access individual element, like the first element or when we use slice operation, so if you use the slice operator and pick the first five elements, then the query set will be evaluated. So, because all of this, we say query sets are lazy, which means they're evaluated at a later point. 

Now you might be wondering why query sets are lazy. Why doesn't Django simply call the database the moment we call the 'all' method?  Well, the reason for this is that we can use query set methods to build a complex queries. So over here, we can call query_set along with filter() to filter the result. And this will return a new query set. So once again, the query is not going to get evaluated at this point. So we get a new query set. And then right away, we can call the another filter method to apply a second filter. Similarly, we can call the order by method after that to sort the result. So by chaining all these methods, we will build a complex query, and at some point, when we iterate over that query or convert it to a list, that query will be evaluated. 
Now imagine if query sets were not lazy. The moment we call the all method, the query would be evaluated, and this would result in thousands or even millions of objects returned from the database. But what if you were only interested in a subset of these products? Then calling the filter method would filter the objects in memory. So we would get thousands or millions of objects will store them in memory and throw most of them out. So to recap, every model has an attribute called objects, which returns a manager, which is an interface to the database. Now, the manager has a bunch of methods for querying and updating data. Most of these methods, like the 'all' method returns a query set. In contrast, we have some other methods that return result immediately.
 
For example, we have the count() method, which returns the number of records in the product table. Now, why don't we get a query set here? Well, because this method returns a number, so it doesn't really make sense to do something extra with that number. We're not going to apply a filter to it, we're not going to sort the result or build a complex query around it. So this was the basics of managers and query sets. As we go through the section, you will learn more about these query sets. Next, we're going to talk about retrieving objects in detail.







Retrieving objects:
-------------------

Alright, in this lesson, we're going to talk about a few different methods for retrieving objects. The first method is the 'all' method that we briefly talked about in the previous lesson. This method returns a query set, and when this query set gets evaluated, we get all the objects in a given table, like the product table. Now, sometimes we want to get a single object, like the product with the id 1. To do that, we use the 'get' method, and we pass a lookup parameter like 'id=1'. Then we could also use 'pk'.  That's a special argument. So when we use pk, Django will automatically translate this to the name of the primary key field. So our primary key field might be id, it might be code, whatever. 
We don't have to remember. This is the benefit of using the pk argument. Now unlike the all method, the get method returns an actual object, not a query set. The reason for this is because once we get an object, it doesn't really make sense to do anything extra with it. We're not going to sort the result. We're not going to apply additional filters and so on. 



product = Product.object.get(pk=1)  //So, here we get a product and that means we should rename the variable to product. 



So always pay great attention to the name of your variables and functions. I cannot emphasize this enough because this is one of the main issues I see in a lot of people's code. They have a function like get airplane. So you see that function and you think you're going to get an airplane. 
But when debugging the application, you realize that this function actually returns an orange And that orange ends up getting stored in an object called book. Don't do this. So always pay great attention to the name of your variables. 

Now, one thing you need to know about the get method is that if it cannot find this object, it will throw an exception. So, if we set  pk=0, we get an exception of 'type does not exist'. So, to handle this, we have to wrap our code inside a try-catch block. 

from django.core.exceptions import ObjectDoesNotExist

try:
	product = Product.object.get(pk=0)

except ObjectDoesNotExist:
	pass
	
	



Now this try catch block looks a little bit ugly. We don't want to repeat this pattern over and over in our code. So, let me show you a better way. Now instead of the get method, we can use the filter method. Now this method returns a query set. So right away we can call the first() method of the query set. Now if the query set is empty, the first() method returns None. So in this case, product is going to be None. We're not going to get an exception. 

product = Product.object.filter(pk=0).first()

Now sometimes we want to check the existence of an object. So over here, right after the filter method, instead of the first method we can call another method called exists. So first we apply a filter and then we check to see if there is an object in our query set with this criteria. So in this case we're not going to get a product object, we get a Boolean value. 

exists = Product.object.filter(pk=0).exists()






Filtering Objects:
------------------

Alright, let's talk about filtering data. So let's say we want to find all the products that are $20. So here we pass a keyword argument and say unit_price equals 20. 

queryset = Product.objects.filter(unit_price=20)


queryset = Product.objects.filter(unit_price>20) # shows error
	
queryset = Product.objects.filter(unit_price__gt=20)

Pretty straightforward. Now, what if you want to find all the products that are more expensive than $20? We cannot use our logical operators here. we would get an error. Because the expression (unit_price>20) is a Boolean expression and returns a Boolean value which can be true or false. But when calling the filter method, We need to pass a keyword argument. So we need to pass a keyword followed by a value(keyword=value), right? So to solve this problem, after the field name, we type two underscores followed by a lookup type. So in Django, we have 'gt', which is short for greater than. 
We also have greater than or equal to. We have less than, less than or equal to. 


Now to find all these lookup types, we can search for queryset api --> https://docs.djangoproject.com/en/5.1/ref/models/querysets/ --> Field lookups


Another useful lookup type is range. With this we can find the products whose price is in a given range. So over here, we cannot pass a single value. 
We need to pass two values a minimum and a maximum So we need to pass a tuple with two values. Let's say 20 and 30.

queryset = Product.objects.filter(unit_price__range=(20, 30))


 
Great. Now we can also filter across relationships. Let's say we want to find all the products in collection number 1. So, we type 'collection', followed by two underscores, so we navigate the relationship, and over here we can type the name of any of the attributes or fields of the collection class. There we can say id equals 1. We can also use our lookup types. So we can add two underscores followed by a lookup type, like greater than or range. And then we can set this to a tuple of, let's say, three values (1, 2, 3). So with this, we get all the products in any of these collections. 

queryset = Product.objects.filters(collection_id=1) 
queryset = Product.objects.filters(collection_id__gt=1)
queryset = Product.objects.filters(collection_id__range=(1, 2, 3))  





So, these were the lookup types for dealing with numbers. Now let's look at an example involving a string. Let's say we want to find the products that contain coffee in their title. we can type two underscores and use the 'contains' lookup type. We set this to coffee and with this we don't get anything because this lookup type is case sensitive. So to perform a case insensitive search we have to use 'icontains'.  

queryset = Product.objects.filters(title__contains='coffee')
queryset = Product.objects.filters(title__icontains='coffee') # case insensitive




Okay. Now, for dates, we have a bunch of lookup types. So let's say we want to find all the products that were updated in 2021. 
Now take a look. So this is what we get. So we can extract individual components and dates like year, month, Second and so on. We can also compare this with a date value. Not something we use that often. 

queryset = Product.objects.filters(last_update__year=2021)




And the last lookup type I'm gonna cover here is checking for null. So, to get all the products without a description, we can say description double underscore is null equals true. 

queryset = Product.objects.filter(description__isnull=True)


Some more examples:

# Customers with .com accounts
querset = Customer.objects.filter(email__icontains='.com')

# Collections that dont have a featured product
queryset = Collection.objects.filter(featured_product__isnull=True)

# Products with low inventory (less than 10)
queryset = Product.objects.filter(inventory__lt=10)

# Orders placed by customer with id = 1
queryset = Order.objects.filter(customer__id=1)

# Order items for products in collection 3
queryset = OrderItem.objects.filter(product__collection__id=3)














Complex Lookups Using Q Objects:
--------------------------------

Alright, let's see how we can apply multiple filters. So, let's say we want to find all the products with inventory less than 10 and unit price less than 20. There are a couple of different ways to implement this query. One way is to pass multiple keyword arguments.  

# inventory < 10 and price < 20

queryset = Product.objects.filter(inventory__lt=10, unit_price__lt=20)


Okay. Now, there is another way to write the same query. Instead of passing multiple keyword arguments, we can chain the call to filter method. 
queryset = Product.objects.filter(inventory__lt=10).filter(unit_price__lt=20)


So, let's take a look at our query. So, exactly like before, where we have two conditions combined using the 'and' operator. Now, how can we combine these conditions using the or operator? Well, to do that, we have to use Q objects. First, we need to import the Q class from Django. So from Django.db.models import Q. So Q is short for query. And using this class, we can represent a query expression or a piece of code that produces a value. Okay, So using this queue class, we can encapsulate a keyword argument. which means each Q object encapsulates a keyword argument or a query expression. 
we can combine a Q object with another Q object using the bitwise operators. So, if we use the bitwise 'OR' operator, this will translate to a logical 'OR' in a sql query. So here we pass a second Q object and add the second condition. 


from django.db.models import Q
	
queryset = Product.objects.filters(Q(inventory__lt=10) | Q(unit_price__lt=20))	


we can also use the Bitwise'AND' operator, but this syntax is a little bit too verbose. If you want to combine multiple conditions using the AND operator, we don't really need Q objects. We can simply pass multiple keyword arguments to the filter method.

queryset = Product.objects.filters(Q(inventory__lt=10) & Q(unit_price__lt=20))  # verbose


Okay, we can also negate a Q object. So, this will translate to the not operator in sequel. So, when we execute this, we'll get all the products whose inventory is less than 10. And their unit price is not less than 20. Okay, so this is how we can build complex lookups using queue objects. Next, we're going to talk about referencing fields using F objects.

queryset = Product.objects.filters(Q(inventory__lt=10) & ~Q(unit_price__lt=20))	





 








Referencing Fields using F Objects:
-----------------------------------

#in products where inventory = price 

queryset = Product.objects.filters(inventory = unit_price)  # error
queryset = Product.objects.filters(inventory = 'unit_price')

Sometimes when filtering data, we need to reference a particular field. For example, let's say we want to find all the products where their inventory equals their unit_price. Now, I know this doesn't really make sense in terms of a business rule, but let's just imagine that we want to compare two fields. So here in the filter method, if we mention inventory equals unit_price, we get an error because unit_price is not a valid value for this keyword argument. And also Where is unit_price defined? we don't know, right? Now, if we convert 'unit_price' to a string, that's not going to work either because the inventory field is a number and we cannot compare a number with a string. So to solve this problem, we need to use an F object. 


from django.db.models import Q, F

queryset = Product.objects.filters(inventory = F('unit_price'))

queryset = Product.objects.filters(inventory = F('collection__id'))

Now using this class, we can reference a particular field. That's why it's called F. So, we're going to create an F object and in the constructor, we're going to pass the name of a field, okay?  

Now, using F objects, we can also reference a field in a related table. For example, here we can say, collection__id, and with this we'll compare the inventory of a product with the id of its collection.









Sorting:
--------

Alright, let's talk about sorting data. So, we have this 'order_by' method that I briefly mentioned before. Using this method, we can sort the result by one or more fields. For example, here we can get all the products and sort them by their title in ascending order. If you want to change the sort direction, We simply add a negative sign here. 

queryset = Product.objects.order_by('title')  descending order -> '-title'


we can also sort by multiple fields. For example, We can sort by unit price in ascending order, and then by title in descending order.
So, with this implementation, we're going to sort our products from the cheapest to most expensive ones, and if we have multiple products with the exact same price, within that group, our products are going to be sorted by their title in descending order, okay? Now, the order by method returns a queryset object, and one of the methods of query set is reverse. So if we call the reverse method there, this will reverse the direction of the sort. So with this implementation, we're going to sort the products by unit price in descending order and then by title in ascending order.


queryset = Product.objects.order_by('unit_price', '-title')

queryset = Product.objects.order_by('unit_price', '-title').reverse()  # does the sorting by unit_price in descending order and title in ascending order



Now we can also call the order by method after filtering data because the filter method returns a query set object and order by is one of the methods of query set objects.


queryset = Product.objects.filter(collection__id=1).order_by('unit_price')

check queryset api reference --> https://docs.djangoproject.com/en/5.1/ref/models/querysets/ --> QuerySet API

Now, sometimes we want to sort the result and pick only the first object. So let's remove the filter method here. We're simply sorting our products by their unit price and then we're going to pick the first product. So with this implementation, we're not going to get a query set because we're accessing the an individual element. So up to this point, when we call the order by method --> Product.objects.order_by('unit_price')--> we get a query set object. But the moment we access an individual element in this query set, the query set gets evaluated, and then we get an actual object. So we should rename this variable to product. 


product = Product.objects.order_by('unit_price')[0]



So another way to rewrite the same query is by using the earliest method to sort the result by unit price and get the first object. Note that the earliest method returns an object. In contrast, order by returns a query set. Now similarly, we have another method called latest, which sorts the products by unit price in descending order, and then it will return the first object. 

product = Product.objects.earliest('unit_price')
product = Product.objects.latest('unit_price')








Limiting Results:
-----------------

So, our product table has a thousand products. Now quite often, we don't want to show all these products to the user in one list. We want to show pages of products. So let's say our page size is five and we want to show the products on the first page. To do that, we use Python's array slicing syntax.

queryset = Product.objects.all()[:5]  # 0, 1, 2, 3, 4

sql statement:
select * from store.product limit 5



Now to get the products on the second page, we can start from five and finish before 10. 

queryset = Product.objects.all()[5:10]  # 5, 6, 7, 8, 9

sql statement:
select * from store.product limit 5 offset 5








Selecting Fields to Query:
--------------------------
So, you have seen that when we query objects, by default, all of their fields are read from the database. But what if you're only interested in a subset of these fields? For example, if you look at the product table. Our product table has a bunch of fields or columns. Some of these columns, like the description column, contain a lot of text. What if we don't care about the values in this column? What if we only want to return the ID and the title of each product to the user. This is where we use the values method. So we call the values method and specify the fields we want to query. 

queryset = Product.objects.values('id', 'title')  # sql: SELECT store_product.id, store_product.title FROM store_product
 


With this implementation, we're only reading the ID and the title of each product. Now, we can also read related fields. For example, we can go to the collection and read the title field. So using the double underscore notation we we can access the related fields. With this implementation, now we have an inner join between the product and the collection tables because we are reading a related field. So this is how we can use the values method. Now, one thing you need to know about this method is that with this method, instead of getting a bunch of product instances, we get a bunch of dictionary objects. 

queryset = Product.objects.values('id', 'title', 'collection__title')  # return value is dictionary
# sql: SELECT store_product.id, store_product.title, store_collection.title FROM store_product INNER_JOIN store_collection ON (store_product.collection_id = store_collection.id)



Now, we have another method called 'values_list'. And with this method, we get a bunch of tuples instead of dictionaries. 

queryset = Product.objects.values_list ('id', 'title', 'collection_title') # return value is tuple



Now, here's your exercise. I want you to write a query to select products that have been ordered and Sort them by their title. 
So, in our database, We have this product table that contains all the products in our system, but not all products have been ordered. So, to find the products that have been ordered, you need to go to the order_item table. Here we have a column called product_id. You need to select all these values, all these product IDs, and use them as an argument when filtering products. 

queryset = OrderItem.object.values('product_id') # we can also give 'product__id', but django will create the reverse relationship 'product_id' during runtime.
	
queryset =  Product.objects.filter(id__in = OrderItem.object.values('product_id').distinct()).order_by('title')  --> we get Product instance









Deferring Fields: 
-----------------
In the last lesson, you learn how we can optimize our queries by specifying the fields that we want to query. Now, We have another technique called deferring fields. So we have a method called 'only'and with this method, we can specify the fields that we want to read from the database. Let's say 'id' and 'title'. Now, you might be wondering how this method is different from the 'values' method. Well, with the 'only' method, will get instances of the product class, whereas with the values method, will get dictionary objects. When using the 'only' method, the same query only has been sent as in previous lesson. 

queryset = Product.objects.only('id', 'title')  --> we get instance of Product, whereas with 'values' we get dictionary 

sql: SELECT store_product.id, store_product.title FROM store_product

Great. Now, you've got to be very careful with this method. If you don't know what you're doing, you'll end up with a lot of queries sent to the database under the hood. What I mean, if anywhere in your template, if you want to render its price. Our application will be freezed for some time.

And when the sql queries sent to the database: 
main query: SELECT store_product.id, store_product.title FROM store_product 
next query : SELECT store_product.id, store_product.unit_price FROM store_product WHERE store_product.id = 1 LIMIT 21 
1000 similar queries

So, after the main query, for each product, it has sent a separate query to read its price. So, because we have a thousand products in this list, we have a thousand extra queries for reading the price for all these products. This is what I was talking about. So you have to be careful when using the 'only' method. If you don't know what you're doing, you'll end up with a lot of extra unnecessary queries. 

Now we don't have this problem with the 'values' method. Because with the values method, we get dictionary objects and these dictionary objects don't have this behavior. So if you access a field that doesn't exist in a dictionary, that dictionary is not going to issue a query to the database. Now we have another method, which is the opposite of the 'only' method, and that is called 'defer'. With this method, we can defer the loading of certain fields to later. So let's say our product table has a bunch of columns. You're interested in all of them except the 'description' field. So we can defer this to later. But once again, you have to be careful. So if somewhere else in the template you have a for loop, and in that loop, you're iterating over the products and rendering the description of each product, once again, you're going to end up with all those extra queries.

queryset = Product.objects.defer('description')







Selecting Related Objects:
--------------------------

<li>{{ product.title }} - {{ product.collection.title }}</li>

Sometimes we need to preload a bunch of objects together. For example, while fetching all the products, we also want to render the collection of each product next to its title (say product.collection.title). But when you do it normally, you would get the same problem as before. Our application will be hanging because Django is sending a thousands of extra queries Queries to the database to read the collection of all the related products. Because when we ask for products, Django is only going to query the product table. It's not going to query the related tables unless we specifically instructed to do so. So here we want to preload the products with our collection. 




To do that we can use the select_related()(before we call the 'all' method, we can call select_related and specify the field that we want to preload). 
Here say the field is 'collection'
Now our products loaded instantly. 

queryset = Product.objects.select_related('collection').all()

SQL:
SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER_JOIN store_collection ON (store_product.collection_id = store_collection.id)

Here we're selecting all the fields from the product table followed by the three fields from the collection table and then we have a join between product and collection table. So, when we use the select related method, Django creates a join between our tables. 




Now, we can also span relationships. So, let's say collection has another field that we want to preload as part of the query. So, we can add double underscores here and then type the name of that other field. 

queryset = Product.objects.select_related('collection__someOtherField').all()




Okay so, this is select_related. now. We have another method called prefetch_related. We use select_related when the other end of the relationship has one instance (a product has one collection). But we use prefetch related when the other end of the relationship has many objects (The promotions of a product). you can check product class real quick, where each product has one collection, but it can have many promotions. So to preload the promotions, we use the prefetch method. 

class Product(models.Model):
    title = models.CharField(max_length=255)
	slug = models.SlugField()
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

#select_related(1) --> other end of the relationship has one instance (product - collection)
#prefetch_related(N) when other end of the relationship has many objects (product - promotion)

#prefetch_related
queryset = Product.objects.prefetch_related('promotions').all()

SQL:
select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price from store_product

select (store_product_promotions.product_id) as _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount
from store_promotion inner join store_product_promotions on (store_promotion.id = store_product_promotions.promotion_id) where store_product_promotions.product_id in (1,2,3,4,5,6,7,8,9,10...)

Here's the first query to read the columns from the product table. Now, after that, we have another query to read the promotions of the products. So, you're reading three columns from the promotion table, and we have a join between promotion and product. So, essentially, we have two result sets. The first set includes the products. The second set includes promotions. Django reads these sets and then populates our objects in memory. 




Now, we can also combine these two methods. So let's say we want to load all the products with their promotions and collection. So after the call to 'prefetch_related', we can call the 'select_related' to load the collection of each product. 

queryset = Product.objects.prefetch_related('promotions').select_related('collection').all()


SQL: 

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER JOIN store_collection ON (store_product.collection_id = store_collection.id)

SELECT (store_product_promotions.product_id) AS _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount FROM store_promotion INNER JOIN store_product_promotions ON (store_promotion.id = store_product_promotions.promotion_id) WHERE store_product_promotions.product_id IN(2,3,12........)

we have two queries. The first query is to read the products and their collection. So, there we have a join between product and collection. And the second query is to read the promotions of all these products.




Exercise: 

I want you to write a query to get the last five orders with their customer and items, including the product reference in each order item. 

First we want to get a list of orders. So, we should start with the order class. Then we go to Objects. Now we want to preload these orders with their customer. So, this is where we call select related to preload the customer field. Now we don't want to show all the orders, we want to show the last five orders. Hence, we need to sort them by 'placed_at' in descending order. So that latest orders come first. And then we use array slicing syntax to pick the top five orders. 
 
queryset = Order.objects.select_related('customer').order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

So, we have a single query to read the orders along with their customers. So, we are selecting all the columns from the order table, followed by all the columns from the customer table. And we have a join operation between order and customer tables. Great. So let's move on to the next step.



Now we should preload the items of these orders. So, here we can call prefetch_related because each order can have many items. Now, to know the name of the field we're going to query, you have a quick look at our Order class. 


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)


So, each order has three fields 'placed_at', 'payment status' and 'customer'. But we don't have a field called 'items', but when you look at the OrderItem class, there we have 'order' field, which is a foreign key to Order. So, Django is going to create the reverse relationship for us. And the relationship name as you know, would be 'orderitem_set'. This is the convention that Django uses to create the reverse relationship. If you don't like this name, you can always set it using the 'related_name' argument. 


queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set').order_by('-placed_at')[:5]

SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

Nothing much, we have one extra query to load the order items. So, we're loading the order items for the Orders in this list. 


So, everything is fine so far Now the last step is to load the products referenced in each order item. So, over where we are prefetching the order item, we can span the relationship by adding two underscores, and then we can type the name of the target field, which is 'product'. 

queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set__product')order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product WHERE store_product.id IN (166, 780, 976, 505, 219)

Now we have one more extra query to read the products referenced in the order items. So, we are reading all the columns from the product table where the product id is in the list(166, 780, 976, 505, 219). And this list is the list of order items we have queried so far. 

So this is how I want you to write code. Write a little bit of code, test your code, make sure everything works before doing a big step. 
With this technique, we can prevent a lot of crazy issues down the road.






Aggregating Objects:
--------------------

Sometimes you want to compute summaries like max or average price of our products. This is where we use the 'aggregate' method.

So, let's say we want to count our products. Here we create a count object and specify the field we want to use for counting. If we use ID, we can count the total number of products because every product has an ID, right?. But if we use a different column, let's say 'description', and assume that description can be NULL, this will count the number of products that have a description, okay? 

So the proper way to count the total number of records to use the ID or the primary key field. Now the aggregate method doesn't return a query set because once we calculate a summary value, it doesn't really make sense to do anything extra with it. We're not gonna add filters or sort data and so on. 


from django.db.models.aggregates import Count, Max, Min, Avg, Sum

result = Product.objects.aggregage(Count('id')) 


So, here we get a dictionary. Let's call that result and add that to our context object in our views. 

def say_hello(request):
	result= Product.objects.aggregate(Count('id'))
	return render(request, 'hello.html', {'name': 'Mosh', 'result': result})
	
	
in UI part: {id__count : 1000}


So, we get a dictionary with one key value pair. Look at the name of the key. It's 'id__count', because we use the 'id' column for counting objects. We can also change the name of this key if we want to. 

result = Product.objects.aggregage(count = Count('id')) 

#in UI --> {'count': 1000}


Now we can also calculate multiple summaries. So, in addition to the total number of products, We can also calculate the minimum price of our products. 

result = Product.objects.aggregage(count = Count('id'), min_price=Min('unit_price'))

#in UI --> {'count': 1000, 'min_price': Decimal('1.06')} 

Since aggregate is one of the methods of query sets, we can also apply it wherever we have a query set. So, we can filter our products and pull out the products in our given collection. And then calculate these summaries over that data set.

result = Product.objects.filter(collection__id=1).aggregate(count=Count('id'))


Aggregate Exercises:

#How many orders do we have?
result = Order.objects.aggregate(count=Count('id'))

#How many units of product 1 have we sold?
result = OrderItem.objects.filter(product__id=1).aggregate(units_sold=Sum('quantity'))

#How many orders has customer 1 placed?
result = Order.objects.filter(customer__id=1).aggregate(count=Count('id'))

#What is the min, max and avg price of products in collection 1? 
result = Product.objects.filter(collection__id=3).aggregate(min_price=Min('unit_price'), avg_price=Avg('unit_price'), max_price=Max('unit_price'))	






Annotating Objects:
-------------------

Sometimes we want to add additional attributes to our objects while querying them. This is where we use the 'annotate' method. And we cannot set keyword directly to any boolean or normal value, else we get an error saying QuerySet.annotate() received non-expressions	. 
This error tells us that we cannot pass a Boolean value. We need to pass an expression object. So, in Django, we have this 'Expression' class, which is the base class for all all types of expressions. Derivatives of this class are 'Value', for representing simple values, like a number, a boolean, a string. We have 'F', which you have seen before. Using the F class, we can reference a field in the same or another table, right? So an F object is essentially an expression object. We also have 'Func' for calling database functions. So, all these database engines have a bunch of functions for manipulating data. To call those functions, We use a 'Func' object. We also have Aggregate, which is the Base class for all Aggregate classes. So those aggregate classes you learn about, like Count,sum, max, min.  All these classes derived from the aggregate class.

Expression 
	Value
	F
	Func
	Aggregate



So back to our code, we cannot pass a boolean value here. We need to pass an expression object. The simplest expression object is a value object. 

from django.db.models import Value, F

queryset = Customer.objects.annotate(is_new=Value(True))

SQL:
SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership, 1 AS is_new FROM store_customer


Let's look at another example. This time we want to give our customers a new field called new_id. And for this demo, we want to set this to the same value as the id field. So we need to reference another field in this model. To do that, first we need to import the F class from django.db.models. And then over here, we can reference the id field. 

queryset = Customer.objects.annotate(new_id=F('id))

SQL:
SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership, store_customer.id AS new_id FROM store_customer



Now, we can also perform computations here. So, for example, we can add 1 to the id to generate the new ID. Now, take a look. So now the new ID is the original ID plus one.

queryset = Customer.objects.annotate(new_id=F('id) + 1)

SQL:
SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership, (store_customer.id + 1) AS new_id FROM store_customer









Calling Database Functions: 
---------------------------




queryset = Customer.objects.annotate(full_name = F(('first_name'), Value(' '), F('last_name'), function = 'CONCAT')
 #Here concat is the concat function database engine


                                   or  by Concat function

                                   full_name = Concat('first_name', Value(' '), 'last_name')



ExpressionWrapper:
dicounted_price = ExpressionWrapper(F('unit_price') * 0.8, output_field = DecimalField())
queryset = Product.objects.annotate(dicounted_price = discounted_price)



content_type = ContentType.objects.get_for_model(Product)

TaggedItem.objects.select_related('tag').filter(
   content_type= content_type,
   object_id = 1)     
   # this object_id is calculated dynamically eg., depending on the product that the user is looking for, we're going get the product id from the url



collection = Collection()
collection.title = 'Video Games'
collection.featured_product = Product(pk=1) or collection.featured_product_id = 1

 or 
 
collection = Collection(title='Video Games') --> this approach won't give IntelliSense
collection.save()


collection = Collection.objects.create(name = 'a', featured_product_id = 1)



collection = Collection(pk=11) #for updating # but this causes data loss if want to update a particular field
collection = Collection.objects.get(pk=11)
collection.title = 'Games'
collection.featured_product = None 
collection.save()

or

collection.objects.filter(pk=11).update(featured_product=None)      --> use only if you face performance problem


collection = Collection(pk=11)
collection.delete()


to delete queryset:
Collection.objects.filter(id__gt=5).delete()



@transaction.atomic()  as a decorator

or by context manager 
with transaction.atomic():



queryset = Product.objects.raw('SELECT * FROM store_product')  #the queryset we get here is completely different

	
cursor = connection.cursor()
cursor.execute('your sql statement')
cursor.close()

cursor.callproc('get_customers',[1,2])   used for writing stored procedures

Note: use the cursor statement inside the context manager (with)	
	
	



The Admin Site:
---------------

python manage.py createsuperuser

Everytime you add an app to INSTALLED_APPS, you need to run the migrate commands

python manage.py changepassword admin


admin.site.site_header = 'Storefront Admin'
admin.site.index_title = 'Admin'


To Register our models in the admin site: 
admin.site.register(models.Collection)     (admin.py of the respective app)


To override the default implementation of __str__:

def __str__(self):
   return self.title
   
   
   
Class Meta:
    ordering = ['title']
   


customizing the list page:

@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price']
	
or
admin.site.register(models.Product, ProductAdmin)


list_editable = ['unit_price'] #the fields that you want to edit on the admin page
list_per_page = 10 #10 items per page, also you get pagination at the bottom
ordering = ['first_name', 'last_name']



adding computed columns:

list_display = ['title', 'unit_price', 'inventory_status']

@admin.display(ordering='inventory')  # in list page to display in order
def inventory_status(self, product):
    if product.inventory < 10:
		return 'low'
	return 'ok'




Selecting Related Objects:

list_display = ['title', 'unit_price', 'inventory_status', 'collection']


To represent the particular field in the Collection:
list_select_related = ['collection']

list_display = ['title', 'unit_price', 'inventory_status', 'collection_title']


def collection_title(self, product):
	return product.collection.title





Overriding the Base QuerySet:

@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']
	
	@admin.display(ordering='products_count')
	def products_count(self,collection):
		return collection.products_count
	
	
	def get_queryset(self, request):
	    return super().get_queryset(request).annotate(
		    products_count=Count('product')
		)



Providing Links to Other Pages:

@admin.display(ordering='products_count')
def products_count(self, collection):
	url = reverse('admin:store_product_changelist')           #reverse('admin:app_model_page')
	return format_html('<a href="{}">{}</a>', url, collection.products_count)




To apply a filter, we need append a query string to the URL 

like this: ?collection__id=1


in code:

url = (reverse('admin:store_product_changelist') 
        + '?'
		+ urlencode({'collection__id' : str(collection.id)})
		)



Adding Search to the List Page:

search_fields = ['first_name', 'last_name']
search_fields = ['first_name__startswith', 'last_name__startswith']
search_fields = ['first_name__istartswith', 'last_name__istartswith']



Adding Filtering to the List Page:

list_filter = ['collection', 'last_update']


you can also create your own custom filter:

class InventoryFilter(admin.SimpleListFilter):
	title = 'inventory'
	parameter_name = 'inventory'
	
	def lookups(self, request, model_admin):
	    return[
		    ('<10', 'Low')
			]
			
	def queryset(self, request, querset):
		if self.value() == '10':
		    return queryset.filter(inventory__lt=10)
			
			
list_filter = ['collection', 'last_update', InventoryFilter]




Creating Custom Actions:

let's say to define a custom action for clearing the inventory of a bunch of products in one go. so we want set their inventory to zero.

@admin.action(description='Clear inventory')
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)
	self.message_user(
	    request,
		f'{updated_count} products were successfully updated.',
		messages.ERROR
		)


actions = ['clear_inventory']
	



Customizing Forms:

fields = ['title', 'slug']

exclude --> opposite of fields

exclude = ['promotions']

read_only = []


prepopulated_fields = {
   'slug': ['title']   
}

autocomplete_fields = ['collection']




Adding Data Validation:

in the model class -->

description = models.TextField(null=True)

we do still get after the above statement, to make this field optional in the admin interface 

description = models.TextField(null=True, blank=True)     


unit_price = models.DecimalField(
    max_digits=6,
	decimal_places=2,
	validators=[MinValueValidator(1)]
	)




Editing Children Using Inlines:

class OrderItemInline(admin.TabularInline):   or StackedInline
	model = models.OrderItem
	extra = 0
	min_num = 1
	max_ num = 10
	

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
	autocomplete_fields = ['customer']
	inlines = [OrderItemInline]
	list_display = ['id', 'placed_at', 'customer']
 




Using Generic Relations:

class TagInLine(GenericTabularInline)
    autocomplete_fields = ['tag']
	model = TaggedItem
	
	
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
	inline=[TagInline]




Extending Pluggable Apps:


create a new store_custom app
register it in INSTALLED_APPS

from django.contrib import admin
from store.admin import ProductAdmin
from tags.models import TaggedItem
from django.contrib.contenttypes.admin import GenericTabularInline

class TagInline(GenericTabularInline):
	autocomplete_fields = ['tag']
	model = TaggedItem
	
class CustomProductAdmin(ProductAdmin);
	inlines = [TagInLine]
	
	
admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)

	
	
	
	
	
Django REST Framework:
----------------------

pipenv install djangorestframework

after installing --> register it in setting.py file of your project folder (note: put it before all the apps)

INSTALLED_APPS = [
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.contenttypes',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
	'rest_framework', 
]



@api_view()
def product_list(request):     --> replaces the request object that comes with django with the restframework request object 
    return Response('ok')



#URLConf
urlpatterns = [
    path('products/', views.product_list),
	path('products/<int:id>/', views.product_detail),
]

@api_view()
def product_detail(request, id):
	return Response(id)




Serializing: 

model --> python dictionary(serializing helps us to convert model into dictionary) --> JSONRenderer(cls) render(dict) --> JSON Object

#serializers.py
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)        # apiguide --> serializer fields in django-rest-framework.org


#views.py
import the respective model class from models.py
import the respective serializer class from from serializers.py

@api_view()
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	serializer = ProductSerializer(product)  ---> serializer.data(python dictionary)
	return Response(serializer.data)  --> under the hood -- at some point, Django is going to create a JSON render object and give this dictionary, the JSON 
	                                       renderer will convert that dictionary to a JSON object and that JSON Object will end up in the response
										   
										   
										   
to avoid decimal to string in the response, in the settings.py
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
}	 


product doesnotexist:

except Product.DoesNotExist:
	return Response(status=status.HTTP_404_NOT_FOUND) 


	
instead of try and except block --> use get_object_or_404:

product = get_object_or_404(Product, pk=id)



we can also pass queryset to the serializer:

queryset = Product.objects.all()
serializer = ProductSerializer(queryset, many=True)


creating custom serializer fields:
price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')


def calculate_tax(self, product: Product):
	return product.unit_price * Decimal(1.1)



if you want rename the field in the serializer class which is different from the model:
price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



serializing Relationships:
1. Primary key
2. String
3. Nested object
4. Hyperlink


way 1 -->
in the serializer class:
collection = serializers.PrimaryKeyRelatedField(
	queryset = Collection.objects.all()
)

way 2 -->
collection. serializers.StringRelatedField()   --> remember to use select_related/prefetch_related if necessary or else you'll end with more queries


way 3 --> as a nested object

#define the respective serializer of the nested object
class CollectionSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length = 255)


#in ProductSerializer class:
collection = CollectionSerializer()


way 4 --> hyperlink to an endpoint for viewing that object 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

urls.py -->
path('collections/<int:pk>/', views.collection_detail, name='collection-detail')


views.py -->
@api_view
def collection_detail(request, pk):
    return Response('ok')


in ProductSerializer class:
serializer = ProductSerializer(queryset, many=True, context={'request': request}) 





Model serializers:  two places, in model and serializer, so a better way)

class ProductSerializer(serializer.ModelSerializer):
	class Meta:
		model = Product
		fields = ['id', 'title', 'unit_price', 'collection', 'price_with_tax']
	
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)
		
		

By default ModelSerializers use primary key related fields, if you don't want it. you can override it easily

example, in the same class above, define 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

also for custom serializers you can override it. 
    fields = ['id', 'title', 'price', 'collection']

price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



Deserializing Objects:

@api_view(['GET', 'POST'])
def product_list(request):
	if request.method == 'GET':
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)
	elif request.method == 'POST':
		serializer = ProductSerializer(data=request.data)  #the deserialized data will be available at serializer.validated_data, but before that we need to  validate the data
		


Data Validation:

if serializer.is_valid():
    serializer.validated_data
	return Response('ok')
else:
	return Reponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


or by cleaner way
serializer.is_valid(raise_exception=True)  ---> we don't need if else block
serializer.validated_data   --> ordereddict



by default, validation rules comes from the definition of model fields. So, if we need anything extra, 
we need to override the validate method in our serializer


So, in our serializer class:
def validate(self, data):
	if data['password'] != data['confirm_password']:
		return serializers.ValidationError('Passwords do not match')
	return data




Saving Objects:

our Model serializer has save method ( used for creating or updating)

right after validating the data
serializer.save() and we don't need serializer.validated_data after this\


Now there are situations where we want to override how a product is created

in serializer class:

def create(self, validated_data):
	product = Product(**validated_data)
	product.other = 1
	product.save()
	return product
	
we can override the update method:

def update(self, instance, validated_data):
	instance.unit_price = validated_data.get('unit_price')
	instance.save()
	return instance


The save method will call one of the above methods depending on the state of the serializer.



For updating:

@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)




Deleting Objects:

@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
	elif request.method == 'DELETE':
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)



Note: for query optimization: 
queryset in view function --> annotate 
queryset in the Model class.
in the admin_model also --> get_queryset





Advanced API Concepts:

class Based Views:

Django provides more features over class based views


from rest_framework.views import APIView

class ProductList(APIView):
	def get(self, request):
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)

	def post(self, request):
		serializer = ProductSerializer(data=request.data) 
        serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
		
				
in urls.py:

path('products/', views.ProductList.as_view()),

			
			
class productDetail(APIView):
	def get(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product)
		return Response(serializer.data)
		
	def put(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data) 
		
	def delete(self, request, id):
		product = get_object_or_404(Product, pk=id)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in urls.py:

path('products/<int:id>/', views.ProductDetail.as_view()),

		
			
ModelSerializer and HyperLinkedModelSerialzer.



cs
# import serializer from rest_framework
from rest_framework import serializers

# create a serializer
class CommentSerializer(serializers.Serializer):
	# initialize fields
	email = serializers.EmailField()
	content = serializers.CharField(max_length = 200)
	created = serializers.DateTimeField()



Mixins:
from rest_framework.mixins import ListModelMixin, CreateModelMixin




Generic Views:

you dont't use mixins directly most of the time, instead you use them with concrete classes that combines one or more mixins, we call these classes Generic views.
ListCreateView
ListAPIView
RetrieveAPIView
etc.


class ProductList(ListCreateAPIView):

	queryset = Product.objects.select_related('collection').all()
	serializer_class = ProductSerializer
		
	 or

#if there's any logic you can define a method
	def get_queryset(self):
		return Product.objects.select_related('collection').all()
		
	def get_serializer_class(self):
		return ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}

from rest_framework.generics import ListCreateView

Another advantage of using generic view is that in the web, you get the sample json format



Customizing Generic Views:

class ProductDetail(RetrieveUpdateDestroyAPIView):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def delete(self, request, pk):
		product = get_object_or_404(Product, pk=pk)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in the above delete function 'id' is changed to 'pk', since Generic views expects pk parameter and uses it internally  
in the urlpatterns --> path('products/<int:pk>/', views.ProductDetail.as_view())





ViewSets:
Using a view set, we can combine the logic for multiple related views inside a single class. 


from rest_framework.viewsets import ModelViewSet


class ProductViewSet(ModelViewSet):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}
	
	def destroy(self, request, pk):      #note modelViewSet has destroy method not delete method
		if OrderItem.objects.filter(product_id=kwargs['pk']).count > 0   (changing the logic, since self. fetching product already)
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		return super().destroy(request, *args, **kwargs)


Check for ReadOnlyModelViewSet and other viewset



Routers:
from rest-framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

Now the urls will be available at --> router.urls


so, 
#URLCONF
urlpatterns = router.urls

if you have other urls

urlpatterns = [
 path('', include(router.urls)),
]


from rest-framework.routers import DefaultRouter




Building the Reviews API:

Building the Model:
create a model model class
create a migration
apply a migration


Building the API:
create a serializer
create a view
register a route



Nested Routers:

nested routers --> https://github.com/alanjds/drf-nested-routers


Note: if you want pass anything from the request(from the user) in viewset to the serializer, we use context 


class ReviewViewSet(ModelViewSet):
	serializer_class = ReviewSerializer
	
	def get_queryset(self):
		return Review.objects.filter(product_id=self.kwargs['product_pk'])
	
	def get_serializer_context(self):
		return{'product_id': self.kwargs['product_pk']}

		
class ReviewSerializer(serializer.ModelSerializer):
	class Meta:
		model = Review
		fields = ['id', 
		
	def create(self, validated_data):
	    product_id = self.context['product_id']
		return Review.objects.create(product_id=product_id, **validated_data) 






Filtering:

/products?collection_id=1

in the ProductViewSet:

overriding the get_queryset function:

def get_queryset(self):
	queryset= Product.objects.all()
	collection_id = self.request.query_params.get('collection_id')
	if collection_id is not None:
		queryset = queryset.filter(collection_id=collection_id)
	
	return queryset  


also remember to add basename to the respective router since we overridden the get_queryset, django will unable to set the basename

in urls.py --> router.register('products', views.ProductViewSet, basename='products')







Generic Filtering:

pipenv install django-filter

add it in the list of installed apps, remember while adding, it is 'django_filters'

from django_filters.rest_framework import DjangoFilterBackend


in ProductViewSet -->

filter_backends = [DjangoFilterBackend]
filterset_fields = ['collection_id']

and bring back the queryset to 
queryset = Product.objects.all()

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Searching:
from rest_framework.filters import SearchFilter

in ProductViewSet -->

filter_backends = [DjangoFilterBackend, SearchFilter]
search_fields = ['title', 'description'] also we can reference fields in related classes 'collection__title'



Sorting:

from rest_framework.filters import SearchFilter, OrderingFilter


filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]

ordering_fields = ['unit_price', 'last_update']



Pagination:
from rest_framework.pagination import PageNumberPagination


in the ProductViewSet class:
pagination_class = PageNumberPagination

To specify the pagesize:
in the settings.py -->
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.pagination.PageNumberPagination',  #pagination applied to all endpoints
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.LimitOffsetPagination',  #if you want limit and offset type pagination instead of page number
	 'PAGE_SIZE': 10
}	 


to surpass the error: mention page_size but not mentioned default_pagination_class

pagination.py
-------------
from rest_framework.pagination import PageNumberPagination


class DefaultPagination(PageNumberPagination):
	page_size = 10
	
	
and now you can remove the PAGE_SIZE in the settings.py
 and in the ProductViewSet --> pagination_class = DefaultPagination




Designing and Implementing a Shopping Cart API:

from uuid import uuid4
id = models.UUIDField(primary_key=True, default=uuid4)










Django Authentication System:
------------------------------

INSTALLED_APPS -->	'django.contrib.auth' -->  contains this

tables --> auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions

MIDDLEWARE --> "django.contrib.auth.middleware.AuthenticationMiddleware" -->


customizing the user model:

extending the user model 
have a profile model and that model will be having one to one link to user model 


use 2nd approach --> 
1st type --> use only for authentication (For storing attributes related to authentication)
2nd type --> for storing non-auth related attributes


Extending the User Model:


#class User(AbstractUser):
	email = models.EmailField(unique=True)
	
	
in the settings.py:
	
AUTH_USER_MODEL = 'core.User'




if other apps depends on this user class:
from django.conf import settings
user = models.ForeignKey(settings.AUTH_USER_MODEL,...) 	



to register the custom user model:

from django.contrib.auth.admin import UserAdmin as BaseUserAdmin

@admin.regis(User)
class UserAdmin(BaseUserAdmin):
	pass