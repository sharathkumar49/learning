To Learn:
---------

learn env, venv, pipenv

Jinja templating, django default templating

Django data models

Django field types -> https://docs.djangoproject.com/en/5.0/ref/models/fields/
https://www.geeksforgeeks.org/django-model-data-types-and-fields-list/

date time field (auto_now_add, auto_now)

in field option --> choice field

one-to-one relationship --> in the child class --> the column value key field from parent class should be set 'primary_key = True'

related_name, reverse relationship
related_name = '+' --> tells django not to create the reverse relationship

circular dependency or circular relationship and how to solve them

ContentType

 content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
 object_id = models.PositiveIntegerField()
 content_object = GenericForeignKey()
 
 
Inner class Meta --> class Meta (explore)

django model metadata  --> https://docs.djangoproject.com/en/5.0/ref/models/options/




Django ORM --> learn about Managers and QuerySets
.Objects. --> manager --> interface 

queryset get evaluated --> iterate, converting it in to list, accessing a single element  --> lazily evaluated

Learn Building complex query using Django ORM

queryset api  --> https://docs.djangoproject.com/en/5.0/ref/models/querysets/



Learn select_related, prefetch_related very well
also learn chaining select_related with prefetch_related



django database functions -->  https://docs.djangoproject.com/en/5.0/ref/models/database-functions/


learn about contentTypes in django


Django ModelAdmin --> https://docs.djangoproject.com/en/5.0/ref/contrib/admin/  --> ModelAdmin options


Django validators --> https://docs.djangoproject.com/en/5.0/ref/validators/ 


url conf in django


resource -- object -- model -- entity 


https://www.django-rest-framework.org/  
  apiguide --> serializer fields
               Generic Views



change detection mechanism doesn't work sometimes. you need to restart the server. 

httpstatuses

nested routers --> https://github.com/alanjds/drf-nested-routers

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Django import statements:
---------------------------

from django.shortcuts import render (default - Views.py - to render html)
  eg: return render(request, 'hello.html')
  eg: return render(request, 'hello.html', {'name': 'Mosh'})
from django.http import HttpResponse (Views.py)  
  eg: return HttpResponse('Hello World')
  
from django.urls import path (in apps urls.py)
from django.urls import path, include (in project urls.py)

from django.db import models (default - models.py)


from django.contrib.contenttypes.models import ContentType ( models.py - to define generic relationship, to find the content_type)
from django.contrib.contenttypes.fields import GenericForeignKey

from django.contrib.auth.models import User

from django.core.exceptions import ObjectDoesNotExist(views.py --> queryset,if we don't get the object we're looking for)

from django.db.models import Q, F, Func, ExpressionWrapper (Q - to combine the conditions using OR Operator, F - to represent a particular field)


from django.db.models.aggregates import Count, Max, Min

from django.db.models import Value 

from django.db.models.functions import Concat

from django.contrib.contenttypes.models import ContentType (in views.py)
from store.models import Product
from tags.model import taggedItem 


from django.db import transaction
from django.db import connection


from django.utils.html import format_html, urlencode ( in admin.py)
from django.urls import reverse( in admin.py)

from django.contrib import admin, messages


from django.core.validators import MinValueValidator

from django.contrib.contenttypes.admin import GenericTabularInline, GenericStackedInline



#rest_framework
from rest_framework.decorators import api_view
from rest_framework.response import Response

from rest_framework import serializers
from rest_framework import status

from django.shortcuts import get_object_or_404

from decimal import Decimal

from rest_framework.views import APIView
from rest_framework.mixins import ListModelMixin, CreateModelMixin

from rest_framework.viewsets import ModelViewSet

from rest_framework.routers import SimpleRouter

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter

from rest_framework.pagination import PageNumberPagination









 
from django.contrib.auth.models import AbstractUser


======================================================================================================================================================================================

Django :
---------

pip install django / pipenv install django(if you want to use pipenv)

django-admin startproject my_proj   / django-admin startproject my_proj . (tells django to use current directory as project Directory)
cd my_proj

manage.py --> wrapper of Django-admin

python manage.py runserver 9000 (optionally, we can supply the port number, by default it will take port 8000)

pipenv --venv ( to check python interpreter in the local venv)








To create a new app:
-------------------
python manage.py startapp app_name

Note : Once you created a new app, you have to register the app in the 'INSTALLED_APPS' in the project settings folder

for example:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]







views.py and urls.py:
-------------------
HTTP is a request response protocol. So, every data exchange involves a request and a response. Every app has view.py and this is where we define our views or view functions. A view function is a function that takes a request and returns a response. So more accurately, it's a request handler. In some frameworks, it's called an action. In Django, it's called a view. But I don't agree with this name because from an architectural point of view, a view is often associated with something that the user sees. That part in Django is called a template. 



from django.http import HttpResponse

def say_hello(request):
	return HttpResponse('Hello World')



Now in this function, we can do anything we want. In a real-world scenario we can pull data from a database, we can transform data, we can send emails and so on. Learn the functionalities of views.py.

Now we need to map this view to url, so when we get a request at that url, this function will be called.

apps --> urls.py:	
	
from django.urls import path
from . import views

#URLConf
urlpatterns = [
    path('hello/', views.say_hello)
 ]	
	

Note: we have 'urlpatterns' variable(all in lower case), which is an array of url pattern objects, we use path() function to create a url patter object

The parameters of path function --> (route: str, view: (*args: Any, **kwargs: Any) -> HttpResponse, kwargs: Dict[str, Any] = ...) -> URLPattern

Now, what we have here is URLConf module, which basically means URL Configuration. So, every app can have its own URL Configuration. But now we need to import this URL Configuration into the main URL Configuration for this project
	
projects --> urls.py:

use the include function from django.urls

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
   path('admin/', admin.site.urls),
   path('playground/', include('playground.urls'))
  ]

So, if the user sends the request to playground/hello, Django knows that all requests that start with playground should be handled by the playground app. So it's going to chop off the first part of this URL 'playground/' and Pass the rest 'hello' to the URL configuration module in the playground app. 




Using Templates:
----------------
So I told you that views in Django are not really views. They're more like request handlers or actions. What we often call a view in other frameworks is called a template in Django.

Add templates folder in any app and then html file inside (say templates/hello.html)

Then in views.py:

from django.shortcuts import render

def say_hello(request):
	return render(request, 'hello.html') 
	

or we can also dynamically render the content, just we need to add another parameter which provides the context 
return render(request, 'hello.html', {'name': 'Mosh'})  --> now you have name parameter in the html content. For more details learn jinja template engine or django template engine




Django Debug toolbar:
---------------------
https://django-debug-toolbar.readthedocs.io/en/latest/

Follow the instruction in the Installation page:

python -m pip install django-debug-toolbar 

of if you're inside virtual env --> pipenv install django-debug-toolbar

Then as said follow the instructions in the Installation page









Data Model: 
-----------
The first step in every Django project is figuring out the pieces of data we want to store. So, what entities or concepts do we have in an application? we need analyze and have a separate chart for that.

eg: product, collection, cart, etc

learn to how to organize models in apps (monolith, self contained, each individual)


models.py:
---------

django field types: https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field types, Field Options

from django.db import models

class Product(models.Model):
	title = models.charField(max_length=255) #varchar(255)
	description = models.TextField() 
	price = models.DecimalField(max_digits=6, decimal_places=2) # floatfield has round issues, so for monetary values always use decimal field  #9999.99
	inventory = models.IntegerField()
	last_update = models.DateTimeField(auto_now=True)
	
Now when we finished writing models for each entities, we need to migrate, then you will see that we can generate our database tables based on the definition of this model. So then we're going to have a table called 'product' and in that table we're going to have a column called 'title' and the type of that column is going to be varchar of 255. 


we want some random field to be primary key instead of one generated by django itself,
sku = models.CharField(max_length=10, primary_key=True)
With this Django is not going to create an ID field and make it the primary key. So, 'sku' is going to be our primary key. 


Choices in Field Options:  
-------------------------

https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field Options --> Choices


class Customer(models.Model):
	MEMBERSHIP_BRONZE = 'B'
	MEMBERSHIP_SILVER = 'S'
	MEMBERSHIP_GOLD = 'G'
	
	MEMBERSHIP_CHOICES = [
		(MEMBERSHIP_BRONZE, 'Bronze'), 
		(MEMBERSHIP_SILVER, 'Silver'), 
		(MEMBERSHIP_GOLD, 'Gold'),
	]
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)
	membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
	

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)




Defining relationships between models:
-------------------------------------

Defining one-to-one Relationships:
---------------------------------
Assume that every customer should have one and only one address, and each address should belong to one and only one customer. So here we have a one-to-one relationship between customers and addresses.

As you probably know, a database relationship has two ends, a parent and a child. The parent should exist before we can store the child, So, we need to define cutomer model first and then address model and then we can create relationship between these two in the child model. 


class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.OnetoOneField(Customer, on_delete=models.CASCADE, primary_key=True)




The argument 'on_delete' specifies the delete behavior. What should happen when we delete a customer or a parent field. So, if we put on_delete to 'models.CASCADE', when we delete a customer the associated address will also be deleted. 
This is called the cascade behavior. Alternatively if this field accepts null values we can use set null(models.SET_NULL). So, when we delete a customer or the parent record, the child record(or the address in this case) is not going to get deleted. It's going to stay in the database and the customer field or the customer column is going to get set to null. Alternatively, we can use 'models.SET_DEFAULT;. So this field will be set to its default value. And one other option we have is models.PROTECT. And with this, we can prevent the deletion. So, if there is a child associated with this parent, we cannot delete that parent, we have to delete the child first.

Now, which value we use really depends on the requirements. There is no one size fits all. In this case, I believe we should use cascade. Because if we delete a customer, the associated address should also be deleted.

Now there is one more argument we need to set is 'primary_key=True'. If we don't set this, Django will create another field here called ID. So, every address is going to have an ID. And that means we're going to end up with a one-to-many relationship between customers and addresses, because we can have many addresses with the same customer. But if we make the customer field as a primary key, we can only have one address for each customer, because primary keys don't allow duplicate values, right? 
So this is how we can implement a one-to-one relationship between two models. Now, you might be wondering if we should define the reverse relationship in the customer class. In other words, do we have to go to the customer class and add a new field called 'address' for the reverse relationship. No, we don't have to do that because Django will automatically creates this for us. 




Defining a one-to-many Relationship:
-----------------------------------

Now let's assume that a customer can have multiple addresses. So we want to change this one-to-one relationship to one-to-many relationship. How can we do this? Really easy. First we need to change the type of the field to foreign key. So we're telling Django that customer is a foreign key in the address table. Okay? Next we need to remove field option 'primary_key=true'. Because we want to have multiple addresses for the same customer. So, we want to allow duplicate values in the customer column. This is how we can define a one-to-many relationship between two models. 

class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)


Other examples as follows:
Collection - Product
Customer - Order
Order - Item
Cart - Item


class Collection(models.Model):
    title = models.CharField(max_length=255)
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
	
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()
	
	
	

Defining Many-to-Many Relationships:
-----------------------------------

Let's talk about many-to-many relationships. So, I'm going to introduce a new class called Promotion and define a many-to-many relationship between promotions and products.

class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()


Now we can define the relationship in either of these classes. And as i said earlier, Django will automatically create the reverse relationship. Now in this particular case, it makes more sense to define the relationship in the product class because we might have a product that we're showing to the user. And at the same time, we want to show all the promotions that apply to that product.
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

Now with this implementation, Django is going to create the reverse relationship in the Promotion class. So, in the Promotion class, we're going to have a field called 'Product_set' that returns all the products that a particular promotion is applied to if you don't like this name You can always change it. So, in our product class, we can supply a keyword argument related_name='products'. Django will use this name as the name of the field in the promotion class. So instead of 'product_set' we're gonna have a 'products'. 

Just remember, if you change the default convention in Django, it's best to change it consistently everywhere, otherwise in some classes you're going to have a field 'products', and in some other classes you're going to have a field 'product_set', and this makes your code really ugly.





Resolving Circular Relationships:
--------------------------------

I told you that sometimes we can have multiple relationships between two models. So, here we have two relationships between collection and product (relationship between Collection and product - one to many, collection and featured_product - zero to one) 

Now, out of the two, You have only implemented the one-to-many relationship. Now, as part of implementing the other relationship, we're going to face a situation called a circular dependency, which is something we should avoid. A Circular dependency happens when two classes depend on each other at the same time. So the product class is going to be dependent on the collection class and And at the same time, the collection class is gonna be dependent on the product class.

Before in the product class, we have a field called 'collection', which is a foreign key to the collection class. So, we had a dependency from the product class towards the collection class(product -> collection). Now, to implement the other relationship, we have to go to the collection class and add a new field featured_product. But while mentioning the 'Product' class name, it will throw an error. We are seeing this error, because the product class is defined after the collection class. 
Now this is where we have a circular dependency. So, in the Product class, we have a dependency to the Collection class. And that's why we define the Collection class before the product class. However, because of the circular dependency, now the Collection class also needs to be dependent on the Product class, which is not possible. To solve this problem, We need to wrap the 'Product' class argument in quotes. However, this introduces a new kind of problem. If tomorrow we decide to rename this Product class to something else, the string that we passed is not going to get updated.

One more error, we might get is reverse query name for featured_product clashes with field name 'collection'. So, in the Collection class we have a field called featured_product, right? Now as you know Django is going to automatically create the reverse relationship for us. So that means, in the product class, we're going to have a field called collection, which represents the other end of the relationship. And this is exactly where the problem happens. Because in the product class, we already have a field called collection. 
So, Django cannot create the reverse relationship because of the name clash. So here we have two choices. One solution is to set related name to something other than collection, or if we don't care about the reverse relationship, we can simply pass a plus sign '+'. This tells Django not to create that reverse relationship.

Also, we're going to set on_delete=models.SET_NULL, because if we delete a product and that product happens to be the featured product for a collection, we want to set the field to null. And that means we can make this field nullable. Also, we can pass another keyword argument 'null=True'. 

class Collection(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey(
        'Product', on_delete=models.SET_NULL, null=True, related_name='+')


class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)






Generic Relationships:
----------------------

So, I told you that we want to design the tags app such that we can reuse it in any projects. Anywhere we want to have the ability to tag items. That's why we have two models(entities) in this app. Tag, which represents an actual tag, and TaggedItem, which represents a tag applied to a particular item, which can be a product, a video, an article, literally anything. So let's see how we can implement these models. 

from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class Tag(models.Model):
    label = models.CharField(max_length=255)


class TaggedItem(models.Model):
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()



INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]




The first model is Tag, we simply do it as usual, nothing special about it. The second model, is bit tricky, first we can have the attribute tag and it's a foreign key to the Tag class. Again, nothing new so far. Now, the interesting part is identifying the object that a particular tag is applied to. The poor way of implementing is adding a field called product, then settingit to a foreign key to the Product class. Now with this implementation, we have to import the Product class on the top and that means the tags app is going to be dependent on the store app. What if tomorrow we want to tag articles or videos? These are completely different apps. So, the tags app should know nothing about these models. 

What we need here is a generic way to identify an object. To do that, we need two pieces of information. The first one is the type of an object, which can be product, video, article, whatever. The second attribute is the id of that object. Using these two pieces of information, we can identify the objects in our application, or in Database terms, we can identify any record in any tables. 

Because using the type, we can find the table, and using the ID, we can find the record, right? So instead of using a concrete model like product, we should use an abstract model called ContentType, which comes with Django.
So earlier, we talked about the list of installed apps in the settings module. There we have an app called Contenttypes. Using this Contenttypes, we can create generic relationships within our models. So ContentType is a model that represents the type of an object in our application. Now, we need to import this on the top --> 'from django.contrib.contenttypes.models import ContentType'  So, this is a model just like any model that we have in our application. But this model is specifically made for allowing generic relationships. Also setting the on_delete to cascade because if that object type is removed we want to remove all the associated tags. 


Now, the second attribute we need here is the id of the target object. So, we can set the field object_id. And this has to be a positive integer field. Because we're assuming that every table is going to have a primary key. And all primary keys are positive integers. Now what if in a particular table, our primary key is not an integer, let's say it's a GUID. Well, in that particular case, this solution is not going to work. So this is the limitation of this solution. So now, with these two pieces of information, we can identify any object in our application. 


Now, one last thing. When querying data, We might want to get the actual object that this tag is applied to, like the actual product. To do that We're gonna add another field called content_object and set this to a particular type of field called GenericForeignKey (imported on the top). Now, using this field, content object, we can read the actual object that a particular tag is applied to. So, let's quickly recap. To define a generic relationship, there are three fields we need to define. content_type, object_id, and content_object.

exercise:

I want you to create an app called likes for tracking the objects that a user likes. So in this app, we're going to have a model called LikedItem. And using an instance of this model, we can tell what user likes what object. So here we need a field called user, which is going to be a foreign key to the user class defined in the model django.contrib.auth.models. So auth is another app that is automatically installed in every Django project. And using this app, we can authenticate and authorize users. 


App: Likes

LikedItem
 -what user likes what object
 -user: ForeignKey to User(django.contrib.auth.models)


likes/model.py:

from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()


So, We have created a new app called likes. And in this app, we have a new model called LikedItem. Now here we have four fields. We have user, which is a foreign key to the User class defined in django.contrib.auth.models. Now here for on_delete, I've used cascade. so if a user is deleted, we want all the objects that the user has liked to be deleted as well. Then we have three fields exactly like before, no changes. We have content_type for identifying the type of an object that the user likes, we have object_id for referencing that particular object, and content_object for reading an actual object. 










python manage.py makemigrations   ---> generates migrations py file 

   --> makemigrations basically generates the SQL commands for preinstalled apps (which can be viewed in installed apps in settings.py) and your newly created appâ€™s model which you add in installed apps 
   
 Note: remember to add all apps to 'INSTALLED_APPS', or else django wouldn't detect any changes 
 
python manage.py migrate  ----> run those migration.py file and create table in database

    -->migrate executes those SQL commands in the database file. 
	
	
python manage.py migrate store 003 (migrate to a specific migration)
  but the proper way is to delete the unwanted migration file and erase all respective changes in the code 	
	
	
python manage.py makemigrations store --empty

python manage.py sqlmigrate store 0003  --> to see the actual sql code that is sent to our database at runtime.



install mysql

install any mysql clients and connect with it 

The next step is to connect our Django project to MySQL --> to do that we need to install a package --> pipenv install mysqlclient


change in the settings:
DATABASES = {
 'default' : 'django.db.backends.mqsql',
 'NAME' : 'storefront',
 'HOST' : 'localhost',
 'USER' : 'root',
 'PASSWORD' : 'Mypassword'
  }
 }


Generating Dummy Data --> mockaroo.com







Django ORM:
-----------

product = Product.objects.filter(pk =0).first() #if the product doesn't exist, we would get None, we are not gonna get exception
exists = Product.objects.filter(pk =0).exists() # we get a boolean value


Learning filtering objects in Django orm 
Also learn keyword arguments

queryset = Product.objects.filter(unit_price__gt=20)



queryset = Product.objects.filters(collection_id__range=(1, 2, 3))

queryset = Product.objects.filters(title__icontains='coffee')

queryset = Product.objects.filters(last_update__year=2021)

	
queryset = Product.objects.filters(Q(inventory__lt=10) | Q(unit_price__lt=20))	

queryset = Product.objects.filters(inventory = F('unit_price'))

queryset = Product.objects.filters(inventory = F('collection__id'))



queryset = Product.objects.order_by('title')  des -> '-title'

queryset = Product.objects.order_by('unit_price', '-title')

check queryset api reference 

product = Product.objects.order_by('unit_price')[0]
product = Product.objects.earliest('unit_price')
product = Product.objects.latest('unit_price')



queryset = Product.objects.all()[:5]

see this sql statement:
select * from store.product limit 5 offset 5



queryset = Product.objects.values('id', 'title')
queryset = Product.objects.values('id', 'title', 'collection_title')  -->
Note: in this case we don't get product instances/ object . we do get dictionaries

queryset = Product.objects.values_list ('id', 'title', 'collection_title') -->
 Here we get tuples instead of dictionary

select store_product.id, store_product.title, store_collection.title from store_product inner join store_collection on 
(store_product.collection_id = store_collection.id) 

	

queryset = OrderItem.object.values('product_id') --> we can give this instead of (product__id) because django will create the reverse relationship during runtime
	
queryset =  Product.objects.filter(id__in = OrderItem.object.values('product_id').distinct())  --> we get Product instance


queryset = Product.objects.only('id', 'title')  --> we get instance of Product, whereas with 'values' we get dictionary 

queryset = Product.objects.defer('description')


to query the related tables -->
queryset = Product.objects.select_related('collection').all()


select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, 
store_collection.id, store_collection.title, store_collection.featured_product_id from store_product inner join store_collection on 
(store_product.collection_id = store_collection.id)


#select_related(1) --> other end of the relationship has one instance (product - collection)
#prefetch_related(N) when other end of the relationship has many objects (product - promotion)



#prefetch_related
queryset = Product.objects.prefetch_related('promotions').all()

select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price from store_product

select (store_product_promotions.product_id) as _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount
from store_promotion inner join store_product_promotions on (store_promotion.id = store_product_promotions.promotion_id) where store_product_promotions.product_id in (1,2,3,4,5,6,7,8,9,10...)



result = Product.objects.aggregage(Count('id')) --> {id__count : 1000}
result = Product.objects.aggregage(count = Count('id')) 
	
	
queryset = Customer.objects.annotate(is_new = Value(True))
	

queryset = Customer.objects.annotate(full_name = F(('first_name'), Value(' '), F('last_name'), function = 'CONCAT')
 #Here concat is the concat function database engine


                                   or  by Concat function

                                   full_name = Concat('first_name', Value(' '), 'last_name')



ExpressionWrapper:
dicounted_price = ExpressionWrapper(F('unit_price') * 0.8, output_field = DecimalField())
queryset = Product.objects.annotate(dicounted_price = discounted_price)



content_type = ContentType.objects.get_for_model(Product)

TaggedItem.objects.select_related('tag').filter(
   content_type= content_type,
   object_id = 1)     
   # this object_id is calculated dynamically eg., depending on the product that the user is looking for, we're going get the product id from the url



collection = Collection()
collection.title = 'Video Games'
collection.featured_product = Product(pk=1) or collection.featured_product_id = 1

 or 
 
collection = Collection(title='Video Games') --> this approach won't give IntelliSense
collection.save()


collection = Collection.objects.create(name = 'a', featured_product_id = 1)



collection = Collection(pk=11) #for updating # but this causes data loss if want to update a particular field
collection = Collection.objects.get(pk=11)
collection.title = 'Games'
collection.featured_product = None 
collection.save()

or

collection.objects.filter(pk=11).update(featured_product=None)      --> use only if you face performance problem


collection = Collection(pk=11)
collection.delete()


to delete queryset:
Collection.objects.filter(id__gt=5).delete()



@transaction.atomic()  as a decorator

or by context manager 
with transaction.atomic():



queryset = Product.objects.raw('SELECT * FROM store_product')  #the queryset we get here is completely different

	
cursor = connection.cursor()
cursor.execute('your sql statement')
cursor.close()

cursor.callproc('get_customers',[1,2])   used for writing stored procedures

Note: use the cursor statement inside the context manager (with)	
	
	



The Admin Site:
---------------

python manage.py createsuperuser

Everytime you add an app to INSTALLED_APPS, you need to run the migrate commands

python manage.py changepassword admin


admin.site.site_header = 'Storefront Admin'
admin.site.index_title = 'Admin'


To Register our models in the admin site: 
admin.site.register(models.Collection)     (admin.py of the respective app)


To override the default implementation of __str__:

def __str__(self):
   return self.title
   
   
   
Class Meta:
    ordering = ['title']
   


customizing the list page:

@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price']
	
or
admin.site.register(models.Product, ProductAdmin)


list_editable = ['unit_price'] #the fields that you want to edit on the admin page
list_per_page = 10 #10 items per page, also you get pagination at the bottom
ordering = ['first_name', 'last_name']



adding computed columns:

list_display = ['title', 'unit_price', 'inventory_status']

@admin.display(ordering='inventory')  # in list page to display in order
def inventory_status(self, product):
    if product.inventory < 10:
		return 'low'
	return 'ok'




Selecting Related Objects:

list_display = ['title', 'unit_price', 'inventory_status', 'collection']


To represent the particular field in the Collection:
list_select_related = ['collection']

list_display = ['title', 'unit_price', 'inventory_status', 'collection_title']


def collection_title(self, product):
	return product.collection.title





Overriding the Base QuerySet:

@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']
	
	@admin.display(ordering='products_count')
	def products_count(self,collection):
		return collection.products_count
	
	
	def get_queryset(self, request):
	    return super().get_queryset(request).annotate(
		    products_count=Count('product')
		)



Providing Links to Other Pages:

@admin.display(ordering='products_count')
def products_count(self, collection):
	url = reverse('admin:store_product_changelist')           #reverse('admin:app_model_page')
	return format_html('<a href="{}">{}</a>', url, collection.products_count)




To apply a filter, we need append a query string to the URL 

like this: ?collection__id=1


in code:

url = (reverse('admin:store_product_changelist') 
        + '?'
		+ urlencode({'collection__id' : str(collection.id)})
		)



Adding Search to the List Page:

search_fields = ['first_name', 'last_name']
search_fields = ['first_name__startswith', 'last_name__startswith']
search_fields = ['first_name__istartswith', 'last_name__istartswith']



Adding Filtering to the List Page:

list_filter = ['collection', 'last_update']


you can also create your own custom filter:

class InventoryFilter(admin.SimpleListFilter):
	title = 'inventory'
	parameter_name = 'inventory'
	
	def lookups(self, request, model_admin):
	    return[
		    ('<10', 'Low')
			]
			
	def queryset(self, request, querset):
		if self.value() == '10':
		    return queryset.filter(inventory__lt=10)
			
			
list_filter = ['collection', 'last_update', InventoryFilter]




Creating Custom Actions:

let's say to define a custom action for clearing the inventory of a bunch of products in one go. so we want set their inventory to zero.

@admin.action(description='Clear inventory')
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)
	self.message_user(
	    request,
		f'{updated_count} products were successfully updated.',
		messages.ERROR
		)


actions = ['clear_inventory']
	



Customizing Forms:

fields = ['title', 'slug']

exclude --> opposite of fields

exclude = ['promotions']

read_only = []


prepopulated_fields = {
   'slug': ['title']   
}

autocomplete_fields = ['collection']




Adding Data Validation:

in the model class -->

description = models.TextField(null=True)

we do still get after the above statement, to make this field optional in the admin interface 

description = models.TextField(null=True, blank=True)     


unit_price = models.DecimalField(
    max_digits=6,
	decimal_places=2,
	validators=[MinValueValidator(1)]
	)




Editing Children Using Inlines:

class OrderItemInline(admin.TabularInline):   or StackedInline
	model = models.OrderItem
	extra = 0
	min_num = 1
	max_ num = 10
	

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
	autocomplete_fields = ['customer']
	inlines = [OrderItemInline]
	list_display = ['id', 'placed_at', 'customer']
 




Using Generic Relations:

class TagInLine(GenericTabularInline)
    autocomplete_fields = ['tag']
	model = TaggedItem
	
	
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
	inline=[TagInline]




Extending Pluggable Apps:


create a new store_custom app
register it in INSTALLED_APPS

from django.contrib import admin
from store.admin import ProductAdmin
from tags.models import TaggedItem
from django.contrib.contenttypes.admin import GenericTabularInline

class TagInline(GenericTabularInline):
	autocomplete_fields = ['tag']
	model = TaggedItem
	
class CustomProductAdmin(ProductAdmin);
	inlines = [TagInLine]
	
	
admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)

	
	
	
	
	
Django REST Framework:
----------------------

pipenv install djangorestframework

after installing --> register it in setting.py file of your project folder (note: put it before all the apps)

INSTALLED_APPS = [
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.contenttypes',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
	'rest_framework', 
]



@api_view()
def product_list(request):     --> replaces the request object that comes with django with the restframework request object 
    return Response('ok')



#URLConf
urlpatterns = [
    path('products/', views.product_list),
	path('products/<int:id>/', views.product_detail),
]

@api_view()
def product_detail(request, id):
	return Response(id)




Serializing: 

model --> python dictionary(serializing helps us to convert model into dictionary) --> JSONRenderer(cls) render(dict) --> JSON Object

#serializers.py
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)        # apiguide --> serializer fields in django-rest-framework.org


#views.py
import the respective model class from models.py
import the respective serializer class from from serializers.py

@api_view()
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	serializer = ProductSerializer(product)  ---> serializer.data(python dictionary)
	return Response(serializer.data)  --> under the hood -- at some point, Django is going to create a JSON render object and give this dictionary, the JSON 
	                                       renderer will convert that dictionary to a JSON object and that JSON Object will end up in the response
										   
										   
										   
to avoid decimal to string in the response, in the settings.py
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
}	 


product doesnotexist:

except Product.DoesNotExist:
	return Response(status=status.HTTP_404_NOT_FOUND) 


	
instead of try and except block --> use get_object_or_404:

product = get_object_or_404(Product, pk=id)



we can also pass queryset to the serializer:

queryset = Product.objects.all()
serializer = ProductSerializer(queryset, many=True)


creating custom serializer fields:
price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')


def calculate_tax(self, product: Product):
	return product.unit_price * Decimal(1.1)



if you want rename the field in the serializer class which is different from the model:
price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



serializing Relationships:
1. Primary key
2. String
3. Nested object
4. Hyperlink


way 1 -->
in the serializer class:
collection = serializers.PrimaryKeyRelatedField(
	queryset = Collection.objects.all()
)

way 2 -->
collection. serializers.StringRelatedField()   --> remember to use select_related/prefetch_related if necessary or else you'll end with more queries


way 3 --> as a nested object

#define the respective serializer of the nested object
class CollectionSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length = 255)


#in ProductSerializer class:
collection = CollectionSerializer()


way 4 --> hyperlink to an endpoint for viewing that object 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

urls.py -->
path('collections/<int:pk>/', views.collection_detail, name='collection-detail')


views.py -->
@api_view
def collection_detail(request, pk):
    return Response('ok')


in ProductSerializer class:
serializer = ProductSerializer(queryset, many=True, context={'request': request}) 





Model serializers:  two places, in model and serializer, so a better way)

class ProductSerializer(serializer.ModelSerializer):
	class Meta:
		model = Product
		fields = ['id', 'title', 'unit_price', 'collection', 'price_with_tax']
	
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)
		
		

By default ModelSerializers use primary key related fields, if you don't want it. you can override it easily

example, in the same class above, define 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

also for custom serializers you can override it. 
    fields = ['id', 'title', 'price', 'collection']

price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



Deserializing Objects:

@api_view(['GET', 'POST'])
def product_list(request):
	if request.method == 'GET':
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)
	elif request.method == 'POST':
		serializer = ProductSerializer(data=request.data)  #the deserialized data will be available at serializer.validated_data, but before that we need to  validate the data
		


Data Validation:

if serializer.is_valid():
    serializer.validated_data
	return Response('ok')
else:
	return Reponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


or by cleaner way
serializer.is_valid(raise_exception=True)  ---> we don't need if else block
serializer.validated_data   --> ordereddict



by default, validation rules comes from the definition of model fields. So, if we need anything extra, 
we need to override the validate method in our serializer


So, in our serializer class:
def validate(self, data):
	if data['password'] != data['confirm_password']:
		return serializers.ValidationError('Passwords do not match')
	return data




Saving Objects:

our Model serializer has save method ( used for creating or updating)

right after validating the data
serializer.save() and we don't need serializer.validated_data after this\


Now there are situations where we want to override how a product is created

in serializer class:

def create(self, validated_data):
	product = Product(**validated_data)
	product.other = 1
	product.save()
	return product
	
we can override the update method:

def update(self, instance, validated_data):
	instance.unit_price = validated_data.get('unit_price')
	instance.save()
	return instance


The save method will call one of the above methods depending on the state of the serializer.



For updating:

@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)




Deleting Objects:

@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
	elif request.method == 'DELETE':
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)



Note: for query optimization: 
queryset in view function --> annotate 
queryset in the Model class.
in the admin_model also --> get_queryset





Advanced API Concepts:

class Based Views:

Django provides more features over class based views


from rest_framework.views import APIView

class ProductList(APIView):
	def get(self, request):
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)

	def post(self, request):
		serializer = ProductSerializer(data=request.data) 
        serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
		
				
in urls.py:

path('products/', views.ProductList.as_view()),

			
			
class productDetail(APIView):
	def get(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product)
		return Response(serializer.data)
		
	def put(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data) 
		
	def delete(self, request, id):
		product = get_object_or_404(Product, pk=id)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in urls.py:

path('products/<int:id>/', views.ProductDetail.as_view()),

		
			
ModelSerializer and HyperLinkedModelSerialzer.



cs
# import serializer from rest_framework
from rest_framework import serializers

# create a serializer
class CommentSerializer(serializers.Serializer):
	# initialize fields
	email = serializers.EmailField()
	content = serializers.CharField(max_length = 200)
	created = serializers.DateTimeField()



Mixins:
from rest_framework.mixins import ListModelMixin, CreateModelMixin




Generic Views:

you dont't use mixins directly most of the time, instead you use them with concrete classes that combines one or more mixins, we call these classes Generic views.
ListCreateView
ListAPIView
RetrieveAPIView
etc.


class ProductList(ListCreateAPIView):

	queryset = Product.objects.select_related('collection').all()
	serializer_class = ProductSerializer
		
	 or

#if there's any logic you can define a method
	def get_queryset(self):
		return Product.objects.select_related('collection').all()
		
	def get_serializer_class(self):
		return ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}

from rest_framework.generics import ListCreateView

Another advantage of using generic view is that in the web, you get the sample json format



Customizing Generic Views:

class ProductDetail(RetrieveUpdateDestroyAPIView):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def delete(self, request, pk):
		product = get_object_or_404(Product, pk=pk)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


in the above delete function 'id' is changed to 'pk', since Generic views expects pk parameter and uses it internally  
in the urlpatterns --> path('products/<int:pk>/', views.ProductDetail.as_view())





ViewSets:
Using a view set, we can combine the logic for multiple related views inside a single class. 


from rest_framework.viewsets import ModelViewSet


class ProductViewSet(ModelViewSet):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}
	
	def destroy(self, request, pk):      #note modelViewSet has destroy method not delete method
		if OrderItem.objects.filter(product_id=kwargs['pk']).count > 0   (changing the logic, since self. fetching product already)
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		return super().destroy(request, *args, **kwargs)


Check for ReadOnlyModelViewSet and other viewset



Routers:
from rest-framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

Now the urls will be available at --> router.urls


so, 
#URLCONF
urlpatterns = router.urls

if you have other urls

urlpatterns = [
 path('', include(router.urls)),
]


from rest-framework.routers import DefaultRouter




Building the Reviews API:

Building the Model:
create a model model class
create a migration
apply a migration


Building the API:
create a serializer
create a view
register a route



Nested Routers:

nested routers --> https://github.com/alanjds/drf-nested-routers


Note: if you want pass anything from the request(from the user) in viewset to the serializer, we use context 


class ReviewViewSet(ModelViewSet):
	serializer_class = ReviewSerializer
	
	def get_queryset(self):
		return Review.objects.filter(product_id=self.kwargs['product_pk'])
	
	def get_serializer_context(self):
		return{'product_id': self.kwargs['product_pk']}

		
class ReviewSerializer(serializer.ModelSerializer):
	class Meta:
		model = Review
		fields = ['id', 
		
	def create(self, validated_data):
	    product_id = self.context['product_id']
		return Review.objects.create(product_id=product_id, **validated_data) 






Filtering:

/products?collection_id=1

in the ProductViewSet:

overriding the get_queryset function:

def get_queryset(self):
	queryset= Product.objects.all()
	collection_id = self.request.query_params.get('collection_id')
	if collection_id is not None:
		queryset = queryset.filter(collection_id=collection_id)
	
	return queryset  


also remember to add basename to the respective router since we overridden the get_queryset, django will unable to set the basename

in urls.py --> router.register('products', views.ProductViewSet, basename='products')







Generic Filtering:

pipenv install django-filter

add it in the list of installed apps, remember while adding, it is 'django_filters'

from django_filters.rest_framework import DjangoFilterBackend


in ProductViewSet -->

filter_backends = [DjangoFilterBackend]
filterset_fields = ['collection_id']

and bring back the queryset to 
queryset = Product.objects.all()

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/





Searching:
from rest_framework.filters import SearchFilter

in ProductViewSet -->

filter_backends = [DjangoFilterBackend, SearchFilter]
search_fields = ['title', 'description'] also we can reference fields in related classes 'collection__title'



Sorting:

from rest_framework.filters import SearchFilter, OrderingFilter


filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]

ordering_fields = ['unit_price', 'last_update']



Pagination:
from rest_framework.pagination import PageNumberPagination


in the ProductViewSet class:
pagination_class = PageNumberPagination

To specify the pagesize:
in the settings.py -->
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.pagination.PageNumberPagination',  #pagination applied to all endpoints
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.LimitOffsetPagination',  #if you want limit and offset type pagination instead of page number
	 'PAGE_SIZE': 10
}	 


to surpass the error: mention page_size but not mentioned default_pagination_class

pagination.py
-------------
from rest_framework.pagination import PageNumberPagination


class DefaultPagination(PageNumberPagination):
	page_size = 10
	
	
and now you can remove the PAGE_SIZE in the settings.py
 and in the ProductViewSet --> pagination_class = DefaultPagination




Designing and Implementing a Shopping Cart API:

from uuid import uuid4
id = models.UUIDField(primary_key=True, default=uuid4)










Django Authentication System:
------------------------------

INSTALLED_APPS -->	'django.contrib.auth' -->  contains this

tables --> auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions

MIDDLEWARE --> "django.contrib.auth.middleware.AuthenticationMiddleware" -->


customizing the user model:

extending the user model 
have a profile model and that model will be having one to one link to user model 


use 2nd approach --> 
1st type --> use only for authentication (For storing attributes related to authentication)
2nd type --> for storing non-auth related attributes


Extending the User Model:


#class User(AbstractUser):
	email = models.EmailField(unique=True)
	
	
in the settings.py:
	
AUTH_USER_MODEL = 'core.User'




if other apps depends on this user class:
from django.conf import settings
user = models.ForeignKey(settings.AUTH_USER_MODEL,...) 	



to register the custom user model:

from django.contrib.auth.admin import UserAdmin as BaseUserAdmin

@admin.regis(User)
class UserAdmin(BaseUserAdmin):
	pass