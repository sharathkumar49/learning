


What is Javascript:

I'm going to answer four frequently asked questions about javascript. What is javascript? What can you do with it? Where does javascript code run? And what is the difference between Javascript and ECMA script? So let's start with the first question. What is javascript? Javascript is one of the most popular and widely used programming languages in the world. Right now, it's growing faster than any other programming languages, and big companies like Netflix, Walmart, and paypal built their internal applications around javascript and the average salary of a javascript developer in the United States is 72 thousand dollars a year. So, it's a great opportunity to get a good job out of learning javascript. You can work as a front-end developer or a backend developer or a full-stack developer who knows both the front-end and the backend. 
Now the second question. What can you do with javascript? For a long time javascript was only used in browsers to build interactive web pages. Some developers refer to javascript as a toy language, but those days are gone because of huge community support and investments by large companies like Facebook and Google. These days you can build full-blown web or mobile apps, as well as realtime networking applications like chats and video streaming services, command-line tools, or even games.
The third question? Where does javascript code run? Javascript was originally designed to run only in browsers, so every browser has what we call a javascript engine that can execute javascript code. For example, the javascript engines in Firefox and Chrome are Spider Monkey and V8. In 2009, a very clever engineer called Ryan Dahl took the open source javascript engine in Chrome and embedded it inside a c++ program. He called that program Node. The Node is a c++ program that includes Google's V8 javascript engine. Now with this we can run javascript code outside of a browser so we can pass our javascript code to Node for execution. And this means with javascript we can build the backend for our web and mobile applications. So in a nutshell, javascript code can be run inside of a browser or in node. 
Browsers and node provide a run-time environment for our javascript code. 
And finally, the last question. What is the difference between Javascript and ECMA Script?  Well, ECMA Script is just a specification. Javascript is a programming language that confirms to this specification. So, we have this organization called ECMA, which is responsible for defining standards. They take care of this ECMA Script specification. The first version of ECMA Script was released in 1997. Then starting from 2015, ECMA has been working on annual releases of a new specification. So in 2015 they released ECMA Script 2015, which is also called ECMA Script Version 6 or ES6 for short. This specification defined many new features for javascript. 
Alright enough theory. Let's see javascript in action. So, every browser has a javascript engine and we can easily write javascript code without any additional tools. Of course, this is not how we build real world applications, but this is just for a quick demo. So, open up Chrome, right click on an empty area and go to inspect. Now this opens up Chrome developer tools. Select the console tab. This is our javascript console, and we can write any valid javascript code. 

console.log('Hello World');  //Hello World
2 + 2 // 4
alert('yo'); //yo

======================================================================================================================================================================================


install vs code from its official website
install node 

! + tab    ---->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <h1>Hello World</h1>
  <script>
	console.log('Hello World');
  </script>
</body>
</html>

install liver server extension


In order to write javascript code here, we need a script element. There are two places where we can add a script element. We can add it in the head section or in the body section. The best practice is to put the script element at the end of the body section after all the existing elements. Why do I say that as a best practice you should put the script element means. Well, there are two reasons for that. One reason is that the browser parses the html file from top to bottom. So, if you put the script element in the head section, you might have a lot of javascript code there. So, your browser may get busy parsing and executing the javascript code and it won't be able to render the content of the page. This will create a bad user experience. When the user looks at your web page, it's gives white or blank images while your browser is busy parsing and executing your javascript code. So that's reason one. The second reason is that the code we have in between the script elements needs to talk to the elements on the web page. For example, we may want to show or hide some elements, so, by adding the code here at the end of the body section will be confident that all these elements are rendered by the browser. Now there are exceptions to this rule. Sometimes you're using third-party code that has to be placed in the head section, but these are exceptions. As I told you before, as a best practice, you should always add your javascript code at the end of the body section. 



Separation of Concerns:
-----------------------
Now while we can easily write javascript code in between the script elements.  In a real world applications, we have thousands or even million lines of code. We don't want to write all that code inside the script tag. We want to extract and separate our javascript code from our HTML. Let me give you a metaphor, think of your house. In your bedroom you have your bed and your clothes. You don't store your clothes in the kitchen. This is what we call separation of concerns. We have the same principle in programming, we want to separate HTML, which is all about content from javascript, which is all about behavior which means How should your web page behave? What should happen when we hover our mouse over a given element? Maybe something should pop up. Maybe something should be hidden. So we use javascript to implement behavior. 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <h1>Hello World</h1>
  <script src="index.js"></script>
</body>
</html>





Javascript in Node:
-------------------
you have to install node

node index.js

Remember, Node is a program that includes Google's V8 Javascript engine. We can give it a piece of javascript code and it will execute that code for us just like how we execute javascript code in a browser.  


======================================================================================================================================================================================
Basics:

Variables:
----------
Let's start this section by a discussion of variables which are one of the most fundamental concepts in javascript and any other programming languages. In programming, we use a variable to store data temporarily in a computer's memory, so we store our data somewhere in the memory and give that memory location a name. And with this name we can read the data at the given location in the future. Here's a metaphor. Think of the boxes you use to organize your stuff. You put your stuff in various boxes and put a label on each box. With this you can easily find your stuff right. A variable is like a box. What we put inside the box is the value that we assign to the variable, and that's the data and the label that we put on the box is the name of our variable. 

Now let's see this in code, I'm going to declare a variable. 
Now previously in the old days before ES6 we use the 'var' keyword to declare a variable but there are issues with var as you will find out later in the course. So, going forward from ES6 the best practice is to use the 'let' keyword to declare a variable. Now we need to give this variable a name or an identifier and this is like the label we put on a box so I'm going to call this 'name' and finally we need to terminate this declaration with a semicolon. 
Now let's log this on the console 

let name;
console.log(name); //undefined

So by default variables that we defined in javascript their value is undefined. Now we can optionally initialize this variable.

let name = 'Mosh';
console.log(name); // Mosh

Note that I'm using single quotes. You can also use double quotes. Different developers have different preferences, but it's more common to use single quotes for declaring strings in javascript. 

Now we have a few rules for naming these variables. Here are the rules. 

Rules:
Cannot be a reserved keyword
Should be meaningful
Cannot start with a number(1name)
Cannot contain a space or hyphen(-)

Note that the variables are case-sensitive

And finally, the last thing you need to know about these variables is that if you want to declare multiple variables, there are two ways to do this, you can declare them on one line and separate them using a comma 

let firstName, lastName;

Now in this case. I have not initialized either of these variables, they're both undefined. 

I can optionally initialize one or both of them, so I can set firstName to 'mosh' and can leave the lastName undefined or set lastName 'Hamidani'. 

But the modern best practice is to declare each variable on a single line.

let firstName = 'mosh';
let lastName = 'haemodani';


Different types of notations used for naming variables:
 
camelNotation: firstName


======================================================================================================================================================================================

const interestRate = 0.3;

interestRate = 0.1;  // you will get an error



Primitive Types: 
----------------


Primitive/Value Types and Reference Types


Primitive/Value Types:

String
Number
Boolean
undefined
null  


let name = 'Mosh';   Here the 'Mosh' is called the String Literal 
let age = 30 // Number Literal
let isApproved = true;  //Boolean Literal  
let firstName; //if you don't initialize the variable name, by default it's value is undefined. But also we can explicitly set the variable name to undefined
let lastName = null; // we use null in situations where we wanna explicitly clear the value of a variable. 

For example, we may want to present the user with a list of colors. If the user has no selection, we want to set the selectedColor variable to null.  

let selectedColor = null; 

In future, if the user selects a color, then we're going to reassign this variable to a color like red, 

let selectedColor = red; 

and then if they click red again, perhaps we want to remove the selection, so we set this back to null.

let selectedColor = null;  

just think interms of accessing the browser.

Now in ES6, we have another primitive which is symbol, and you're going to learn about that later in the course. 




Dynamic Typing:
---------------


One thing that separates javascript from a lot of programming languages is that javascript is a dynamic language. What do I mean by dynamic? Well, we have two types of programming languages, static languages or dynamic languages. In static languages, when we a variable, the type of that variable is static and it cannot be changed in the future. In a dynamic language like javascript, the type of a variable can change at runtime. 


Static - (Statically-typed)  --> string name = 'John';
Dynamic - (Dynamically-typed)  --> let name = 'John';


Let's see this in code, 

let name = 'Mosh';

typeof name; // "string"

name = 1; 

typeof name; // "number" 

name = 30.1;

typeof name; // "number" 

This is what we call a dynamic language. So unlike static languages, the type of these variables will be determined at runtime based on the values that we assigned to them. Also, in javascript, unlike other programming languages, we don't have two kinds of numbers, we don't have floating point numbers and integers all numbers are of type 'number'. Now 


let firstName = undefined;


let's look at the type of ISPROD. It's a Boolean as I told you before. What about the first name? Let's have a look type of first name. 
It's undefined and that's funny because the value of this variable is undefined, but its type is also undefined. What does this mean well? Earlier. I told you that we have two categories of types. We have primitives or value types and reference types. In the primitive types category, we have strings, numbers, booleans, undefined and no so undefined is actually a type but is also a value. In this example, because we have set first name to undefined as a value, its type is also undefined. O now. What about selected color? Let's have a look so type of selected color. 
The type of this variable is an object? What is an object? That's the topic for the next lecture. 

 





Objects:

{} object literal syntax


//object-oriented programming
const circle = {
radius : 1,
location : {
 x : 1,
 y : 2
},
isVisible : true,
draw: function() {
  console.log('draw');
 }
};

circle.draw(); // Method


Factory Funtions: these factory functions produce objects


function createCircle(radius) {     // Naming convention: camel notation 
	return {
	radius :,
	draw() {
	console.log('draw');
	}
  };
}


const myCircle = createCircle(1);




Constructor Function:


//Pascal Notation

Note: In Javascript objects are dynamic, once we create them we can always add additional properties or methods to them. 


function Circle(radius){
	this.radius = radius;
	this.draw = function() {
		console.log('draw');
	}
}

const circle1 = new Circle(1);

When we use the new operator, three things happen,

This operator first creates an empty object
Then it will set 'this' to point to this object 
and finally it will return that object from this function 


So, with factory function, we simply call a function and in this function we return a new object. 
In contrast, with constructor functions, we use the new operator and instead of returning an object, we use this keyword





Dynamic Nature of Objects:
you can always add new properties, methods or remove existing ones after creation

circle.color = 'yellow';

delete circle.color;

delete circle.draw;








Constructor Property:


circle.constructor    // the circle object we created and returned it from our factory function, and because we used the object literal syntax, internally it was created using
                       //this object constructor function. (f Object())
another.constructor


let x = {};  --> // let x = new Object();



Other built-in constructors :

new String(); but quite often we use string literals --> '', "", `` using these literals is cleaner and simpler than using the constructor



So, Every object has a constructor propery and that references a function that was used to create that object.








Functions are Objects:


function Circle(radius){
   this.radius = radius;
   this.draw = function(){
     console.log('draw');
	}
}

the Circle is an object and if you use . operation you can see all the members of Circle function(or Circle object), the purple icons are methods, and the blue icons are properties 




circle.constructor  --> F Function() { [native code] }


So, when we declare a function using the 'function syntax', internally javascript engine will use this function constructor ' F Function() { [native code] } ' to create the object



you can check by using -->   

const Circle1 = new Function('radius', `
  this.radius = radius;
   this.draw = function(){
     console.log('draw');
	}
`);
So, when we declare a function, interally it is represented like above




Circle.call({}, 1)  here {} references 'this'  and this expression is equal to new Cirlce(1)


So, when we use the new operator, this new operator will internally create an empty object {} and pass that as the first argument to the call method. And this object {} will determine the context of 'this'. So, 'this' will reference this object '{}'. If you don't use the new operator 'this' by default will point to the global object which is window. 


eg:

Circle.call(window, 1)

const another = Circle(1);  



Similar to call method, we do have apply method and the only difference is instead of passing all the arguments explicitly, we pass them in an array. So, this is useful if you already have an array somewhere in your application and you want to pass that array as the second argument to the apply method










Value vs Reference Types:


Value types: (primitives) --> Number, String, Boolean, Symbol, undefined, null
Reference Types: Object, Function, Array


As we see earlier, function are objects, arrays are also objects

So, in the nutsell we have primitives and objects


let x = 10;
let y = x;

x = 20;

if we print them, x --> 20 y --> 10 so they are independent


But when we use an object, that object is not stored in the variable x, that object is stored somewhere else in the memory and the address of the memory location is stored inside that variable. So when we copy x into y, it's the address or reference that is copied. In other words, both x and y are pointing to the same object in memory. And when we modify that object either x or y, changes are immediately visible to other variable. 


So, Primitives are copied by their value and Objects are copied by their reference


Another example,

let number = 10;

function increase(number){
  number++;
}

increase(number);
console.log(number);   

here it gives as 10, But didn't we increase the number. well, when we call increase function and the pass the number variable which outside the function, it's value is copied into the number variable which is local to that function. So, the number variable in function is completely independent of the other number variable. Even though we increase the number variable inthe function. After the function its scope ends and when we log the number variable we are referencing the one we declared at the beginning.


But if you change the above logic to object type, it is copied by the reference and we get the same result even though we increase it 


let obj = { value : 10 }

function increase(obj){
  obj.value++;
}


increase(obj);
console.log(obj.value); // 11










Enumerating Properties of an Object:

const circle = {
	radius : 1,
	draw() {
		console.log('draw');
	}
};


for (let key in circle)
	console.log(key, circle[key])
	
	
similarly, for of loop only be used with iterables such as arrays and maps. And object is not iterable

However, we can iterate over keys

for(let key of Object.keys(circle))
	console.log(key);
	
	
So, earlier you have learned that object is a built in constructor function. So somewhere we have this constructor function..
function Object(){...} and whenever we create an object using the object literal syntax, internally that is translated into a call to this constructor function.


So, when we create an object using the object literal syntax {} --> say const x = { value: 1}; this is translated to the call the constructor function --> function Object {...} and it looks like const x = new Object()


Also you learned all functions in javascripts are objects  and they have properties and methods that we can access using the dot notation


that's we get Object.keys, similarly to Object.keys, we have Object.entries -->

for(let entry of Object.entries(circle))
	console.log(entry)  //['radius', 1]
	
	
to check if the property or method is present or not

if('color' in circle) console.log('yes');


======================================================================================================================================================================================

Cloning an Object:
In the last lecture, you learned how to enumerate the properties of an object. Now using this technique, we can get all the properties in an object and copy them into another object. So let's say we want to create another circle object, which is a copy of the circle object here. 

const circle = {
	radius : 1,
	draw() {
		console.log('draw');
	}
};



const another = {}

Initially, we set it to an empty object. then

for(let key in circle)
	another[key] = circle[key]
	
	
	
or by using	
	
const another = Object.assign({}, cirlce);


Now this target object that we pass here. It doesn't have to be an empty object. It can be an existing object. It can have one or more properties or methods. 

object. I'm going to show you yet another simpler and more elegant way to clone an object. We can use the spread operator. 

const another = { ...circle };  //Basically what this operator does is that it takes all the properties and methods from the circle object and Puts them in between the curly braces. 

So here's what I want you to take away object of the assign Copies the properties and methods from one or more source objects into a target object and we can use that to clone an object or combine multiple objects into a single object and The spread operator is used to spread an object which basically means getting all these properties and methods and putting them into another object. 

======================================================================================================================================================================================

Garbage Collection:

In low-level languages like C or C++, when creating an object, we need to allocate memory to it. And when we're done, we have to D allocate memory but in JavaScript, we don't have this concept. We can easily create a new object. At the time we initialize this object, the memory is automatically allocated to this object. Next, we can use that. And when we're done using, we don't have to D allocate the memory. So our JavaScript engine has what we call a garbage collector. The job of this garbage collector is to find the variables or constants that are no longer used and then Deallocate the memory that was allocated to them earlier. So you as a JavaScript developer do not have to worry about this. 
Memory allocation and the allocation happens automatically behind the scene and you have no control over that. You cannot tell garbage collector when to run and what variables to remove from the memory. So based on some complex algorithms this garbage collector runs in the background it figures out what variables are not used and then it will automatically Deallocate their memory.

======================================================================================================================================================================================

Math: built in object, search in google for javascript math. --> developer.mozilla.org

======================================================================================================================================================================================

String: 



In javascript we have two types of string, String primitive ('',"",``) and String object which uses the String constructor String('hi')


const message = 'hi'; //String primitive
const another = new String('hi'); //String object


typeof message; // string
typeof another; //object


However, when we use the dot notation with a string primitive, JavaScript engine internally wraps this with a string object. We don't see that, but we can work with this like a string object. Now, just like the math object, if you want to learn about all these methods, it's best to look at the documentation. So simply search for JavaScript string. 
Once again, on developer.mozilla.org. On this page, you can see All the properties and methods of the string object. 


Also learn about escape notation 

======================================================================================================================================================================================
Template literals:


Object {}
Boolean true, false
String '', ""
Template ``

you can also have placeholders with any kind of expressions 

const message = 
`hi ${name},
    Thank you for joining my mailing list.
`	
======================================================================================================================================================================================
Date:

Many formats are available. Go through the documentation

======================================================================================================================================================================================

Exercise: Address Object
All right, here's your first exercise for this section. I want you to create an address object with three properties, street, city, and zip code. When you do that, then create a function called showAddress that takes an address object and displays all the properties in this object along with their value. 

//street
//city
//zipcode
//showAddress(address)

let address = {
   street: 'a'
   city : 'b',
   zipCode : 'c'
};

function showAddress(address) {
  for(let key in address)
     console.log(address, key[address]);
}


showAddress(address);



Exercise: Factory and Constructor Functions
So in the last exercise, we used the object literal syntax to initialize an address object. In this exercise, I want you to initialize an address object first using a factory function and then using a constructor function. So your exercise is to write two different functions. One is a factory function, the other is a constructor function to initialize an address object. 

So factory functions simply return a new object. 


//Factory Function (camel notation)

function createAddress(street, city, zipCode) {

	return {
	  street,
	  city, 
	  zipcode
	  };
}


let address = createAddress('a', 'b', 'c')


//Constructor function (Pascal notation)

function Address(street, city, zipCode) {
	this.street = street;
	this.city = city;
	this.zipCode = zipCode;
}


let address = new Address('a', 'b', 'c')




Exercise 3: Object Equality

let address1 = new Address('a', 'b', 'c');
let address2 = new Address('a', 'b', 'c');


function areEqual(address1, address2){
	return address1.street === address2.street && address1.city === address2.city && address1.zipCode === address2.zipCode; // returns true
}


function areSame(address1, address2){
  return address1 === address2;  // checks whether they are referencing the same object (as address1 and address2 holds the memory address) // returns false
}


but if you create another another3 = address1, now both are referencing the same object in the memory, function areSame will returns true 




Exercise 4: Blog post object
In this exercise, I want you to create a blog post object with these properties, title, body, author, views, which represents the number of times this post has been viewed, comments. Now, each comment should have a couple properties, author and body. And finally, another property that each post should have is is life. That can be either true or false. So once again, you should use the object literal syntax to create and initialize a blog post Give each property some value the actual value doesn't really matter. I just want you to get comfortable with the object literal syntax. 

//title
//body
//author
//views
//comments
// (author, body)
//isLive

let post = {
 title : 'a',
 body : 'b',
 author : 'c', 
 views : 10,
 comments : [
   {author: 'a', body: 'b'},
   {author: 'c', body: 'd'}
   ],
  isLive : true
};


console.log(post);



Exercise 5: Constructor Functions:

In this exercise, once again, we're going to use a constructor function to create a post object. But this constructor function is a little bit different from the constructor function you wrote in an earlier exercise. So here's the scenario. Imagine we're building a blogging engine. The user is drafting a post, but they have not published it yet. What do you think that constructor function should look like? So spend a couple minutes on this exercise. 


function post(title, body, author){
	this.title = title;
	this.body = body;
	this.author = author;
	this.views  = 0;
	this.comments =[];
	this.isLive = false;
};

But we don't need the number of views because the first time we create a post, Views should be set to zero. 
And every time we view that post, we increment that value. So views is not something that we want to pass here and We want to use a default value of 0 when initializing this post object The same is true for the comments property for a new post that has not been published yet We don't have any comments. So we don't want to add a comments parameter here The same is true For the is live property. We want to set this to false by default So there is really no need to add an extra parameter in this function so You should aim to have functions with fewer parameters the more parameters a function has the harder it gets to use it. 


let post = new Post('a', 'b', 'c');




Exercise: Price Range Object:

let priceRanges = [
	{ label: '$', tooltip: 'Inexpensive', minPerPerson: 0 , maxPerPerson: 10 },
	{ label: '$$', tooltip: 'Inexpensive', minPerPerson: 11 , maxPerPerson: 20 },
	{ label: '$$$', tooltip: 'Expensive', minPerPerson: 21 , maxPerPerson: 50 }

];

======================================================================================================================================================================================

Arrays:


Adding Elements:

const numbers = [3, 4];

we have declared numbers as const which we can't reassign numbers as another [] or anything else. However it's perfectly fine to modify the content of this array. we can add new elements or remove existing elements.


Array is an object which means it has methods and properties


//end
numbers.push(5,6)


//beginning
numbers.unshift(1,2)


//splice 
numbers.splice(2, 0, 'a', 'b')

======================================================================================================================================================================================
Finding Elements Primitives:

Finding elements really depends on if you're storing primitive or reference types. Let's start with primitives 


const numbers = [1,2,3,4]

numbers.indexof(2) //if exists, return index of the element, or else returns -1

number.lastIndexOf(1) //returns the last index of the element

To check if the element is present:

numbers.indexof(2) !== -1  or numbers.includes(2)


All these parameters has the second parameter which is optional and that is the starting index (the index where the search will begin)

numbers.indexOf(1, 2)

======================================================================================================================================================================================

Finding Elements(Reference Types/Objects):

const courses = [
{id : 1, name : 'a'},
{id : 2, name : 'b'},
]


courses.includes({id : 1, name : 'a'});  // we get false


The includes doesn't work here to check whether the course with name 'a' is there or not because these two objects (the object you passed in the includes method and the object that we have in courses array) are two different objects, they have two different references, they are in two different locations in memory. as we learned objects are reference types, and so when we check them for their equality, the references are checked, In this case these are two different references. That's why we get false 


So if you have an array with reference types, you need to use the find method. 


in Google, search for javascript array find

learn about predicates or call back--> functions passed as an argument


const course = courses.find(function(course) { 
	return course.name === 'a';
});


console.log(course) // {id : 1, name : 'a'} 

// if the search doesn't find the match, we will get undefined 


similarly, we have findIndex which will return the index of an object and if there is no match found, it will return -1
======================================================================================================================================================================================
Arrow Functions:

Shorter cleaner way of writing the predicate functions

So, whenever you want to pass a function, as a callback function or as an argument for a different method, you can use the arrow function syntax.

remove function keyword
put fat arrow to separate from its body
remove parenthesis if you have only one parameter, if you don't have any parameter, you have to pass empty parenthesis
and if your function has single line of code and returns a value, remove curly braces  


const course = courses.find(course => course.name === 'a');
======================================================================================================================================================================================
Removing Elements:

//end
const last = numbers.pop();  // removes the element from the last and returns it


//beginning
const first = numbers.shift();


//middle
numbers.splice(2, 1)  //(index, number of elements you want to delete, element to be added)
======================================================================================================================================================================================
Emptying an Array:

let numbers = [ 1, 2, 3, 4]

//solution 1
you can reassign to new empty array, if is not declared as const
numbers = [];


what if there is an another reference, it would not be garbage collected, even though we make an original array empty, there's still an reference to it 

so the solution 1 works only if there is no another reference to it.


//solution 2
numbers.length = 0;

it will truncate the array, it will remove all the elements
 
 
//solution 3
numbers.splice(0, numbers.length) 

//solution 4
while(numbers.length .> 0)
	number.pop();
	
	
Now this last solution is not something that I recommend you to do, because if you're dealing with a large array, let's say if you have a million objects in this array there's going to be a performance cost. you're essentially calling this pop method a million times. My personal preference is to set the length of the array to 0 and also the first solution is also perfectly valid if you have a single reference to your array. 

Solution 3 is also little bit noisy. Overall you can go either solution 1 or solution 2 
======================================================================================================================================================================================
Combining and Slicing Arrays:

const first = [1, 2, 3];
const second = [4, 5, 6];

const combined = first.concat(second);


const sliced = combined.slice(2,4)  //here 2 is inclusive and 4 is exclusive
const sliced = combined.slice(2) // we get all the elements starting from index 2
const sliced = combined.slice() // copy of an original array, which means return [1, 2, 3, 4, 5, 6]


The one thing that you need to note down about both these methods is that if you're dealing with primitive values. These primitive will be copied to the target array. but if you have object in your array. The objects themselves not copied, their references are copied. And that means the elements in both input and output arrays will point to the same object.
======================================================================================================================================================================================The spread operator:

const combined = [...first, ...second]    //[1, 2, 3, 4, 5, 6]

When we spread an array, all itxs elements are spread individually. So basically here we are declaring a new array and in that array we're adding the individual elements of first and second arrays 

const combined = [...first, a, ...second, b]  // if you want to add an element between them or at the end or at the beginning


In the last lecture, we've seen that if you call the slice method without any arguments, this will return the copy of the original array.
We can also use the spread operator to copy all the element of an array into a new array. 

const copy = [...combined]
======================================================================================================================================================================================
Iterating an Array:

const numbers = [1, 2, 3]

for (let number of numbers)
	console.log(number)
	


Another simpler approach,  
	
numbers.forEach(function(number) {
  console.log(number);
});


writing the above code using arrow function syntax:

numbers.forEach(number => console.log(number));  

The call back function that we pass to the forEach method can optionally take a separate parameter, and that's the index  

numbers.forEach((number, index) => console.log(number)); 


We don't get the index when you uses the for of loop, but you can use the for in loop 
======================================================================================================================================================================================
Joining Arrays:

const numbers = [1, 2, 3];
const joined = numbers.join(','); // returns a string
console.log(joined) // 1,2,3 


opposite to this is the split method with the string 

we get the string, split it using a separator and then combining the resulting array using some joining separator.  This technique is particularly useful when building a URL slug.
======================================================================================================================================================================================
Sorting Arrays:

const numbers = [2, 3, 1]
numbers.sort();  // this method converts each element into string and then sorts the elements in the array
console.log(numbers);


numbers.reverse(); // reverse the elements of an array


The sort method is pretty useful when you have numbers and strings in an array. But when you have objects, it doesn't work by default, you have to do some extra work. 


const courses = [
	{id: 1, name: 'Node.js'},
	{id: 2, name: 'Javascript'}
];

The sort method optionally takes an argument and thats the function that is used for comparison. So when we call the sort method, this method gets those two objects in the above array and compares them. Now if they are in the right order, it will skip to the next few elements, otherwise it's going to rearrange them. 


courses.sort(function(a, b) {
  // a < b => -1
  // a > b => 1
  //a === b => 0
  
  if (a.name < b.name) return -1;
  if (a.name > b.name) return 1;
  return 0;
  });
  
  
  Note: that words are case sensitive,  learn ascii table by searching in google 
  
  
  you can do a work around by assigning the two arguments as 
  
  const nameA = a.name.toUpperCase();  //either uppercase or lowercase
  const nameB = b.name.toUpperCase(); 
  
======================================================================================================================================================================================Testing the Elements of an Array:


we have two very useful methods, every and some 


const numbers = [1, 2, 3]

let's say you want to check all numbers in the array are positive


const allPositive = numbers.every(function(value) {
	return value >= 0;
});


this method will run the callback function on every element in the array, as soon as it finds an element that doesn't match the criteria, it's going to stop  searching.



console.log(allPositive); //true
const numbers = [1, -1, 2, 3]; // with this input we get false and as soon it hits the number -1, the search will stop



the some methods checks for atleast one element matches the criteria


const atLeastOnePositive = numbers.some(function(value) {
	return value >= 0;
});

the callback function will be applied to every element in the array, as soon as it find the element which matches the criteria, the search will stop.

======================================================================================================================================================================================
Filtering an Array: filter elements from an array (learn it in google) 

Mapping an array: map each element in an array to something else (learn it in google)

note: if you're returning an object in the arrow function syntax you need wrap them inside brackets like this ({value:n})


Reducing an Array: we can reduce all the elements in an array into a single value, like sum of all elements in an array (learn it in google)


let sum = 0;
for(let n of numbers)
	sum += n;


const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);
 
The accumulator parameter is exactly (sum = 0), it's something that we initialize and the callback function is executed multiple times and each time the currentValue is set to one element in this array. 

Internally the reduce method will get the result (accumulator + currentValue) and store it in the accumulator,

To initialize the accumulator to zero, as the second argument to the reduce method we pass 0 

So the reduce method has two arguments, the first argument is callback function and the second argument is the initial value for the accumulator. 

if we don't initialize or didn't mention the second argument, accumulator will be set to first element in the array

for more info, learn it in google

======================================================================================================================================================================================
Exercises:

1. Array from Range:

const numbers = arrayFromRange(-10, -4);

console.log(numbers);

function arrayFromRange(min, max){
	const output = []
	for(let i=min; i <= max; i++)
		output.push(i);
	return ouput; 
}



2. Includes  -- write a function like includes method for array:

const numbers = [1, 2, 3, 4];

console.log(numbers.includes(numbers, 1));

function includes(array, searchElement) {
	for(let element of array)
		if(element === searchElement)
			return true;
	return false;
}



3. Except -- rewrite array's except method implementation

const numbers = [1, 2, 3, 4, 1, 1]

const output = except(numbers, [1, 2]);

console.log(output);

function except(array, excluded) {
	const output = [];
	for(let element of array)
		if(!excluded.includes(element))
			output.push(element);
	return output;
}




4. Moving an Element:

const numbers = [1, 2, 3, 4];

const output = move(numbers, 1, -1);

console.log(output);

function move(array, index, offset) {
	const position = index + offset;
	if (position >= array.length || position < 0) {
		console.error('Invalid offset.');
		return;
	}
	const output = [...array];
	const element = output.splice(index, 1)[0];
	output.splice(index + offset, 0, element);
	return output;
}




5. Count Occurences:

const numbers = [1, 2, 3, 4];

const count = countOccurences(numbers, 1);

console.log(output);

function countOccurences(array, searchElement){
	let count = 0;
	for(let element of array)
		if (element === searchElement)
			count++;
	return count;
}

using reduce method to achieve the same thing:

array.reduce((accumulator, current) => {
  if (current === searchElement)
	return accumulator++;
}, 0);


array.reduce((accumulator, current) => {
	const occurence = (current === accumulator) ? 1 : 0;
	console.log(accumulator, current, searchElement) 
	return accumulator + occurence;
}, 0);





6. Get Max:

const numbers = [1, 2, 3, 4];

const max = getMax(numbers);

console.log(max);

function getMax(array){
	if (array.length === 0) return undefined;
	
	let max = array[0];
	
	for(let i = 1; i < array.length; i++)
		if array[i] > max)
		max = array[i];
		
	return max;
}


using reduce method: // remember if you don't pass the initial value to the reduce method, by default it will be set to first element in the array.
function getMax(array){
	if (array.length === 0) return undefined;
	
	array.reduce((accumulator, reduce) => {
	
	if (current > accumulator) return current;
	
	return accumulator;
	
	// or for the above two lines, by using the conditional operator
	// return (current > accumulator) ? current : accumulator;
	
	// or for simplicity we can also change the name of accumulator and current to a and back
	// array.reduce((a, b) => (a> b) ? a : b);
	
	});
}




7. Movies:


const movies  = [
 { title : 'a', year: 2018, rating: 4.5	},
 { title : 'b', year: 2018, rating: 4.7	},
 { title : 'c', year: 2018, rating: 3	},
 { title : 'd', year: 2017, rating: 4.5	}
 ];
 
 // All the movies in 2018  with rating > 4
 // sort them by their rating
 // Descending Order
 // pick their title 
 
 // Hence the result should be  --> 'b' 'a'
 
 const titles = movies
				.filter(m => m.year === 2018 && m.rating >= 4)
				.sort((a,b) => a.rating - b.rating)
				.reverse()
				.map(m => m.title)
				
=====================================================================================================================================================================================

Function Declarations vs Expressions:

//Function Declaration
function walk() {
	 console.log('walk');
}


In Javascript, there is another way to define a function, and that is using a function expression.
// Function Expression
let run = function() {};

and as you know, functions are objects. so setting the run variable to a function is similar to setting it to an object 


//Named Function Expression
let run = function walk() {
	console.log('walk');
};

//If you don't mention the name of the function, we call it as Anonymous Function Expression 


we can call the function --> run();

let move = run;  Now both move and run are referencing the same function which is one object in memory

So, to recap, in javascript there are two ways to define a function, we can use the function declaration syntax or function expression which basically involves declaring a variable or a constant and then setting it to a function. 

=====================================================================================================================================================================================

Hoisting:

The key difference between between the function declaration and function expression is, we call the function(the function that is defined using the function declaration syntax) before it is defined.

eg:

walk();

function walk() {
	 console.log('walk');
}


But we cannot do the same with the function that is defined using the function expression syntax. 

run();

let run = function walk() {
	console.log('walk');
};

We get an error(Uncaught ReferenceError). This is exactly like using a variable or a constant before it is defined. 


The reason for all of this is, because when our javascript engine executes this code, it moves all the function declarations to the top. This is what we call hoisting.

So, Hoisting is the process of moving function declarations to the top of the file. and this is done automatically by the javascript engine executing the code. 
=====================================================================================================================================================================================

Arguments:

Every function in javascript has a special object called arguments.

like args and kwargs in python. learn it in google


we can use for of loop to iterate over argument for basic operations like adding all the arguments and returns the result.

Now earlier I told you that we can use the for of loop on arrays, but technically this loop can used on any object that has an iterator. So the plain objects that we create with the object literal syntax don't have a iterator. But this particular object(arguments) has symbol.iterator which means this object has an iterator. So we can use for loop  to iterate over this object. 
=====================================================================================================================================================================================

The Rest Operator:

In modern javascript, if you want to have a function with a varying number of parameters you can use the rest operator. 

function sum(...args){
	console.log(args);
}

console.log(sum(1,2,3,4,5,6,7));

When we apply the rest operator to a parameter of a function, we can pass a varying number of arguments and the rest operator will take all of them and put them in an array.


you can use the reduce method with this array:

args.reduce((a, b) => a + b);



function sum(discount, ...prices) {
	const total = prices.reduce((a, b) => a + b);
	return total * (1 - discount);
}


sum(0.1, 20, 30);

Also, note that we cannot have a parameter after using the rest operator and the rest parameter should the last parameter in the function. That's why we call it rest. we can have 0 or more parameters before this, in this case we can have discount, and the rest of the parameters, or the rest of arguments that have passed to this function. That's the reason this operator is called the rest operator. 
=====================================================================================================================================================================================

Default Parameters:


function interest(principal, rate, years) {
	rate = rate || 3.5;
	years = years || 5;
	
	return principal * rate / 100  * years;
}

console.log(interest(10000));


Starting from ES6, we have cleaner way of implementing the above logic.

function interest(principal, rate=3.5, years=5) {

	
	return principal * rate / 100  * years;
}

console.log(interest(10000));

But there's just one caveat here, once you give a parameter a default value, you should also give all the other parameters after that a default value. Because sometimes it's really confusing.

So, as a best practice, whenever you want to give the function parameter a default value, make sure that parameter is the last parameter in the list, or give all the parameters after that a default value. 
=====================================================================================================================================================================================

Getters and Setters:


const person = {
	firstName : 'Mosh'
	lastName : 'Hamedani'
	fullName : function() {}, //older syntax
	fullName() {
		return `${person.firstName} ${person.lastName}`
	}
};

console.log(person.fullName());


However, there are a couple of problems with this approach. The first problem is that this is read only. In other words, we cannot set a person's full name from outside. It would be nice if we could do this. and then firstName and lastName properties would be automatically set based on what we passed from outside. 

The other issue. that we don't like to call this like a method. It would be nicer, if we could treat this as a property. 
That's where getters and setters come into the picture  

//getters -> to access properties 
//setters -> change/mutate them 

with getter, we can read the value as a property and with setter we can set if from outside

const person = {
	firstName : 'Mosh'
	lastName : 'Hamedani'
	fullName : function() {}, //older syntax
	get fullName() {
		return `${person.firstName} ${person.lastName}`
	}
};


Hence we can access it from outside, person.fullname



Now, to able to set it from outside we need to add a setter. 

const person = {
	firstName : 'Mosh'
	lastName : 'Hamedani'
	fullName : function() {}, //older syntax
	get fullName() {
		return `${person.firstName} ${person.lastName}`
	},
	set fullName(value){
		const parts = value.split(' ');
		this.firstName = parts[0];
		this.lastName = parts[1];
	}
};


person.fullName = 'John smith';

=====================================================================================================================================================================================

Try and Catch:


const person = {
	firstName : 'Mosh'
	lastName : 'Hamedani'
	fullName : function() {}, //older syntax
	get fullName() {
		return `${person.firstName} ${person.lastName}`
	},
	set fullName(value){
		if (typeof value !== 'string')
			throw new Error('Value is not a String');
			
		const parts = value.split(' ');
		if (parts.length !== 2)
			throw new Error('Enter a first and last name.');
			
		this.firstName = parts[0];
		this.lastName = parts[1];
	}
};


try{
	person.fullName = null;
}

catch(e){
	console.log(e);
}




difference between errors and exception:

const e = new Error(); //this is an error object

throw e; //but the moment you throw this error, we refer to that as an exception. so this is an exceptional situation that should not have happened


Also, basically when we throw an exception, the lines after the throw statement are not executed. will jump out this method and control will move to the catch block. There we will catch the exception and do something with it. 
=====================================================================================================================================================================================

Local vs Global scope:


When we declare variables or constants with let or const, their scope is limited to the block in which they are defined.

The condition is applied to if, else block, for loop,


We can have two variables or constants with the same name but different functions. And that's perfectly valid

function start(){
	const message = 'hi';
}

function stop(){
	const message = 'bye';
}

start();



If you declare a variable outside the function or block, the scope will be global scope
But what if you have same name inside function as global scope, the local variable will take the precedence

const color = 'red';

function start(){
	const message = 'hi';
	const color = 'blue';
	console.log(color); // 'blue'
}

So, local variables, or local constants in a function, take precedence over global variables or constants.  Now, In general you should avoid defining global variables or constants, that is considered bad practice.

As a metaphor, imagine the globally declared variable is a tooth brush and each function is a person. you don't want to have a tooth brush that is shared with multiple people. Each person should have their own tooth brush. So, you should avoid defining global variables or constants because they're accessible everywhere, globally and each function can accidentally change their value and this will lead to all kinds of bugs and issues in our programs. 
=====================================================================================================================================================================================

Let vs Var:

Normally if you define variable with let in for loop, it doesn't not be accessible outside its scope. But if you declared it with var, we can access it. 

eg: 
function start(){

	for(let i=0; i<5; i++)
		console.log(i);
	
	console.log(i);// i cannot be accessible
}


function start(){

	for(var i=0; i<5; i++)
		console.log(i);
	
	console.log(i);// i can be accessible
}

This is the problem with the 'var' keyword. when you declare a variable with var. It's scope is not limited to the block in which it's defined. It's limited to the function in which it's defined and this is not how most or all programming languages out their work. It's one of the weird things in Javascript that we have had for a long time. 


//var => function-scoped variables
//ES6 (ES2015: let, const => block-scoped variables



The second issue is with global variables. 

var color = 'red';
let age = 30; 


Now, when we use 'var' outside of a function, this creates a global variable and attaches that global variable to the window object in the browser. 

But when you use the let keyword to define a global variable, that global variable is not attached to the window object 


Avoid, using the var keyword, because it creates variables that are function scope, not block scope. 
=====================================================================================================================================================================================

The 'this' keyword:


'This' references the object that is executing the current function

Let me give you a very simple rule of thumb. If the function is part of an object, we call that function a method, right? So, if that function is a method in an object, 'this' references that object itself. Otherwise if that function is a regular function, which means it's not part of an object, this references the global object, which is the window object in browsers and global in Node. 

//method -> obj
//function -> global (window, global)


eg:
with the first rule    method -> obj

const video = {
	title : 'a',
	play() {
		console.log(this);
	}
};

video.play(); //{title : 'a', play:f}

Since play is a method in a video object, this references the object itself(video)




with the second rule 

function playVideo() {
	console.log(this);  // we do get global object in the console which is window in browsers and global in Node
}



and what if it is a constructor:

function Video(title) {
	this.title = title;
	console.log(this);
}

const v  = new Video('a'); // here we get a new object  

Because earlier in this course we mentiond that new operator, when you use the new operator it creates a new empty object({}) and sets 'this' in this constructor function to point to this empty object({})


also note that using 'this' inside the call back function will references the window object only, because call back function is regular function only, but how we can solve this

showTags(){
	this.tags.forEach(function(tag) {
		console.log(this, tag);
	}, this);  // since showTags() is a method inside a object, 'this' will references the current object only and here we are not inside of a callback function. we are still     // in the execution context of the showTags method
  }
 
 
 Although, not all methods in Javascript give you the ability to pass the 'this' argument. So we have a few different solutions for that and that's the topic for the next lecture. 
====================================================================================================================================================================================

Changing 'this':


Let's see the few different solutions to change the value of 'this' in a function. 

so, now let's imagine our for each method doesn't have the second parameter. How we can change the value of 'this'


One solution is to define self or that and assign it to 'this'

const video = {
	title: 'a',
	tags: ['a', 'b', 'c']
	showTags(){
	const self = this;  // or const that = this   // at this point, self is referencing the video object and in our callback we can use self instead of this. 
	this.tags.forEach(function(tag) {
		console.log(self.title, tag);
	}, this);      
  }

But this is not the preferred approach, but it's something that you see in a lot of Javascript applications out there. So I just want you to understand it, but don't use this approach.


Now let's take a look at another approach.



Earlier in the course, we learned that functions are objects in javascript. So the functions are having properties and methods that we can access using a dot notation. In that we have methods apply, bind, call. With this we can change the value of 'this'

let's say:

function playVideo(){
	console.log(this);
}

if we use call method... playVideo.call(...   here first parameter of call is 'this'. So we can pass an object and 'this' will reference that object

for example:

playVideo.call( {name : 'Mosh'} ) // we get as {name: 'Mosh'}
playVideo() // we get an window object


similar to 'call', we have 'apply', so what do you first argument to 'call' or 'apply', will be used as a value of 'this'. The difference between 'call' and 'apply' is only about passing arguments. let's say the function playVideo has multiple arguments, we can supply them to the 'call' method using comma and with the apply method, we would pass them as array. 

We have another method which is 'bind'

playVideo.bind( {name : 'Mosh'} ) , but this 'bind' method does not call our playVideo function. It returns a new function and sets 'this' to point to the object that we pass( {name : 'Mosh'}) permanently. So no matter how we call that function, 'this' will always, always, always, point to the object that we pass.



Now let's use this in video object:

const video = {
	title: 'a',
	tags: ['a', 'b', 'c']
	showTags(){
	this.tags.forEach(function(tag) {
		console.log(this.title, tag);
	}.bind(this));      
  }
  

So using bind is second solution. But there is a newer and better solution. Starting from ECMA script 6, we have arrow functions.  The good thing about the arrow functions is that they inherit the 'this' value.

Let me show you what I mean by that


const video = {
	title: 'a',
	tags: ['a', 'b', 'c']
	showTags(){
	this.tags.forEach(tag => {
		console.log(this.title, tag);
	});      
  }  
  
  we will get the same result without doing anything extra. The reason for this is because arrow functions inherit 'this' from the containing function. In the above function(showTags()) 'this' references the video object. So, when we pass an arrow function here, the same 'this' value is used in this arrow function. In other words, 'this' is not rebound to a new object. 
  
  
  So, to quickly recap,  there are 3 ways to change the value of 'this'. The first solution is by using the 'self' approach. The second solution is by using the 'bind' method. And the newest and modern approach to solve the particular problem when dealing with callbacks is to use an arrow functions. 
  
=====================================================================================================================================================================================  
Exercise 

1. Sum of Arguments:

function sum(...items) {  
	if (items.length === 1 && Array.isArray(items[0]))
		items = [...items[0]];  // spread operator
	return items.reduce((a, b) => a + b); // the rest operator will convert all to an array
	
}
	





2. Area of Circle:

const circle = {
	radius : 1,
	get area() {
		return Math.PI * this.radius * this.radius;
	}
};

console.log(cirlce.area) // 3.14159265..  here we have implemented read only property of area



3. Error Handling:

try{
	const numbers =[1, 2, 3, 4, 5]
	const count = countOccurences(null, 1);
	console.log(count);
}
catch(e) {
	console.log(e.message);
}


function countOccurences(array, searchElement){
	if (!Array.isArray(array))
		throw new Error('Invalid array.');
	return array.reduce((accumulator, current) => {
		const occurence = (current === accumulator) ? 1 : 0;
		console.log(accumulator, current, searchElement) 
		return accumulator + occurence;
	}, 0);
}
=====================================================================================================================================================================================


JavaScript 2: Advanced


What is OOP(Object-oriented Programming)?


Object-oriented programming is a programming paradigm or style of programming that is centered around objects rather than functions.


Languages that support object oriented programming:

C#
Java
Ruby
Python

Now Javascript is little bit controversial 

It may interest you to know that many of the popular frameworks out there that you may know or be using are actually desinged with object oriented programming concepts in mind.  Angular is an example of these frameworks. So, object-oriented programming is a very popular style of programming, and it comes up in many technical interviews. 






4 pillars of Object-oriented Programming:

Encapsulation
Abstraction
Inheritance
Polymorphism 

Before Object oriented programming, we had procedural programming that divided a program into a set of functions. So, we have data stored in a bunch of variables and functions that operate on the data. This style of programming is very simple and straight forward. But as your programs grow, you will end up with a bunch of functions that are all over the place. place. You might find yourself copying and pasting lines of code over and over. You make a change to one function and then several other functions break. 
That's what we call spaghetti code. There is so much interdependency between all these functions, it becomes problematic. 
Object-oriented programming came to solve this problem. In object-oriented programming, we combine a group of related variables and functions into a unit. We call that unit an object. 

We refer to these variables as properties and the functions as methods. Here's an example. Think of a car. A car is an object with properties such as make, model, and color, and methods like start, stop, and move. Now you might say, but Mosh, we don't have cars in our programs. Give me a real programming example. Okay, think of the local storage object in your browsers. Every browser has a local storage object that allows you to store data locally. 
This local storage object has a property like length, which returns the number of objects in the storage and methods like set item and remove item. So in object oriented programming, we group related variables and functions that operate on them into objects. And this is what we call encapsulation. 

Let me show you an example of this in action. So here we have three variables, base salary, overtime, and rate. Below these we have a function to calculate the wage for an employee. We refer to this kind of implementation as procedural. So we have variables on one side and functions on the other side. They are decoupled. 

let baseSalaray = 30_000;
let overtime = 10;
let rate = 20; 

function getWage(baseSalary, overtime, rate){
	return baseSalary + (overtime * rate);
}


Now let's take a look at the object-oriented way to solve this problem. We can have an employee object with three properties, base salary, overtime and rate, and a method called getWage. 

let employee = {
	baseSalary : 30_000,
	overtime : 10,
	rate : 20, 
	getWage : function() {
		return this.baseSalary + (this.overtime * this.rate);
  }
};
employee.getWage();



Now why is this better? Well, first of all, look at the getWage function. This function has no parameters. In contrast, in a procedural example, our getWage function has three parameters. The reason in this implementation we don't have any parameters is because all these parameters are actually modeled as properties of this object. All these properties and the getWage function, they're highly related, so they're part of one unit. So one of the symptoms of procedural code is functions with so many parameters. When you write code in object-oriented way, your functions end up having fewer and fewer parameters. As Uncle Bob says, the best functions are those with no parameters. The fewer the number of parameters, the easier it is to use and maintain that function. So that's encapsulation. 

Now let's look at abstraction. Think of a DVD player as an object. This DVD player has a complex logic board on the inside and a few buttons on the outside that you interact with. You simply press the play button and you don't care what happens on the inside. All that complexity is hidden from you. This is abstraction in practice. We can use the same technique in our objects. So we can hide some of the properties and methods from the outside, And this gives us a couple of benefits. First is, that we'll make the interface of those objects simpler. Using and understanding an object with a few properties and methods is easier than an object with several properties and methods. The second benefit is that it helps us reduce the impact of change. Let's imagine that tomorrow we change these inner or private methods. None of these changes will leak to the outside because we don't have any code that touches these methods outside of their containing object. We may delete a method or change its parameters, but none of these changes will impact the rest of the application's code. So, with abstraction, we reduce the impact of change.

Now, the third core concept in object-oriented programming, inheritance. Inheritance is a mechanism that allows you to eliminate redundant code. Here's an example. Think of HTML elements like text boxes, drop-down lists, check boxes, and so on. All these elements have a few things in common. They should have properties like hidden and inner HTML and methods like click and focus. Instead of redefining all these properties and methods for every type of HTML element, we can define them once in a generic object, call it HTML element, and have other objects inherit these properties and methods. 
So inheritance helps us eliminate redundant code. 

And finally polymorphism. Poly means many, morph means form. So polymorphism means many forms. In object-oriented programming, polymorphism is a technique that allows you to get rid of long if and else or switch and case statements. So back to our HTML elements example, all these objects should have the ability to be rendered on a page. But the way each element is rendered is different from the others. If we want to render multiple HTML elements in a procedural way, our code would probably look like (switch case: case('select')... case('text')...)  But with object orientation, we can implement a render method in each of these objects and the render method will behave differently depending on the type of the object we are referencing. So we can get rid of this nasty switch and case and use one line of code like this(element.render())

So here are the benefits of object-oriented programming. Using encapsulation, we group related variables and functions together and this way we can reduce complexity. Now we can reuse these objects in different parts of a program or in different programs. With abstraction, we hide the details and the complexity and show only the essentials. This technique reduces complexity and also isolates the impact of changes in the code. With inheritance, we can eliminate redundant code. And with polymorphism, we can refactor ugly switch case statements. 
=====================================================================================================================================================================================

Setting Up the Development Environment:

visual studio code
have basic html code (! and press tab)
have script tag element and refer index.js

write all code in the index.js
to test it use console.log and check it in chrome development tools
=====================================================================================================================================================================================

Next, we will look at classes in ES6, which stands for ECMAScript 6. 
Now, if you don't know what is ECMAScript, ECMAScript is a specification developed by ECMA, which is an organization that defines standards technologies. So ECMA as an organization has developed ECMAScript which is a specification. Now JavaScript is a programming language that confirms to the ECMAScript specification. Now starting from year 2015 ECMA started to enhance JavaScript so the specification that came out in year 2015 is referred to as ECMAScript 2015 or ECMAScript version 6. Now in this specification we have some new features in JavaScript. One of them is classes. But classes that we have in JavaScript are not like classes we have in languages like C sharp or Java because JavaScript is a dynamically typed language. So classes are essentially syntactic sugar over prototypes and prototypical inheritance. 
So that's why we have two sections on these topics in the course. Once you master these, then we'll look at ES6 classes in section five. and finally we will finish this course by looking at modules. 
=====================================================================================================================================================================================

Objects:

JavaScript is all about objects. So in order to learn object-oriented programming, first you need to have a good understanding of objects. So in this section, I'm gonna cover some fundamental concepts around objects, such as creating objects, factories and constructors, primitives and reference types and how they behave differently, working with the properties of an object, such as adding, removing properties, as well as enumerating them. You're also gonna learn how to define private properties as well as getters and setters. If you know all these topics well, feel free to skip this section and move to the next section where I talk about prototypes. Otherwise, continue watching. So now, let's get started. 

=====================================================================================================================================================================================

Object Literals:

Let's start this section by creating an object. So I'm going to use the 'let' keyword in ES6, which is the replacement for 'var'. So in ES5 and before, we had 'var' for declaring variables, but 'var' has a number of issues when it comes to scoping. That's beyond the scope of this course. I just want to let you know that as a best practice, stop using 'var', use either 'let' or 'const'. With 'const', you're basically defining a constant, so you won't be able to reassign it. If you want to reassign a variable use 'let', now in this demo, I'm going to use 'const; to define a constant So let's call this circle and set it to an object Here I'm using object literal syntax. 

let circle = {};

So these curly braces refer to them as object literal syntax an Object in JavaScript is essentially a collection of key value pairs. 

const circle = {
	radius: 1, 
	location: {
		x : 1, 
		y : 1
	},
	draw : function() {
		console.log('draw');
	}
};

Now I want to define a few terms here this circle object has three members radius,location and draw, if a member is a function we refer to that as a method.  So here we say Draw is a method. These other members are what we call properties Now, in some JavaScript tutorials, they refer to all these members as properties, whether they're functions or not. But technically, in object-oriented programming, properties and methods are fundamentally different because a property is used to hold values. A function or a method is used to define some logic. So, now that we have the circle object, we can access its members using the dot notation. 

circle.draw();



So, object literal is a simple way to define an object. but we can also define objects using factories and constructors and that's the topic for the next lecture.

=====================================================================================================================================================================================

Factories:

Now let's imagine we want to create another circle. With the current implementation. We have to duplicate all the current object into new one. Now, this can be a problem if we have one or more methods in our object. In this case, We have the draw method. And as you can see, we have duplicated that in two different places. So if there is a bug in this method, we have to come back and fix it in multiple places. Now, this is a very simple object. imagine if the circle object had 10 methods. So object literal syntax is not a good way to create an object and duplicate it if the object has at least one method. If an object has one or more methods, we say that object has behavior. 
Like a person that can do different things. So it has behavior. Now let's imagine here we didn't have this draw method. Duplicating the object wouldn't be a big deal. So basically we would end up with two objects and then here we could use different values. So creating objects with the object literal syntax is an issue only if that object has behavior. So what's the solution? The solution is to use a factory or a constructor function. So let me show you how that works.


//Factory Function
function createCircle(radius,  ){
return {
	radius: 1, 
	draw : function() {
		console.log('draw');
		} 
	};  
}


const circle =  createCircle(1);
=====================================================================================================================================================================================

Constructors:

Now there is another way to create an object using a constructor function. 

So once again, we define a function, but the naming convention we use for a constructor function is different. The first letter should be uppercase. So we call it circle with an uppercase C(pascal convention). The developers with background in languages like C sharp and Java this kind of looks like a class However, as you can see we're defining a function in JavaScript. We don't have the concept of classes so our circle function is gonna take a radius parameter But in the body instead of returning an object We're gonna use the 'this' keyword to set the properties of this object What is 'this'? 

'this' is basically a reference to the object that is executing this piece of code. So imagine we have a new empty object in memory now we're gonna use 'this' to reference that object and then use dot notation to set various properties on that object. so we can set the radius property to this radius argument (this.radius = radius;)


function Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}

const another = new Circle(1);

When we use the new operator, a few things happen under the hood. This new operator will create an empty object. So, like this({} -> an empty object). Then, it will set 'this' to point to that object. Because 

Because by default, 'this' points to the global object. If you're running this code inside of a browser, the global object is the window object. If you're running it inside a node environment, the global object is global. 


try printing 'this' keyword inside the function Circle --> it will refer to the Circle object, it is because that we use the new operator here. 

then print 'this' outside the function -->  now 'this' will references to the window object. Window object is the global object in the browser. We don't want to use this, we don't want to mess up with this. We don't want to define global variables because they're bad practice, because they're available everywhere in our application. So it is possible that one function or another will modify the value of these variables accidentally and create a bug in our application. 

So when we use the new operator to call a function, three things happen. First, the new operator will create an empty object. Then it will set 'this' to point to that object and and finally, it will return that object from the function. So note that, we don't have an explicit return statement. We are not returning 'this'. This will happen automatically when we use the new operator. 

So basically, we have two ways to create an object. We can use a factory function or a constructor. There is nothing special about these. They're both regular functions in JavaScript. If we return an object in the function(the normal function way), we refer to that function as a factory function. In contrast, if we use the 'this' keyword along with the new operator, we refer to that function as a constructor function.  

Now you might ask, what is the difference between these two patterns for creating an object? Which approach should you use? Well, it really depends who you ask. Developers coming from languages like C sharp and Java Prefer the constructor function syntax because this looks like creating an instance of a class. 
But once again, in JavaScript, we don't really have classes. Other developers don't like this approach. They prefer to use factory functions. And one of their arguments is what if a developer? Forgets to use the new operator here? Then we're defining These property methods on the global object, which is in this case the window object. But this discussion, this argument is really outdated. With the modern JavaScript and the tools that are available to us, We get an error if we forget to use the new operator here. So my suggestion to you is not to get hung up on these religious arguments about factories versus constructors. As a developer, You should be familiar with both these patterns because as you work on different projects and different teams, You will see both of these patterns for creating an object so you should understand how they work. choose the pattern that you prefer 
=====================================================================================================================================================================================

Constructor Property:

Every object in JavaScript has a property called constructor, and that references the function that was used to construct or create that object. So 

function createCircle(radius,  ){
return {
	radius: 1, 
	draw : function() {
		console.log('draw');
		} 
	};  
}

const circle =  createCircle(1);



function Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}

const another = new Circle(1);


So here we have two objects, circle and another. Let's look at the constructor property. 
 
So here on the console --> another.constructor --> 

f Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}

So as you see, this returns our circle function that we used to create this object. 


Now let's look at circle.constructor. 

circle.constructor --> f Object() { [native code] }

What is this? Well, you can tell that this is a function because here we have this blue F. And as you can see, the first letter of this function is uppercase. So this is a built-in constructor function in JavaScript. When we create an object using the object literal syntax, internally, the JavaScript engine uses this constructor function. Let me show you. 

let's define an object like this --> let x = {}; --> When we use this syntax(object literal}, JavaScript engine will translate that to something like this --> let x = new Object();

Okay, so the circle object we created and return it from our factory function. And because we use the object literal syntax, internally it was created using this object Constructor function(f Object ()). 

In JavaScript. We have a few other built-in constructors. For example, We have string for creating strings, but quite often we use string literals. So single quote or double quote or back tick. Using these literals is cleaner and simpler than using the constructor. you also have boolean, but again, we don't use this. We either use true or false and 
so we refer to these as boolean literals. We also have number, but instead we use number literals, like one, two, three, whatever. So this is what i want you to take away. Every object has a constructor property, and that references the function that was used to create that object. 
=====================================================================================================================================================================================

Functions are Objects:

One of the confusing concepts in JavaScript is that here functions are objects. So this circle function we have here is actually an object. Don't believe me? If you use dot operator with Circle you get the intellisense of all members of the circle function or cirlce object. 


function Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}

const another = new Circle(1);


So the purple icons are methods like call, bind, and apply, and the blue icons are properties. So let's take a look a few of these members 

Circle.name --> returns the name of the function
Circle.length --> the number of arguments


Also, I told you that every object in javascript has a constructor property, and that references the function that was used to create that object. Now here's the interesting part. 
Who do you think Created this object. Let's have a look. 

Circle.constructor --> f Function() { [native code] }   --> When we declare a function using the above syntax, internally JavaScript engine will use this function constructor to create this object. object. Let me show you so I'm gonna define a constant called circle1 and Separate from our circle set it to new function 


const circle1 = new Function('radius', `
this.radius = radius; 
this.draw = function() {
console.log('draw');
	}
`);


Now we can call this circle1, just like calling our circle function. 

const circle = new Circle1(1);

circle --> {radius: 1, draw: f} //circle. Look, it's a real circle object with these two members. 


Now let's take a look at a couple of methods that are available in our functions. 

//call 

Circle.call({}, 1)  
The first argument is 'this' argument. Here we need to pass an empty object, and 'this' will reference this object({}} that we pass here as first parameter. Okay after that we add our arguments explicitly So here we have one argument we pass '1', if you had multiple arguments, we would pass them Explicitly like this '1, 2, 3, 4'

this expression  --> Circle.call({}, 1); -->  is exactly equal to -->  const another = new Circle(1);

when we use the new operator, this new operator will internally create an empty object({}) and Pass that as the first argument to the call method and this object({}) will determine the context for 'this'.  so 'this' will reference this object({}). Earlier I told you that if you don't use the new operator This by default will point to the global object which is window. So if I want to rewrite this expression -->(const another = Circle(1);) in this way -->(Circle.call({}, 1);) instead of passing an empty object. I would pass window -->
(Circle.call(window, 1);) and of course, we don't want to do this. I'm just explaining to you what happens under the hood. So let's revert this back. So the first argument here specifies the target of 'this', okay? 

Now we have another method called apply. It's exactly like the call method. With this, we can call a function, but instead of passing all the arguments explicitly, we pass them An array so this is useful if you already have an array somewhere else in your application and you want to pass an array as the second argument to the apply method. 

Circle.apply({}, [1, 2, 3, 4]);

So this is the takeaway. In JavaScript, functions are objects.

=====================================================================================================================================================================================

Value vs Reference Types:

JavaScript we have two categories of types. On one side, we have value types also called primitives, on the other side, we have reference types. So, in the value types category, we have number, string, boolean, Symbol which is new in ES6. We're gonna look at that later in the course as well as undefined and null. These are the primitive or value types. On the other side, we have objects, functions and arrays. So in the last lecture, you learned that functions are also objects. The same is true about arrays. So in a nutshell, in JavaScript, we have primitives and objects. 
Now in this lecture, I'm gonna show you how primitives and objects behave differently Because this is absolutely important for you to understand before we move on to the next section where I talk about prototypes. 


let x = 10;
let y = x;

x = 20;

What I want you to note here is that X and Y are two independent variables. So, let's save the changes, go back in the console, Let's log x and y. 

x --> 20
y --> 10


They are independent. So when we work with primitives, the value(10) is is stored inside of this variable(x). when we copy that variable, the value that is stored in the variable is copied into this new variable(y). so they are completely independent of each other.

Now, let's see what happens if we use a reference type or an object here. So i'm going to change the x to an object that has a property called value and then instead of setting x to 20. I'm gonna set x.value to 20. 


let x = {value : 10};
let y = x; 

x.value = 20;

now let's log x and y

x --> { value: 20 }
y --> { value: 20 }

So, this is the takeaway. When we use an object, that object is not stored in the variable(x). That object is stored somewhere else in the memory. And the address of that memory location is stored in inside the variable x. So then when we copy x into y, it's the address or the reference that is copied. In other words, both x and y are pointing to the same object in memory. And When we modify that object using either x or y, the changes are immediately visible to the other variable. 


So here's the conclusion. Primitives are copied by value, reference types or objects are Copied by the reference. 


Let's take a look at another example. So I'm gonna define a function called increase that takes a number.



let number = 10;

function increase(number) {
	number++;
}

increase(number);
console.log(number);  // 10


We see 10, but didn't we increase the number? Well, when we call increase and pass the number variable, its value is copied into this parameter('number' in function) that is local in this function. So, both number variable are independent of each other
In the function, we increment number by 1, so it will be 11. But after this function, the number we used in the function is going to go out of the scope. So when we log the number variable on the console, we're essentially dealing With the first number( let number = 10 ). So I told you that primitives are copied by their value. So here we're dealing with two independent copies. That's why we see 10 on the console.


Now let's change this number variable to a reference type or an object. So I'm gonna change 10 to an object That has a value property.


let obj = { value = 10 };

function increase(obj) {
	obj.value++;
}

increase(obj);
console.log(obj) // { value : 11 }

We got this object with value 11. The reason for this is because when we call increase function and pass this object(obj), this object is passed by its reference. So this local parameter that we have here will point to the same object that we defined here. So in this case, we are not dealing with two independent copies. We have two variables that are pointing to the same object. So any changes we make to this object will be visible to the other variable and So remember this, in JavaScript we have value types, also called primitives, as well as reference types, which are objects. Our primitives are number, string, boolean, symbol, undefined, and null. Primitives or value types are copied by their value. Reference types or objects are copied by their reference. 

=====================================================================================================================================================================================

Adding/Removing Properties:


function Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}


const circle = new Circle(10);

circle.location = { x: 1 }; 

in console --> circle  //Circle{radius: 10, draw:f, location{}}


So here we have our circle constructor function and using that we create a circle object. Now these objects in JavaScript are dynamic. That means after you create them, you can add extra properties in them or delete some properties. You may be wondering why this is useful in the real world. Imagine you're working with a user object. The client that can be a web or a mobile application is going to send a user object to the server and On the server, we get this user object, and then we add additional stuff to it. For example, we can add a token property that we generate on the fly on the server. So we can always add something extra to an existing object. Because we don't have classes, we don't need to define these properties ahead of time. 
We can add them whenever we need them. And this makes JavaScript extremely powerful and easy to work with. In languages like C Sharp or Java, Every time we want to implement scenarios like this, we have to go back and change our classes.  


you also have another notation for accessing properties and that is bracket notation. So another way to rewrite this code is like this --> circle['location'] =  { x: 1 }; 



As you can see, the dot notation is simpler and less verbose than bracket notation. But this notation is also useful in certain scenarios. For example, when you want to dynamically access a property name. 

For example, let's imagine we have this constant called property name set to location -->  const propertyName = 'location';
We have that somewhere in our application. Now we want to access the location property of a circle. If you're dealing with this dynamically, at the time of writing the code, we don't know what is the name of that property. That is calculated at runtime. So we can't type something like this--> circle.location. But what we can do is use the bracket notation. So we use circle[propertyName] =  { x: 1 }


Another use case for using the bracket notation is when you're using the property names that are not valid identifiers. 
For example, let's imagine the name of this property is 'center-location' we can access this property like this --> Circle.center-location. That doesn't work. So if you have special characters or a space, that's when you use the bracket notation, okay? 


Now we can also delete a property from an existing object. A real-world use case for this is when you get a user object from a database and you want to return it to the client. But maybe that user object has certain properties you don't want to send to the client. don't want to send the password. You don't want to send the credit card info. In that case, you will dynamically delete one or more properties from an object. So we use the delete operator and then reference the property name. 

delete circle.location; or delete circle['location'];

=====================================================================================================================================================================================

Enumerating Properties:

Sometimes you need to iterate over or enumerate the properties in an object. We can do that using the for-in loop. 


function Circle(radius) {
	this.radius = radius; //setting a property
	this.draw = function() {
		console.log('draw');
	}
}


const circle = new Circle(10);


for (let key in circle)
	console.log(key, circle[key]);
	
	
What if we want to get only the properties and not the methods. Well, in that case we can use the type of operator to check the type of the value 


for (let key in circle){
	if (typeof circle[key] !== 'function')
		console.log(key, circle[key]);
}


There is another approach to get all the keys in an object:
const keys = Object.keys(circle); 
console.log(keys)  //["radius", "draw"]  With this approach, we cannot separate properties from methods. 


Finally sometimes you want to know if an object has a given property for that we use the 'in' operator 


if ('radius' in circle)
	console.log('Circle has a radius')
	
	
So remember, to enumerate all the members in an object, you can use a 'for in' loop. To get all the keys in an object, use 'object.keys'. And to check for the existence of a property or a method in an object, use the 'in' operator. 
=====================================================================================================================================================================================

Abstraction:


function Circle(radius) {
	this.radius = radius;
	this.defaultLocation = { x: 0, y: 0};
	this.computeOptimumLocation = function() {
	//
	}
	this.draw = function() {
		this.computeOptimumLocation();
	    console.log('draw');
	};
}

cons circle = new Circle(10);
circle. (the intellisense will show the computeOptimumLocation, defaultLocation. where these members should not be accessible to me, he consumer or the client of this object, for example, what would happen if I set default location to false? That's gonna completely mess up with this object. Or as another example, Maybe this computeOptimumLocation method should only be called inside of the draw method. So, if I accidentally call it oustide (circle.computeOptimumLocation), maybe this will put this object in a bad state and then if I call circle.draw, we're going to get a weird error at runtime. 

So in object-oriented programming, we have this core concept called abstraction. Abstraction means we should hide the details and complexity and show or expose only the essentials. In this particular example, we should hide the properties default location, as well as the method computeOptimumLocation. These are implementation details. These are Part of the complexity of this object we want to hide these from the consumers of this object instead we want to expose only the essentials that is the radius and the draw method.

Let me give you a metaphor, think of a DVD player, a DVD player has a complex logic board on the inside But only a few buttons on the outside that you interact with. So what we have on the inside is the implementation detail and what we have on the outside is the public interface of a DVD player. We want our objects to look like this DVD player. We want to hide all the details, all the unnecessary complexity on the inside and expose only a few members or a few buttons on the outside. A lot of developers who have not been able to apply object-oriented programming effectively have failed to comply with this principle. Everything in their objects is public and accessible from the outside. This will bring a number of issues. One issue is that every time you change the implementation of that object, you have to go and modify many different places in your code.  

	this.computeOptimumLocation = function(factor) {
	//
	}
	
	
circle.computeOptimumLocation(0.1)

For example, let's imagine now this compute method requires an argument. Let's say a factor argument. With the current implementation, because we can access this from the outside, Everywhere we have used this method. You have to come back and pass an argument. So one simple change in the implementation of an object results in a number of changes your source code. 

In contrast, imagine if this method was not accessible from the outside. Then we wouldn't have to modify anything outside. we would only modify inside the constructor function, where we have called this computeOptimumLocation function, Right. So remember the abstraction principle of object-oriented programming. Hide the details and expose only the essentials and In the next lecture, I'm going to show you how to implement this in JavaScript. 

====================================================================================================================================================================================

Private Properties and Methods:

So how do we implement abstraction here? You wanna hide certain members from the outside. So earlier you learned that 'this' references the new circle object. Now what happens if I declare a local variable in this function? Let's say 'color', we set that to red. Is this going to be part of that object? Of course not, because we have not set that as a property on that object. We didn't set this.color to color(this.color = color). Okay, so this is only a local variable inside of this function when we get out of this function, this variable goes out of scope and dies. Now with this technique, we can easily hide certain members from the outside. So, DefaultLocation is implementation detail. We don't want this to be accessible from the outside. Instead of setting it as a property on our new object. we define it as a local variable.



function Circle(radius) {
	let color = 'red';
	this.radius = radius;
	this.defaultLocation = { x: 0, y: 0};
	this.computeOptimumLocation = function() {
	//
	}
	this.draw = function() {
		this.computeOptimumLocation();
	    console.log('draw');
	};
}


declaring defaultLocation as local variable and computeOptimumLocation as local method and also inside the draw method, instead of calling this.computeOptimumLocation, we can simply call computeOptimumLocation (since computeOptimumLocation is no longer a method of the object). This will work because in JavaScript, we have this concept of closure. 

function Circle(radius) {
	let defaultLocation = { x: 0, y: 0};
	this.radius = radius;	
	let computeOptimumLocation = function() {
	//
	}
	this.draw = function() {
		computeOptimumLocation();
	    console.log('draw');
	};
}


If you don't know closure, let me simplify it for you. So here we have one function(Circle) and another function(this.draw) inside of that function(Circle). In this function, we can declare certain variables like x and y. And these are local variables, that are only available in the draw function. 
Their scope is limited to the draw function. So when we finish executing the draw function, X&y will go out of scope. 

function Circle(radius) {
	let defaultLocation = { x: 0, y: 0};
	this.radius = radius;	
	let computeOptimumLocation = function() {
	//
	}
	this.draw = function() {
		let x, y;
		computeOptimumLocation();
	    console.log('draw');
	};
}


In contrast to scope, We have closure. A closure determines what variables will be accessible to an inner function. So, the draw function will be able to access all the local variables defined inside that, as well as the variables defined in its parent function(computeOptimumLocation, defaultLocation). These are the variables that are defined in the parent function(Circle). They(computeOptimumLocation, defaultLocation) are within the scope of the Circle function but within the closure of this inner function(draw). 

Now don't confuse closure with a scope because the scope is temporary and it dies. So every time we call the draw method these variables(x and y) will be recreated and reinitialized and then after this function they will die. So, scope is temporary but closure stays there. When we call the draw function, after we finish executing the draw function, the variables(computeOptimumLocation, defaultLocation) will continue to stay in memory, they will preserve their state, because they're part of the closure of the draw function.


Now, let's back to work. private properties and methods..  


function Circle(radius) {
	let defaultLocation = { x: 0, y: 0};
	this.radius = radius;	
	let computeOptimumLocation = function() {
	//
	}
	this.draw = function() {
		computeOptimumLocation();
		//defaultLocation
		//this.radius
	    console.log('draw');
	};
}


const circle = new Circle(10);
circle. --> you only get intellisense of draw method and radius

if you want to access the private members, you simply use them there. You can also use default location. But if you want to access members of the circle object, you need to use 'this' like this.radius. 

If you access the members of the circle object, we only see draw and radius. So, the public interface of new cirlce object is simpler and easier to work with and 
and this will also prevent issues later down the road.
=====================================================================================================================================================================================


Getters and Setters:

In the last lecture, we converted defaultLocation and computeOptimumLocation to private members. Now more accurately, these are not private members of the circle object because technically they are not inside of a circle object. There are local variables that we have defined inside of the Circle function. But from an object-oriented point of view, we can refer to them as private members of the circle object. 



function Circle(radius) {
	let defaultLocation = { x: 0, y: 0};
	this.radius = radius;	
	this.draw = function() {
	    console.log('draw');
	};
}

So, we have this private property defaultLocation. We cannot access this from outside. But, what if we want to display that defaultLocation somewhere in our application? So we don't want to modify, we just want to be able to read it. So, one solution is to define a method called 'this.defaultLocation'. We set it to a function. And in this function, we simply return defaulLocation. Once again, we're dealing with an inner function here. The closure of this function includes all the variables defined here, as well as all the variables defined in its parent functions. So here we have access to default location. And with this, we can call circle.getDefaultLocation() However, I don't like this syntax. 
I don't like the fact that we're calling it as a method. It would be nicer if we could access this property like 'this.defaultLocation'. But we shouldn't be able to set this from the outside. We can only read it So let me show you how to define a property like that,


you can use Object.defineProperty()

Object.defineProperty(this, 'defaulLocation', {
	get: function() {
		return defaulLocation;
	}
});

the first argument to the method is the object that we want to add a new property to. That object is the one that is referenced by 'this', the new circle object, right? So we pass that as the first argument.  The second argument is the name of our property, defaulLocation and the third argument is an object. In this object, we add a key value pair. The key is get. This is a special keyword for JavaScript. And the value is a function. So, when we access circle.defaultLocation, this function will be called. There we can simply return defaultLocation. Again, this variable defaulLocation is part of the closure of the inner function(get: function()). So, we can access defaulLocation.


Now if you want to set the value of this property from the outside, we define a 'setter'. So in this object, we add Another key value pair, the key is set, which is a special keyword, and the value is a function.  But what is interesting is that because we are using a function, in this function we can perform some validation for this value before setting the default location.
 
Object.defineProperty(this, 'defaulLocation', {
	get: function() {
		return defaulLocation;
	},
	set: function(value) {
		if(!value.x || !value.y)
			throw new Error('Invalid Location');
			
		defaulLocation = value;
	}
});

So to recap, use object.defineProperty to define getters and or setters. 
=====================================================================================================================================================================================

Exercise: Stopwatch

Here is a great exercise for you. I want you to use what you have learned in this section and design a stopwatch object like this. So let me show you how this behaves. I'm going to define a constant called SW and set it to a new stopwatch. So that's our stopwatch object. Now, this object has a few members, duration, which is a property, as well as three methods, reset, start, and stop. And the other members you see here, they are inherited from the base object, okay? Now, initially, duration is zero. We can start the stopwatch. Now at this time, if we call start again, it's gonna scream at us. Stopwatch has already started. So we cannot call start twice. Now we can call stop. 
And again, we cannot call stop twice in a row. It's gonna complain because stopwatch is not started. Now we can access the duration property. So stopwatch, oops, sorry. So stopwatch.duration. So this stopwatch counted 19 seconds from the moment I called the start method until I called the stop method. Now we can repeat. So if we call start again, now it continues counting. and then we call stop, and then let's look at the duration again. Now it's a total of 20 seconds. We can also call reset, and this takes the stopwatch to its initial state. So we can call start, and then stop, and then look at the duration. Only two seconds, okay? So this is how the stopwatch works. Now I want you to go ahead and spend about 30 minutes on this exercise, 
Use what you have learned and do your best to implement an object that behaves like this. In the next lecture, I'm going to show you my solution. 


All right, here's my implementation of the stopwatch object. Now don't worry if your implementation is different from mine, chances are it's gonna be different because there is no one solution to a given problem. As long as your stopwatch behaves like what I showed you in the last lecture and it has a clean implementation, your solution is perfectly fine. So here we have a function called stopwatch. This is a constructor function. I have defined a few private variables here, start time, end time, Running to see if the stopwatch is running or not, and duration, which you have initially set to zero. You can see we have three methods here, start, stop, and reset. And I've also defined a read-only property called duration. Look, here. 
We have a getter, which simply returns this duration, which is a local variable in this function, Okay. Now, let's take a look at the implementation of each of these methods. So start. First we have a validation check if the stopwatch is running we simply throw a new error With this message stopwatch has already started otherwise, we said running to true and Set start time to the current date time very simple implementation The stop method is very similar. So First we have a validation check if it's not running. Obviously, we cannot stop it. That's why we throw a a new error. Otherwise, we set running to false. Next, we set end time to the current date time. And then we calculate the seconds between the end time and start time. 
So we call end time dot get time and subtract it from start time dot get time. This expression returns the milliseconds between these two date objects. So we divide it by a thousand to get the seconds and then add that to the duration Variable which we defined earlier. And finally, let's take a look at the reset method. Here we simply set these variables to their initial value. So we set start time and end time to null, Running to false, and duration to zero. So once again, if your implementation is different, don't worry. There is no one best solution to a given problem. If I come back and solve this problem in a month from now, chances are my Implementation is gonna be different from what you see right now. 


function Stopwatch(){
	let startTime, endTime, running, duration = 0;
	
	this.start = function() {
		if (running)
			throw new Error('Stopwatch has already started;');
		running = true;
		startTime = new Date();
	};
	
	this.stop = function() {
		if (!running)
			throw new Error('Stopwatch is not started.');
		running = false;
		endTime = new Date();
		
		const seconds = (endTime.getTime() - startTime.getTime()) / 1000;
		duration += seconds
	};
	
	this.reset = function() {
		startTime = null;
		endTime = null;
		running = false;
		duration = 0;
	};
	
	 Object.defineProperty(this, 'duration', {
		get: function() { return duration; }
	  });
}

=====================================================================================================================================================================================


Prototypes:

Inheritance:
------------
Inheritance is one of the core concepts of object-oriented programming, that enables an object to take on the properties and methods of another object. And this makes it easy to reuse code in different parts of an application. Here is a real example. In the last section, we defined this circle object with the method, computeOptimumLocation(). Now for this discussion, let's imagine here we're working with a class. So let's imagine circle is a class and not an object. SinceI want to explain inheritance in its classical terms. So we have the circle class with one method, computeOptimumLocation(). Let's imagine tomorrow we're going to add another class to our application called square. And square also needs this method, computeOptimumLocation(). For now, let's imagine the implementation of this method is exactly the same across these two different classes. 
We don't want to repeat this implementation. Because if there is a bug in this implementation, we have to fix it in multiple places. Or if we decide to change the implementation and make it better, again, we have to repeat this in different places. So that's when inheritance comes to rescue. We can define a new class called shape, put this method there, and have circle and square inherit this method from the shape class. 
Now, in inheritance we have a few terms that you should be familiar with because I'm gonna use these terms throughout this course. The Shape class is the base class or super class or parent class. All these terms are exactly the same. Different tutorials and different books use different terms. 
In contrast we refer to the Circle class as the derived class or subclass or child class. And finally we refer to the inheritance relationship as 'IS-A' relationship. So we say circle is a shape. Now this is the classical definition of inheritance. But as you know, in JavaScript, they don't have classes. they only have objects. So that's when prototypical inheritance comes in the picture. So essentially we have two types of inheritance, classical and prototypical. And that's one of the topics for interview questions. 

=====================================================================================================================================================================================

Prototypes and Prototypical Inheritance:
----------------------------------------

So in the last lecture, we talked about the circle and shape classes. But in JavaScript, we don't have classes. We only have objects. So how can we implement inheritance only by using objects? Well, conisder we have a Circle object. We can define another object, say Shape, and add all the common behavior or all the common methods in this object, like computeOptimumLocation. And then somehow we can link the circle object to the shape object. Now we refer to the shape object as the prototype of the circle. So a prototype is essentially a parent of another object. A lot of courses and tutorials make prototypes sound so confusing and complicated. It's not. Whenever you hear the word prototype, just think it is 'parent'. So every object in JavaScript, has a prototype or parent except the root object. 

It inherits all the members defined in its prototype. Let me show you 

let x = {}

//while inspecting this x in console you can see the property  --> __proto__: Object 

We have a property called proto know that this property is faded because it's deprecated and you shouldn't directly access it and it's only available here in the console to help you to troubleshoot problems. If you expand that,you can see the properties and methods like constructor( which references the function that was used to construct or create that object), toString, etc. So we have this x object in the memory, and x has a link to another object, which is its prototype. For our discussion. Let's call this object objectBase. It's not an official term. You're not gonna find it anywhere. It's just a name. I'm gonna give it for our discussion. So every object that we create in JavaScript directly/indirectly inherits from objectBase. ObjectBase is the root of all objects in JavaScript and it doesn't have a prototype or parent.
  
If you create another object --> let y = {}, it should also have a prototype property, Which is the same objectBase that we got with x. So here is what we have in memory. We have X and Y, and both these objects reference object base. So, we have a single instance of objectBase in memory. To check, 

Object.getPrototypeOf(x) === Object.getPrototypeOf(y)  //true



Now you might be wondering why I didn't write this expression like this,

x.__proto__ === y.__proto__ //true

The reason for this is, because this property is deprecated. So you shouldn't use it in the code. But you can use it here on the console when debugging your applications. 



So, now that you understand what a prototype is, let's define a Prototypical inheritance. So earlier, I accessed the toString method on the x object. We didn't define this method in our x object, because x was an empty object, right? So, how does this work? How can we access this method? Well, when we access a property or a method on an object, JavaScript engine first looks for that property or method on the object itself. 
If it can't find it, then it looks at the prototype for that object. Again, if it can find that member, it will look at the prototype of that object all the way up to the root object, Which we called object base. So this is prototypical inheritance in action. When accessing a property or a method on an object, JavaScript engine walks up the prototype chain to find a target member. So once again, I want to emphasize that a prototype is just a regular object in memory. There is nothing special about it. Every object has a prototype or a parent except the root object. 

=====================================================================================================================================================================================

Multi-level Inheritance:
------------------------


let x = {};


Generally, if you define a empty array, this will have proto property , you can see an object which has similar methods and properties as of an array and this one will have another proto property where you can see the objectBase.

We have an array which derives from the object arrayBase. Now if you inspect the prototype of the arrayBase object. We would have another proto property. If you expand that, you would get objectBase or the root object in JavaScript.


So here's a visualization of what we have in memory. the array that we have defined derives from arrayBase and arrayBase derives from objectBase. This is what we call multi-level inheritance. 


Now, What about the objects that we create using our custom constructors? consider we have created the circle object using a custom constructor. 

const circle = new Circle(10);

So let's inspect this on the console. if you inspect this -> 

Circle
 draw: f()
 radius: 10
 __proto__: constructor: f Circle(radius)
		  : __proto__: Object
	  

So, our circle object has a prototype and this prototype is the prototype for all circle objects that we create using our circle constructor. 
Let's call this circleBase. So every time we call the circle constructor to create a new circle object, this constructor(f Circle(radius)) will create a new object and set its prototype property to circleBase which means --> __proto__: constructor: f Circle(radius). 

In other words, objects created by a given constructor will have the same prototype. So all circle objects created by the circle constructor will have the same prototype. And similarly, all arrays created by the array constructor will have the same prototype. Now when examining our circle base. Circle base also has a prototype which is our objectBase, the root object in JavaScript. So this is what we have in memory --> We have the circle object that inherits from circleBase and circleBase inherits from the objectBase. 
=====================================================================================================================================================================================

Property Descriptors:
---------------------

Whenever you define a new object like string, array or whatever and log it in console, we can see the all its members and the prototype and the prototype members. However if we iterate over the members of the object. We're not going to see the members of the prototype. None of the properties and methods defined in objectBase are going to visible.  

By the same token, if we use, --> Object.keys(person) //we only get the members of the object
So, how come we can't iterate over all the properties and methods defined in objectBase? 
Well, the reason is because in JavaScript our properties have attributes attached to them. Sometimes these attributes prevent a property from being enumerated. 



let person = { name : "sharath"};

let objectBase = Object.getPrototypeOf(person);

let descriptor = Object.getOwnPropertyDescriptor(objectBase,'toString');

console.log(descriptor);
//

{

    "enumerable": false,
    "configurable": true,
	"value": f toString(),
	"writable": true,
	"__proto__": Object
}

Lets look at the properties of the descriptor object, 
Configurable is true, that means we can delete this member if you want to. 
Enumerable is false, and that's why when we iterate over our person object We couldn't see the 'toString' method. 
You also have writable set to true which means we can overwrite this method, we can change its implementation, we can set its value 
and also you can see the value property, which is set to a method and this is where we have the default implementation of the toString method. 


Now, when you create your own objects, You can set these attributes for your properties. Let me show you an example. 

Earlier in the last section, you learned about 'Object.defineProperty' method, we use this to define a getter and a setter for a property. 


Object.defineProperty(person, 'name', {
	writable : false,
	enumerable: false
});

So, the first argument is an object, we pass person. The second argument is the name of the target property, which is 'name'. And the third argument is an object, which is our property descriptor object. This is where we add the attributes to this property. So in the last section, we used 'get' and 'set' to define a getter and a setter. Now we're going to use different set of properties. Let's set this to writable, false, This will become read-only. Now if set person.name to something else, it won't change. we have another attribute 'Enumerable',  we can set this to false and then this will not show up in Object.keys. So if we log object that keys in Person, we would get an empty array. In contrast, if it was true, It will show up there. If you set configurable to false, you cannot delete this property, which means if you try to do --> delete person.name --> nothing will happen
By default, all these attributes are true. All properties are writable, enumerable, and Configurable. 
=====================================================================================================================================================================================

Constructor Prototypes:

you have learned that every object in javascript except the root object has a prototype or a parent. Now the proper way to get the prototype of an object is,
  
Object.getPrototypeOf(myObj);  And what we get here is exactly what we see in the chrome console under  'myObj.__proto__' What we have here is the prototype or the parent of myObj




function Circle(radius){
	this.radius = radius;
}

const circle = new Circle(1);

Now, one thing you need to know is that constructors also have a prototype property. So here we have the circle constructor function, and you know that in JavaScript, functions are objects, so they have properties and methods. If you circle.(circle dot) you would all the properties and methods of the Cirlce constructor. In one of those properties, we have prototype property. What is this? This is the object that will be used as the parent for objects created by the Circle constructor.  




So, if I want to put all this together, Assuming that we have this my object, 

Assuming that we have this myObj is created by the constructor and this constructor has a prototype property. So,

//myObj.__proto__ (parent of myObj)
//Constructor.prototype --> the object that we get here, is exactly the same as above i.e. parent of myObj

So, the object that will be used as the parent for objects created by this constructor. 


Let me show you this entire thing in action:

let obj = {}

This object has a prototype property, which is its parent. And you know that this is what we call object base, right? 

obj.__proto__
//{__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}


Now you know that this object is created using the 'Object()' Constructor function, right?  right? So, when we use the Object literal syntax({}) under the hood, that's translated to a 'new object()', right? so that's our constructor. Now this constructor has a prototype property --> Object.prototype --> and this is the object that will be used as the prototype for all objects created by this constructor. 

Bottomline, obj.__proto__ and Object.prototype are equal

The parent for this object --> obj.__proto__ and The prototype for this constructor -->Object.prototype



Let's look at another example. let's define an array empty array. 

let array = [];

This array has a prototype proto and This is the object that includes the methods that can be called on arrays, right? So we call this arrayBase. Now when we use an array literal under the hood the array constructor(Array()) will be called 

[at: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]

This constructor has a prototype property which references array base the same object

Array.prototype

=====================================================================================================================================================================================

Prototype vs Instance Members:


function Circle(radius){
	this.radius = radius; 
	this.draw = function(){
		console.log("draw");
	}
}


const c1 = new Circle(1);
const c2 = new Circle(1);


we have the circle constructor with two members, the radius property and the draw method. And we have two circle objects. So with the current implementation, if we have, let's say a thousand circle objects in the memory, We're going to have a thousand copies of the draw method. Now, this is a very simplified example. In a real world application, your objects might have several methods. So if you want to have a large number of these objects in the memory, You're going to waste a lot of memories by keeping copies of all these methods. 
So what's the solution? Well, you know how prototypical inheritance works. When we access a property or a method on an object, JavaScript engine first looks at the object itself. If it can't find that property or method, it will look at the prototype of that object. So now we can take this draw method out of the circle object and put it in its prototype. We're going to have a single instance of this prototype in the memory, which we call 'circleBase'. So we're going to have a single instance of the draw method. So how do we do that? 
Well, in the last lecture, you learned that every constructor has a prototype property 
So, Circle.prototype is exactly same as c1.__proto__  but essentially these two properties are referencing the same object in memory. That's the circle base. 
So using Circle.prototype, we can quickly and safely access this object so You know that JavaScript objects are dynamic, so we can always add something to them later. 

Circle.prototype.draw = function() {
	console.log('draw');
}

With this, we no longer need the draw method on the object instance itself. 

function Circle(radius){
	this.radius = radius; 
}

now if log c1 in console

//
Circle {radius: 1}
radius: 1
[[Prototype]] : Object
	draw: ƒ ()
	constructor: ƒ Circle(radius)
	[[Prototype]] : Object
	
Now our object, only has a radius property. The draw method is on the prototype, the circleBase object, right? And the same is true for C2. 

Now, because of the prototypical inheritance, we can still access 'C1.draw', and everything works fine. So essentially we have two kinds of properties and methods in JavaScript. We have instance-(Properties and methods) and other one of prototypes. Let's call them instance members and prototype members.



Now let's take this to the next level. So, you know that every object has 'toString' method.  

c1.toString() // "[object Object]"

We can overwrite the implementation of this method in the prototype our circleObject. So, I'm gonna add circle.prototype.toString  and set it to a new function. 

Circle.prototype.toString = function() {
	return 'Circle with radius' + this.radius; 
}

with this, if we log c1.toString in the console,
"Circle with radius 1"


So, back to our prototypical inheritance, when we call this method(Circle.prototype.toString), JavaScript engine looks at our circle object. Obviously, we don't have this method there, then it looks at its prototype. So here's the interesting part, even though we have another implementation of the toString method in object base, this implementation will be used, because this is more accessible. 


And by the way, remember that in both these kind of members, you can reference other members. For example, in the draw method(Circle.prototype.draw), which is a prototype method, I can easily call an instance method on the circle class. 


So, let's add a method in Circle constructor function -->this.move 

function Circle(radius){
	//Instance members
	this.radius = radius; 
	this.move = function(){
		console.log("move");
	}
}

Now, we can reference this function, or the method 'move' more accurately, in our prototype method. 

// Prototype members
Circle.prototype.draw = function() {
	this.move();
	console.log('draw');
}

So, if we log c1.draw in console
c1.draw()
//move
//draw


By the same token, in an instance method we can reference a prototype member. So, let's reverse this. 


function Circle(radius){
	//Instance members
	this.radius = radius; 
	this.move = function(){
		this.draw();
		console.log("move");
	}
}

//Now essentially what is happening here? We're calling the draw method Obviously, it's not an instance method. So the JavaScript engine will find this method on the prototype So everything will continue to work


C1.move()
//draw
/move
=====================================================================================================================================================================================

Iterating Instance and Prototype Members:	


function Circle(radius){
	//Instance members
	this.radius = radius; 
	this.move = function(){
		this.draw();
		console.log("move");
	}
}


// Prototype members
Circle.prototype.draw = function() {
	this.move();
	console.log('draw');
}

const c1 = new Circle(1);


I've simplified the example from the last lecture. We have the circle object with two instance members, radius and move, and one prototype member which is called draw. Now one thing I want to emphasize here is that it doesn't matter when you change the prototype. So in this case we're modifying the prototype before creating an object. you could create an object first and then modify the prototype. The draw method will still be available in this circle object. Because here we're dealing with object references. So we have a single object in memory. As soon as we modify that, all the changes are immediately visible.

Now in this lecture. I'm going to show you how to iterate over instance versus prototype properties. Object.keys only returns instance members radius and move. Draw is not there because draw is a prototype member. 

console.log(Object.keys(c1)); //['radius', 'move']


what about for-in loop?

for (let key in c1) console.log(key); 

//
radius
move
draw

Here we have all the instance and prototype members. So, we get the draw method as well. So remember, the for in loop returns all members, instance and prototype. 

//Returns instance members
console.log(Object.keys(c1));

//Returns all members (instance + prototype)
for (let key in c1) console.log(key); 

Now in JavaScript language, we often use the word 'own' instead of instance. So, in some documents in some tutorials you may hear own property versus prototype property.

Some useful methods:

c1.hasOwnProperty('radius') //true

c1.hasOwnProperty('draw')  // false 

we get false because this is a prototype member or a prototype property.
=====================================================================================================================================================================================

Avoid Extending Built-in Objects:
---------------------------------


So you have learned how easy it is to modify the prototype of an object. So you might be tempted to do something like Array.prototype.shuffle (we're going to add a new method to our arrays for shuffling an array).  

Array.prototype.shuffle = function() {
//..
};


const array = [];
array.shuffle();
  
Now, while this is very easy to accomplish in JavaScript, that's something you should avoid. You should not modify the built-in objects in JavaScript. Because it is possible that tomorrow you're going to use a library and in that library someone has also extended the array prototype and added a shuffle method but with a different implementation. 


Then you will end up spending the whole day debugging the problem. Also, nothing stops the developers of JavaScript from adding this method to arrays in the future versions of JavaScript. So here's the lesson. Don't modify objects you don't own. Yes, JavaScript is a dynamic language. It makes it really easy to add properties and methods to an existing object, but that doesn't mean that you should modify the built-in objects. So don't override methods, don't add new methods or properties, and don't remove existing properties and methods because somewhere else in a library you might be using, there might be code that is dependent on those methods in the built-in objects. So if you modify the built-in objects, you will create all sorts of issues. 

=====================================================================================================================================================================================

Exercise:

Now it's time for an exercise. So here's the stopwatch object that we created in the last section. Now, in this exercise, I want you to move the methods we have here like start, stop, and reset to the prototype of the stopwatch. Now, before we get started, I want to clarify something. You should put methods on the prototype as an optimization technique. So if you're working with a large number of objects of the same type, you don't want to have Multiple copies of these methods in memory. In case of a stopwatch. We don't really have that requirement. If you're gonna use stopwatch in a program, we need only one instance. So in this case, We don't really need to put these methods on the prototype. 
And as you will see, Putting these methods on the prototype will lead to another issue. And that's part of the exercise you're going to work on. So, Go ahead, put these methods on the prototype, and then notice that you will not be able to access any these variables like running and start time because these variables are defined in this function. They are within the scope of this function. When you put the start method on the prototype, you can only access the public members of the stopwatch. So in order to access running, you need to define this as a public read-only property on the stopwatch and then access it using this. So that was a quick hint for you. Go ahead. Do this exercise and you will see my solution next. 


=====================================================================================================================================================================================

Prototypical Inheritance:

Creating your Own Prototypical Inheritance:

function Circle(radius){
	this.radius = radius;
}

Circle.prototype.draw = function(){
	console.log('draw');
}

Circle.prototype.duplicate = function(){
	console.log('duplicate');
}


So, here we have a circle object with a radius property and two methods that are defined on its prototype. You have the draw method and the duplicate method. Now let's imagine tomorrow we're gonna add a square object here, And that square object should also have a duplicate method with the exact same implementation. We don't wanna repeat this implementation. In other words, we don't want to define a square constructor and then redefine the duplicate method on the prototype of this constructor.


Instead, we wanna use inheritance. So we can define a shape object and put this duplicate method there, and then have circle and square inherited from the shape object.


function Shape(){
}

Shape.prototype.duplicate = function(){
	console.log('duplicate');
}



let's define 2 objects here. one is a shape and the other is a circle.

const s = new Shape();
const c = new Circle(1);


Now back to the console. So here's our shape. It inherits from the object, which we call shape base. And in shape base, we have the duplicate method. And as we can see, shape base inherits from another object, which is our object base, the root of all objects in JavaScript.

s
//Shape{}
  __proto__:   // shapeBase
    duplicate: f
	constructor: f Shape()
	__proto__: Object  //objectBase
	

	
Okay. We have the exact same structure in our circle. Let's verify that. So we have a circle. Circle has a radius.

c
//Circle{radius : 1}
     radius: 1
	 __proto__:  // circleBase
	 draw: f()
	 constructor:  f Circle(radius)
	 __proto__: Object //objectBase
	 
So, it inherits from circleBase. In circleBase, we have the draw method. And as you can see, circleBase inherits from objectBase. 

So here's a visualization of what we have in memory. We have the c object, which inherits from circleBase, which is essentially 'Circle.prototype', and this circleBase inherits from objectBase.
Similarly, we have s which inherits from shapeBase, and this is the same object referenced by 'Shape.prototype', and this object inherits from objectBase. 
Now to set up inheritance here, we wanna have circleBase inherits from shapeBase. How do we do this? It's really easy. 


In JavaScript, we have a method for creating an object with a given prototype.

Object.create(Shape.prototype); //So, we want a new circleBase object that inherits from shapeBase instead of objectBase. Now, shape base is Shape.prototype.

                             //this returns an object that inherits from shapeBase. Now all we have to do is to use this object as the prototype for our circles. So we reset Circle .prototype to this new object.
							 

Circle.prototype = Object.create(Shape.prototype);


So before this, our circleBase or Circle.prototype was like this,

Circle.prototype = Object.create(Object.prototype); //objectBase

So this was the implicit relationship. Now we change circleBase or Circle.prototype to a new object that inherits from Shape.prototype or shapeBase, okay?

Let's go check again.

c
//Circle {radius: 1}
	radius: 1
	__proto__: Shape //circleBase
	  draw: f()
	  __proto__: 
		 duplicate: f() //shapeBase
		 constructor: f Shape()
		 __proto__: Object
	  
	  
So circle inherits from circle base. Now don't worry about this shape here.
This doesn't mean that this is a shape object. This is a circleBase object. What you see here is the parent for that object. Let me explain what I mean. So let's expand this.
In circleBase, we have the draw method. Perfect. Now circleBase inherits from shapeBase, and that's why we have shape here. Let's look at the prototype. Look, this is shape base.
We have the duplicate method, and shape base inherits from object base. So now with all this, the circle object has a draw method. It also has the duplicate method that it inherits from the shape object. So this is prototypical inheritance in action.

=====================================================================================================================================================================================

Resetting the Constructor:
--------------------------

Now there is a tiny problem with this implementation. 

Let me comment out this line 
//Circle.prototype = Object.create(Shape.prototype);


and go back to the console. 


c
//Circle {radius: 1}
	radius: 1
	__proto__:
		draw: f()
		constructor: f Circle(radius)
		__proto__: Object
		
		
Earlier I told you that every object in javascript has a constructor property that returns the function that was used to construct or create that object. Let's take a look at our circle object, so this circle look at its prototype. This is essentially circle prototype right. Here we have this constructor property which references our circle function now with this technically we can create a circle object like this 

Circle.prototype( which returns the 
	__proto__:
		draw: f()
		constructor: f Circle(radius)
		__proto__: Object
		
		

Circle.prototype.constructor( which returns the constructor function in the __proto__ --> constructor: f Circle(radius) )

new Circle.prototype.constructor(1) // return a new Circle object and this expression is equivalent to 
new Circle(1)

they're exactly the same. now obviously we use this form (new Circle()) because it's shorter and cleaner, but in some rare circumstances you may get a constructor function somewhere in your application and you may want to dynamically create an object based on that constructor function. So there you can access the prototype property and from there you get the constructor and then use the new operator. 


Now let's see what happens when we uncomment this line. So back in the console let's take a look at the circle one more time. 


Circle.prototype = Object.create(Shape.prototype);



c
//Circle {radius: 1}
	radius: 1
	__proto__: Shape
		draw: f
		__proto__: 
			duplicate: f()
			constructor: f Shape()
			__proto__: Object
			
Look we no longer have that constructor property here, so let's look at the prototype for this object. Here we have the constructor property, but this is returning the shape function, not the circle function. In other words, with what we have now we no longer can create circle objects based on its constructor in a dynamic fashion. 


So, if we try to access 

--> new Circle.prototype.constructor()

//Shape{}  --> we do get a shape object, not a circle 0bject


object. The reason we're having this problem is because we reset the prototype of the circle.

Before this the prototype of the circle was

//Circle.prototype.constructor = Circle;  that's why we could new up a circle like this ==>new Circle.prototype.constructor() ==> new Circle()


So, as a best practice, whenever you reset the prototype of an object you should also reset the constructor. So here we should set 

Circle.prototype.constructor = Circle; 


Now let's inspect the console one more time

c
//Circle{radius: 1}
	radius: 1
	__proto__: 
		constructor: f Circle(radius)
		draw: f()
		__proto__:
			duplicate: f()
			constructor: f Shape()
			__proto__: Object
			
So here's the prototype for the circle you can see. Constructor is referencing the circle function. Beautiful, we have the draw method which is part of the prototype for circles, and the rest is exactly like before. So this is shape base or the prototype for shapes where we have the duplicate method. Now we can new up a circle like this, Circle.prototype.constructor(1) and we get circle object

So one more time whenever you reset the prototype as a best practice, make sure to reset the constructor as well. 

=====================================================================================================================================================================================

Calling the Super Constructor:
------------------------------

Alright, now let's take this example to the next level. I'm gonna modify the Shape constructor and introduce a color parameter. We want every shape to have a color. 

function Shape(color){
	this.color = color;
}

Now with the current implementation, when we create a circle, we only pass the radius. So if we log C on the console, we can only see the radius property. There is no color here. But from an inheritance point of view, this circle object should have a color property and that should be initialized at the time of creating a circle. How do we do this? Very easy? Here in the circle constructor. We should call the shape constructor. 

function Circle(radius, color){
	Shape(color);
	this.radius = radius; 
}


c = new Circle(1, 'red');


c
//Circle {radius: 1}

Let's look at the circle in the console. We don't have the color property. We only have the radius. Why didn't it work? Well, earlier I told you that when you use the new operator, three things happen. This new operator creates a New empty object. And then sets 'this' to point to that empty object. So, here we set the radius property on that new object. And finally, that new object will be returned from this constructor, right? Also, I told you that if you don't use the new operator, This by default will point to the global object, which is window in the browser and global in node. So, in the Circle function, we're are calling Shape function and by default 'this' in Shape function will point to the global object(since we don't call it with new --> Shape(color)). So we didn't set the color property on the new instance of the circle object. We set it on the window object ( you can verify it by window.color). We don't want to use the new operator again inside Circle function to call Shape constructor. Because it will create another new object and then set the color property on that newly created object. You want to use the object which is referenced by 'this' (one that is referred by circle object)

So, How to fix this. To fix this problem, we need to call the Shape function and set 'this' to point to the new instance of the circle object. Earlier, I told you that every function in JavaScript is an object. you can access its member by Shape. (Shape dot) where you also learn about the call method so we can call this shape function and have a look at the first argument of the call method --> 'this' arg --> the object to be used as the current object 


we can shape.call() and pass 'this' which would references the current object i.e circle object,

function Circle(radius, color){
	Shape.call(this, color);  // 'this' is an instance of an circle object. And the same is being passed to the Shape constructor
	this.radius = radius; 
}


Hence this would solve our problem

c
//Circle{color: 'red', radius: 1}



So, this is how you call the super constructor. 

=====================================================================================================================================================================================

Intermediate Function Inheritance:
----------------------------------
So, we have set up our inheritance chain properly. Now let's create another object like a square that inherits from the shape. So that should be very easy. We create a constructor, square, it takes a size.



function Square(size){
	this.size = size; 
}


Now, we want this square to inherit from the shape. So, 

Square.prototype = object.create(Shape.prototype);
Square.prototype.constructor = Square;


sq
//Square{size: 10}
	size:10
	__proto__: Shape
		constructor: f Square(size)
		__proto__: 
			duplicate: f ()
			constructor: f Shape(color)
			__proto__: Object
			
			
However, the abovetwo lines for setting up the prototype chain is a little bit noisy. And as we define multiple objects, this logic gets in the way, and chances are, you might make a mistake along the way. So let's refactor this code and extract these two lines into a function that we can reuse. So here I'm gonna define a function called 'extend' that takes 2 parameters, Child and Parent. And note that here the first letter of these parameters is upper case because I'm expecting these parameters to be constructor functions.


function extend(Child, Parent){
Child.prototype = object.create(Parent.prototype);
Child.prototype.constructor = Child;
}


So instead of those two lines, right after we define the constructor function, we call extend function with Square and Shape.

extend(Circle, Shape);


So this extend function is what we call intermediate function inheritance.

=====================================================================================================================================================================================

Method Overriding: 
------------------


function extend(Child, Parent){

Child.prototype = object.create(Parent.prototype);
Child.prototype.constructor = Child;

}

function Shape(){
}


Shape.prototype.duplicate = function(){
	console.log('duplicate');
}


function Circle(){
}

extend(Circle, Shape);

const c = new Circle(); 


c.duplicate() //duplicate


I've simplified the code from the last lecture, so we can focus on one concept. So let's see what we have here. We have our extend function. We have a very simple shape constructor. This shape has duplicate method on its prototype.

After that, we have the circle constructor. We have the circle inherit from the shape, and finally, we create a new circle object. So now if you go on the console and type c.duplicate, we get duplicate on the console.

Now sometimes as you work with inheritance, you may face a situation where the implementation that you have defined in a parent object may not work or may not be ideal in a child object. So let's imagine this algorithm for duplicating a shape works for most of the shape objects, but maybe it should behave differently for circle objects.

What should we do? That's when we use method overriding. So we override a method that is defined in the base object. And it's very simple. All we have to do is to redefine this method in the circle object.

It's very important to put this after extending the circle, because at that point we are resetting the prototype. So, if we define this before resetting the prototype, then this implementation is gonna disappear.


after the line --> extend(Circle, Shape);


Circle.prototype.duplicate = function(){
	console.log('duplicate circle');
}

c.duplicate()
//duplicate circle

Note that we get the 'duplicate circle' message. So, the reason this works is that how prototypical inheritance works in JavaScript. When we access a property or a method on an object, JavaScript engine walks up the prototype chain and picks the first implementation. So even though in this hierarchy, we have implemented the duplicate method, both on the parent and child objects, the implementation on the child object will be used. 

Now sometimes you may wanna call the implementation on the parent object as well. In those cases you can simple call it, if you are not using 'this' in parent prototype

Circle.prototype.duplicate = function(){
	Shape.prototype.duplicate(); 
	console.log('duplicate circle');
}

If you're using 'this' in parent prototype, then we need to use the 'call' method to set the context for 'this'.


Circle.prototype.duplicate = function(){
	Shape.prototype.duplicate.call(this); 
	console.log('duplicate circle');
}

=====================================================================================================================================================================================

Polymorphism:
-------------

So, in the last lecture, you learned about method overriding, which basically means reimplementing a method in a child object. Now this brings us to a very important and powerful concept in object oriented programming called polymorphism. Poly means many, morph means form. So polymorphism means many forms. It's an extremely powerful technique in object oriented programming, as I'm gonna show you in this lecture.

So continuing from the example from the last lecture, I'm gonna define a new shape object called square. So let's define a constructor square. Now just like the circle, we want to have this square inherit from shape. So we extend square with shape. And then we're going to redefine this duplicate method on the square object.

function Square(){
}

extend(Square, Shape);

Square.prototype.duplicate = function(){
	console.log('duplicate square');
}


So, basically what we have now is a simple hierarchy. On the top, we have the Shape, and we have 2 derivatives or child objects, Circle and Square. Each object will provide a different implementation of the duplicate method.

So, we have many implementations or many forms of the duplicate method. That's what we call polymorphism. Now why is this so powerful? Let me show you.


So let's define an array. In this array, I'm gonna add 2 objects. A circle and a square. Now we can iterate over this array using for-of loop.

const shape = [
	new Circle(),
	new Square(),
};


for (let shape of shapes)
 shape.duplicate();
 
//duplicate circle
//duplicate square

Depending on the type of the shape object, a different implementation or a different form of the duplicate method will be called. So if shape is a circle, the implementation of duplicate in the circle object will be called. If it's a square, a different implementation will be called. We have got duplicate circle, duplicate square.


Why is this so powerful? Well, before object oriented programming, if we wanted to implement this logic, we would have to write code like below. So in this for loop, we would have to check the type of each object. 


for (let shape of shapes){
	if(shape.type === 'circle')
		duplicateCircle();
	else if (shape.type === 'square')
		duplicateSquare();
	else
		duplicateShape();
}


If it's circle, then perhaps we'll have a function somewhere else like duplicateCircle(). We would have to call that function. Now this function is not part of any objects. It's just a standalone function. This is the non-object oriented way of writing code.

In object oriented programming, we encapsulate our variables and functions into objects. Now continuing with this implementation, then we would have to check for square, and we'll have to call a different function called duplicateSquare(). And we could have another else statement, duplicateShape(). Now this is a very simple program. What if we had 10 different types of shapes?

We would end up with 11 conditional statements in this block. In contrast, when we encapsulate variables and functions into objects, and use inheritance, we can execute many forms of a method using a single line of code. So instead of all these, it would call shape.duplicate(), isn't that beautiful? So that's polymorphism in action.

=====================================================================================================================================================================================

When to Use Inheritance: 
------------------------

So you have seen inheritance and polymorphism in action. While inheritance is a great tool for solving the problem of code reuse, you have to be really careful about using it because it can make your source code complex and fragile. So don't use inheritance just for the sake of using it, especially in small projects. As I've always emphasized in all my courses, keep it simple and stupid. Start with simple objects, and then if you see a number of these objects share similar features, then perhaps you can encapsulate those features inside of a generic object and use inheritance.

But remember, inheritance is not the only solution to enable code reuse. There is another technique called composition which you're gonna learn about soon. 

So let's see the problem with inheritance. Here we have this animal object with 2 methods, eat() and walk(). And we have 2 objects that derive from animal, person and dog.

Now tomorrow we're gonna introduce a new object called goldfish that derives from animal. Our hierarchy is broken. Why? Because goldfish cannot walk(). It can swim().

So we got the hierarchy wrong. And this is something that happens quite often especially amongst inexperienced developers. So, to solve this problem, we need to change our hierarchy. On the top, we should have the animal object with the eat() method. Under that, we're gonna have 2 objects, mammal() and fish().

Mammals can walk(). Fish can swim(). And then we can have person and dog derived from mammal. And goldfish derived from fish. See what happened?

As a result of introducing a new kind of animal that is goldfish, we had to change our hierarchy. And now this hierarchy is more complex than what we had before. Now what would happen if we had 10 different types of animals? This hierarchy would get more and more complex. And we have to constantly go back and forth to determine the right place to implement a method.

So avoid creating inheritance hierarchies because they are very fragile. If you wanna use inheritance, keep it to one level. Do not go more than one level of inheritance. There is a famous saying that says, favor composition over inheritance. With composition, instead of having a complex hierarchy like this, we can compose a few objects together to create a new object.

And this technique gives us great flexibility. So back to our previous example, instead of using inheritance, we can define various features for our animals as independent objects. So we can have 3 objects like canWalk, canEat and canSwim. Each of these objects are plain JavaScript objects with certain properties and methods. Now we wanna have a person object, right?

Okay. We simply compose canWalk and canEat to create a person object. Tomorrow, if we wanna introduce a goldfish, we can compose, canEat, and canSwim together to produce a goldfish.

So we don't have a hierarchy, and we can come up with any combination of these objects to create new objects. In JavaScript, we can use mixins to achieve composition. And that's what you're gonna see in the next lecture.
=====================================================================================================================================================================================

Mixins:
-------

Alright. Let's start by defining a new object. canEat, we use the object literal syntax, and in this object we add one method called eat(). Here we can reduce the hunger and logging it in the console.

const canEat = {
	eat: function() {
		this.hunger--;
		console.log('eating');
	}
};



So we're defining one feature as an object. Now similarly, we can define another feature, canWalk. 

const canWalk = {
	walk: function() {
		console.log('walking');
	}
};




Now we can compose these objects together to create a person that canEat and canWalk. So in ES6 we have a new method, that is Object.assign, and we can use this to copy the properties and methods from one object to another. So we pass an empty object as the target and then pass one or more source objects. So if we pass canEat, this Object.assign will copy all the properties and methods that we have defined in canEat into the blank object. Now we can add more sources here. So, we can add canWalk as well. And with this, our empty object will end up being the combination of these two different objects.

const person = Object.assign({}, canEat, canWalk); 


So let's store that in person, and log it on the console. Now save the changes. So here is our person object with 2 methods, eat and walk. 

console.log(person);
//{eat: f, walk: f}





Now if we're using a constructor function, we can still use this technique. So let's define a constructor called person.

function Person(){
}



Inside the constructor function, we can add any properties and methods specific to person objects, right?  So, in Object.assign() instead of passing an empty object as the first argument, we can pass Person.prototype as the target object. And we don't need the return value anymore like we did before. So, we have basically modified the prototype of person, and added the capability to eat and walk. Now next time we create a person object, that person will have these capabilities.


Object.assign(Person.prototype, canEat, canWalk); 
const person = new Person(); 


Now, here's our person object. In this prototype, we have the eat and walk methods. 

person
//
Person{}
 __proto__: 
	eat: f()
	walk: f()
	constructor: f Person()
	__proto__: Object
	
	

Now let's say tomorrow we're gonna add two new objects in this application, goldfish and duck. Both the goldfish and duck should have the capability to swim. So we can define a new feature canSwim.

const canSwim = {
	swim: function() {
		console.log('swim');
	}
};


And here we add the swim method, very simple implementation. And then we can define a new constructor, like Goldfish() and use Object.assign() to modify the prototype for Goldfish. 
This time we're gonna mix Goldfish with canEat, and canSwim. So, you can see composition or mixins gives us great flexibility. 
So now, let's create a new goldfish object. 

function Goldfish(){
}


Object.assign(Goldfish.prototype, canEat, canSwim);


const goldfish = new Goldfish();

console.log(goldfish); 

//Goldfish{}
	__proto__: 
		eat: f()
		swim: f()
		constructor: f Goldfish()
		__proto__: Object
		





Now to make the code a bit more readable, we can extract the logic of Object.assign() into a function called mixin.

function mixin(target, ...sources){
	Object.assign(target, ...sources);
}


We add the target object here, and we want to have one or more sources. Now we don't want to add multiple parameters here like source 1, source 2, because we don't know every time we wanna use this function, how many arguments we're gonna pass here. So, to solve this problem, we can use the rest operator in ES6. So, we add only one parameter here, sources, and then use the rest operator, which is 3 dots, and this will collect all the arguments and turn them into an array. 

Now here, sources is an array. But Object.assign needs sources explicitly. We cannot pass an array here. So this time we can use the spread operator to spread an array into multiple arguments. So the syntax is exactly the same, but this time we call this operator, spread operator because we're spreading an array into multiple objects.

Now with this new mixin function, we can simplify this code.

mixin(Person.prototype, canEat, canWalk); 
mixin(Goldfish.prototype, canEat, canSwim);

=====================================================================================================================================================================================

Exercise: Prototypical Inheritance



Alright. Now it's time for an exercise. I want you to design two objects. One is HtmlElement, and the other is HtmlSelectElement, which represents a drop down list. We have prototypical inheritance between HtmlSelectElement and its parent which is HtmlElement.

Now see how these objects behave. I'm gonna define a constant and set it to a new HtmlElement. Let's inspect this object. So in this object we have one method, click() in its prototype, we have another method, focus.

The implementation of these method is very simple. Just a console.log statements. What is important here is that we have one instance or own method and one prototype method. So start with this object. Implement it, test it, make sure it works.

const e = new HtmlElement()


e
//HtmlElement{click: f}
	click: f()
	__proto__: 
		focus: f()
		constructor: f HtmlElement()
		__proto__: Object

So we can call e.click() and e.focus(), we get messages like, 

		
e.click()  //clicked

e.focus() //focused




Once you have HtmlElement, go ahead and create HtmlSelectElement. Let's see how that object behaves. So I'm gonna define another constant, send it to a new HtmlSelectElement. Now here in the constructor we can optionally pass an array of items but we don't have to.

If we don't pass anything here, it will be initialized to an empty array. Let's inspect this object. So here we have this items property which is initialized to an empty array. We also have 2 methods, additem and removeitem. 

Now what is important here is that this HtmlSelectElement inherits from HtmlElement. So let's look at its prototype. This prototype is an instance of HtmlElement object. Remember our HtmlElement objects have 2 methods. 1 is click, which is an instance or own method.


const s = new HtmlSelectElement([1, 2, 3])


s
//HtmlSelectElement {items: Array(0), addItem: f, removeItem: f}
	addItem: f (item)
	items: []
	removeItem: f (item)
	__proto__: HtmlElement
		click: f()
		__proto__: 
			focus: f()
			constructor: f HtmlElement

And the other is focus, which is a prototype method. So this is the tricky part of this exercise. I want you to pay great attention to this part. So do not use the extend function that we created earlier in the section. I want you to manually set the prototype for HtmlSelectElement.You should set that to an instance of the HtmlElement object, because the click method is on the instance. If you set the prototype of HtmlSelectElement to the prototype of HtmlElement, you would only get the focus method because this is defined under prototype. So go ahead spend about 20 to maximum 30 minutes on this exercise and next you will see my solution.


Solution: 

Alright, now let's take a look at my solution. So here we have this HTML element constructor function. We have a simple method here click. We also have this focus method, which is defined on the prototype of HTML element. So this is our parent object.

Now below that we have another constructor, HTML select element. Note that I have initialized this items parameter to an empty array. This is something that we can do in e s 6. Before e s 6, we had to do something like this. So if items is defined, we would use that, otherwise we would use an empty array.

Now with e s 6, we can initialize the parameter so this syntax is cleaner. So we set the items array here. We also have 2 methods, add item and remove item. The implementations are pretty straightforward. So in add item, I simply push an item to this array.

And in remove item, I simply use the splice method to delete an item at the given position. This is just basic JavaScript. Now let's look at the important and tricky part of this exercise. That's the tricky part. We set the prototype of this HTML select element to an instance of an HTML element object.

Earlier in this section, we used a different approach. So we use object dot create and passed, let's say HTML element dot prototype. But this will not work in the current implementation. Let me explain why. Here, object dot create will create a new object and set the prototype of that object to the prototype of HTML element.

For discussion sake, let's call the prototype of HTML element as base HTML element. So this is an object that has only one method. Look, here is a prototype of HTML element. It's an object with only one method, focus. So click is not there, right?

So when we use object dot create, we create a new object and the prototype of that object would be base HTML element, which has the focus method. Now we can call this object that is returned here, let's call that base Html select element. So when we create an instance of Html select element, its prototype will be base HTML select element, which is an empty object that is linked to base HTML element as it's prototype. Let's have a look at this on the console. So I'm going to create an HTML select element.

Let's inspect this. So, here's the prototype. This is an empty object. This is an empty object that is returned from object dot create. Okay.

The object dot create uses what we pass here as the prototype for that object. In this case, the prototype is base HTML element, or HTML element dot prototype, which is an object with a single method, focus. Right? So back in the console, here the prototype of HTML select element is an empty object. It doesn't have anything, but its prototype is the prototype of HTML element where we have the focus method.

Okay? So with this implementation we don't inherit the click method in HTML select element. Now to fix this, instead of using object dot create, to create an empty object that has HTML element dot prototype as its prototype, we need to new up an HTML element object. Because in this object we have the click method. And this object has its own prototype where we have defined the focus method.

Right? Now let me remove this comment. Let's go back in the console, create another HTML select element. So now here's the prototype. This is an instance of HTML element object.

We have the click method, and in the prototype we have the focus method. So with this we can click the select element, we can also focus it. Now technically here I should also have set the constructor, So HTML select element dot prototype dot constructor. We set this to HTML select element. Why did I set it to HTML select element?

Because I told you that this expression is kinda similar to new HTML select element. So we can create an instance of HTML select element like this or like this, new HTML select element dot prototype dot constructor. Obviously we're not going to use this former approach, but in your applications if you have a function where you get a constructor dynamically, and you want to create an instance of an object based on that constructor, then you have to reset the constructor property. Now in the next section when we get to ES 6, you will see that implementing inheritance is far easier in ES 6. You don't have to worry about this complexity.

Okay? So that brings us to the end of this exercise.

function HtmlElement(){
	this.click = function() {
		console.log('Clicked');
	}
}

HtmlElement.prototype.focus = function(){
	console.log('focused');
}



function HtmlSelectElement(items = []) {
	this.items = items;
	
	this.addItem = function(item){
		this.items.push(item);
	}
	
	this.removeItem = function(item){
		this.items.splice(this.items.indexOf(item), 1);
	}
}



HtmlSelectElement.prototype = new HtmlElement();



//baseHtmlSelectElement
Object.create(HtmlElement.prototype); //baseHtmlElement



HtmlSelectElement.prototype.constructor = HtmlSelectElement;


HtmlSelectElement.prototype.constructor  similar to new HtmlSelectElement()
=====================================================================================================================================================================================

Exercise: Polymorphism


Alright. Now the second exercise. Continuing from the last exercise, I want you to extend HTML select element and implement a render method. So here I'm gonna define an HTML select element, and initialize it with an array of 3 items. Now s dot render, this is what we get.

A select element with 3 options. Now similarly, I want you to create an HTML image element that inherits from HTML element so it can be clicked, it can be focused, but it also has its own render method. So let's create an image here, new HTML image element. Now here we can optionally pass the source or the address of the image. I'm not gonna set that yet.

Let's inspect this element. So here we have a source property which is undefined and the render method. We can see it's prototype, so it inherits from an instance of HTML element, it has the click method as well as the focus method. So now I'm going to set image, the source to H T T P, whatever, it doesn't really matter. And call image dot render.

So we get an image element in HTML. Once you do this, then I want you to create an array of elements, so here we have one select element and one image element. Then iterate over this array of elements, and render them each. Note that here my render method is returning a string. It's not doing a console dot lock.

It's not the responsibility of this object. We don't want to couple this render method with console dot log. We just want the HTML representation of an element, and somewhere else we decide what to do with that HTML representation. Maybe we want to add it to document object model, or maybe we wanna log it on the console. That's why we shouldn't use console dot log inside of the render method.

So this is your polymorphism exercise. We have different objects, they all have the same parent. They all have a render method, but the render method behaves differently. We have different forms or multiple forms of the render method. That's what we call polymorphism.

So save the changes back in the console, that's what you should get.

const s = new HtmlSelectElement([1, 2, 3]);

s.render()
//
"
<select>
	<option>1</option>
	<option>2</option>
	<option>3</option>
</select>



const img = new HtmlImageElement()

img

//HtmlImageElement {src: undefined, render: f}
	render: f()
	src: undefined
	__proto__: HtmlElement
		click: f()
		constructor: f HtmlImageElement(src)
		__proto__: 
			focus: f ()
			constructor: f HtmlElement()
			__proto__: Object 
			
			
img.src = 'http://......'


img.render()
//
<img src="http://......"



const elements = [
	new HtmlSelectElement([1, 2, 3]),
	new HtmlImageElement('http://')
];


for (let element of elements)
	console.log(element.render());

		


Solution: 


So here's my implementation of the HTML image element object. We have this constructor that receives a source parameter. Here we set the source property, and we also define the render method. Note that here to return this HTML markup, I'm using a template string. So instead of a single or a double quote, I'm using the back tick character, which is the character before number 1 on your keyboard.

So this is part of ES 6 and it allows us to pass arguments to this string. So here note that I have this argument, indicated by a dollar sign and curly braces. So what we have inside of these curly braces, in this case this dot source, will be dynamically placed into this string at runtime. This is much cleaner than code like this. Return, image, source, then we concatenate this with this dot source, then concatenate again, now here I have to remember that I used single quotes so I add double quote to terminate this source attribute, and then add a slash and angle brackets.

Look, this is really ugly. So use template strings in ES 6, that's much cleaner. And to pass arguments use a dollar sign and curly braces. Then whatever you put here will be placed into the string at runtime. Now there is a more advanced version of a template string, I'm going to show you in a second.

So, let's go to our HTML, select element object. This is the other render method. So here we are returning a template string. Inside of this template string we have the select element but we want to render multiple option elements. See how we can achieve this.

How we can add a loop inside of a template string. So note that here I have an argument. Right? Here I'm referencing this dot items which is our array of items. I'm using the map method in ES 6.

So we can get each item in this array and map or convert it to something else. So here this map method takes an arrow function, which is again another new feature in e s 6. So in case you're not familiar with arrow functions, this is how they work. Let's imagine I have a function that takes an item and returns a template string like this. So I get the item and convert it to a string with option and slash option and in the middle, I'm gonna add an argument where I render the item.

Right? Oops, I forgot to name this function. Let's use a function expression. So I'm gonna define a constant called render item and set it to this function expression. Right?

Now we can rewrite this function in a shorter and cleaner way using an arrow function. So we get rid of the function keyword, we add the parameters here, and to separate them from the body of the function, we use a fat arrow. Now if we have only a single parameter, we can also remove the parenthesis. And if we have a single return statement here, we can make this code even shorter. We can get rid of the return keyword, as well as the curly braces.

So put everything in one line. This is what we call an arrow function. We take an item and map it to a string like this. Now I have used this inside of my template string here. So here after the select element, I have an argument in the template string.

Inside this argument, I have this expression, this dot items dot map. So I'm calling the map method on the array, and as an argument I'm passing an arrow function. Item goes to this template string. So we can have a template string inside of another template string. Now in this template string, we have option, item, and option.

This is exactly what we have here. Now this is the end of the map method. Map basically returns an array. So we get an array of items and map them to another array. That's an array of strings, options.

Right? Now, we want to combine all the elements in this array using an empty string. If we don't use the join method here, when this array is converted to string, we will end up getting a comma after each option. So to solve that problem, we combine all the elements in the array using an m two string. Okay?

So, that's a more advanced usage of the template strings in e s 6. I hope you enjoyed this lecture and thank you for watching.




function HtmlElement() { 
  this.click = function() { 
    console.log('clicked');
  }
}

HtmlElement.prototype.focus = function(){
  console.log('focused');
}



function HtmlSelectElement(items = []) { 
  this.items = items;
  
  this.addItem = function(item) { 
    this.items.push(item);
  }

  this.removeItem = function(item) {
    this.items.splice(this.items.indexOf(item), 1);
  }

  this.render = function() {
    return `
<select>${this.items.map(item => `
  <option>${item}</option>`).join('')}
</select>`;
  }  
}
HtmlSelectElement.prototype = new HtmlElement(); 
HtmlSelectElement.prototype.constructor = HtmlSelectElement;



function HtmlImageElement(src) { 
  this.src = src; 
  
  this.render = function() {
    return `<img src="${this.src}" />`
  }
}
HtmlImageElement.prototype = new HtmlElement(); 
HtmlImageElement.prototype.constructor = HtmlImageElement;



const elements = [
  new HtmlSelectElement([1, 2, 3]),
  new HtmlImageElement('http://')
];

for (let element of elements) 
  console.log(element.render());
  
=====================================================================================================================================================================================

ES6 Classes:
------------


Over the last few sections, you learned all about objects and prototypical inheritance in JavaScript. Now in ES6 or ES2015, which is like the modern version of JavaScript, there is a new way to create objects and implement inheritance. That's using classes. But these classes are not like classes that we have in languages like c# and Java. They're essentially syntactic sugar over prototypical inheritance.

That's why I wanted to make sure that you fully understand how prototypical inheritance works before we look at the new syntax which is cleaner and simpler. So here we have this constructor function that you have seen throughout the course. We have this radius property, as well as the draw method.

function Circle(radius){
	this.radius = radius; 
	
	this.draw = function () {
		console.log('draw');
	}
}



Now let's see how we can rewrite this code using ES6 classes. So for now, I'm gonna create a class with the same name. We start with the class keyword, add the name of the class, and then curly braces. This is what we call the body of this class. In this body, we can define properties and methods. One of tge special method that we have is called constructor, and we use that to initialize objects just like the constructor function that we have above. So in this method, we pass the radius parameter and set the radius property on the new object instance that is created.

So that's our radius property. Now if you want to define a method, we won't use 'this' syntax. That's not how we do it. Instead, we define methods in the body of this class. So here we add the draw method.

So note that we don't have the function keyword here, we just add the name of the method and parenthesis and then curly braces. So this syntax is more familiar to people who come from languages like c# and Java. But as I told you before, these classes are just syntactic sugar over constructor functions. 


class Circle {
	constructor(radius) {
		this.radius = radius; 
	}
	
	draw() {
		console.log('draw');
	}
}




Now we can create circle objects just like before.  
const c = new Circle(1); 

Now here in the console, let's inspect c. So we have a circle object with the radius property.
c
//Circle {radius: 1}
	radius:1
	__proto__:
		constructor: class Circle
		draw: f draw()
		__proto__: Object
		
		


In this prototype, we have the draw method. So all the methods that we add, will end up on the prototype of the circle object. Now if you don't want a method to end up on the prototype, then you need to define it in the constructor just like before. So here I'm gonna define a move method. Save the changes.

class Circle {
	constructor(radius) {
		this.radius = radius; 
		this.move = function() {
			console.log('move');
		}
	}
	
	draw() {
		console.log('draw');
	}
}


const c = new Circle(1);

Now let's inspect c. So here we have the move method on the object instance and the draw method on the prototype. 

c
//
Circle {radius: 1, move: f}
	move: f ()
	radius: 1
	__proto__: 
		constructor:  class Circle
		draw:  f draw()
		__proto__: Object
		



So that's our circle object. Now let's look at the type of circle class. 
		
typeof Circle  //"function"

That's a function.
So that's why I said these classes are essentially functions, they're constructor functions. Don't believe me? Let me show you. So if you head over to babeljs.io, you can see babel. Babel is a JavaScript compiler. We give it our modern JavaScript code, and it compiles it down to ES 5 code that all browsers understand. So we can type some modern JavaScript code here, and then see the result of compilation in ES5 below.		


So, earlier in the course where I talked about factory and constructor functions, I told you that one of the arguments that people make against constructor functions is that the developer has to remember to use the new operator. Personally, I don't really like this argument. It's very childish. If a programmer forgets to use the new operator, what kind of programmer are they? But anyway, let's just stick to that.

Classes in ES6 enforce the use of the new operator. So that argument about the new operator, in my opinion, is no longer valid. Now later in this section, when we get to inheritance, you will see that classes provide a cleaner syntax to implement inheritance than what you learned in the last section about prototypical inheritance. So that's the basic of classes. Over the next few lectures, we're going to look at classes in more detail.
=====================================================================================================================================================================================

Hoisting:

In this lecture, I'm going to talk about hoisting. So in JavaScript, there are 2 ways to define functions. We can use the function declaration syntax, 

//Function Declaration
function sayHello() {}


or we can use the function expression syntax. So we define a variable or a constant. Let's call it say, goodbye and set it to a function. So this is what we call a function expression.

//Function  Expression 
const sayGoodbye = function () {}; 

const number = 1; 


Now by convention, with function expressions, we should add the semicolon at the end, but with function declarations, we don't add the semicolon here. The reason for that is, let's say here we're going to define a number, set it to 1. Here because we're dealing with an expression, we put a semicolon at the end.

So on both function expression and assigning a value to a variable, we're dealing with expressions and that's why we terminate them with a semicolon. Now, semicolon aside, there is a critical difference between a function declaration and a function expression in JavaScript. Function declarations are hoisted, which means they're raised to the top of the code. So I can declare this function here and then call it before its declaration. So here we can call say hello, and that's perfectly valid.


sayHello();

function sayHello() {}   // perfectly valid 

So, you won't get any errors in the console. Because this function is hoisted which means raised to the top. 



But with function expression if you call it before, Say if you call sayGoodbye(), you gonna get an error, sayGoodbye is not defined. The reason is, because here we're dealing with the expression, we're dealing with a constant or a variable that is not initialized. So if I define, let's say a constant called number and set it to 1 here, what would happen if we do a console.log of that number before it is assigned? We're going to get the same error, number is not defined.

So here, the only difference between number and sayGoodbye is that number is a primitive, sayGoodbye is a function or more accurately is an object. So we cannot use these identifiers before they're declared. So function expressions are not hoisted. Okay? Now, when it comes to classes, we can define classes using a declaration or an expression syntax.





We can define a class like this. 

//class Declaration

class Circle {
.
.
.

}


And this is what we call class declaration. Alternatively, we can use a class expression.


//Class Expression

const Square = class {
.
.
.
};





const c = new Circle(); // gives an error

class Circle {
}  
Now, unlike functions, class declarations or class expressions are not hoisted. 

That's because this class declaration is not hoisted or raised to the top. Now, which syntax should you use? A class declaration or class expression? Personally, I have not seen a use case for using a class expression.

Pretty much everyone uses the class declaration syntax. So stick to that because that's simpler and cleaner.

=====================================================================================================================================================================================

Static Methods:

In classical object oriented languages, we have two types of methods, instance methods and static methods. So let's see what is the difference. 

class Circle {
	constructor(radius) {
		this.radius = radius; 
		this.move = function() {
			console.log('move');
		}
	}
	
	draw() {
		console.log('draw');
	}
}


In this example, this draw method is what we call an instance method. Because this method is available on an instance of a class, which is an object. So if we create a circle object here, and log it in on the console.


So, in the circle object, on this instance, we have the draw method. 


const circle = new Circle(1);

c
//
Circle {radius: 1, move: f}
	move: f ()
	radius: 1
	__proto__: 
		constructor:  class Circle
		draw:  f draw()
		__proto__: Object
		




In contrast, we have static methods. Static methods are available on the class itself, not the object instance. We often use them to create utility functions that are not specific to a given object. For example, in this circle class, this draw is specific to a circle object.

we used draw method as instance method becuase it's a particular circle object that we want to draw. Right? So that's why it's an instance method. But here I can define a static method that is not tied to a particular circle object. Let's call that parse.

class Circle {
	constructor(radius) {
		this.radius = radius; 
		this.move = function() {
			console.log('move');
		}
	}
	
	//Instance Method
	draw() {
		console.log('draw');
	}
	
	//Static Method
	static parse(str){  //available only at the class level
		const radius = JSON.parse(str).radius;
		return new Circle(radius);
	}
}



const circle = Circle.parse('{ "radius": 1 }')

So parse takes a string, which is supposed to be a JSON string. It will parse it and return a new circle object. Now to make this static, we use the static keyword on the front. And with this, this method will no longer be available on a circle object. So here we won't have circle.parse, it doesn't exist, but it's accessible on the class reference. So Circle.parse, it's here. So with this method, we're not working with a particular circle object, we're working with the circle class itself.

So to call static methods, we don't have to create an instance of a class. Now let's go ahead and implement this method.  



So one more time, we use static methods to create utility functions that are not tied to a particular object. Let me show you another example. In JavaScript we have this built in object, math, and this object gives us a bunch of utility methods.

Now here we are not newing up a math object, we are not doing something like this --> new Math(). We directly access these methods on the math object itself. So here math looks like a class. If this math object didn't exist in JavaScript, and we wanted to implement it using ES6 classes, this is how we would do it.


So, we would define a class called math, and define a bunch of static methods like abs or absolute which takes a value and does some magic there, we don't care about that. Then we could access this method directly on the Math class itself. 

class Math{

	static abs(value) {
	//...
	}
}

Math.abs

=====================================================================================================================================================================================

The 'This' Keyword:
-------------------
In this lecture we're going to have a closer look at 'this' keyword in Javascript. 

So, I'm going to start by declaring a constructor function called circle. And in this constructor function I'm gonna set draw function and inside that we simply do a console.log of this. Now we create a circle object.

So constant c, we set it to a new circle, and then call c. Draw.

const Circle = function(){
	this.draw = function() { console.log(this); }

};


const c = new Circle();

c.draw();

//
Circle { draw: f }
	draw: f ()
	__proto__: Object

Now when I save the changes on the console, you're going to see our circle object because 'this' in console.log will point to the circle object. So let's see. Save the changes and here is our circle object.





Right? Now let me show you something interesting. 

Instead of calling the draw method like this, I'm gonna get a reference to this method, store it in a constant called 'draw'. Note that I'm not calling this method, I'm simply getting a reference to this method. So if we do a console.log of draw, we're going to see this function. 
Let's take a look. Save the changes
	
const draw = c.draw:
console.log(draw):

//
f() {
	console.log(this);
	}


and here's our draw function, right?	






Now I'm gonna call this draw function like this, 
draw();   //Note: here 'draw' is the constant that we assigned and we're are invoking it as function

Now when I save the changes, instead of seeing the circle object, you're going to see the window object. Let me show you.

//Window {...}

But what happened here? Why didn't we get the circle object? Okay, let me tell you why. First of all, the syntax we have below, is what we call method call.
c.draw();  //Method call

Because we are calling a method(which is draw) on an object(which is c), right? In this case, 'this' in the function 'draw' will point to the object(which is c), which is our circle object. Right? 


Now the syntax we have below, is what we call function call.
draw(); //function call

Because we're calling this like a standalone function that is not part of an object.

So when we call this method(which is draw) as a function, by default, this will point to the global object, which is window in the browser and global in node. Now to refresh your memory, earlier in the course I told you that. Here when we use the new operator, this new operator will create a new empty object and set 'this' in the constructor function to point to that newly created object. And I also told you that if you forget to use the new operator, 'this' by default will point to the global object which is window in the browser or global in node. We have exactly the same principle here.

So, when we call draw as a method on an object, 'this' will point to that object. And if we call this method as a standalone function, 'this' will point to the global object. 







Now, in JavaScript, we have this mode that is called strict mode. When we enable this mode, JavaScript engine will be more sensitive, so it will do more error checking. If there are errors that silently fail, it's going to turn them into exceptions.

And also it will change the behavior of the 'this' keyword in functions. So, we can enable the strict mode by adding, 

'use strict';  --> note it should be at the top of the script

Now, when I save the changes, you will see that instead of getting the window object, you'll get undefined.

So, when we enable strict mode, if we call a method as a function, 'this' by default will no longer point to the global object. It will be set to undefined. And the reason for this is to prevent us from accidentally modifying the global object because that's bad practice. Now there's more to this strict mode that is beyond the scope of this course. But let's see how did 'this' keyword behaves in our ES6 classes.

So I'm gonna define a Circle class. And we add the draw method,

class Circle{
	draw() {
		console.log(this);
	}
}


const c = new Circle();
const draw = c.draw();

draw(); //undefined

We get undefined. Because by default, the body of our classes are executed in the strict mode.

So, whether we explicitly enable the strict mode on top of the file or not, JavaScript engine will execute the body of the class in the strict mode. And this will prevent us from accidentally modifying the global object.


=====================================================================================================================================================================================

Private Members Using Symbols:
------------------------------

Earlier in the course, I talked about abstraction as one of the core principles of object oriented programming. So abstraction means hiding the details and complexity and showing only the essential parts. Remember the DVD player? That's abstraction. Now, to implement abstraction, we use private properties and methods.

So we hide certain members of an object so they won't be accessible from the outside. So here we have this circle class, we set the radius property in the constructor. And as you know, this radius property is public by default. Which means, if I create a circle object, pass 1 as the radius, then I can access this radius property using that circle object. Now in this case, we want the radius to be public because that's an essential attribute about a circle.


Class Circle{
	constructor(radius) {
		this.radius = radius;
	}
}


const c = new Circle(1);
c.radius


But in this lecture, let's imagine we want this radius property to be private. So I'm gonna show you how to implement private properties and methods when using ES6 classes. There are basically 3 different approaches, but the first approach, in my opinion, is a terrible approach, so I don't even count that. The first approach is using an underscore as a naming convention. So, some developers name their private properties or methods using an underscore.

So they prefix it with an underscore like this, 


Class Circle{
	constructor(radius) {
		this._radius = radius;
	}
}

c._radius

and then they assume that this is a private property. Why do I say this is a terrible approach? Because I can still access this radius from the outside. So this is not abstraction, this is a convention for developers. It doesn't prevent another developer from writing code against this property.






As I told you before, with abstraction, we wanna hide some of these properties and methods from the outside, so as we change them, we isolate the impact of changes to the containing object. We don't want these details to leak to the outside. Right? So this is not a way to implement private properties and methods. Please do not use this approach.

Now in this lecture, I'm gonna show you how to use ES6 symbols to implement private properties and methods. And in the next lecture, I'm gonna show you how to use maps to achieve the same thing. So in ES6, we have a new type, a primitive type called symbol. Remember primitives? We have number, string, Boolean, etc. Now we have another primitive called symbol. So I'm going to define a constant called underline radius, and set it to a symbol. So symbol is a function we call to generate a symbol. A symbol is essentially a unique identifier. Every time we call this function, we get a new unique identifier.


const _radius = Symbol();


And note that this is not a constructor function, so we cannot new that up like 'new Symbol()', otherwise we get an error. So here in the console, I'm going to create one symbol and compare it with another symbol. 

Symbol() === Symbol() // false


Look, they're not the same. So every time we call the symbol function, we get a new unique value. And we can use this unique value as the property name for an object.

Okay, so you know that in JavaScript there are two ways to access a property in an object. We can use the dot notation, or by using brackets and we use string inside those brackets. 

this.radius 
this['radius'] 

So these two lines are exactly the same. Now, with the introduction of symbols, we can also use a symbol as a property name instead of a string. So here we can use this square brackets

this[_radius] = radius; 


Class Circle{
	constructor(radius) {
		this[_radius] = radius;
	}
}

const c = new Circle(1);

Let's see the impact of this change. So save the changes. Now we have a circle object, let's log it on the console. 

c
//
Circle{Symbol(): 1}
	Symbol(): 1
	__proto__: Object


So look at the property, it's called symbol. Now this is just how we see it internally, the name of the property is a unique value.

So if we set multiple properties using symbols, the property names all will show up as symbol, but internally, they are unique. Now you might say, this is not private because we still have this property here. Well, yes and no. Let me explain. So, if you use c.(c dot), you don't see that radius property anymore, which means We don't have _radius. So we cannot directly access that property in code. 


There is a hack around that, let me show you. So we have this method object.getOwnPropertyNames

console.log(Object.getOwnPropertyNames(c)); // []

We get an empty array because we don't have any properties, or more accurately any regular properties in this object. But we have another method, getOwnPropertySymbols instead of names. Now look at this, you get array of symbols, let's check first value of it  

console.log(Object.getOwnPropertySymbols(c)); // [Symbol()]

const key = Object.getOwnPropertySymbols(c)[0];
console.log[c[key]); // 1

We get the value of the radius property. But we're not going to write code like that to access these kind of private properties. This is kind of awkward, right? So we can use symbols as a simple way to implement kind of private properties and methods. Now how do we implement a private method?







Now to make the method as  private, similarly we can define another symbol, let's call that draw. We set that to a new symbol. Now instead of using the draw name inside the class, we want to use our symbol. Now in ES6 we have this new feature called computed property names. So, we can add brackets and inside of these brackets we add an expression. When that expression is evaluated, the resulting value will be used as the name of a property or method. So, here we pass _draw. So with this expression, our symbol, will be evaluated. We get a unique value, a unique identifier, and because we have put that inside of these brackets, that unique identifier will be used as the name of this method.


const _radius = Symbol();
const _draw = Symbol();


class Circle{
	constructor(radius) {
		this[_radius] = radius;
	}
	
	[_draw]() {
		...//
	}

}

const c = new Circle(1);


c
//
Circle{Symbol(): 1}
	Symbol(): 1
	__proto__:
		constructor: class Circle
		Symbol(): f()
		__proto__: Object



So we have the radius property, and in the prototype where all those methods outside the constructor end up, we have another property, which is a symbol, and that's set to a function. So that's our draw function or more accurately the draw method. In the next lecture, I'm gonna show you how to use maps to implement private properties and methods.

=====================================================================================================================================================================================

Private Members Using WeakMaps:


In this lecture, I'm going to show you how to use WeakMaps(which is a new type in ES6), to implement private properties and methods in an object. So, continuing with our circle example, we wanna turn the below radius property into a private property. 

Class Circle{
	constructor(radius) {
		this.radius = radius;
	}
}


const c = new Circle(1);






On the top, we're gonna define a constant. We call it  _radius. That's just for our own convention to indicate that this is a private property. We set this to a new WeakMap(). A Weak Map is essentially a dictionary where keys are objects, and values can be anything. And the reason we call them Weak Maps, is because the keys are weak. So if there are no references to these keys, they will be garbage collected. Now inside of this constructor, we're not going to set the radius property anymore. Instead we're going to work with this _radius key map. We call the set method, and the first argument is the key (the intellisense will show you that the key has to be an object and it cannot be a symbol. So here we pass 'this', which represents the instance of circle object, and that's our key. And for the value, I'm going to use the radius argument we get in the constructor. Now technically, we can access the 'radius' private property outside the class if we can get access to the WeakMap mapped to _radius.


const _radius = new WeakMap();

Class Circle{
	constructor(radius) {
		_radius.set(this, radius);
	}
}


const c = new Circle(1);






But later that I'm going to talk about modules, and you will see that we can hide the _radius in a module and only export the circle class. So, imagine like somewhere else in the code we get the circle class, we won't have access to the weak map. Hence the circle object doesn't have a radius property. Right? 

Let's inspect this on the console. 


c
//
Circle{}
	__proto__:
		constructor: class Circle
		__proto__: Object


Look we don't have the radius property. Now if you wanna access the radius property inside of this class, we can do something like this. 

Let's imagine we want to read this somewhere. So I'm going to add our draw method.
In order to read the radius property, we use our WeakMap _radius. Now instead of calling the set method, we can call the get method, and we have to mention a key. In this case, the key is the instance of the circle object, 'this'. And it will return the value of the radius property. So let's log that on the console.


Class Circle{
	constructor(radius) {
		_radius.set(this, radius);
	}
	
	draw() {
		console.log(_radius.get(this));
	}

}

const c = new Circle(1);


c.draw()
//
1





Now how about defining a private method? We have to use another key map. 

Once again in the constructor, we pass 'this' as the key, and a function as the value. 

while logging it in the console. we can also log 'this', to check what it is referencing

Now let's imagine in our draw method, which is a public method, we wanna call the move method which is a private method. So, in order to access this move function we use the same technique we used above which is by using 'get'. 

Note that _move.get(this) will return a function, so we can call that function using (). 

const _move = new WeakMap();

Class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
	
	_move.set(this, function() {
		console.log('move', this);
	});
	
	
	draw(){
		_move.get(this)();
		console.log('draw');
	}
}



c.draw()
//

move undefined
draw


We got the message from the move method, which is undefined. Because I told you that the body of the class is executed in strict mode, and 'this' by default will be set to undefined as opposed to the global object. Now, in this particular implementation, maybe in the move method, say that we want to access the instance of the circle object. So how can we do this? Well, instead of using a regular function, we can use an arrow function, and the problem will go away.

Because arrow functions use the 'this' value of their containing function. So in this case, 'this' is not going to be rebound, it's going to be inherited from what we have in the constructor. So in the constructor, 'this' references a circle object and when we use an arrow function inside of constructor function, 'this' will not be rebound, it's not going to be reset, it will be inherited from the constructor function. 


const _move = new WeakMap();

Class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
	
	_move.set(this, ()=> {
		console.log('move', this);
	});
	
	
	draw(){
		_move.get(this)();
		console.log('draw');
	}
}


c.draw()
//
move Circle{}
draw

Now we have the message from the move method and here's our circle instance. So we can access all the public and private properties of the circle object in the move method. 






Now one part you might be confused about is why we're using a separate week map for each property or method. Why don't we create just one week map for all the private members? Something like this.
constant, privateProps, we set it to new WeakMap, and then here in the constructor we could do something like privateProps.set and passsing 'this' object as first argument, in this object we can add all the private properties and methods. So we can add the radius property and set it to this radius argument. We could also add the move method, we use an arrow function here, and so on. Personally, I don't like this syntax, I think it's a little bit polluted.

const privateProps = new WeakMap();


class Circle{
	constructor(radius){
		privateProps.set(this, {
			radius: radius,
			move: () => {
			}
		}
	});
	
	
	




I prefer to work with each private member independently, but if you prefer this former syntax, by all means go for it. Just remember that if you use a single week map, then in order to access, let's say the radius property, you would do something like this. Say for example, you want to access radius property

privateProps.get(this).radius

Personally, I don't like this approach. So, my preference is to use a separate week map for each private member.

=====================================================================================================================================================================================

Getters and Setters:
--------------------

So, I've simplified the example from the last lecture. Here we have only one private property which is the radius property. Now earlier in the course, I talked about getters and setters. So here we have defined a private property, but maybe we want to read this value from the outside. Perhaps we don't want to set it, we just want to read it.

One way is to define a method like getRadius, And here we return, _radius.get() function. And then in the console, we can call c.getRadius to read that value. But I don't like that here we're calling a method. It would be nicer if we could read that like a property. Okay? like 'c.radius'

const _radius = new WeakMap();

class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
	
	getRadius(){
		return _radius.get(this);
	}
	
}


const c = new Circle(1);


c.getRadius()






So earlier in the course where we talked about constructor functions, you saw that there we used object.defineProperty to define a getter. That syntax is very convoluted. In ES6 we can create a getter and setter much easier. 

Object.defineProperty(this, 'radius', {
	get: function(){
	 ..///
	}
	set:
});
	
	
	
	
	
	

Now to implement a getter, change the name of the method to radius, so it looks like a property. And then simply add the get keyword in the front. It looks like a method, but actually we can access it like a property. 

class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
	
	get radius(){
		return _radius.get(this);
	}
	
}

c.radius //1






We can also define a setter very easily. There we can do some validation. So if value is less than or equal to 0, we're gonna throw a new error, invalid radius. Otherwise, we need to set this radius private property.

So just like how we set it in the constructor, we access our Weak Map, and then call the set method. 

class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
	
	get radius(){
		return _radius.get(this);
	}
	
	set radius(value) {
		if (value <= 0) throw new Error('invalid radius')
		_radius.set(this, value);
}




c.radius //1

c.radius = 10;

c.radius //10

=====================================================================================================================================================================================

Inheritance:
------------


Alright now that we have learned all about classes in ES6, lets see how we can implement inheritance. So I'm going to start by declaring a class called shape. In this class we add a method called move. Simply log this on the console. 

class Shape {
	move() {
		console.log('move');
	}
}


Now let's define a circle. And to have the circle inherits from the shape class, all we have to do is to add 'extends shape'. So we don't have to reset the prototype, we don't have to reset the constructor. It's far easier and cleaner. And in the circle class, we can add a draw method.

class Circle extends Shape{
	draw() {
		console.log('draw');
	}
}


const c = new Circle();


Let's inspect it in the console. So here's our circle object. Note that in its prototype, we have the draw method. Because as I told you before, all the methods we implement outside the constructor will end up in the prototype. Now this prototype object itself has a prototype. And this is where we have the move method. Note the constructor property here. So, this object was created by the Shape class, and the object above was created by the Circle class. So, you can see with the extends keyword, we don't have to reset the constructor. It's far easier. So now our circle object can be moved and drawn. 

c
//
Circle{}
	__proto__: Shape
		constructor: class Circle
		draw: f draw()
		__proto__: 
			constructor: class Shape
			move: f move()
			__proto__: Object
			
			
			
			
			


			



Now let's take this to the next level. Let's imagine all our shapes need a color. So I'm going to add a constructor here and add a color property.

class Shape {

	constructor(color){
		this.color = color;
	}
	
	move() {
		console.log('move');
	}
	
	
}
		

Okay? Now if I save the changes, we don't get any errors. However, if we add a constructor in the circle class, we get an exception, "Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived contructor at new circle."

class Circle extends Shape{

	constructor(){
	}
	
	draw() {
		console.log('draw');
	}
}


If you have a constructor in the parent class, and then you add a constructor in the derived class and inside of that constructor, you should make sure to call the super class constructor first to initialize the base object. Okay? So here in the Cirlce class constructor, we can use the super keyword to reference the parent object. 

class Circle extends Shape{

	constructor(color){
		super(color);
	}
	
	draw() {
		console.log('draw');
	}
}


const c = new Circle('red');



We can add additional properties here like radiuse.

class Circle extends Shape{

	constructor(color, radius){
		super(color);
		this.radius = radius;
	}
	
	draw() {
		console.log('draw');
	}
}

const c = new Circle('red', 1);


c
//
Circle {color: "red", radius: 1}
	color: "red"
	radius: 1
	__proto__: Shape

=====================================================================================================================================================================================

Method overriding: 
------------------

Earlier in the section about prototypical inheritance, I talked about method overriding. So method overriding is when we have a method in a base class or a base object, but we wanna change its implementation in a derived class or a derived object. So maybe the algorithm for moving a shape is common amongst most of the shapes, but perhaps our circles need a different algorithm to be moved. So here we can override this move method by reimplementing it in the circle class. So we add the move method here.

class Shape {
	move() {
		console.log('move');
	}
}


class Circle extends Shape {
	move(){
		console.log('circle move');
	}
}


c.move() // circle move



c
//

Circle{}
	__proto__: Shape
	constructor: class Circle
	move: f move()
	__proto__: Object



So when we access c.move, JavaScript engine first looks for this move method on the circle object itself. Now in the circle object we don't have the move method, so then the JavaScript engine looks at the prototype for this object. Note that this object has its own prototype, and in this prototype we have another move method, that is the move method we implemented in the shape class.

Now, when accessing a property or a method, because the JavaScript engine walks up this tree from the child all the way to the parent, the move method in the prototype will be accessible first. That's why this implementation is used. Now let's imagine you have a scenario where you wanna reuse some of the code that you have implemented in the parent move method. In that case, you can call that method by using the super keyword. 

class Circle extends Shape {
	move(){
		super.move();
		console.log('circle move');
	}
}


c.move();
//
move
circle move
=====================================================================================================================================================================================

Exercise: Stack Operations



Alright, now it's time for an exercise. I want you to implement a stack using ES 6 classes. What is a stack? A stack is a special kind of data structure like a physical stack or pile. It's one of those topics that you learn at university in your data structure subject.

Unfortunately, there are a lot of developers out there who can build applications with Angular, React, Node, and whatnot, But they don't know the fundamentals of algorithms and data structures. That's why I'm planning to create a comprehensive course on this topic. So if you wanna learn from me, be sure to keep an eye on my website and enroll in the course when it's ready. So let's see how a stack works. So look at this box we have here.

A stack has 2 essential operations. Push for adding an object in this box and pop to remove the object on top of this box. So we can call the push method and push a and now a is on the stack. Next, we can push b and now we have b. And similarly, we can push c and now we have c on top of this stack.

Now unlike arrays, we cannot access objects in a stack using their index. But we can always remove the object on top of the stack by calling the pop method. So we can call the pop method and c will pop out of the stack. Similarly, if we call the pop method again, b will pop out. So let's see this in action.

I've implemented the stack class. So let's create a stack object, new stack. Alright. Have a look at this object. So here we have account property.

Currently, we have 0 items in the stack. Under prototype, we have 3 methods, peak, pop, and push. Peek is similar to pop, it returns the object on top of the stack, but it does not remove it from the stack. It only shows you what is on top of the stack. So let's see these methods in action.

Stack dot push, I'm gonna push a, stack dot push this time b, and finally c. So c is on top of this stack. Now if you look at the count property, you can see we have 3 objects in this stack. So to remove the object on the top, stack dot pop, it returns c. And if you look at count, now we have 2 objects in this stack.

Now if we call the peak method, it tells us that b is on top of the stack, but it doesn't remove it. So if we look at the count property one more time, we still have 2 objects on the stack. So let's call pop a couple more times. Now we removed a, so if you read the count property one more time, we have 0 items. Now let's see what happens if we call the pop method on an empty stack.

So stack dot pop, it's an invalid operation. So your code should throw an exception, stack is empty. The same is true for the peak method, so if we call peak on an empty stack again, we get the same error. So I want you to implement this data structure using e s 6 classes. Next you will see my solution.


const _items = new WeakMap();


class Stack{

	constructor(){
		_items.set(this, []);
	}
	
	push(obj){
		_items.get(this).push(obj);
	}
	
	pop(){
		const items = _items.get(this);
		
		if(items.length === 0)
			throw new Error('Stack is empty');
		
		return items.pop();
	}
	
	peek(){
		const items = _items.get(this);
		
		if(items.length === 0)
			throw new Error('Stack is empty');
			
		return items[items.length - 1];
	}
	
	get count(){
		return _items.get(this).length;
	}
}

=====================================================================================================================================================================================

ES6 Tooling:		

Modules:		
---------

In all the examples so far, we have written all the code inside of one file, index.js. But that's not how we build real world applications, because we don't wanna have one gigantic file with hundred or thousands of lines of code. That's really hard to maintain. So we should split our code into multiple files and we call each of these files a module. This gives us a number of benefits.

First, is that we can increase the maintainability of our application, because our code is better organized. Second, is that we get the chance to reuse one or more of these modules in different parts of an application or in different applications. And third, is that we can abstract code. So we can apply the abstraction principle, which means we can hide some of the complexity in a module, and only expose the essentials. Here's a real example.


Benefits of having modules

Modularity:
Maintainability
Reuse
Abstract


const _radius = new WeakMap();

class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
		
	draw(){
		console.log('Circle with radius ' + _radius.get(this));
	}
	
}

const c = new Circle(10);


So, earlier we wrote this code to implement a private property in our circle class. So we have this radius which is a Weak Map, and we're using that inside our circle class to implement a private property. And then when we create a circle object, we don't have access to a radius property like this 'c.radius'. This does not exist. However, in the code, if I have access to this _radius weak map, I can read the radius private property of the circle object.

console.log(_radius.get(c)); //10







Now, what we should do here is to take the circle class and the _radius weak map out of this file, put it in a separate file which we call a module, and then only expose the circle class to the outside. So we can import that file here in the current file, create a circle object, but we will not have access to this _radius object which is our weak map. So this is abstraction in practice.

So, now you know what modules are, what are their benefits. You might be asking, how can we use modules in JavaScript? Well, before I tell you the answer, I wanna quickly give you a brief history of modules in JavaScript. In ES5, we didn't have the concept of modules. So different solutions emerged to solve this problem.

Smart developers and the community introduced new syntaxes to define modules. We refer to these syntaxes as module formats. So, the popular module formats we have are AMD, which stands for asynchronous module definition. And this is primarily used in browser applications. We also have CommonJS, which is used in Node.

We have UMD, which stands for Universal Module Definition, and this can be used both in the browser and in Node. So we use these module formats in ES5, but as of ES6, JavaScript natively supports a module format. Now out of this list, we're going to focus only on two formats, commonJS because that's used in Node, and ES6 modules because that's used in browsers. So technically, going forward, you don't need to learn about AMD or UMD, unless you're maintaining a legacy application that is built around this module format. So next, we're going to look at commonJS, and then we'll look at ES6 modules.


Modules used in ES5: 

AMD  --> Browser
CommonJS --> Node.js
UMD --> Browser/Node.js


Modules we going to use in ES6:

CommonJS --> Node.js
ES6 Modules --> Browser

=====================================================================================================================================================================================

CommonJS Modules:
-----------------

In this lecture, I'm going to talk about commonJS module format that is used in Node. So, as part of this, I'm assuming you have some basic familiarity with Node. At least you have installed it on your machine and built a simple hello world example. If you haven't, that basically means you are a front end developer. So you have only used JavaScript inside of browsers.

If that's the case, skip this lecture and watch the next lecture where I talk about ES6 modules.  

const _radius = new WeakMap();

class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
		
	draw(){
		console.log('Circle with radius ' + _radius.get(this));
	}
	
}

const c = new Circle(10);
c.draw();


Now, here in the terminal, we can run this application, 

node index.js
//
Circle with radius 10


Now we wanna modularize this simple program. So here's a basic rule of thumb about modularity.

Things that are highly related, they should go together. For example, in your kitchen, you have glasses, plates, spoons and forks, and so on. You don't store your clothes in the kitchen. Right? They belong to your bedroom.

So, things that are highly related, they should go together. This is what we call cohesion in software engineering. The same principle applies to code. So, in this piece of code, we're gonna find things that are highly related and then move them outside of the index.js. Can you guess what parts are highly related?

Well, we have this Weak Map radius that is used inside of the circle class. Right? So these two pieces are highly related, we need to take these outside of the 'index.js' and put them in a separate file. So I'm going to create a new file, 'circle.js' and move all the code there.

So, here's our circle module. Now, by default, everything that we defined in a module is considered to be private. So it won't be accessible to the outside, unless we explicitly export it. The way we export objects in Node or commonJS format is like this. So here we have this keyword, module, which refers to the current module.
This module has a property called exports, and this is an object. We can add 1 or more properties to this object. So we can add a property called circle, and set that to this circle class here. Now if we had multiple classes here and we wanted to export them all together,

In circle.js:

module.exports.Circle = Circle;
moduel.exports.Square = Square;


But in this implementation, we're exporting only a single object. So we can simplify this code like this. 
Now instead of adding a circle property to the 'module.exports' object, we can just reset this object to circle. So when we import the circle module, we'll get the circle class. Okay? 

module.exports = Circle;


Now, let's go back to our index.jS, or index module. On the top, we wanna import the circle module.

We use the require function for that. This require function is part of the commonJS format. So commonJS format defines this require function, and 'module.exports'. This is the syntax that is used in commonJS format. Okay.

Now back in 'index.js', we want to require, here we pass a relative path to this target module. We use period and slash to refer to the current folder, and then add circle. Note that we don't need to add the extension, we don't need to add circle.js because that's assumed by default. Now, when we require this, we get what is returned from this module. So module.exports represents the object that is exported from this module.

In this case, that object is the circle class. So back in 'index.js', we get this and store the result in a constant called Circle. And then we can use circle to create a new circle object. 


In index.js:

const Circle = require('./circle');

const c = new Circle(10);
c.draw();


Now here's the interesting part here. In the circle module, we are only exporting the circle class. So, this radius weak map is not accessible in our other modules. This is part of the implementation detail of the circle module. What we're exporting, which is our circle class, is what we call the public interface. So, this is abstraction in practice.

We're hiding the details, or the complexity inside of a module. Tomorrow we may decide to replace this weak map, maybe with a symbol or a different object. That change is not going to break the rest of this application. Because nowhere else we have code that touches this _radius object. It's part of the implementation detail of this circle module.

So this is how we use commonJS modules in Node. In the next lecture, we're going to look at ES6 modules.
 
=====================================================================================================================================================================================

ES6 Modules: 
-------------


Alright, now we're going to look at ES6 modules. So, here in index.js, we want to grab the circle class and the radius weak map, and put them in a separate module. And then in that module, we want to export only the circle class because this is the public interface of that module, and we want to keep this radius weak map private. Because this is part of the implementation detail of that module, we don't want that to be leaked to the outside.

So, let's see how we can use ES6 modules to achieve this. I'm going to create a new file, call it circle.js. Now back in 'index.js', I'm gonna grab the radius weak map and the circle class, cut them, and put them in 'circle.js'. Now by default, everything that we define here is considered private unless we explicitly export it using the export keyword. So here, if we put the export keyword before the circle class, this will be exported to the outside.

So when we import the circle module in our index module, we'll have access to the circle class, but we won't be able to work with this radius weak map. Okay? So save the changes, now back in 'index.js', we import circle, we put it between curly braces and then we add the path, period slash(./) to refer to the current folder, and then circle. Now if we refresh the console, we get this error.

Syntax error, unexpected token. Now there is a proper way to fix this issue using webpack, but in this lecture I'm going to show you a quick work around. It's not something you want to do in production, it's just for this demo. So we go to index dot HTML. Here is our script element.

We need to change the type of this script element to module. With this, our browser treats 'index.js' as a module so it will understand these curly braces here. Okay. So save the changes in index dot HTML. Now we get a different error.

GET http://localindex.js:2lhost:5500/Circle net::ERR_ABORTED

So you can see we have a get request to local host port 55100 slash circle. Because in 'index.js', we're trying to load this circle module. That's why we have this HTTP request to this endpoint. But the name of the file is not circle, it's 'circle.js'. So again as a temporary workaround in this lecture, we need to add .js in the import statement.

Now what I want you to take away from this lecture is the syntax of ES6 modules. So, in circle module, we use the export keyword to export one or more objects, and then in other modules, we use import to import those objects from our modules.


In circle.js:
-------------
const _radius = new WeakMap();

export class Circle{

	constructor(radius) {
		_radius.set(this, radius);
	}
		
	draw(){
		console.log('Circle with radius ' + _radius.get(this));
	}
	
}



in index.js:
------------
import {Circle} from './circle';

const c = new Circle(10);

c.draw();





in index.html:
---------------

<script type="module" src="index.js"></script>

=====================================================================================================================================================================================

ES6 Tooling:
------------

Alright now let's talk about ES6 tooling. These tools that I'm gonna introduce you to, they're only important if you're building browser applications. If you're using JavaScript in Node, you don't have to worry about these tools. So what are these tools? When using modern JavaScript, we need 2 kinds of tools.

A transpiler and a bundler. Transpiler is the combination of 2 words, translator and compiler. Basically, it's a tool that we give it our modern JavaScript code And it will convert our JavaScript code into code that all browsers can understand. Earlier, I showed you Babel. Babel is an example of a very popular transpiler for modern JavaScript.

A module bundler is responsible for combining all our JavaScript files into a single file which we call a bundle. There are many module bundlers out there but the most popular one is webpack. So we give all our JavaScript files to webpack. Webpack will combine them into a single file. It will minify our code by getting rid of all the white space and comments, and then it will uglify our code which basically means it will shorten the name of our identifiers like classes, functions, objects and so on.

So this will reduce the size of the bundle that we will serve to the client. So over the next two lectures, we're going to explore each of these tools.

====================================================================================================================================================================================

Babel:
------


In order to install the tools that I told you about, we need node. Now at this point, you don't need to know how node works because we're not going to program in node. All we need is a tool that comes with node called node package manager or npm. You probably know this but I wanna make sure to explain it very briefly for students who are not familiar with npm. So npm is a tool that we use to install third party libraries and tools.

So if you haven't installed node on your machine, head over to nodejs.org, and on the homepage download the latest stable version and install it. When you're done, open up the command prompt or terminal, and run node dash v to make sure you have installed node properly. Now for this demo, I'm going to create a new folder. Let's call that es6 dash tooling. Let's go in this folder.

The first thing we need to do is to initialize a node project in this folder. To do that we run npm init dash dash yes. What this command does is it creates a file in this folder called package.json, which is an identification for our application. Here we have properties like name, version, description, and so on. Now we are ready to install babel.

So npm, I as in short for install. There are 3 packages that we need to install. So I want you to pay great attention here, make sure you get the spelling right, as well as the version number. Because chances are in the future when you're watching this video, the latest version might be different and it might behave differently. So make sure to install the same version that I'm installing in this video.

So the first package is babel dash cli, we add at sign to specify the version number. The version I'm going to install is 6.26.0. Now the second package is babel core and its version is 6.26.0. And the last one is babel presetdashn and the version is 1.6.1. Now let me quickly explain what each of these packages are.

So babelcli is Babel's command line interface, it's the tool that we run from the command line, like npm. So we run it from the command line, and give it the name of our JavaScript file, and then it will convert or compile that JavaScript code. The second package, babel dash core, is basically the core of babel where all the logic for transpiling code is implemented. And finally, we have babel preset. What is this?

Well, in babel, we have a plugin for every new JavaScript feature starting from ES 6. So, let's say you wanna use let and const in ES 6, there's a plugin for that. You wanna use arrow functions in ES 6, there's a plugin for that. So every new feature in ES 6 and newer versions has a corresponding plugin. Now, let's say in your application you want to use only 2 of these new features.

So you can install only those 2 plugins. But if you want to have more flexibility, you can install this preset and this preset is basically the combination of all these plugins. So it understands all the new features in JavaScript starting from ES 6. Now, finally, we need to supply a flag here, dash dash save dash dev, And this means we're going to install these as development dependencies. So they are not going to be part of our application, they are not going to be deployed to the production, they are purely on the development machine.

Let's go ahead. Alright, we're done. Now let's open up Visual Studio Code. So in this folder we have this package dot JSON, and package dash log dot JSON, which is used internally by NPM. And we have this node modules folder where all these packages that we installed are stored.

Now there are more folders here than what we installed, these are the dependencies of those packages. So you don't have to worry about any of this. Now I'm going to add a new file here, index dot JS, and write some basic e s six code. So let's define a constant x and set it to 1. Alright, now we want to use Babel to convert this to code that all browsers can understand.

The first thing we need to do is to go to package dot JSON, here in the script section, delete what we have here for test, don't worry about this. We're gonna add a new script, and I'll tell you how that works in a second. We call this babble and set this to a command that will run in terminal. So the command we're gonna run is like this, babel, that's babels command line interface that we run from the terminal. Then we add dash dash presets, the preset we're gonna use is env, after that we add the name of our source file which is index dot JS, and then we add dash O, output is going to be in a folder like build, and then index dot JS.

Now in order for this to work, we need to create this folder otherwise we're going to get an error. So here in this project I'm going to add a new folder, build, now save the changes. So basically the script that we define under the script section, we can run them using NPM. So if we go to the terminal, and run NPM run babel, this will execute this command on the terminal. It's faster and easier to type npm run babel as opposed to this complex command.

So back in the terminal, npm run babel. Our code is compiled. Now it's stored in build/index.js. So let's have a quick look here. Build index.js.

So note that in ES 5, we don't have let or const, so our code is converted to something like this. We're using strict mode by default, that's a best practice, and const is replaced with var. Now this is just the basic of babel. There is way more to babel, it really requires its own course. I just wanted you to get a taste of how it works.

Obviously, one problem with this setup is that in package dot JSON, we are compiling only index dot JS. Our application might have 100 or 1000 of files. So we don't want to repeat this for every file. That's where we use webpack. So with webpack, we're going to get all our JavaScript files and put them in a bundle.

However, before putting these files in a bundle, we're gonna run each file through babel. And that's what you're going to see in the next lecture.


mkdir es6-tooling
cd es6-tooling
npm init --yes


wrote to package.json 


npm i babel-cli@6.26.0 babel-core@6.26.0 babel-preset-env@1.6.1 --save-dev

package.json
package-lock.json
node_modules


index.js:
---------
const x = 1;


package.json:
-------------

"Scripts": {
	"babel": "babel --presets env index.js -o build/index.js
}.


npm run babel



build/index.js:
---------------

"use strict";

var x = 1;

=====================================================================================================================================================================================

Webpack:
--------

What you learned in the last lecture about using babel was purely for demonstration. It's not the workflow you use when building real world applications. So in this lecture, I'm gonna show you the workflow that you should use on a day to day basis. So for this demo, I'm using this project that we worked on earlier. We have 2 modules, index dot JS and circle dot JS.

In index, we simply import the circle module, we get the circle class, create an object, and draw it. If you want to code along with me, I've attached this project as a zip file to this lecture. Now open up command prompt or terminal, and run this command. Npm install dash g, which is short for global. We're going to install webpack CLI globally, so we can access it in every project.

The package name is webpack dash CLI, and the version I'm going to use which is the latest version right now is 2.0.14. Now if you're on Mac and you haven't configured permissions properly, you need to prefix this command with sudo. Alright. So we have installed webpack CLI. Now in our project folder, we run webpack, dash CLI space init.

So webpack CLI is going to ask us a bunch of questions and based on these it will create a webpack configuration file, which used to be painful in the past, You had to jump back and forth in the documentation, but now we can easily generate this configuration file using Webpack CLI. So let's see what these questions are. Will your application have multiple bundles? Let's say no, we are going to have a single bundle. Which module will be the first to enter the application?

We need to specify the starting point. So by default it's suggesting to use index in the source folder. So back in our project, as a best practice, I'm going to move all our Javascript files inside of a folder. So let's call that folder s r c, and move index and circle there. Okay, now back in the terminal, so the path is period slash s r c slash index.

The next question is which folder will your generated bundles be in? The default is dist, so we can press enter and accept the default. Are you going to use this in production? For simplicity lets say no. Will you be using ES 2015 or ES 6?

Absolutely, because we're using classes and modules. So, yes. And when we answer yes to this, this is going to automatically install babel to transpile our code into e s 5. So we don't have to explicitly install all those babel packages. That's the benefit of using this webpack CLI.

Not only will it help us generate the configuration file for webpack, but it will also download and install any other libraries and tools that we need. Let's go ahead. The next question is about CSS. We're not gonna use CSS here, so no. Again another question about CSS, if you want to bundle your CSS files, what will you name the bundle?

So you can see with webpack not only can you bundle your JavaScript code but you can also bundle your CSS. Again we press enter to skip. And finally it's asking us the name of our configuration file. So by default is webpack.config.js, but you can change this if you want, I suggest not to do that. Let's go ahead, now this is installing a few packages.

Alright, so here are the packages. It installed Webpack CLI locally, it also installed Uglify JS, this is used for uglifying code which basically means shortening the name of our identifiers. You're going to see that in a second. It installed babel core, so unlike the last lecture we didn't have to explicitly install this. It installed babel loader.

In webpack we use loaders to pre process files. So this is like a plugin for Webpack that uses Babel to transpile our files. It also installed babel preset env, which you are familiar with, and finally Webpack library itself. Now back in the project, you can see here is our webpack configuration file, all the details we supplied are now stored here. So the next step we need to do is create a package dot JSON file.

So back in the terminal, let's run npm init dash dash yes. Now back in the project, here's our package dot JSON. In the script section, we're gonna add a new command, call it build, and set it to webpack. And the only problem with the current implementation of webpack CLI is that it's storing all these tools like babel core, babel loader, and so on, under dependencies in package dot JSON. But these are essentially development dependencies so they should be stored here.

But this will probably change in the future. So everything is ready, now let's bundle our application. So back in the terminal, run NPM, run build. So this runs Webpack, you can see Webpack created a bundle called main.bundle.js, and it used these 2 source files, circle and index, both of them are in the source folder. So, back in the project, here's our dist folder, here's our bundle, you can see our code is uglified.

Look at this short identifiers like t r n, there's no white space in this code, there are no comments, and this is basically ES 5 code. So webpack run our code through babel, and it converted it to ES 5. Now, we have 1 JavaScript file to serve to the client, so we go to index dot HTML. Here in the script element, we remove type set to module because this was purely for demonstration earlier. And then change the source to dist slash main dot bundle dot js.

Now finally, we go live with this and you should see this message, circle with radius 10. So this guarantees that everything is working, our modules are working. Now with the current setup, every time we make a change to our source files, we have to go in terminal and run NPM run build. This is time consuming. So let's simplify this.

Back in package dot JSON, here I'm going to change this build script to webpack dash w, that's short for watch. So with this, webpack is going to watch our files and every time we make a change to any of our files, it will automatically regenerate our bundle. So save the changes. Now back in the terminal, we run NPM run build. So you can see Webpack is watching the files, it generated our bundle.

Now let's go and make a simple change to one of our source files. So let's open up index dot JS. I'm gonna do a console dot log, I've changed. Save the changes. You can see Webpack regenerated our bundle.

And here's our changed message on the console. Also note that earlier, when I was demonstrating ES 6 modules, I told you that as a temporary work around we had to add this dot JS extension here, so the browser could request this file from the server. But now that we're using a bundle, we don't need this anymore, so let's delete this, save the changes, webpack regenerated our bundle, and everything is still working. If I refresh, see, we still get all these messages.



npm i -g webpack-cli@2.0.14


webpack-cli init

put all the javascript files inside src/index



npm init --yes


"scripts": {
	"build": "webpack"
	"test" : "echo \"Error: no test specified\" && exit 1"
},


npm run build



<script src="dist/main.bundle.js"></script>


"scripts": {
	"build": "webpack -w"
	"test" : "echo \"Error: no test specified\" && exit 1"
},



import {Circle} from '.circle.js';  --> import {Circle} from '.circle';


=====================================================================================================================================================================================