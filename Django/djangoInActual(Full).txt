

The course is concentrated on teaching you to build production-grade backends.


Prerequisites:
--------------
For starters, you need to know Python. You need to know the basics of Python, as well as object-oriented programming concepts such as classes, inheritance, polymorphism, and so on. You should also know the basics of relational databases, so you should be familiar with concepts such as tables, columns, primary and foreign keys, relationships, and so on.


Here we're talking about using Python and Django to build and deploy the back-end for an e-commerce application (say like Amazon)





What is Django?
---------------
Django is a free and open source framework for building web applications with Python. 
It's not the only web framework for Python, but it's the most popular one. Because it helps us build a website in less time with fewer lines of code. That's why a lot of companies like YouTube, Instagram, Spotify, and Dropbox use Django in their tech stack.

Django is what we call a batteries included framework, which means It comes with a lot of features out of the box, so we don't have to code them from scratch.

The Feature includes: 
admin interface(admin interface for the database for managing our data), which is a huge time saver.
It also has an object relational mapper or ORM that abstracts the database so we can query or persist data without writing a lot of SQL code. 
It also comes with an authentication package for identifying users. It also has a package for caching data and much, much more. 

So, since Django offers all these amazing features, we can focus on our application and its requirements. We don't have to reinvent the wheel and code all these features from scratch. 

If ever you come up with Django is a piece of crap because it's old and bloated with so many features. Well, saying a framework is better than Django because it's faster is kind of like saying a Ferrari is better than a truck, because it's faster. What if you want to move something? You're not going to use your Ferrari for that, right? So a wise software engineer doesn't pick up a framework merely based on its performance. There are so many other things you need to take into account like the maturity of the framework, how stable it is from one version to another, its learning curve(difficulty), the size of the community and so on.


Django has been around for a long time and it has a huge community. So there are tons of Django packages built by the community that you can reuse in your applications. Also, If you get stuck, there's always someone out there to help you. 


Now, Regarding Django features. yes, Django comes with a lot of features, but you don't have to use or even learn all of them, because all these features are optional.





How the Web Works?
------------------
So, Django is a framework for building web applications with python.

Now, let's talk about some of the fundamental concepts you need to understand to build web applications. 
Let's say we're going to build an online store and publish it at 'dancooper.com'. Now this website is going to have two parts or two applications. A frontend and a backend. The frontend is the part that is loaded inside a web browser on a client machine. It's the part that the user sees and interacts with(also referred as UI). The backend is the part that runs on a web server and is responsible for data processing, validating business rules, and so on. 

Now let's imagine that Alice wants to visit our website. So she points her browser to 'dancooper.com'. This address is also called a URL, which is short for Uniform Resource Locator. It's basically a way to locate a resource on our internet. A resource can be a webpage, an image, a video, a PDF, and so on. So Alice types 'dancoop.com' in her browser and presses enter. At this moment, her browser sends a request to the web server that hosts our website and says, "hey, Alice wants to see the homepage". So,  the web server should take this request, process it, and return a response back to the client. This data exchange is defined by a protocol called HTTP, which is short for Hypertext Transfer Protocol. It defines how clients and servers can communicate. So this is the big picture. As Alice navigates our website, for each page, her browser sends an HTTP request to the server and receives an HTTP response. 


Front End (client) <----------> Back End (Server)


Client --- Request ----> Server

Client <-- Response ---- Server

The Response can be html, or can be only the data that is needed to build the webpage

Now, as part of building the backend for this website, we need to decide how we're going to respond to clients. One option is to generate the requested page on the server and return it to the client. We can use HTML for that. HTML is short for hypertext markup language. It's a simple language for representing web pages and their content. Every web page we have seen on our internet is built using HTML. So, one option is to generate the page on the server and return an HTML document to the client. The other option is to return only the data needed on the requested page and have the client generate the page. So instead of putting a complete page or a complete HTML document in an HTTP response, we only return the data like the list of products. 
Now, what is the difference? Well, if we push this responsibility to the client, we can free up the server so it can serve more clients. Our application will be more scalable. That's why over the past few years, this approach has become more trendy and is now considered the industry best practice. These days, we have tools like React, Angular, and Vue for generating web pages on the client. These are all client-side tools that are used by front-end developers. In contrast, we have server-side tools for building backends. Django falls in this category, so you should not compare Django with, let's say, React. You may compare Django with other server-side frameworks like ASP.NET Core, which is used by C# developers, Express, used by JavaScript developers, and so on. 

So,  if we push the responsibility of generating web pages to the client, the server essentially becomes a gateway to the data. On the server, we can provide endpoints that the client can talk to to get or save various pieces of data. For example, we can provide one endpoint to get the list of products and another endpoint to get the list of orders someone has placed. Now, all these endpoints together represent the interface that clients use to talk to the server. In technical terms, we say the server provides an API or an application programming interface to clients. This API is essentially like the buttons on a remote control. All these buttons together represent the interface or the API we use to interact with the TV.

So in this course, our focus will be on using Django to build an API for our online store. Client applications can use this API to get or save the data. How these clients are built is irrelevant here. We can use React, Angular, or even plain JavaScript. That falls under front-end development, which has nothing to do with Django. Once we build this API, if you know front-end development, you can always build a client app that talks to this API. 





Some of the concepts redefined below:
-------------------------------------
1. Gateway:
A server acting as an intermediary between a client (e.g., web browser or mobile app) and stored data. It processes requests, retrieves necessary information, and responds accordingly‚Äîfunctioning as a bridge between client and server.


2. Endpoint:
A designated URL or path on the server where clients interact with specific resources. Examples from an e-commerce platform:
- /products ‚Äì Retrieve a product list
- /orders ‚Äì Fetch order details
- /users ‚Äì Access user information


3. API (Application Programming Interface):
A collection of endpoints that enable interaction with a server, akin to a remote control with buttons (endpoints) for different functionalities.


Real-World Example ‚Äì Amazon:
- Gateway: The Amazon server facilitates data access when users browse products or place orders.
- Endpoints: Specific paths enable different actions:- /products ‚Äì Fetch product details
- /orders ‚Äì Retrieve order history
- /cart ‚Äì Update cart items

- API: The full set of endpoints that allow client-server interactions for shopping, ordering, and account management.


RESTful APIs:

REST (Representational State Transfer):
An architectural style for networked applications based on these principles:
- Stateless: Each request contains all necessary information; the server does not retain client context.
- Client-Server: Separate entities interact over a network.
- Uniform Interface: Standardized HTTP methods (GET, POST, PUT, DELETE).
- Resource-Based: Everything is treated as a resource with unique identifiers (URLs).


RESTful API:
An API adhering to REST principles, enabling clients to interact with server resources via standard HTTP methods.
Example ‚Äì Amazon API:

/products
	GET ‚Äì Retrieve available products
	POST ‚Äì Add a new product (admin use)

/orders
	GET ‚Äì View order history
	POST ‚Äì Place a new order

/users
	GET ‚Äì Retrieve user details
	PUT ‚Äì Update account information


Example Request and Response:

GET /products HTTP/1.1  
Host: api.amazon.com  

Response (JSON format):
[
  { "id": 1, "name": "Laptop", "price": 999.99 },
  { "id": 2, "name": "Smartphone", "price": 499.99 }
]



Process Flow:
Website Interaction Example ‚Äì Amazon:
1. User Inputs URL: The browser sends a request (e.g., amazon.com).
2. DNS Lookup: Resolves domain to an IP address.
3. Browser Sends HTTP Request: Requests the homepage.
4. Server Processes Request: Retrieves necessary content.
5. Server Sends Response: Returns HTML, CSS, and JavaScript.
6. Browser Renders Page: Displays content and loads additional resources as needed.



API Request Flow:
1. Client Sends API Request: Example:GET /api/products HTTP/1.1  
Host: api.amazon.com  

- API Server Processes Request: Identifies endpoint, retrieves data.
- Server Responds with JSON: Sends structured data.
- Client Processes Response: Uses data for UI updates.


API Infrastructure:
API Server: Hosts the API, handling requests and managing data.
API Endpoints: Specific URLs facilitating interactions.
Example ‚Äì Amazon API:
- API Server: Amazon's infrastructure manages client requests.
- Endpoints: Paths for various operations:- /api/products ‚Äì Retrieve product data
- /api/orders ‚Äì Fetch order details
- /api/users ‚Äì Access user account information


An API Server is a backend system that processes incoming API requests from clients (such as web applications, mobile apps, or other services). It is responsible for:
- Handling Requests: Accepting client requests, processing them, and sending responses.
- Managing Data: Retrieving, modifying, or storing data in databases.
- Enforcing Security: Authentication, authorization, and data validation to ensure secure access.
- Ensuring Scalability: Handling multiple concurrent requests efficiently.
- Implementing Business Logic: Executing operations based on the requested action (e.g., fetching user details, processing transactions).


Example ‚Äì Amazon API Server
Amazon‚Äôs API server manages e-commerce functionalities:
- API Request: A client application sends a request to api.amazon.com.
- API Server Processes: It verifies user authentication, retrieves requested products, and applies business rules.
- API Response: The server sends back the relevant data (e.g., a list of products in JSON format).







Setting Up the Development Environment:
---------------------------------------

install python 

check python version in the terminal/cmd prompt:  python --version


steps to create virtual environment: 

1. Navigate to your project directory: cd /path/to/your/project

Install virtualenv (if needed):
If you're using Python 3.3 or later, you already have the built-in venv module. But if you prefer virtualenv, install it with: pip install virtualenv

2. Create the virtual environment: python -m venv venv
	This creates a folder named venv containing the virtual environment.
	Replace venv with any name you prefer
3. Activate the virtual environment:
	On macOS/Linux: source venv/bin/activate
	On Windows (Command Prompt): venv\Scripts\activate
	On Windows (PowerShell): .\venv\Scripts\Activate.ps1
4. Install your dependencies: pip install -r requirements.txt
	Or install packages manually: pip install <package-name>
5. Deactivate the environment when done: deactivate

Also, install the python extension for visual studio code, because with this you get features such as intellisense, debugging, code navigation and so on. 



Difference between virtualenv and built-in venv:
------------------------------------------------
Both virtualenv and the built-in venv module are used to create isolated Python environments, but there are some key differences:

1. Availability:
	venv is built into Python (since version 3.3), so you don‚Äôt need to install anything extra.
	virtualenv is a separate package, meaning you have to install it manually with pip install virtualenv.

2. Feature Set:
	virtualenv supports more customization, including options to work with different Python versions.
	venv is simpler and lacks some of the extra features virtualenv offers, but is sufficient for most standard use cases.

3. Compatibility:
	virtualenv works with older Python versions (including Python 2), making it more versatile.
	venv is designed specifically for Python 3, so it won‚Äôt work with Python 2.

4. Speed:
	virtualenv is generally faster because it includes optimizations to speed up environment creation and activation.
	venv works well but might be a bit slower in comparison.

5. Package Management:
	virtualenv creates environments that come with pip automatically installed.
	venv might require you to install pip manually in some cases.

Which One Should You Use?
If you‚Äôre working with Python 3 and don‚Äôt need extra features, venv is simple and efficient. But if you need more flexibility, support for older versions, or extra options, virtualenv is a better choice.



pipenv and its comparison with venv:
------------------------------------
What is pipenv?

pipenv is a tool that combines package management (pip) and virtual environment management (venv) into one streamlined workflow. It simplifies dependency management by:
Automatically creating and managing a virtual environment.
Using a Pipfile (instead of requirements.txt) to track dependencies.
Handling dependency resolution better than pip.
Offering built-in security checks for installed packages.


Also, from the source - codewithmosh: 

pipenv is basically a dependency management tool for installing our application dependencies in virtual environments. This way, our application dependencies will not clash with other applications dependencies

Difference Between pipenv and venv
Feature	                     venv	                                        pipenv
Purpose	                     Creates isolated environments	                Manages dependencies and environments
Dependency File	             No built-in file (you use requirements.txt)	Uses Pipfile and Pipfile.lock
Package Installation	     Requires manual pip install commands	        Automatically installs dependencies when activating the environment
Dependency Management	     No automated dependency resolution	            Automatically resolves dependencies to avoid conflicts
Security	                 No built-in security checks	                Runs safety checks on dependencies


Which One Should You Prefer?
	Use venv if you just need a simple virtual environment without extra features.
	Use pipenv if you want better dependency management, automatic virtual environment handling, and a cleaner project structure.

If you work on larger projects or need strict dependency resolution, pipenv is great. But if you prefer simplicity and direct control, venv is a solid choice.


Setting up pipenv:
Unlike venv, pipenv combines virtual environment and package management.

Step 1: Install pipenv
First, install pipenv using:
pip install pipenv

Step 2: Create and Activate a Virtual Environment
Navigate to your project folder and run:
pipenv install
This will: ‚úÖ Create a virtual environment automatically ‚úÖ Generate a Pipfile for managing dependencies

Step 3: Install Dependencies
Instead of using pip, install packages like this:
pipenv install requests

Step 4: Activate the Virtual Environment
To enter the virtual environment, use:
pipenv shell

Step 5: Deactivate the Virtual Environment
Exit the environment using:
exit








Creating Your First Django Project: 
-----------------------------------

cd Desktop
mkdir storefront
cd storefront
pipenv install django 

This will create a Virtual environment and then install Django in that environment 

How Does the Virtual Environment Look?
Pipenv stores virtual environments outside the project directory to keep things clean. You won‚Äôt see a direct venv folder inside your project. Instead, it places the environment in a location managed by your system.

To find the virtual environment's path, run:
pipenv --venv

It will output something like:
/home/user/.local/share/virtualenvs/project-name-abc123/


Activates the Virtual Environment:
When you run 'pipenv shell', it opens a new shell session inside that environment, meaning all installed packages (like Django) are available.

Adjusts Environment Variables:
pipenv shell modifies your terminal‚Äôs settings so that Python and pip use the virtual environment‚Äôs isolated environment rather than the system Python.

Allows Access to Django & Other Packages:
Once inside the shell, you can check if Django is installed:
python -m django --version

You can also start a Django project:
django-admin startproject myproject


How Is This Different from Regular venv?
With venv, you manually activate the environment using:
source myenv/bin/activate

Whereas with pipenv, pipenv shell handles activation automatically and ensures dependencies are properly managed with Pipfile.



In addition to that pipenv will create two files in the storefront directory 'Pipfile' and 'Pipfile.lock'

Pipfile:
Acts as a replacement for the traditional requirements.txt file.
Stores all declared dependencies for your project.
Helps organize package dependencies into two categories:
	[packages] ‚Üí Regular dependencies (e.g., requests, numpy).
	[dev-packages] ‚Üí Development dependencies (e.g., testing tools like pytest).

Example Pipfile:

[packages]
requests = "*"
flask = "^2.0"

[dev-packages]
pytest = "^7.0"


Pipfile.lock:
Locks the exact versions of installed dependencies.
Ensures consistent environments across different setups.
Stores checksum hashes to verify package integrity.

Example snippet from Pipfile.lock:

json
{
    "default": {
        "requests": {
            "version": "2.27.1",
            "hashes": [
                "sha256:abc123..."
            ]
        }
    }
}

Whenever you install or update packages, pipenv updates the Pipfile.lock, keeping dependencies consistent across different machines.

Why Are They Useful?
‚úÖ Pipfile makes dependency management cleaner 
‚úÖ Pipfile.lock ensures reproducibility, avoiding conflicts 
‚úÖ It prevents unexpected version mismatches when sharing projects



Now, as we discussed, back to the terminal window inside the storefront directory, we need to activate this particular virtual environment where pipenv created. So we'll use the Python interpreter inside this virtual environment, not the one that is installed globally on your machine. To do that, we're going to run 'pipenv shell'
 


django-admin startproject my_proj   (or) 
django-admin startproject my_proj . (tells django to use current directory as project Directory)
cd my_proj

Note: 

The django-admin utility command is a powerful tool that comes with Django, helping developers manage Django projects efficiently. It provides various commands for tasks like creating new projects, running the development server, managing database migrations, and interacting with Django apps.

manage.py --> This is a wrapper around Django-admin

So, Going forward, inside our project, we'll using 'manage.py' instead of 'django-admin'. The reason for this that 'manage.py' takes the settings of this project into account.

For eg., one of command that django-admin has is 'runserver'

But if we do so, django-admin runserver --> we get an error saying 'Requested setting DEBUG but settings are not configured'. Because at this point, Django admin doesn't know about the settings of our project. Instead of Django admin, we're going to run 'Python manage.py', which you can see the same commands that Django admin provides. 

So, you can run the application by, 
python manage.py runserver 9000 (optionally, we can supply the port number, by default it will take port 8000) 

Here at this point you won't get error as when you do django-admin, because 'manage.py' knows about the settings of our project



What is a Wrapper?
A wrapper is essentially a layer that simplifies or enhances functionality. In programming, wrappers are often used to make commands more user-friendly or project-specific. manage.py wraps django-admin to ensure Django commands work within your specific project.


Difference Between manage.py and django-admin:
Feature	         manage.py	                                 django-admin
Scope	         Project-specific	                         Global (works outside a project)
Purpose	         Helps manage a Django 
                 project with correct settings	             General Django utility tool
Configuration	 Uses the project's settings.py file	     Doesn't automatically use a project's settings
Usage	         Run commands from inside a Django project	 Works globally for creating Django projects or general tasks


When to Use Each?
‚úÖ Use django-admin when working outside a project, like creating a new one:
django-admin startproject myproject


‚úÖ Use manage.py when working inside a Django project, since it ensures the correct settings are applied:
python manage.py runserver
python manage.py migrate





Using the Integrated Terminal in VSCode:
----------------------------------------
ctrl + ~
to select the interpreter: ctrl + Shift + p --> Python: Select Interpreter --> 

you can the select the interpreter you want. or if you have been using the pipenv, you can choose the python related to that pipenv

To do that:
pipenv --venv    --> generates the path
select 'Enter the interpreter path'   --> path + /bin/python


Also, in the storefront directory, you'll have extra directory '.vscode', there we have '{..}settings.json' file, where python interpreter path is defined
{
	"python.pythonPath" : "/users/moshfeghhamedani/............

}



quick note: 
Sometimes, when running the 'runserver' command, you might get a syntax error saying invalid syntax. This happens every now and then when VS Code fails to activate the virtual environment for this project. To solve this problem, all you have to do is open a new terminal window



Creating Your First App:
-----------------------
So, every Django project is essentially a collection of various apps, each providing certain functionality. Just like the apps on your mobile phone, each app provides a certain functionality, right? Django projects are also exactly the same.

In the settings.py of projects core folder:
Every Django project by default includes these default apps, together we can add our own custom apps.

INSTALLED_APPS = [
    "django.contrib.admin",   # Admin interface
    "django.contrib.auth",    # Authentication system
    "django.contrib.contenttypes",  # Content type framework
    "django.contrib.sessions", # Session management
    "django.contrib.messages", # Messaging framework
    "django.contrib.staticfiles", # Static file handling

    # Custom apps
    "blog",  # Example of a user-created app
    "store", # Another user-defined app
]

INSTALLED_APPS is an important setting in Django's settings.py file that defines the list of applications that Django should recognize and use in a project. It determines which Django apps are active and available for use.

It is a list of strings, where each string represents a Django app.
Includes both Django‚Äôs built-in apps and custom apps created for the project.
Controls which apps Django loads into the project for database models, middleware, signals, and other features.


Built-in Apps Explained:

Django comes with several built-in apps, each serving a specific purpose:

django.contrib.admin = Provides the Django Admin interface to manage models.
django.contrib.auth = Manages user authentication, groups, and permissions.
django.contrib.contenttypes = Enables generic relationships between models.
django.contrib.sessions = Handles session management for user data storage. (Admin app is dependent on the sessions app, don't try to delete it) 
django.contrib.messages = Enables messaging framework (for sending notifications in templates). (is used for displaying one time notifications to the user)
django.contrib.staticfiles = Manages static files like CSS, JavaScript, and images.

Why is INSTALLED_APPS Important?
‚úÖ Determines which apps are active in the project 
‚úÖ Ensures database models are registered 
‚úÖ Allows Django to load configurations for each app 
‚úÖ Helps define third-party apps (e.g., django-rest-framework, django-debug-toolbar)


To create a new app: 
-------------------
python manage.py startapp app_name

Note : Once you created a new app, you have to register the app in the 'INSTALLED_APPS' in the project settings folder

for example:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]










Structure of Django project and APP:
------------------------------------
When you create a Django project using django-admin startproject myproject, it generates a directory inside the project folder with the same name (myproject). This inner directory is the core of the application, containing essential configurations for Django.

Project Structure Overview

After running:
django-admin startproject myproject

Your directory will look like this:

myproject/       ‚Üê Project root
‚îÇ
‚îú‚îÄ‚îÄ manage.py    ‚Üê Command-line utility for project management
‚îú‚îÄ‚îÄ myproject/   ‚Üê Inner directory (Django project settings & configurations)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py   ‚Üê Marks this directory as a Python package
‚îÇ   ‚îú‚îÄ‚îÄ settings.py   ‚Üê Project settings & configurations
‚îÇ   ‚îú‚îÄ‚îÄ urls.py       ‚Üê URL routing for the project
‚îÇ   ‚îú‚îÄ‚îÄ asgi.py       ‚Üê ASGI configuration (for async applications)
‚îÇ   ‚îú‚îÄ‚îÄ wsgi.py       ‚Üê WSGI configuration (for deployment)


Detailed Explanation of Each File:

üîπ manage.py:
A command-line tool to interact with the project.
Used to run the development server, create apps, handle migrations, etc.
Example usage:
python manage.py runserver


üîπ __init__.py
An empty file marking the directory as a Python package.
Enables Django to treat myproject/ as a module.


üîπ settings.py
Most important file‚Äîcontains all Django configurations.
Defines:
	Installed apps (INSTALLED_APPS)
	Middleware (MIDDLEWARE)
	Database settings (DATABASES)
	Static files, templates, security options, and more.
Example:
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "myapp",  # Custom app
]


üîπ urls.py
Defines URL routing for the project.
Maps URLs to views using the urlpatterns list.
Example:
from django.urls import path
from myapp import views

urlpatterns = [
    path("home/", views.home, name="home"),
]


üîπ asgi.py
Configuration for Django‚Äôs ASGI server (for handling async requests).
Used in production setups requiring real-time capabilities (WebSockets, async APIs).


üîπ wsgi.py
Configuration for Django‚Äôs WSGI server (for traditional deployments).
Used when hosting Django on platforms like Apache or Gunicorn.


Summary
‚úÖ Outer myproject/ ‚Üí Contains manage.py (entry point for commands). 
‚úÖ Inner myproject/ ‚Üí Holds Django settings, URLs, WSGI/ASGI configs. 
‚úÖ settings.py ‚Üí The heart of the project, controlling configurations. 
‚úÖ urls.py ‚Üí Defines how URLs map to views. 
‚úÖ manage.py ‚Üí Used for running and managing the project.



App structure:
--------------
command: 
python manage.py startapp myapp

Django generates a directory (myapp/) containing several files that define the structure of your app. This folder helps organize everything related to your app, including models, views, templates, and more.

Django App Folder Structure:

myapp/            ‚Üê App directory
‚îÇ
‚îú‚îÄ‚îÄ __init__.py   ‚Üê Marks this folder as a Python package
‚îú‚îÄ‚îÄ admin.py      ‚Üê Configuration for the Django admin panel
‚îú‚îÄ‚îÄ apps.py       ‚Üê Configuration for the app within Django settings
‚îú‚îÄ‚îÄ models.py     ‚Üê Defines database models
‚îú‚îÄ‚îÄ views.py      ‚Üê Handles request processing & response logic
‚îú‚îÄ‚îÄ tests.py      ‚Üê Contains test cases for the app
‚îú‚îÄ‚îÄ urls.py       ‚Üê Manages routing within the app (must be created manually)
‚îú‚îÄ‚îÄ migrations/   ‚Üê Tracks database changes for models
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py  
‚îÇ   ‚îú‚îÄ‚îÄ 0001_initial.py  ‚Üê Auto-generated migration files



üîç Explanation of Each File
üîπ __init__.py
Marks myapp/ as a Python package.
Enables Django to treat it as a module.


üîπ admin.py
Used to register models so they appear in Django‚Äôs admin interface.
Example:

from django.contrib import admin
from .models import Post

admin.site.register(Post)


üîπ apps.py
Defines app configurations.
This is where we configure this app. Here the name is misleading. I don't know why Django developers decided to call this module 'apps', it would be better if it was called 'config'
Example:
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "myapp"
	
	
üîπ models.py
Defines database models using Django‚Äôs ORM.
Models module is where we define the model classes for this app. We use model classes to pull out data from the database and present to the user.
Example:
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
	
	
üîπ views.py
Handles business logic and returns responses.
Again, the name is misleading. This is not the view that you think, if you havecome from a front-end development background. So, What they mean here is essentially a request handler. It's not a view which has a template or HTML in other frameworks. 
Example:
from django.http import HttpResponse

def home(request):
    return HttpResponse("Welcome to MyApp!")


üîπ urls.py (Must be manually created)
Manages routing for the app.

Example:
from django.urls import path
from . import views

urlpatterns = [
    path("", views.home, name="home"),
]


üîπ tests.py
Contains unit tests for the app.

Example:
from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_math(self):
        self.assertEqual(2 + 2, 4)


üîπ migrations/
Tracks database schema changes.

Auto-generated files when running:
python manage.py makemigrations
python manage.py migrate


üìå Summary
‚úÖ models.py ‚Üí Defines the database 
‚úÖ views.py ‚Üí Handles requests 
‚úÖ urls.py ‚Üí Manages routing 
‚úÖ admin.py ‚Üí Registers models for Django admin 
‚úÖ apps.py ‚Üí Configures the app 
‚úÖ migrations/ ‚Üí Manages database changes 
‚úÖ tests.py ‚Üí Helps in testing


Every time you create an app, you need to register it in the INSTALLED_APPS of project's 'setting.py' module

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'playground'
]


views.py and urls.py:
--------------------
HTTP is a request response protocol. So, every data exchange involves a request and a response. Every app has 'views.py' and this is where we define our views or view functions. A view function is a function that takes a request and returns a response. So more accurately, it's a request handler. In some frameworks, it's called an action. In Django, it's called a view. But I don't agree with this name because from an architectural point of view, a view is often associated with something that the user sees. But that part in Django is called a template. 

Now in this function, we can do anything we want. In a real-world scenario we can pull data from a database, we can transform data, we can send emails and so on. For now, let's just return a simple response.

apps --> view.py:

from django.http import HttpResponse

def say_hello(request):
	return HttpResponse('Hello World')


Now we need to map this view to url, so when we get a request at that url, this function will be called.


let's say whenever we send a request to 'playground/hello', our view function should be called and return 'Hello World' to the user.

apps --> urls.py:	
	
from django.urls import path
from . import views

#URLConf
urlpatterns = [
    path('hello/', views.say_hello)
 ]	
	

Note: we have 'urlpatterns' variable(all in lower case), which is an array of url pattern objects, we use path() function to create a url patter object

The parameters of path function --> (route: str, view: (*args: Any, **kwargs: Any) -> HttpResponse, kwargs: Dict[str, Any] = ...) -> URLPattern

Now, what we have here is URLConf module, which basically means URL Configuration. So, every app can have its own URL Configuration. But now we need to import this URL Configuration into the main URL Configuration for this project

	
projects --> urls.py:

use the include function from django.urls

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
   path('admin/', admin.site.urls),
   path('playground/', include('playground.urls'))
  ]

So, if the user sends the request to 'playground/hello', Django knows that all requests that start with playground should be handled by the playground app. So it's going to chop off the first part of this URL 'playground/' and Pass the rest 'hello' to the URL configuration module in the playground app. 










Using Templates:
----------------
So, I told you that views in Django are not really views. They're more like request handlers or actions. What we often call a view in other frameworks is called a template in Django.

Add templates folder in any app and then html file inside (say templates/hello.html)

Then in views.py:

from django.shortcuts import render

def say_hello(request):
	return render(request, 'hello.html') 
	

Note: render returns a HttpResponse object

we can also dynamically render the content, we just need to add another parameter which provides the context 
return render(request, 'hello.html', {'name': 'Mosh'})  --> now you have name parameter in the html content. For more details learn jinja template engine or django template engine








Django Debug toolbar:
---------------------


1. launch.json
2. select Django

understand Run and Debug in Visual Studio code 

to run the application without debugging --> ctrl + F5





Using Django Debug Toolbar:
---------------------------

There is another way to debug django applications using a powerful tool called Django Debug Toolbar.

The official documentation: 
https://django-debug-toolbar.readthedocs.io/en/latest/

Follow the instruction in the Installation page:


Note: 
The Django Debug Toolbar should appears only when we return proper HTML document.

i.e. in proper format --> starts from <html></html>










Building a Data Model: 
---------------------

Introduction to Data Modeling: 
------------------------------
Understanding Data Entities in a Django-Based E-Commerce Application:
The foundation of any Django project begins with identifying the pieces of data we need to store. In an e-commerce application, we must first define essential entities and their relationships.

Primary Entities:
1. Product ‚Äì Represents an item available for purchase, with attributes like:
	title (name of the product)
	description (details about the product)
	price (cost of the product)
	inventory (stock availability)

2. Collection (or Category) ‚Äì Groups products into different categories like shoes, beauty products, or fruits, with attributes like:
	title (name of the collection/category)



Defining Relationships:

One-to-Many Relationship:
Each product belongs to one and only one collection
A collection can have multiple products

Optional Relationship (Featured Product):
A collection can have zero or one featured product
This helps highlight a product in that collection

Additionally, every entity inherently has an id attribute, which Django automatically generates.



Below is a simple entity-relationship diagram illustrating these relationships:

[Collection] 1 ---- * [Product]
      |
      | (0 or 1)  
      v  
 [Featured Product]



Your Turn!
Take a moment to identify five more essential entities in an e-commerce application, considering attributes and relationships. Keep it simple‚Äîno need to create an overly detailed diagram!






Building an E-commerce Data Model:
----------------------------------

Data Modeling for an E-Commerce Application in Django:
When designing an e-commerce application, we must define key entities, attributes, and relationships between them. The structure should always align with the requirements of the application rather than arbitrary decisions. Below are the primary entities and relationships required for an efficient e-commerce system.

Entities and Their Attributes:
1. Product
	title (name of the product)
	description (details about the product)
	price (cost of the product)
	inventory (available stock)

2. Collection (or Category) (Optional: Depending on whether products belong to multiple collections)
	title (name of the category)
	Relationships:
		A product belongs to one collection and a collection can contain multiple products (One-to-Many).
		Alternatively, a product can belong to multiple collections and a collection contains multiple products (Many-to-Many).

3. Shopping Cart:
	created_at (timestamp of cart creation for cleanup purposes)
	Relationships:
		A cart can contain multiple products, and a product might be in multiple carts (Many-to-Many).

4. Cart Item (Association Class for Cart-Product Relationship):
	quantity (number of instances of the product in the cart)
	Relationships:
		A cart item belongs to one cart, while a cart can contain multiple items (One-to-Many).
		A cart item represents one product, while a product might appear in multiple cart items (One-to-Many).

5. Customer (Optional, since carts can be anonymous):
	name
	email
	Relationships:
		A customer can place multiple orders, but each order belongs to one customer (One-to-Many).

6. Order:
	placed_at (timestamp of order placement)
	Relationships:
		A customer can place multiple orders (One-to-Many).
		An order contains multiple products, and a product can appear in multiple orders (Many-to-Many).

7. Order Item (Association Class for Order-Product Relationship)
	quantity (number of instances of the product in the order)
	Relationships:
		An order item belongs to one order, while an order contains multiple order items (One-to-Many).
		Each order item represents one product, while a product might appear in multiple order items (One-to-Many).

8. Tag (Additional classification for products)
	title (tag name)
	Relationships:
		A product can have multiple tags, and a tag might be referenced by multiple products (Many-to-Many).



Entity-Relationship Diagram:

[Product] * ---- * [Cart]  
             |  
             | (Tracks product quantity) cartitem 
             V	  
[Product] 1 ---- * [CartItem]      [CartItem] * ---- 1 [Cart]



[Customer] 1 ---- * [Order]  



[Product] *  ----  *[Order]  
              |  
              | (Tracks Order quantity) cartitem 
              V	  
[Product] 1 ---- * [OrderItem]      [OrderItem] * ---- 1 [Order]



[Product] * ---- * [Tag]  


This refined explanation provides a clear structure for understanding Django data models in an e-commerce application.


What is an Association Class?
An association class is a special type of class that represents a relationship between two entities and contains attributes specific to that relationship.


Does an Association Class Only Come in Many-to-Many Relationships?
No, but it‚Äôs most commonly seen in many-to-many relationships because many-to-many relationships often require additional information beyond just linking two entities.
However, an association class can exist in other types of relationships too if the relationship itself has attributes that need to be stored.


Why Do Many-to-Many Relationships Need an Association Class?
A simple many-to-many relationship between two entities (e.g., Products and Tags) can usually be represented with a linking table.

But what if the relationship itself has attributes? That‚Äôs when we need an association class.

Example: Shopping Cart Scenario

Consider the relationship between Carts and Products:
	A Cart can contain multiple Products.
	A Product might be in multiple Carts.
	This is a many-to-many relationship.

Now, we need an attribute specific to this relationship ‚Äî 'Quantity' (how many units of a product are inside a cart).

How Do We Solve This?
1. Instead of linking Cart directly to Product, we introduce a CartItem entity.
2. CartItem represents the relationship and contains the extra attribute quantity.
3. Now, instead of a single many-to-many link, we have two one-to-many relationships:
	A Cart can have multiple CartItems, but each CartItem belongs to one Cart.
	A Product can be referenced by multiple CartItems, but each CartItem points to a single Product.


Alternative Cases Where Association Classes Exist in Non-Many-to-Many Relationships:
While association classes are most common in many-to-many relationships, they can also appear in one-to-many or one-to-one relationships when the connection itself has attributes.

Example: Employment Records

Imagine a Company and its Employees:
	A Company employs multiple Employees (One-to-Many).
	Each Employee works for one Company.
	However, we may want to store an attribute about the relationship, such as hire_date.

Instead of just linking Company and Employee directly, we might introduce an EmploymentRecord association class, which holds:
	The company_id
	The employee_id
	The hire_date

This is an example of an association class appearing in a one-to-many relationship.

Key Takeaways:
‚úÖ Association classes are required when a relationship needs extra attributes. 
‚úÖ Most commonly used in many-to-many relationships, but can also exist in one-to-many or one-to-one cases. 
‚úÖ Turns a many-to-many relationship into two one-to-many relationships for better data organization. 
‚úÖ Provides flexibility when extra details must be stored in a connection.


Real world Examples of Association classes: 
-------------------------------------------
Association classes are widely used in various real-world scenarios where relationships between entities require additional attributes. Here are a few examples:

1. University Course Enrollment
Entities:
	Student (name, ID, email)
	Course (title, description, credits)
	Enrollment (Association Class)
		grade (the student's grade in the course)
		enrollment_date (when the student registered)

üëâ A student can enroll in multiple courses, and a course can have multiple students. However, the enrollment itself needs attributes like grade and enrollment date, making Enrollment an association class.


2. Employee Job Assignment
Entities:
	Employee (name, ID, department)
	Project (name, budget, deadline)
	Assignment (Association Class)
		role (position in the project, e.g., Developer, Manager)
		hours_worked (amount of time contributed)

üëâ An employee can work on multiple projects, and a project can have multiple employees, but the role and hours worked are specific to the relationship, so we introduce Assignment as an association class.


3. Online Shopping Order System
Entities:
	Customer (name, email)
	Product (title, price)
	OrderItem (Association Class)
		quantity (number of units purchased)
		discount_applied (any discount used for this item)

üëâ A customer can place multiple orders, and an order can contain multiple products. However, the quantity and discount are tied to individual order-product pairs, making OrderItem an association class.


4. Movie Ticket Booking
Entities:
	Viewer (name, email)
	Movie (title, genre, runtime)
	Ticket (Association Class)
		seat_number (specific seat booked)
		price_paid (cost of ticket)

üëâ A viewer can book multiple movies, and a movie can have multiple viewers. Since each ticket must track seat number and price paid, Ticket acts as an association class.


Key Takeaway:
‚úÖ Association classes appear when relationships between entities have attributes that must be stored. 
‚úÖ They commonly occur in many-to-many relationships, but can also exist in other types when needed.









Organizing Models in Apps:
--------------------------
Structuring a Django Project with Multiple Apps:
In Django, a project consists of one or more apps, each providing a specific functionality‚Äîsimilar to the apps on a phone. Each app has its own data model and serves a distinct purpose in the project.

Approaches to Organizing Django Apps:

1. Monolithic Design (Single App):
One approach is to create a single app called store and include all entities‚Äîsuch as Product, Collection, Customer, Shopping Cart, and Orders‚Äîwithin it.
‚úÖ Advantages:
	Can be bundled and distributed via pip for reuse.
	Eliminates redundant development across multiple projects.

‚ùå Disadvantages:
	Becomes bloated with too many models and views.
	Hard to maintain and reuse effectively.
	Leads to a monolith‚Äîdifficult to scale and update.


2. Fine-Grained App Separation (Too Many Small Apps):
An alternative is breaking down the project into several small apps:
	Products App (Manages products, collections, and tags)
	Customers App (Manages customer data)
	Shopping Cart App (Handles cart operations)
	Orders App (Manages order processing)

‚ùå Disadvantages:
	Creates tight coupling between apps.
	Apps depend on each other in a specific order (Products ‚Üí Shopping Cart ‚Üí Orders).
	Any update in Products App might break Shopping Cart and Orders Apps, requiring simultaneous updates.


3. Optimal Middle Ground (Balanced Separation)
Instead of separating highly interdependent apps, bundle related functionalities while keeping optional ones separate.
	Store App (Includes products, collections, cart, and orders)
	Tags App (Handles tagging functionality separately)

This approach ensures that:
‚úÖ Store functionality is self-contained (Products, Cart, and Orders work together).
‚úÖ Tags are independent (Tagging might apply to products, blog posts, videos, etc.).
‚úÖ Apps can be reused independently without breaking dependencies.


Guiding Principles for Django App Design:
1. Avoid a Monolithic Structure ‚Äì Too many features in one app make it hard to maintain.
2. Minimize Tight Coupling ‚Äì Apps should not depend too much on each other.
3. Ensure High Cohesion ‚Äì Each app should focus on one piece of functionality while including everything needed for that functionality.


Creating the Apps in Django:
To set up the Store and Tags apps, run:

python manage.py startapp store  
python manage.py startapp tags  


Then, register these apps in Django‚Äôs settings:

INSTALLED_APPS = [
    'store',
    'tags',
    ...
]
With this structure, each app is modular, reusable, and maintainable, making future development smoother.



Some real-time examples where middle ground is involved: 
--------------------------------------------------------
In the context of Django apps, finding the middle ground means designing a structure that balances maintainability, modularity, and low coupling. Here are real-world Django app examples where this principle is applied:

1. E-Commerce App Structure:
Imagine you're building an e-commerce platform.
	Monolithic Approach: All functionalities‚Äîproducts, shopping cart, orders, and payments‚Äîare in a single store app, making it hard to maintain.
	Overly Fragmented Approach: Each feature (products, cart, orders, payments) is a separate app, leading to complex interdependencies.

‚úÖ Middle Ground:
A store app (manages products, collections, cart, orders).
A separate tags app (manages tagging functionality for products).
A payments app (handles transactions, keeping financial logic separate).

üëâ This ensures reuse, modularity, and maintainability while keeping key functionalities together.



2. Content Management System (CMS) with Blog and Comments:
A CMS typically has features like articles, comments, categories, and tags.
	Monolithic Approach: One giant app manages everything, making customization difficult.
	Overly Fragmented Approach: Each feature (articles, comments, categories, tags) is a separate app, increasing dependencies.

‚úÖ Middle Ground:
A blog app (manages articles, categories).
A comments app (handles commenting, so it can be reused for different types of content).
A tags app (optional tagging system that can work for articles, images, and other content).

üëâ This makes the system modular yet cohesive.



3. Social Media Platform (Users, Posts, Messaging):
A social media platform contains user profiles, posts, likes, messaging, and notifications.
Monolithic Approach: Everything is lumped into a single app, reducing scalability.
Overly Fragmented Approach: Individual apps for users, posts, likes, messaging, notifications create complex dependencies.

‚úÖ Middle Ground:
A users app (manages authentication, profiles).
A posts app (handles user-generated content).
A messaging app (for direct user communication).
A notifications app (alerts for likes, comments, messages).

üëâ This allows independent development of messaging while keeping posts and notifications closely related.



Guidelines for Finding the Middle Ground in Django Apps
üìå Keep related functionalities bundled together to avoid excessive dependencies. üìå Separate features only when they are reusable across different projects (e.g., tags, payments, notifications). üìå Ensure apps are self-contained, meaning they work independently without forcing unnecessary installations.








Creating Models:
----------------
django field types: https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field types, Field Options
you can check for what field type and field option we need to mention for a particular field 

models.py:

from django.db import models

class Product(models.Model):
	title = models.charField(max_length=255) #varchar(255)
	description = models.TextField() 
	price = models.DecimalField(max_digits=6, decimal_places=2) # floatfield has round issues, so for monetary values always use decimal field  #9999.99
	inventory = models.IntegerField()
	last_update = models.DateTimeField(auto_now=True)
	
Now when we finished writing models for each entities, we need to migrate, then you will see that we can generate our database tables based on the definition of this model. So then we're going to have a table called 'product' and in that table we're going to have a column called 'title' and the type of that column is going to be varchar of 255. 


class Customer(models.Model):
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)


Now you might be curious why don't we have an ID field in any of these classes. Because as I said earlier, Django creates it for us automatically. So every entity or every model class is going to have an ID field which is going to be a primary key. But what if we don't want to have an ID field? What if in this product class, we need a field called SKU and this is going to be our primary key. 

So, if we want some random field to be a primary key instead of one generated by django itself,
sku = models.CharField(max_length=10, primary_key=True)

With this Django is not going to create an ID field and make it the primary key. 'sku' is going to be our primary key. 







Choice Fields:  
--------------
Sometimes we need to limit the list of values that can be stored in a field. For that you can use the 'choices' parameter 


https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field Options --> Choices


MEMBERSHIP_CHOICES = [
		('B', 'Bronze'), 
		('S', 'Silver'), 
		('G', 'Gold'),
	]
Here in the tuple, the first value is the actual value that we're storing in the database. And the second value is a human readable name
This human readable name will be used in the admin interface.

class Customer(models.Model):
	MEMBERSHIP_BRONZE = 'B'
	MEMBERSHIP_SILVER = 'S'
	MEMBERSHIP_GOLD = 'G'
	
	MEMBERSHIP_CHOICES = [
		(MEMBERSHIP_BRONZE, 'Bronze'), 
		(MEMBERSHIP_SILVER, 'Silver'), 
		(MEMBERSHIP_GOLD, 'Gold'),
	]
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)
	membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
	

Tomorrow if we have decided to change the value 'B' to something else. Then there are two places, we have to modify(in default, in MEMBERSHIP_CHOICES). So the best practice is to define these values separately, like MEMBERSHIP_BRONZE, MEMBERSHIP_GOLD, MEMBERSHIP_SILVER
 

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)










Defining one-to-one Relationships:
---------------------------------
Assume that every customer should have one address, and each address should belong to one customer. So, here we have one-to-one relationship between customers and addresses.

As you probably know, a database relationship has two ends, a parent and a child. The parent should exist before we can store the child. Here in this case, customer is obviously the parent. So, we need to define cutomer model first and then address model and then we can create relationship between these two in the child model. 


class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.OnetoOneField(Customer, on_delete=models.CASCADE, primary_key=True)




The argument 'on_delete' specifies the delete behavior. What should happen when we delete a customer or a parent field. So, if we put 'on_delete' to 'models.CASCADE', when we delete a customer the associated address will also be deleted. 
This is called the cascade behavior. Alternatively if this field accepts null values we can use set null(models.SET_NULL). So, when we delete a customer or the parent record, the child record(or the address in this case) is not going to get deleted. It's going to stay in the database and the customer field or the customer column is going to get set to null. Alternatively, we can use 'models.SET_DEFAULT;. So this field will be set to its default value. And one other option we have is models.PROTECT. And with this, we can prevent the deletion. So, if there is a child associated with this parent, we cannot delete that parent, we have to delete the child first.

Now, which value we use really depends on the requirements. There is no one size fits all. In this case, I believe we should use cascade. Because if we delete a customer, the associated address should also be deleted.

Now there is one more argument we need to set is 'primary_key=True'. If we don't set this, Django will create another field here called ID. So, every address is going to have an ID. And that means we're going to end up with a one-to-many relationship between customers and addresses, because we can have many addresses with the same customer. But if we make the customer field as a primary key, we can only have one address for each customer, because primary keys don't allow duplicate values, right? 
So this is how we can implement a one-to-one relationship between two models. Now, you might be wondering if we should define the reverse relationship in the customer class. In other words, do we have to go to the customer class and add a new field called 'address' for the reverse relationship. No, we don't have to do that because Django will automatically creates this for us. 










Defining a one-to-many Relationship:
-----------------------------------

Now let's assume that a customer can have multiple addresses. So we want to change this one-to-one relationship to one-to-many relationship. How can we do this? Really easy. First we need to change the type of the field to foreign key. So we're telling Django that customer is a foreign key in the address table. Okay? Next we need to remove field option 'primary_key=true'. Because we want to have multiple addresses for the same customer. So, we want to allow duplicate values in the customer column. This is how we can define a one-to-many relationship between two models. 

class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)


Other examples as follows:
Collection - Product
Customer - Order
Order - Item
Cart - Item


class Collection(models.Model):
    title = models.CharField(max_length=255)
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
	
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()


	
	
	





Defining Many-to-Many Relationships:
-----------------------------------

Let's talk about many-to-many relationships. So, I'm going to introduce a new class called Promotion and define a many-to-many relationship between promotions and products. So, a product can have different promotions and a promotion can be applied to different products.

class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()


Now we can define the relationship in either of these classes. And As I said earlier, Django will automatically create the reverse relationship. 
Now in this particular case, it makes more sense to define the relationship in the product class, because we might have a product that we need to show to the user and at the same time, we want to show all the promotions applied to that product.
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

Now with this implementation, Django is going to create the reverse relationship in the Promotion class. which means, in the Promotion class, we're going to have a field called 'Product_set' that returns all the products that a particular promotion is applied to, if you don't like the name You can always change it. 
So, in our product class, we can supply a keyword argument related_name='products'. Django will use this name as the name of the field in the promotion class. So instead of 'product_set' we're gonna have a 'products'. 

Just remember, if you change the default convention in Django, it's best to change it consistently everywhere, otherwise in some classes you're going to have a field 'products', and in some other classes you're going to have a field 'product_set', and this makes your code really ugly.










Resolving Circular Relationships:
--------------------------------

Handling Circular Dependencies and Reverse Relationship Errors in Django:
When designing models in Django, you may encounter situations where two models have multiple relationships with each other. While implementing these, it's crucial to avoid circular dependencies and handle reverse relationship conflicts properly.



Understanding Circular Dependencies:
A circular dependency occurs when two classes depend on each other at the same time, causing errors in model definition.

Example: Collection and Product Models
1. The Product model contains a field called collection, which is a ForeignKey to the Collection model.

2. Now, we need another relationship: A Collection can have a featured_product, which is a ForeignKey to the Product model.

üëâ This introduces a circular dependency:
The Product model depends on Collection.
The Collection model now depends on Product at the same time.



How to Resolve Circular Dependencies:

Django allows referencing models using string literals, so instead of:
featured_product = models.ForeignKey(Product, on_delete=models.SET_NULL, null=True)

We use:
featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True)


‚úÖ Why does this work?
Django will resolve the model reference later, avoiding an immediate dependency issue.


‚ùå Potential downside:
If the Product model is renamed, this string won‚Äôt update automatically, which can lead to errors.

üîπ Use this technique only when necessary.




Handling Reverse Relationship Name Conflicts:
Django automatically creates reverse relationships to allow querying from both sides of a foreign key.

Issue in Collection-Product Relationship:
	The Product model already has a collection field.
	The Collection model now adds featured_product, which also creates an implicit reverse relationship in Product.
	Since Django auto-generates reverse relationships, it causes a naming conflict.

Solution Options
‚úÖ Option 1: Set related_name in featured_product to avoid conflicts:

featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True, related_name="featured_in_collections")

Now, instead of Django auto-generating collection again, we control the naming.



‚úÖ Option 2: Use "+" to disable the reverse relationship:

featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True, related_name="+")

This prevents Django from creating the reverse link, ensuring no conflicts.




Final Takeaways:
Circular dependencies occur when models depend on each other simultaneously.
Using string literals for model references ("Product") solves circular dependency issues but requires caution when renaming models.
Reverse relationship conflicts arise when Django tries to auto-generate conflicting names.
Setting related_name or using "+" prevents these conflicts.

With these solutions, your Django models remain clean and maintainable. üöÄ


class Collection(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey(
        'Product', on_delete=models.SET_NULL, null=True, related_name='+')


class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)











Generic Relationships:
----------------------

Understanding Generic Relationships in Django:
Generic relationships allow models to associate with multiple types of objects without creating dependencies on specific models. This approach makes apps more reusable across different projects.

Why Use Generic Relationships?
Consider a 'tags' app where we want to tag different types of items‚Äîproducts, videos, articles, etc.

‚úÖ Challenge:
If we directly reference a specific model (Product), the tags app becomes tightly coupled with the store app.
This limits reuse, as the app won't work for other types of items (e.g., articles, videos).

‚úÖ Solution:
Instead of linking a concrete model (Product), we use Django‚Äôs ContentType framework to allow tagging any object dynamically.
This makes the tags app independent and reusable across multiple projects.


INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',  #this one 
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]




from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey

# Tag Model
# Represents the actual tag label.
class Tag(models.Model):
    label = models.CharField(max_length=255)

# TaggedItem Model
# Tracks what item is associated with a tag.
class TaggedItem(models.Model):
	# Using this class, we can find out what tag is applied to what object
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
	
	# Generic Relationship Fields
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)  # Identifies the model type (Product, Article, etc.)
	object_id = models.PositiveIntegerField()  # Stores the specific object's ID
    content_object = GenericForeignKey()
    confirmmmmm between these two
    content_object = GenericForeignKey('content_type', 'object_id')  # Retrieves the actual object



How Generic Relationships Work
‚úÖ Instead of a direct ForeignKey, we use:
1. content_type ‚Üí Links to the type of object (Product, Article, Video).
2. object_id ‚Üí Stores the object's primary key.
3. content_object ‚Üí Acts as a dynamic reference to fetch the actual object.

üîπ When querying a tagged item, we can retrieve the actual product/video/article dynamically instead of being restricted to a fixed model.



Limitations of Generic Relationships:
‚ùå Only works well if primary keys are integers.
	If a model uses UUIDs or other non-integer keys, this approach may not work.

‚ùå Less efficient in queries compared to direct ForeignKeys.
	Generic relationships rely on joining multiple tables, which can slow down performance in large datasets.

‚úÖ Best used when flexibility outweighs performance concerns.



exercise:

I want you to create an app called likes for tracking the objects that a user likes. So in this app, we're going to have a model called LikedItem. And using an instance of this model, we can tell what user likes what object. So here we need a field called user, which is going to be a foreign key to the user class defined in the model django.contrib.auth.models. So auth is another app that is automatically installed in every Django project. And using this app, we can authenticate and authorize users. 


App: Likes

LikedItem
 -what user likes what object
 -user: ForeignKey to User(django.contrib.auth.models)


likes/model.py:

from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # User who liked the item
	
	# Generic Relationship Fields
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE) # Object type
    object_id = models.PositiveIntegerField()  # Object ID
    content_object = GenericForeignKey()
	confirmm between these two
	content_object = GenericForeignKey('content_type', 'object_id')  # Actual object reference


So, We have created a new app called likes. And in this app, we have a new model called LikedItem. Now here we have four fields. We have user, which is a foreign key to the User class defined in django.contrib.auth.models. Now here for on_delete, I've used cascade. so, if a user is deleted, we want all the objects that the user has liked to be deleted as well. Then we have three fields exactly like before, no changes. We have content_type for identifying the type of an object that the user likes, we have object_id for referencing that particular object, and content_object for reading an actual object. 


üí° How this works:
A user can like any type of content (Product, Video, Post) without the app knowing specific models in advance.
Completely decoupled, making the app reusable across multiple projects.









                                                                                                                   

Setting up the database:
------------------------

In this section, we'll use Django migrations to generate our database schema based off of the models we've built in the previous section. So we'll talk about making migrations, running them, reversing them in case we make mistakes. We'll also talk about populating our database. So by the end of the section, we'll have a production grade database that we can query in the next section.


Supported Database Engines:
---------------------------

Django supports multiple database management systems (DBMS), allowing flexibility in choosing a backend based on project needs.

Default Database: SQLite
	Preconfigured in Django by default.
	A lightweight database suitable for development and low-traffic websites.
	‚ùå Not recommended for serious production applications due to limited scalability.


Production-Ready Databases:
For larger applications, Django officially supports:
	PostgreSQL
	MySQL
	MariaDB
	Oracle
Additionally, third-party libraries exist for Microsoft SQL Server and other databases.


Commonly Used Databases in the Django Community:
PostgreSQL ‚Äì Popular for complex queries, scalability, and advanced features.
MySQL ‚Äì Widely used for web applications, offering high performance and ease of setup.


Choosing a Database for a Django Project:
If starting with basic development, stick with SQLite.
If building a serious project, switch to PostgreSQL or MySQL.
If using PostgreSQL, research its integration with Django independently.


Next Step: Creating Migrations
Once a database is selected, the next step in Django development is creating migrations, which helps manage database schema changes efficiently.










Creating Migrations:
-------------------

Migrations in Django help create and update database tables based on the models defined in your project. Instead of manually writing SQL commands, Django automates database management using migration files.

Why Use Migrations?
Automatically creates, updates, and manages tables.
Ensures database schema remains in sync with model changes.
Reduces manual work, preventing errors in database structure.

Generating Migrations:
To create migrations after defining or modifying models, run:

python manage.py makemigrations	

Django scans installed apps and generates migration files.
Each migration file has a sequence number and a descriptive name.

üìå Example: If we rename 'price' to 'unit_price' in the Product model, Django asks for confirmation and creates a rename field migration instead of recreating the table.




Renaming Migrations Carefully:
If renaming a migration file manually, update all references in other migration files.

üìå Example:
dependencies = [
    ('store', '0001_initial'),
]

If "0001_initial" is renamed to "first_migration", update it here as well.



Handling Missing Changes in Migrations:
If makemigrations doesn‚Äôt detect model changes, check the INSTALLED_APPS list in settings.py. Missing an app here means Django won‚Äôt track changes.



Adding New Fields and Default Values:
When adding a new field like slug, Django may ask:
‚ùå Error: "You're trying to add a non-nullable field 'slug' to 'Product' without a default."

‚úÖ Solutions:
1. Set a default value in the model
slug = models.SlugField(default='-')

2. Make it nullable
slug = models.SlugField(null=True)

üìù Choosing the first option keeps the database clean, while the second allows flexibility.



Final Takeaways
‚úî Migrations automate database updates in Django. ‚úî makemigrations detects model changes and creates migration files. ‚úî Rename migration files carefully to avoid broken dependencies. ‚úî Adding non-nullable fields requires a default value or null=True.

Note: slug --> slug is when you go to the stack overflow and if you search for a question in the address bar you can see the id of the question and the actual question itself(https://stackoverflow.com/questions/4492979/error-git-is-not-recognized-as-an-internal-or-external-command), what you see there is called a slug.  Slug can only contain letters, numbers, underscores and hyphens. So, any other characters other than these is going to be replaced by any special character like hypens or even removed. Now the whole point of adding a slug here is to make it easier for search engines to find our content. So this is a search engine optimization technique. 
 
 
 
 
 
 
 
 


Running Migrations: 
-------------------

Migrations in Django convert model definitions into actual database structures. Once migrations are created, they must be executed to apply these changes to the database.

1. Running Migrations:
To apply migrations and create/update database tables, run:

python manage.py migrate

‚úÖ This command:
Checks installed apps for pending migrations.
Executes each migration sequentially like commits in a version control system.
Creates the database schema for models.
üìå Example: After running migrate, tables are created for installed apps like auth, admin, and your custom apps (store, tags, etc.).



2. Locating the Database
After migration, a database file is generated.

‚úÖ Default for Django:
SQLite (db.sqlite3) ‚Üí Used for development & small projects.
PostgreSQL/MySQL ‚Üí Recommended for larger applications.

üîπ Viewing the database in VS Code:
Install the SQLite extension or use DB Browser for SQLite (sqlitebrowser.org).
Open the Command Palette (Shift + Ctrl + P on Windows / Shift + Cmd + P on Mac).
Search for "SQLite: Open Database" and select db.sqlite3.
Expand the SQLite Explorer to view tables.




3. Understanding the Migrations Table:
Django tracks migration history in a special django_migrations table.

‚úÖ Viewing Applied Migrations:

1. Open the sqlite Explorer panel in VS Code.
2. Locate the django_migrations table.
3. Right-click ‚Üí Select "Show Table" to see:
	Migration names (e.g., 0001_initial)
	Date & time applied
	Total executed migrations

üí° If no new migrations exist, running migrate again does nothing‚Äîsince all migrations have been applied.




4. Viewing SQL Statements Using sqlmigrate
To preview the SQL commands Django will execute:

python manage.py sqlmigrate app_name migration_number

üìå Example:
python manage.py sqlmigrate store 0003

‚úÖ Output: Displays raw SQL code for the specified migration, which differs based on database backend (SQLite, MySQL, etc.).



Exercise:
Add a zip field to the Address model.
Run makemigrations.
Execute migrate.
Inspect the django_migrations table to verify changes.

Key Takeaways
‚úî migrate applies pending migrations to the database. 
‚úî SQLite is default in Django, but PostgreSQL/MySQL are preferred for large applications. 
‚úî The django_migrations table tracks executed migrations. 
‚úî sqlmigrate lets you preview SQL commands before execution.



 








Customizing Database Schema:
----------------------------
In Django, you may need more control over your database schema by customizing table names, adding indexes, or setting default ordering. This is done using the Meta class inside models.

django model metadata --> https://docs.djangoproject.com/en/5.1/ref/models/options/


1. Defining Metadata for a Django Model:
To customize database behavior, define an inner Meta class inside your model.

Example: Customer Model with Metadata

class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE
    )

    class Meta:
        db_table = 'store_customers'  # Custom table name
        indexes = [models.Index(fields=['last_name', 'first_name'])]  # Index for faster lookup
		
		
		
‚úÖ Metadata Options:
db_table ‚Üí Renames the database table from default (store_customer) to 'store_customers'.
indexes ‚Üí Creates an index on last_name and first_name to improve query performance.

üí° Indexing helps speed up queries when filtering or sorting large datasets.



2. Creating and Running Migrations
After adding metadata changes, generate migrations:

python manage.py makemigrations

This creates a new migration file that updates the database schema.

üìå Important Consideration: 
‚ùå Avoid mixing multiple types of operations in a single migration (e.g., renaming a table + adding an index). 
‚úÖ Instead, make changes incrementally‚Äîcreate separate migrations for each modification.


üîπ Applying migrations:

python manage.py migrate

After running the migration, the table name changes to store_customers, and indexes are applied.




3. Checking the Updated Database Schema

To inspect the changes:
Open SQLite Explorer in VS Code.
Refresh the database.
Check that the table name is updated and indexes are applied.

üìå Observations:
The table name change may cause inconsistencies if other tables still use singular naming conventions.
Sticking to Django default table naming (lowercase_singular) maintains consistency.


Key Takeaways
‚úî The Meta class customizes model behavior in Django. 
‚úî Use db_table to rename tables (though default naming is usually preferable). 
‚úî Indexes improve query performance for frequently used fields. 
‚úî Migrations must be structured carefully‚Äîavoid combining unrelated changes.

üöÄ Next Step: Learning how to undo migrations if changes need to be reverted.










Reverting Migrations:
---------------------

Reverting Migrations in Django:
Sometimes, we need to undo a migration due to mistakes or changes in project requirements. Django allows two approaches for reverting migrations:

1. Selectively Undoing a Migration
If you want to undo only part of the migration (e.g., keep the index but remove the custom table name), follow these steps:

‚úÖ Steps:
1. Modify the model by removing or adjusting the unwanted changes.
2. Run:
	python manage.py makemigrations
	(This creates a new migration to revert the changes).
3. Apply it using:
python manage.py migrate
This ensures only selected changes are undone while keeping the rest intact.




2. Fully Reverting the Last Migration
If the entire migration must be removed, follow these steps:

‚úÖ Steps:

1. Identify the last migration number.
	Open the migrations folder (store/migrations/ in this example).
	Find the last migration (e.g., 0004_customization).
2. Downgrade to the previous migration (migration 0003 in this example):
python manage.py migrate store 0003
(This removes the last migration from the database).

‚úÖ Verification:
Check the database ‚Üí The unwanted migration is removed.
Inspect the django_migrations table ‚Üí The last migration entry should be gone.




3. Removing the Migration File and Code Changes
Even though the migration is removed from the database, the migration file still exists. 

To fully revert:
1. Delete the migration file manually (store/migrations/0004_customization.py).
2. Undo the code changes in the related model (e.g., remove the Meta class in Customer).
3. Prevent reapplying the migration by ensuring no code references remain.

üöÄ Best Practice: Use Git for version control, so reverting changes becomes easier.




4. Using Git for Reverting Code Changes
Instead of manually removing changes, use Git commands:

‚úÖ Steps:
1. Open the terminal and check Git history:
git log --oneline
(Find the last commit that introduced the migration).

2. Reset the branch to undo that commit:
git reset --hard HEAD~1
(Moves Git history one step back, removing all related changes).

‚úÖ Verification:
The migration file is gone.
The model definition is restored to its previous state.


Exercise:
Try the following steps to practice reverting migrations:
1. Rename the first_name field in the Customer model to given_name.
2. Create a migration (makemigrations + migrate).
3. Revert the migration using the techniques discussed above.

Key Takeaways:
‚úî Use makemigrations selectively if you only want partial changes reverted. 
‚úî Use migrate <app> <previous_migration> to fully undo a migration. 
‚úî Remove the migration file and associated model changes to prevent reapplying. 
‚úî Using Git simplifies reverting code changes without manual deletion.










Installing MySQL:
-----------------
Connecting to MySQL:
--------------------

Setting Up and Using MySQL in Django:
When working on a Django project, switching from the default SQLite database to MySQL can provide better scalability and performance. Below is a step-by-step guide for installing MySQL, connecting to it, and integrating it with Django.


1. Installing MySQL
‚úÖ Steps:

1. Go to MySQL Community Downloads.
2. Select MySQL Community Server and choose your operating system.
3. Download and install MySQL.
4. During installation, set:
	A root password for MySQL.
	Strong password encryption for secure access.
5. Confirm installation:
mysql -u root -p
(If this command runs successfully, MySQL is installed properly).

üìù If you encounter errors, Google them or check forums like StackOverflow for solutions.



2. Choosing a GUI Tool for MySQL:
‚úÖ Popular Database Management Tools:
	MySQL Workbench (Free and official from MySQL).
	TablePlus (Lightweight, supports multiple databases).
	DataGrip (Best tool but requires a paid license).


E.g.
Setting Up MySQL Connection in DataGrip:
1. Open DataGrip and create a new project.
2. Click "+" ‚Üí New Data Source ‚Üí Select MySQL.
3. Enter connection details:
	Host: localhost
	Port: 3306
	User: root
	Password: (Set during installation)
4. Fix missing driver error ‚Üí Download required drivers.
5. Set Time Zone ‚Üí UTC.
6. Test Connection ‚Üí Ensure successful authentication.




3. Creating a MySQL Database:
Before connecting Django to MySQL, create the database manually:

CREATE DATABASE storefront;
‚úÖ This step ensures Django has a database to work with.





4. Installing MySQL Client for Django:
Django requires a package to communicate with MySQL. Install it using:

pip install mysqlclient

üìù Troubleshooting:
If installation fails, ensure MySQL is correctly installed.
If mysql command not found, add MySQL to your system PATH.

‚úÖ Verify MySQL installation:
mysql -u root -p





5. Configuring MySQL in Django Settings:
Modify the DATABASES setting in settings.py:

python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # Change from SQLite to MySQL
        'NAME': 'storefront',  # Database name created earlier
        'USER': 'root',
        'PASSWORD': 'your_password',  # Replace with your MySQL password
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
üöÄ Note: This setup is fine for development, but in production, avoid storing passwords directly in the settings file. Use environment variables instead.




6. Applying Migrations in MySQL
Once MySQL is integrated, run migrations to create database tables:

python manage.py migrate

‚úÖ Check database updates in DataGrip:
Refresh the connection.
Look for storefront database with all Django-generated tables.




7. Troubleshooting Common Issues
üö® Potential Errors & Fixes:
MySQL command not found ‚Üí Add MySQL to PATH.
Access denied ‚Üí Ensure correct password.
Missing drivers in DataGrip ‚Üí Download required drivers.
Server returns invalid time zone ‚Üí Set timezone to UTC.

‚úÖ Best Practice: Be patient and determined when fixing installation issues.



Key Takeaways:
‚úî Install MySQL and set up authentication. 
‚úî Use GUI tools like MySQL Workbench, TablePlus, or DataGrip for easier database management. 
‚úî Create a database manually before connecting it to Django. 
‚úî Update settings.py to use MySQL instead of SQLite. 
‚úî Run migrate to generate tables in MySQL.

üöÄ Now your Django project is successfully connected to MySQL!











Running Custom SQL:
-------------------
Running Custom SQL in Django Migrations:
Sometimes, we need full control over how our database schema is modified. Django allows executing custom SQL queries within migrations, which is useful for tasks like: ‚úî Creating stored procedures, views, or functions ‚úî Modifying tables manually ‚úî Performing data transformations


To do that: 
1. Creating an Empty Migration:
Instead of letting Django generate migrations, create an empty migration to manually define SQL commands:

python manage.py makemigrations store --empty

‚úÖ This creates a migration file in the store/migrations/ folder without any predefined operations.




2. Writing Custom SQL in the Migration File:
Open the newly generated migration file and modify it using Django‚Äôs RunSQL class:

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('store', '003_add_slug_to_product'),
    ]
    
    operations = [
        migrations.RunSQL(
            '''INSERT INTO store_collection (title) VALUES('collection1')''',
            '''DELETE FROM store_collection WHERE title='collection1' '''
        )
    ]

‚úÖ Explanation:
The first SQL command inserts a record into store_collection.
The second SQL command removes that record, allowing reversal of the migration.

üöÄ Best Practice: Always provide a downward migration SQL statement, otherwise reverting the migration won't be possible.




3. Applying the Migration:
Run the migration to execute custom SQL in the database:

python manage.py migrate

üîπ Verifying the change:
	Open DataGrip or any MySQL GUI tool.
	Navigate to the store_collection table.
	The new record (collection1) should be inserted.




4. Reverting the Migration
To undo this migration and remove collection1, downgrade the database to the previous migration:

python manage.py migrate store 003

‚úÖ Verification:
Refresh the store_collection table ‚Üí The inserted record should be deleted.
The django_migrations table should no longer list the latest migration.

Key Takeaways: 
‚úî Use empty migrations for manual SQL execution. 
‚úî Always provide a downward SQL statement (DELETE for insertions, etc.). 
‚úî Check the migration table (django_migrations) to verify changes. 
‚úî Revert changes using python manage.py migrate <app> <previous_migration>.

üöÄ Now you have full control over database modifications with Django migrations!	
	
	
	
	
	

Generating Dummy Data --> mockaroo.com









Django ORM:
-----------

In this section, you will learn how to query and manipulate data using Django ORM or Object Relational Mapper. We'll start off this section by a quick overview of Django ORM and the problem it solves. Then we'll spend the rest of the section on various ways to query and manipulate data. We'll cover filtering, sorting, grouping data, and much, much more. So by the end of this section, you'll be able to confidently pull out the data from the relational database or also store it in a the relational database.

Django ORM:
Understanding Django ORM (Object-Relational Mapper):

Django ORM (Object-Relational Mapper) simplifies database interactions by mapping relational database records to Python objects. Instead of manually writing SQL queries, ORM allows us to manipulate data using Python code, which is converted into SQL at runtime.



1. The Problem ORMs Solve
In traditional databases:
	Data is stored as rows in tables.
	Querying data requires SQL commands.
	Developers must manually map rows to objects in their application.

‚úÖ Before ORMs:
Developers had to write SQL, retrieve data, and convert rows into objects manually.
This process was time-consuming and repetitive.

‚úÖ With ORMs:
The ORM automates the mapping between rows and objects.
Eliminates the need for manual SQL queries in many cases.
Allows coding directly in Python, while ORM translates it into SQL.


üí° Example: Instead of writing
SELECT * FROM products WHERE price > 100;

In Django ORM, we can simply write:
Product.objects.filter(price__gt=100)


This reduces complexity and speeds up development.





2. Do We Still Need SQL?
‚ùå ORMs are not always perfect
For complex queries, ORM may generate inefficient SQL.
In such cases, it's better to write optimized SQL manually.


‚úÖ Best Approach:

Use ORM for most queries.
Switch to raw SQL when performance optimization is necessary.

üîπ Example of ORM helping in Django migrations:
ORM automatically creates database tables during migration without manual SQL.
ORM manages relationships and indexes efficiently.




3. ORM in Django Models
All model classes in Django inherit from models.Model, gaining ORM capabilities automatically.

üìå Example:
class Product(models.Model):
    title = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=10, decimal_places=2)
		
‚úÖ This model allows querying without SQL, such as:
Product.objects.all()  # Fetch all products
Product.objects.filter(price__lt=50)  # Get products with price < 50





4. Addressing ORM Criticism
Some developers prefer manual SQL, believing ORMs are slow. However, ORM reduces repetitive coding, making projects easier to maintain.

‚úÖ Best Practice: 
‚úî Use ORM where appropriate. 
‚úî Optimize only when performance issues arise. 
‚úî Avoid premature optimization‚Äîfocus on development speed first.



Key Takeaways:
‚úî Django ORM automates database interactions, reducing manual SQL work. 
‚úî Simplifies querying using Python instead of SQL commands. 
‚úî Manual SQL is needed for complex optimizations. 
‚úî Avoid over-engineering‚Äîuse the right tool based on project needs.

üöÄ Next: Using ORM for database queries in Django.







Resetting the Database:
-----------------------

resetting the everything 










Managers and Querysets:
-----------------------

Understanding Managers and QuerySets in Django ORM:
Django ORM (Object-Relational Mapper) provides an efficient way to interact with the database without writing raw SQL queries. Two key components of ORM are Managers and QuerySets, which help in querying and updating data.


1. Managers in Django Models
Every Django model automatically gets an attribute called objects, which provides access to the Manager.

‚úÖ What is a Manager?
A Manager is an interface to the database.
Acts as a remote control with methods to query or modify database records.
Every model has a default Manager (objects), but custom Managers can be defined.

üìå Example:
from store.models import Product  

# Default Manager
Product.objects.all()  # Retrieves all records
Product.objects.filter(price__gt=50)  # Filters products with price > 50

üöÄ The Manager provides methods such as:
all() ‚Üí Fetches all records.
get() ‚Üí Retrieves a single object.
filter() ‚Üí Filters data based on conditions.
count() ‚Üí Returns the number of records (does NOT return a QuerySet).




2. What is a QuerySet?
A QuerySet represents a query that has not yet been executed.
Django delays evaluation of QuerySets (they are lazy).


üîπ When is a QuerySet evaluated?
1. Iteration ‚Üí Looping through results:

for product in Product.objects.all():
    print(product)

2. Conversion to list (list(QuerySet)) ‚Üí Forces execution.
3. Accessing specific elements (QuerySet[0], QuerySet[:5]).

‚úÖ Why are QuerySets lazy?

Allows building complex queries efficiently without fetching unnecessary data.

Example:
products = Product.objects.filter(price__gt=50).order_by('title')
üöÄ This query will not execute until we iterate over it.





3. Debugging SQL Queries in Django
Django Debug Toolbar helps inspect SQL queries generated by ORM.

üìå Example Output:

SELECT id, title, price FROM store_product WHERE price > 50 ORDER BY title;
‚úÖ Helps optimize queries for performance improvements.





4. When NOT to Use QuerySets
Some methods return direct results instead of QuerySets, for example:
Product.objects.count()  # Returns an integer, not a QuerySet

‚úÖ This avoids unnecessary query chaining.




Key Takeaways:
‚úî Managers provide methods for querying/updating database records. 
‚úî QuerySets are lazy and only execute when needed. 
‚úî Efficient QuerySet chaining builds optimized queries before execution. 
‚úî Use Django Debug Toolbar for SQL inspection.

üöÄ Next Step: Learning how to retrieve objects in Django ORM!











Retrieving objects:
-------------------

Django provides multiple ways to retrieve objects from the database using its Object-Relational Mapper (ORM). Below are the key methods for querying data efficiently.


1. Retrieving All Objects (all()):
The all() method retrieves all records from a table.

üìå Example:

from store.models import Product

products = Product.objects.all()  # Returns a QuerySet of all products

‚úÖ Returns a QuerySet, which is evaluated only when iterated over.




2. Retrieving a Single Object (get())
The get() method fetches a single object based on a lookup parameter.

üìå Example:
product = Product.objects.get(id=1)  # Fetches product with ID 1

üöÄ Using pk Instead of id:
pk refers to the primary key field, whether it's id, code, or any other identifier.

Equivalent to:
product = Product.objects.get(pk=1)

‚úÖ Returns a single object (not a QuerySet). 
‚ùå Throws an exception if the object does not exist.





3. Handling Errors in get() Method
If no matching object is found, Django raises DoesNotExist exception.

‚úÖ Using Try-Except Block:
from django.core.exceptions import ObjectDoesNotExist

try:
    product = Product.objects.get(pk=0)  # Product with ID 0 (not found)
except ObjectDoesNotExist:
    product = None  # Handle error gracefully

üöÄ Best Practice: 
Organize Django imports together for cleaner code. Like, 
from django.shortcuts import render
from django.core.exceptions import ObjectDoesNotExist

These two lines should goes together





4. Better Alternative: Using filter().first()
To avoid exceptions, use .filter().first() instead of get().

üìå Example:
product = Product.objects.filter(pk=0).first()  # Returns None if not found

‚úÖ Does not throw an exception if no product exists. ‚úÖ Returns the first matching object or None.




5. Checking If an Object Exists (exists())
Sometimes, we just need to verify whether a record exists without retrieving it.

üìå Example:
exists = Product.objects.filter(pk=0).exists()  # Returns True or False

‚úÖ Returns a Boolean value (True or False) instead of an object.




Key Takeaways:
‚úî all() ‚Üí Retrieves all objects (returns a QuerySet). 
‚úî get() ‚Üí Retrieves one object, throws exception if not found. 
‚úî Try-except block handles missing objects in get(). 
‚úî Use filter().first() instead of get() to avoid errors. 
‚úî exists() checks if a record exists without fetching the actual object.

üöÄ Next Lesson: Detailed Filtering in Django ORM!







Filtering Objects:
------------------
Filtering Objects in Django ORM:
Django ORM provides powerful filtering capabilities using the filter() method. This allows querying based on conditions such as numeric comparisons, string searches, date filtering, and null checks.

1. Filtering by Numeric Values
üìå Find products with price exactly $20:
queryset = Product.objects.filter(unit_price=20)



üìå Find products priced higher than $20:
queryset = Product.objects.filter(unit_price__gt=20)

üöÄ Explanation:
Logical operators (>, <) cannot be used directly in filter().

Use lookup types:
__gt ‚Üí Greater than
__gte ‚Üí Greater than or equal to
__lt ‚Üí Less than
__lte ‚Üí Less than or equal to




üìå Find products within a price range ($20 to $30):
queryset = Product.objects.filter(unit_price__range=(20, 30))
‚úÖ Uses the range lookup type, which requires a tuple (min_value, max_value).







2. Filtering Across Relationships
Django allows filtering based on related models.

Syntax: 
relationship + __field or attributes of the particular relationship  (example: collection__id, only if you put double underscore, you would navigate to the relationship


üìå Find products in collection ID 1:
queryset = Product.objects.filter(collection__id=1)

üìå Find products in collections greater than ID 1:
queryset = Product.objects.filter(collection__id__gt=1)


üìå Find products belonging to multiple collections:
queryset = Product.objects.filter(collection__id__range=(1, 2, 3))

üöÄ Explanation:
collection__id represents the foreign key to the Collection model.
filter() can navigate relationships using double underscores (__).






3. Filtering Strings (Case-Sensitive and Insensitive)

üìå Find products with ‚Äúcoffee‚Äù in their title (case-sensitive):
queryset = Product.objects.filter(title__contains='coffee')
üö® Issue: This lookup is case-sensitive, meaning "coffee" and "Coffee" are treated differently.


üìå Case-insensitive search:
queryset = Product.objects.filter(title__icontains='coffee')
‚úÖ Using icontains ensures case insensitivity.


üîπ Other useful string lookup types:
startswith ‚Üí Matches only if a string starts with a given value.
endswith ‚Üí Matches only if a string ends with a given value.
istartswith, iendswith ‚Üí Case-insensitive versions.





4. Filtering Dates
üìå Find products updated in 2021:
queryset = Product.objects.filter(last_update__year=2021)
‚úÖ Allows extracting specific components like year, month, day, hour, etc.


üìå Filtering by exact date values (rarely used):
queryset = Product.objects.filter(last_update='2021-05-10')




5. Checking for Null Values
üìå Find products without a description:
queryset = Product.objects.filter(description__isnull=True)
‚úÖ Returns objects where description is NULL in the database.

üìå Find products with a description:
queryset = Product.objects.filter(description__isnull=False)




Key Takeaways
‚úî Use filter() with lookup types (__gt, __contains, etc.) for complex queries. 
‚úî Filter related models using double underscores (collection__id). 
‚úî Use case-insensitive lookups (icontains, istartswith). 
‚úî Extract date components (year, month). 
‚úî Check for null values (isnull=True).

üöÄ Next Lesson: More advanced querying techniques!




Using collection__id vs. collection_id:
----------------------------------------
collection_id: This is the actual database column automatically created by Django for a ForeignKey field. ‚úÖ Example:

queryset = Product.objects.filter(collection_id=1)
  
This works because collection_id is a direct reference to the column in the database.



collection__id: This follows Django‚Äôs ORM lookup syntax, allowing navigation through relationships. ‚úÖ Example:

queryset = Product.objects.filter(collection__id=1)  

Here, collection is the ForeignKey field in Product, and we are accessing the id attribute of the related Collection model.



üöÄ Key Difference: Both work, but:
collection_id is more direct (avoids ORM navigation).
collection__id is used when filtering based on related model attributes.

üí° Example with Other Attributes in Related Models:

queryset = Product.objects.filter(collection__title="Summer Collection")
Here, collection__title accesses the title field of the related Collection model.



Understanding collection_id vs. collection__id in Django ORM:
-------------------------------------------------------------
When dealing with ForeignKey relationships in Django models, Django provides two ways to reference related objects in queries:

1. collection_id ‚Üí Directly refers to the ForeignKey column in the database.
2. collection__id ‚Üí Uses ORM relationship traversal, accessing the actual id field of the related model.

Example Scenario
Let‚Äôs say we have a Product model with a ForeignKey relationship to a Collection model:

class Collection(models.Model):
    title = models.CharField(max_length=255)

class Product(models.Model):
    title = models.CharField(max_length=255)
    collection = models.ForeignKey(Collection, on_delete=models.CASCADE)

üöÄ Django automatically creates a database column called collection_id in the Product table to store the relationship.



Using collection_id (Direct Reference to the Database Column):
When filtering directly in the Product table:

Product.objects.filter(collection_id=1)

‚úÖ This queries the database column directly, avoiding ORM relationship traversal. ‚úÖ Efficient and faster since it doesn‚Äôt check the Collection model.

üìå Equivalent SQL Query:
SELECT * FROM product WHERE collection_id = 1;

‚úî Django treats collection_id as a normal integer field since it exists directly in the database.



Using collection__id (Navigating Relationships with ORM):
Alternatively, you can use collection__id:

Product.objects.filter(collection__id=1)

‚úÖ This tells Django ORM:
Navigate the collection relationship (go to the Collection model).
Check the id field within the Collection model.

üìå Equivalent SQL Query:
SELECT * FROM product 
JOIN collection ON product.collection_id = collection.id
WHERE collection.id = 1;

‚úî This performs an INNER JOIN between the Product and Collection tables.




Key Difference
Query Syntax	     How It Works	                                     Performance
collection_id=1	     Direct lookup on the database column (faster)	     ‚úÖ More efficient
collection__id=1	 Navigates ORM relationships & joins related table	 ‚ùå Can be slower




When to Use Each?
‚úî Use collection_id when filtering using the ForeignKey column directly. 
‚úî Use collection__id when filtering based on attributes inside the related model.

üí° Example of filtering by related model attributes:
Product.objects.filter(collection__title="Summer Collection")
‚úÖ This navigates the relationship to filter based on the title field inside the Collection model.

Final Summary
‚úî collection_id ‚Üí Fast, direct lookup in the database. 
‚úî collection__id ‚Üí Navigates ORM relationships, useful when filtering by related model fields.




Some more examples:

# Customers with .com accounts
querset = Customer.objects.filter(email__icontains='.com')

# Collections that don‚Äôt have a featured product
queryset = Collection.objects.filter(featured_product__isnull=True)

# Products with low inventory (less than 10)
queryset = Product.objects.filter(inventory__lt=10)

# Orders placed by customer with id = 1
queryset = Order.objects.filter(customer__id=1)

# Order items for products in collection 3
queryset = OrderItem.objects.filter(product__collection__id=3)














Complex Lookups Using Q Objects:
--------------------------------

Django ORM provides Q objects to build complex queries involving multiple conditions. This is useful when applying AND, OR, and NOT filters dynamically.

1. Filtering with Multiple Conditions Using filter()
The simplest way to filter using multiple conditions is by passing multiple keyword arguments:

üìå Find products with inventory < 10 AND unit price < 20:
queryset = Product.objects.filter(inventory__lt=10, unit_price__lt=20)
‚úÖ Generates a SQL query with the AND operator:

SELECT * FROM product WHERE inventory < 10 AND unit_price < 20;


Alternatively, you can chain filter calls:
queryset = Product.objects.filter(inventory__lt=10).filter(unit_price__lt=20)
‚úÖ Returns the same result but makes filtering more readable.




2. Using Q Objects for Complex Lookups
Q objects allow logical combinations (AND, OR, NOT) using bitwise operators.

üìå Importing Q Objects:
from django.db.models import Q


3. Using the OR (|) Operator
üìå Find products where inventory < 10 OR unit price < 20:
queryset = Product.objects.filter(Q(inventory__lt=10) | Q(unit_price__lt=20))

‚úÖ Generates a SQL query with the OR operator:
SELECT * FROM product WHERE inventory < 10 OR unit_price < 20;
üöÄ Q objects must be enclosed in parentheses for the OR operation to work correctly.



4. Using the AND (&) Operator
üìå Find products where inventory < 10 AND unit price < 20:

queryset = Product.objects.filter(Q(inventory__lt=10) & Q(unit_price__lt=20))
‚úÖ Works like passing multiple conditions in filter(), but is more verbose.



5. Using the NOT (~) Operator
üìå Find products where inventory < 10 AND unit price is NOT less than 20:

queryset = Product.objects.filter(Q(inventory__lt=10) & ~Q(unit_price__lt=20))
‚úÖ This negates the second condition, ensuring unit price is NOT less than 20.




Key Takeaways
‚úî Use filter() directly for simple AND conditions. 
‚úî Use Q objects (Q(condition1) | Q(condition2)) for OR conditions. 
‚úî Use ~Q(condition) to negate a condition. 
‚úî Use parentheses to ensure correct precedence in Q objects.

üöÄ Next Lesson: Using F objects to reference fields dynamically!











 


Referencing Fields using F Objects:
-----------------------------------

When filtering data in Django ORM, sometimes we need to compare a field against another field in the same model instead of a static value. This is where F objects come into play.

1. The Problem: Direct Field Comparison Causes Errors

üìå Incorrect way to filter:
queryset = Product.objects.filter(inventory = unit_price)  # ‚ùå Causes error
‚úÖ Issue: Django expects a value, but unit_price is a field, not a variable.


üö® Another incorrect attempt:

queryset = Product.objects.filter(inventory = 'unit_price')  # ‚ùå Doesn't work
‚úÖ Issue: This compares inventory (a number) with a string "unit_price", which is invalid.




2. Solution: Using F Objects
üìå Import the F class:

from django.db.models import F


üìå Correct way to compare fields:
queryset = Product.objects.filter(inventory = F('unit_price'))

‚úÖ Explanation:
F('unit_price') references the unit_price field dynamically.
Django converts this to SQL where the database compares two columns.

üìå Generated SQL Query:
SELECT * FROM product WHERE inventory = unit_price;





3. Comparing Fields Across Related Models
We can also reference fields from related models using ForeignKey relationships.
üìå Compare inventory with collection_id:
queryset = Product.objects.filter(inventory = F('collection__id'))

‚úÖ Explanation:
collection__id navigates the ForeignKey relationship and retrieves the id of the related Collection object.

üìå Generated SQL Query:
SELECT * FROM product 
JOIN collection ON product.collection_id = collection.id
WHERE inventory = collection.id;


Key Takeaways:
‚úî Use F('field_name') to reference fields dynamically in queries. 
‚úî Avoid using variables or strings for field comparisons. 
‚úî Can reference fields in related models using double underscores (collection__id). 
‚úî Django automatically translates F objects into SQL queries.

üöÄ Next Lesson: Sorting Query Results!











Sorting:
--------

Django ORM allows sorting query results using the order_by() method. You can sort by one or multiple fields and control the sorting direction.

1. Basic Sorting with order_by()
üìå Sort products by title in ascending order:
queryset = Product.objects.order_by('title')
‚úÖ Default sorting order is ascending (A ‚Üí Z).

üìå Sort products by title in descending order:
queryset = Product.objects.order_by('-title')
‚úÖ Adding a negative sign (-) reverses the order (Z ‚Üí A).




2. Sorting by Multiple Fields
üìå Sort by unit price (ascending), then by title (descending):
queryset = Product.objects.order_by('unit_price', '-title')
‚úÖ First, products are sorted by price (lowest ‚Üí highest). ‚úÖ If multiple products have the same price, they are sorted by title (Z ‚Üí A).




3. Reversing the Sorting Order (reverse())
üìå Reverse the sorting direction of a query set:
queryset = Product.objects.order_by('unit_price', '-title').reverse()
‚úÖ Final order:
Unit price ‚Üí descending (highest ‚Üí lowest).
Title ‚Üí ascending (A ‚Üí Z).

üìå Example SQL Query Generated:
SELECT * FROM product ORDER BY unit_price DESC, title ASC;
üöÄ Useful when dynamically adjusting sorting without modifying field names.




4. Sorting After Filtering
You can sort results after applying a filter.
üìå Filter products in collection ID 1, then sort by unit price:
queryset = Product.objects.filter(collection__id=1).order_by('unit_price')
‚úÖ Filters products first, then applies sorting.



5. Selecting the First Object After Sorting
üìå Retrieve the cheapest product:
product = Product.objects.order_by('unit_price')[0]
‚úÖ Extracts the first object after sorting by unit price. ‚ùå Warning: If no records exist, this may cause an error.


üìå Better Alternative: Using earliest() and latest() ‚úÖ These methods sort and return the first object directly.



üìå Get the cheapest product using earliest():
product = Product.objects.earliest('unit_price')
‚úÖ Automatically sorts by unit_price and returns the first result.

üìå Get the most expensive product using latest():
product = Product.objects.latest('unit_price')
‚úÖ Sorts by unit_price in descending order and returns the first product.




Key Takeaways
‚úî Use order_by() to sort by fields (ascending or descending). 
‚úî Use multiple fields to refine sorting (e.g., unit_price, -title). 
‚úî Use reverse() to dynamically flip sorting direction. 
‚úî Apply order_by() after filtering for precise results. 
‚úî Use earliest() and latest() instead of manually accessing queryset[0].

üöÄ Next Lesson: Limiting Query Results!












Limiting Results:
-----------------

Our product table has a thousand products. Now quite often, we don't want to show all these products to the user in one list. We want to show pages of products. So let's say our page size is five and we want to show the products on the first page. To do that, we use Python's array slicing syntax.

queryset = Product.objects.all()[:5]  # 0, 1, 2, 3, 4

sql statement:
select * from store.product limit 5



Now to get the products on the second page, we can start from five and finish before 10. 

queryset = Product.objects.all()[5:10]  # 5, 6, 7, 8, 9

sql statement:
select * from store.product limit 5 offset 5

Note: 
LIMIT 5 ‚Üí Fetch only 5 records.
OFFSET 5 ‚Üí Skip the first 5 records and start fetching from the 6th record onward.

Use Case: This is useful for pagination, where you need to display results in batches (e.g., pages of search results).
Page 1 ‚Üí LIMIT 5 OFFSET 0 (fetch first 5 records).
Page 2 ‚Üí LIMIT 5 OFFSET 5 (fetch next 5 records).
Page 3 ‚Üí LIMIT 5 OFFSET 10 (fetch next 5 records), and so on.








Selecting Fields to Query:
--------------------------


By default, when querying objects in Django ORM, all fields are retrieved from the database. However, if you only need a subset of fields (to optimize performance), you can use values() and values_list().

1. Using values() for Specific Fields
üìå Query only id and title from the Product table:
queryset = Product.objects.values('id', 'title')

‚úÖ Result: Instead of returning full model instances, it returns a list of dictionaries:

[
    {'id': 1, 'title': 'Product A'},
    {'id': 2, 'title': 'Product B'},
]

üìå Generated SQL Query:
SELECT store_product.id, store_product.title FROM store_product;

üöÄ Useful when you don't need all fields, reducing database load.





2. Querying Related Fields
You can also retrieve fields from related models using double underscore (__) notation.

üìå Get the product ID, title, and its collection title:
queryset = Product.objects.values('id', 'title', 'collection__title')

‚úÖ Result:
[
    {'id': 1, 'title': 'Product A', 'collection__title': 'Summer Collection'},
    {'id': 2, 'title': 'Product B', 'collection__title': 'Winter Collection'},
]


üìå Generated SQL Query:
SELECT store_product.id, store_product.title, store_collection.title 
FROM store_product 
INNER JOIN store_collection ON store_product.collection_id = store_collection.id;

üöÄ Automatically performs an INNER JOIN to fetch related fields.





3. Using values_list() for Tuples Instead of Dictionaries
üìå Retrieve data as tuples instead of dictionaries:
queryset = Product.objects.values_list('id', 'title', 'collection__title')


‚úÖ Result:
[
    (1, 'Product A', 'Summer Collection'),
    (2, 'Product B', 'Winter Collection'),
]
üöÄ Useful when you don‚Äôt need key-value mapping (faster processing).





4. Finding Ordered Products Using Subqueries
Not all products have been ordered‚Äîwe need to identify products present in the OrderItem table.

üìå Step 1: Extract Product IDs from OrderItem table
queryset = OrderItem.objects.values('product_id')

üöÄ Why product_id instead of product__id?
Django automatically creates the product_id field for ForeignKey relationships at runtime.
You don‚Äôt need to explicitly define product_id in models, Django handles it internally.


üìå Step 2: Remove duplicates using .distinct()
queryset = OrderItem.objects.values('product_id').distinct()
‚úÖ Ensures we don't get duplicate products from multiple orders.

üìå Step 3: Filter products using the extracted product IDs
queryset = Product.objects.filter(id__in=OrderItem.objects.values('product_id').distinct())
‚úÖ Finds all products that exist in the OrderItem table.

üìå Final Step: Sort by Title
queryset = Product.objects.filter(id__in=OrderItem.objects.values('product_id').distinct()).order_by('title')
üöÄ Returns ordered products sorted by title.



Key Takeaways
‚úî Use values() to return dictionaries (for key-value mapping). 
‚úî Use values_list() to return tuples (faster processing). 
‚úî Use product_id for ForeignKey filtering (product__id works too). 
‚úî Use distinct() to remove duplicate results. 
‚úî Use the IN lookup (id__in) to filter records efficiently.

üöÄ Next Lesson: Advanced Querying Techniques!








Deferring Fields: 
-----------------

When querying objects, Django ORM retrieves all fields from the database by default. However, sometimes we only need specific fields for optimization. Django provides two methods for controlling this:
1. only() ‚Üí Load only selected fields.
2. defer() ‚Üí Delay loading of certain fields until needed.



1. Using only() to Optimize Queries
üìå Retrieve only id and title from the Product table:
queryset = Product.objects.only('id', 'title')

‚úÖ Instead of querying all fields, it fetches only the specified ones. ‚úÖ Returns full Product instances, unlike values(), which returns dictionaries.

üìå Generated SQL Query:
SELECT store_product.id, store_product.title FROM store_product;

üö® Potential Issue:
If we later access a field not included in only(), Django will send a separate query for each missing field, leading to many unnecessary queries.

Example: If we display product.unit_price in a template after using only('id', 'title'), Django will issue one query per product to fetch unit_price, causing performance issues.




2. How Excess Queries Can Occur with only()
üìå Example:
queryset = Product.objects.only('id', 'title')
Later, in a template, we try to display product.unit_price:
html:
{{ product.unit_price }}

üöÄ What Happens:
Main Query: Fetches only id and title.

sql
SELECT store_product.id, store_product.title FROM store_product;
Extra Queries (One Per Product):

sql
SELECT store_product.id, store_product.unit_price FROM store_product WHERE store_product.id = 1 LIMIT 21;
SELECT store_product.id, store_product.unit_price FROM store_product WHERE store_product.id = 2 LIMIT 21;
...
(1000+ queries if 1000 products exist)
‚ùå This can drastically slow down performance.

üõë Solution: Avoid only() if you will need other fields later.





3. Using defer() to Delay Loading Fields
üìå Exclude description from initial query:
queryset = Product.objects.defer('description')

‚úÖ The description field will not be loaded unless explicitly accessed. ‚úÖ Better performance compared to only(), because fewer queries are sent.

üö® Potential Issue:
If you later iterate over products and access description, Django will issue separate queries for each product, leading to performance issues similar to only().

üìå Example Scenario:
queryset = Product.objects.defer('description')

for product in queryset:
    print(product.description)  # ‚ùå This triggers extra queries



Key Takeaways
‚úî Use only() to load specific fields but avoid accessing missing fields later. 
‚úî Be cautious with defer()‚Äîit delays loading but may cause excessive queries if the deferred field is later accessed. 
‚úî If optimizing queries, always check Django Debug Toolbar to analyze query performance.

üöÄ Next Lesson: Further ORM optimization techniques!












Selecting Related Objects:
--------------------------

<li>{{ product.title }} - {{ product.collection.title }}</li>

Sometimes we need to preload a bunch of objects together. For example, while fetching all the products, we also want to render the collection of each product next to its title (say product.collection.title). But when you do it normally, you would get the same problem as before. Our application will be hanging because Django is sending a thousands of extra queries Queries to the database to read the collection of all the related products. Because when we ask for products, Django is only going to query the product table. It's not going to query the related tables unless we specifically instructed to do so. So here we want to preload the products with our collection. 




To do that we can use the select_related()(before we call the 'all' method, we can call select_related and specify the field that we want to preload). 
Here say the field is 'collection'
Now our products loaded instantly. 

queryset = Product.objects.select_related('collection').all()

SQL:
SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER_JOIN store_collection ON (store_product.collection_id = store_collection.id)

Here we're selecting all the fields from the product table followed by the three fields from the collection table and then we have a join between product and collection table. So, when we use the select related method, Django creates a join between our tables. 




Now, we can also span relationships. So, let's say collection has another field that we want to preload as part of the query. So, we can add double underscores there and then type the name of that other field. 

queryset = Product.objects.select_related('collection__someOtherField').all()




Okay so, this is 'select_related'. Now. We have another method called 'prefetch_related'. We use select_related when the other end of the relationship has one instance (a product has one collection). But we use prefetch related when the other end of the relationship has many objects (a product may have many promotions). you can check product class real quick, where each product has one collection, but it can have many promotions. So to preload the promotions, we use the 'prefetch_related' method. 

class Product(models.Model):
    title = models.CharField(max_length=255)
	slug = models.SlugField()
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

#select_related(1) --> other end of the relationship has one instance (product - collection)
#prefetch_related(N) when other end of the relationship has many objects (product - promotion)

#prefetch_related
queryset = Product.objects.prefetch_related('promotions').all()

SQL:
select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price from store_product

select (store_product_promotions.product_id) as _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount
from store_promotion inner join store_product_promotions on (store_promotion.id = store_product_promotions.promotion_id) where store_product_promotions.product_id in (1,2,3,4,5,6,7,8,9,10...)

Here's the first query to read the columns from the product table. Now, after that, we have another query to read the promotions of the products. So, you're reading three columns from the promotion table, and we have a join between promotion and product. So, essentially, we have two result sets. The first set includes the products. The second set includes promotions. Django reads these sets and then populates our objects in memory. 



Now, we can also combine these two methods. So let's say we want to load all the products with their promotions and collection. So after the call to 'prefetch_related', we can call the 'select_related' to load the collection of each product. 

queryset = Product.objects.prefetch_related('promotions').select_related('collection').all()


SQL: 

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER JOIN store_collection ON (store_product.collection_id = store_collection.id)

SELECT (store_product_promotions.product_id) AS _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount FROM store_promotion INNER JOIN store_product_promotions ON (store_promotion.id = store_product_promotions.promotion_id) WHERE store_product_promotions.product_id IN(2,3,12........)

we have two queries. The first query is to read the products and their collection. So, there we have a join between product and collection. And the second query is to read the promotions of all these products.






Note on what is 'store_product_promotions':
-------------------------------------------
store_product_promotions is a junction table (also known as a many-to-many relationship table) that Django automatically creates when a Many-to-Many relationship exists between two models.



Why Does Django Create store_product_promotions?

In your Django model:
class Product(models.Model):
    title = models.CharField(max_length=255)
    promotions = models.ManyToManyField(Promotion)

The ManyToManyField between Product and Promotion means each product can have multiple promotions, and each promotion can apply to multiple products.
Since relational databases do not support direct Many-to-Many relationships, Django automatically creates an intermediate table (store_product_promotions) to link Product and Promotion.



What Does store_product_promotions Contain?
It consists of two ForeignKey columns:
product_id ‚Üí Links to the store_product table.
promotion_id ‚Üí Links to the store_promotion table.


üìå Structure of store_product_promotions:
product_id	promotion_id
1	            2
1	  			3
2				1
3				2
4				1




How Django Prefetches Related Objects?
üìå SQL Query Explanation:

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price 
FROM store_product;
‚úÖ First, fetches all products.

SELECT store_product_promotions.product_id AS _prefetch_related_val_product_id, 
       store_promotion.id, store_promotion.description, store_promotion.discount
FROM store_promotion 
INNER JOIN store_product_promotions ON store_promotion.id = store_product_promotions.promotion_id 
WHERE store_product_promotions.product_id IN (1,2,3,4,5,6,7,8,9,10...);
‚úÖ Then, fetches all related promotions, linking them via store_product_promotions. 
‚úÖ This avoids extra queries per product, optimizing database performance.


üöÄ In Summary: ‚úî store_product_promotions is a junction table that Django creates for Many-to-Many relationships. ‚úî Used to link Product and Promotion efficiently in queries. ‚úî Prefetching loads related objects in batches, improving performance compared to individual queries.





Exercise: 
---------
I want you to write a query to get the last five orders with their customer and items, including the product reference in each order item. 

First we want to get a list of orders. So, we should start with the order class. Then we go to Objects. Now we want to preload these orders with their customer. So, this is where we call select related to preload the customer field. Now we don't want to show all the orders, we want to show the last five orders. Hence, we need to sort them by 'placed_at' in descending order. So that latest orders come first. And then we use array slicing syntax to pick the top five orders. 
 
queryset = Order.objects.select_related('customer').order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

So, we have a single query to read the orders along with their customers. So, we are selecting all the columns from the order table, followed by all the columns from the customer table. And we have a join operation between order and customer tables. Great. So let's move on to the next step.



Now we should preload the items of these orders. So, here we can call prefetch_related because each order can have many items. Now, to know the name of the field we're going to query, you have a quick look at our Order class. 


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)


So, each order has three fields 'placed_at', 'payment status' and 'customer'. But we don't have a field called 'items', but when you look at the OrderItem class, there we have 'order' field, which is a foreign key to Order. So, Django is going to create the reverse relationship for us. And the relationship name as you know, would be 'orderitem_set'. This is the convention that Django uses to create the reverse relationship. If you don't like this name, you can always set it using the 'related_name' argument. 


queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set').order_by('-placed_at')[:5]

SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

Nothing much, we have one extra query to load the order items. So, we're loading the order items for the Orders in this list. 


So, everything is fine so far Now the last step is to load the products referenced in each order item. So, over where we are prefetching the order item, we can span the relationship by adding two underscores, and then we can type the name of the target field, which is 'product'. 

queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set__product')order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product WHERE store_product.id IN (166, 780, 976, 505, 219)

Now we have one more extra query to read the products referenced in the order items. So, we are reading all the columns from the product table where the product id is in the list(166, 780, 976, 505, 219). And this list is the list of order items we have queried so far. 

So this is how I want you to write code. Write a little bit of code, test your code, make sure everything works before doing a big step. 
With this technique, we can prevent a lot of crazy issues down the road.











Aggregating Objects:
--------------------

Sometimes you want to compute summaries like max or average price of our products. This is where we use the 'aggregate' method.

So, let's say we want to count our products. Here we create a count object and specify the field we want to use for counting. If we use ID, we can count the total number of products because every product has an ID, right?. But if we use a different column, let's say 'description', and assume that description can be NULL, this will count the number of products that have a description, okay? 

So the proper way to count the total number of records to use the ID or the primary key field. Now the aggregate method doesn't return a query set because once we calculate a summary value, it doesn't really make sense to do anything extra with it. We're not gonna add filters or sort data and so on. 


from django.db.models.aggregates import Count, Max, Min, Avg, Sum

result = Product.objects.aggregage(Count('id')) #returns a dictionary

	
while rendering in the UI part: {id__count : 1000}


The reason for the name 'id__count' is because we use the 'id' column for counting objects. 

We can also change the name of this key if we want to, by passing the keyword arguments
result = Product.objects.aggregage(count = Count('id')) 

#in UI --> {'count': 1000}


Now we can also calculate multiple summaries. So, in addition to the total number of products, We can also calculate the minimum price of our products. 

result = Product.objects.aggregage(count = Count('id'), min_price=Min('unit_price'))

#in UI --> {'count': 1000, 'min_price': Decimal('1.06')} 

Since aggregate is one of the methods of querysets, we can also apply it wherever we have a query set. 
So, we can filter our products and pull out the products in our given collection(say collection 1). And then calculate these summaries over that data set.

result = Product.objects.filter(collection__id=1).aggregate(count=Count('id'))


Aggregate Exercises:

#How many orders do we have?
result = Order.objects.aggregate(count=Count('id'))

#How many units of product 1 have we sold?
result = OrderItem.objects.filter(product__id=1).aggregate(units_sold=Sum('quantity'))

#How many orders has customer 1 placed?
result = Order.objects.filter(customer__id=1).aggregate(count=Count('id'))

#What is the min, max and avg price of products in collection 1? 
result = Product.objects.filter(collection__id=3).aggregate(min_price=Min('unit_price'), avg_price=Avg('unit_price'), max_price=Max('unit_price'))	










Annotating Objects:
-------------------

Django ORM provides the annotate() method to add custom attributes to query results dynamically. These attributes are not actual database fields but are computed at runtime.


we cannot go and simply add the value 'True' directly, we would get an error saying QuerySet.annotate() received non-expressions	. 
This error tells us that we cannot pass a Boolean value. We need to pass an expression object. So, in Django, we have this 'Expression' class, which is the base class for all all types of expressions. Derivatives of this class are 'Value', for representing simple values, like a number, a boolean, a string. We have 'F', which you have seen before. Using the F class, we can reference a field in the same or another table, right? So an F object is essentially an expression object. We also have 'Func' for calling database functions. So, all these database engines have a bunch of functions for manipulating data. To call those functions, We use a 'Func' object. We also have Aggregate, which is the Base class for all Aggregate classes. So those aggregate classes you learn about, like Count,sum, max, min.  All these classes derived from the aggregate class.

Expression 
	Value
	F
	Func
	Aggregate



1. Basic Annotation with Value()
To add a static field to query results, use Value():

üìå Add a field is_new with a constant value True:
from django.db.models import Value

queryset = Customer.objects.annotate(is_new=Value(True))
‚úÖ Result: Adds a column called is_new to every customer with value True.

üìå Generated SQL Query:
SELECT id, first_name, last_name, TRUE AS is_new FROM store_customer;
üöÄ Note: The boolean True is stored as 1 in the database.


‚ùå Error if we use a raw Boolean:
queryset = Customer.objects.annotate(is_new=True)  # ‚ùå Causes an error
Django requires expressions, not raw values‚Äîhence the need for Value(True).




2. Referencing Existing Fields Using F()
To reference another field in the model, use F().

üìå Add a field new_id, duplicating the existing id field:
from django.db.models import F

queryset = Customer.objects.annotate(new_id=F('id'))
‚úÖ Result: new_id is identical to id.

üìå Generated SQL Query:
SELECT id, first_name, last_name, id AS new_id FROM store_customer;

üìå Perform a Calculation on id:
queryset = Customer.objects.annotate(new_id=F('id') + 1)
‚úÖ Result: new_id = id + 1.

üìå Generated SQL Query:
SELECT id, first_name, last_name, id + 1 AS new_id FROM store_customer;

üöÄ Use Case:
F() allows dynamic field computations without needing to fetch data into Python memory.




3. Other Expression Classes in Django
Django provides other expression types for more advanced annotations:

Value() ‚Üí Wraps static values.
F() ‚Üí References existing fields.
Func() ‚Üí Calls database functions.
Aggregate() ‚Üí Performs aggregations (Count(), Sum(), etc.).



Key Takeaways
‚úî Use annotate() to add computed fields to queries. ‚úî Use Value() for static values. ‚úî Use F() to reference existing model fields dynamically. ‚úî Perform computations directly in the query (F('field') + 1). ‚úî Avoid passing raw values‚Äîalways wrap them in expression objects.

üöÄ Next Lesson: Using Func() for database functions in annotations!















Calling Database Functions: 
---------------------------

Alright, now let's see how we can call a database function. So,from the same module, we're need to import the Func class. Now we're going to give our customers a new field called 'full_name'. And this is where we're going to call the CONCAT function of a database engine. So, pretty much all database engines have this function for concatenating strings. So, we have to create a 'Func' object and give it a bunch of arguments. Just remember that can we reference fields using the F objects. Next we need to give a keyword argument that specifies the target function. So, we set function to 'CONCAT'. We also need to add a space in between and we cannot simply pass a white space. We need to pass an expression object. So, we need to wrap this inside a value object.

from django.db.models import Value, F, Func

queryset = Customer.objects.annotate(full_name = Func(('first_name'), Value(' '), F('last_name'), function = 'CONCAT')
 #Here concat is the concat function database engine

SQL: SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership CONCAT(store_customer.first_name, '', store_customer.last_name) AS full_name FROM store_customer



Great. Now, there is also a shorthand to achieve the same result. we're going to import the CONCAT class from Django. Remember to add a white space, we need to wrap it inside a 'Value' object otherwise Django thinks this is a column in our table. 


from django.db.models.functions import Concat

queryset = Customer.objects.annotate(full_name = Concat('first_name', Value(' '), 'last_name'))



Now, if you're curious about Django database functions, just Google 'Django database functions' 
https://docs.djangoproject.com/en/5.1/ref/models/database-functions/

On this page. You can see various functions in different categories. For example, we have a bunch of functions for working with dates, we have mathematical functions. We have functions for manipulating text and so on. These functions are common across all database engines, but different database engines have their own unique functions. So, to call those functions you have to go back and use a 'Func' object.













Grouping Data:
--------------

Now let's say we want to see the number of orders each customer has placed. So we're going to annotate our customers with a new field called 'orders_count'. For that we are going to use the count class.


from django.db.models import Value, F, Funct, Count


Now if you look at Customer and Order class


class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)



When you look at the order class, we have customer field, which is a foreign key. And with this implementation, Django is going to create the reverse relationship for us. So, in the customer class, we're gonna have a field called 'order_set'(the singular name of the target class followed by '_set' and this all should in lowercase). 
Now, for some reason that is known to Django developers, we cannot use the same, to count the number of orders for each customer, which means  

if you use,
queryset = Customer.objects.annotate(orders_count=Count('order_set'))

we get an exception saying "cannot resolve keyword order_set into field. Our choices are address, birth_date, email, first_name, id, last_name, membership, order, phone." 



So, the name of the field that we should use for counting is 'order'. Why? Honestly, I don't know. So back to our code, let's change it to 'order'. 

queryset = Customer.objects.annotate(orders_count=Count('order'))

SQL:
SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership, COUNT(store_order.id) AS orders_count FROM store_customer LEFT OUTER JOIN store_order ON (store_customer.id =  store_order.customer_id) GROUP BY store_customer.id ORDER BY NULL

So in the SQL,  we are selecting all the fields from the customer table, and we're also counting the number of orders. Now look, we have a left join between customers and orders, because not every customer has an order. And finally we have, a group by clause for grouping the number of orders for each customer.



üöÄ Reason:
order_set is only available for direct queries on Customer objects, but not in ORM aggregation methods like annotate().
Instead of order_set, Django ORM refers to the related model name (order) when counting instances.

üìå Correct Query:
queryset = Customer.objects.annotate(orders_count=Count('order'))

‚úÖ This ensures orders_count is calculated properly.













Working with Expression Wrappers:
---------------------------------




So, let's quickly recap what you have learned so far. We talked about the Expression class, which is the base class for all types of expressions. Derivatives of this class are 'Value' for representing simple values like a boolean, a number, a string. We have 'F' for referencing fields, 'Func' for calling database functions, 'Aggregate', which is the base class for all aggregate classes like count, sum, and so on. Now in this lesson, we're going to talk about another derivative of the Expression class called ExpressionWrapper. We use this class when building complex expressions. 

Expression 
	Value
	F
	Func
	Aggregate
	ExpressionWrapper



Let's do an example and check an error: 
queryset = Product.objects.annotate(discounted_price=F('unit_price') * 0.8)


So, here's an example. Let's say we're going to annotate our products and give them a new field called discounted_price. So here we're going to get the unit price and multiply it by 0.8. 

Now, if we run it, we're going to get an exception. So we get this error saying "FieldError: Expression contains mixed types: DecimalField, FloatField. you must set output_field." Here because we have mixed decimal field, which is our unit price field, with a float field, which is our 0.8 number. Now the error is saying that we must set the output field. 


So, to solve this problem, first we need to import the ExpressionWrapper class from the same module. Then we should wrap the expression inside an ExpressionWrapper object, and that's where we specify the type of the output field. As the second argument to the constructor of the ExpressionWrapper class, we specify the output field. So, we need to decide what is the type of the output field. For monetary values, we should always use a decimal field, because float fields have rounding issues and are not very accurate. 

from django.db.models import Value, F, ExpressionWrapper

dicounted_price = ExpressionWrapper(F('unit_price') * 0.8, output_field = DecimalField())
queryset = Product.objects.annotate(dicounted_price = discounted_price)


SQL: select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, (store_product.unit_price * 0.8e0) AS discounted_price FROM store_product


More exercises with ExpressionWrapper:

# customers and their last order ID
queryset = Customer.objects.annotate(last_order_id=Max('order__id'))

# collections and count of their products
queryset = Collection.objects.annotate(products_count=Count('product'))

# Customers with more than 5 orders
queryset = Customer.objects.annotate(orders_count=Count('order')).filter(orders_count__gt=5)



# Customers and the total amount they've spent
queryset = Customer.objects.annotate(total_spent=Sum(F('order__orderitem__unit_price') * F('order__orderitem__quantity')))

from django.db.models import Sum, F, ExpressionWrapper, DecimalField

total_spent = ExpressionWrapper(
    Sum(F('order__orderitem__unit_price') * F('order__orderitem__quantity')),
    output_field=DecimalField()
)

queryset = Customer.objects.annotate(total_spent=total_spent)




# Top 5 best-selling products and their total sales
queryset = Product.objects.annotate(total_sales=Sum(F('orderitem__unit_price') * F('orderitem__quantity'))).order_by('-total_sales')[:5]


total_sales = ExpressionWrapper(
    Sum(F('orderitem__unit_price') * F('orderitem__quantity')),
    output_field=DecimalField()
)

queryset = Product.objects.annotate(total_sales=total_sales).order_by('-total_sales')[:5]



üöÄ Why Use ExpressionWrapper?
Ensures Django treats computed values correctly (e.g., decimal types).
Useful for complex calculations within annotations.












Querying Generic Relationships:
-------------------------------
Django‚Äôs content type framework allows models to relate dynamically to multiple models, making them more reusable. This is useful for tagging systems where a TaggedItem model can associate tags with different models (e.g., products, articles, blog posts).

1. Understanding Content Types and Generic Relationships:
Content Type Table:
Django maintains a table called django_content_type, which contains metadata about all models in the project.

üìå Example Entries in django_content_type:
id	app_label	model
1	admin	logentry
2	auth	user
11	store	product

‚úÖ Each model has a unique content_type_id. 
‚úÖ The Product model‚Äôs content type ID is 11, meaning Django refers to it internally with this ID.





2. Finding Tags for a Given Product

üìå Steps to Query Tags for a Product:
1. Find the content type ID for the Product model.
2. Use that ID to filter TaggedItem records where:
	content_type_id = Product‚Äôs content type ID
	object_id = Product‚Äôs ID

üìå Implementation:
from django.contrib.contenttypes.models import ContentType
from store.models import Product
from tags.models import TaggedItem

# Get the content type ID for the Product model
content_type = ContentType.objects.get_for_model(Product)

# Filter TaggedItem objects for a specific product
queryset = TaggedItem.objects.select_related('tag').filter(
    content_type=content_type,
    object_id=1  # Replace with dynamic product ID
)


üöÄ Why Not Hardcode content_type_id = 11?
The ID may differ in production versus development databases.
get_for_model(Product) dynamically retrieves the correct ID.



üìå SQL Query Generated:
SELECT django_content_type.id, django_content_type.app_label, django_content_type.model
FROM django_content_type
WHERE (django_content_type.app_label = 'store' AND django_content_type.model = 'product')
LIMIT 21;

‚úÖ Finds the content type ID for the Product model.





3. Optimizing the Query with select_related()
Since TaggedItem refers to Tag, we need to preload the tag field to avoid extra queries.

üìå Optimized Query Using select_related()

queryset = TaggedItem.objects.select_related('tag').filter(
    content_type=content_type,
    object_id=1
)

üöÄ Ensures only ONE query is sent, instead of separate queries for each tag lookup.


üìå SQL Query Generated:
SELECT tags_taggeditem.id, tags_taggeditem.tag_id, tags_taggeditem.content_type_id, tags_taggeditem.object_id,
       tags_tag.id, tags_tag.label
FROM tags_taggeditem
INNER JOIN tags_tag ON (tags_taggeditem.tag_id = tags_tag.id)
WHERE (tags_taggeditem.content_type_id = 11 AND tags_taggeditem.object_id = 1);

‚úÖ Uses INNER JOIN to fetch tag labels in a single query.




Key Takeaways
‚úî Use Django‚Äôs content type framework to decouple models dynamically. 
‚úî Use get_for_model(Product) instead of hardcoded IDs to ensure correct lookup. 
‚úî Use select_related('tag') to optimize queries when fetching related objects. 
‚úî Format long ORM queries using \ for better readability.

üöÄ Next Lesson: Creating a custom manager to simplify generic relationships in Django ORM.














Custom Managers:
================

Django allows us to create custom managers to extend the functionality of model queries. This improves code reusability and ensures cleaner, more efficient queries.

1. The Problem: Querying Generic Relationships Manually

Previously, to find tags for a given product, we had to:
1. Retrieve the content type ID for the Product model.
2. Query the TaggedItem table using this ID.
3. Use select_related('tag') to optimize queries.

üöÄ This approach worked but was repetitive‚Äîevery time we needed tags, we had to write the same logic manually.




2. Solution: Creating a Custom Manager for TaggedItem
A custom manager allows us to: ‚úî Encapsulate the query logic in a reusable method. ‚úî Call TaggedItem.objects.get_tags_for(product) instead of writing complex queries manually.


Step 1: Creating a Custom Manager
üìå Define a new manager in tags/models.py:

from django.db import models
from django.contrib.contenttypes.models import ContentType

class TaggedItemManager(models.Manager):
    def get_tags_for(self, obj_type, obj_id):
        content_type = ContentType.objects.get_for_model(obj_type)

        return TaggedItem.objects \
            .select_related('tag') \
            .filter(
                content_type=content_type,
                object_id=obj_id
            )



So, this class 'TaggedItemManager' is inheriting from the 'Manager' class in the 'models' module. So, the 'models.Manager' class is the base class for all Managers.

‚úÖ What This Manager Does:
Retrieves the content type ID for the given model (obj_type).
Queries TaggedItem.objects filtering by content type & object ID.
Uses select_related('tag') to optimize queries and fetch tags efficiently.


Step 2: Assigning the Custom Manager to the Model
üìå Use the custom manager in TaggedItem:

class TaggedItem(models.Model):
    objects = TaggedItemManager()  # Assign the custom manager

    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()

‚úÖ This replaces Django's default manager with TaggedItemManager.

Now, instead of manually querying for tags, we can simply call:
TaggedItem.objects.get_tags_for(Product, 1)  # Fetch tags for Product ID 1
üöÄ Cleaner and more reusable!





3. Query Execution Behind the Scenes
üìå Generated SQL Query:
SELECT tags_taggeditem.id, tags_taggeditem.tag_id, tags_taggeditem.content_type_id, tags_taggeditem.object_id,
       tags_tag.id, tags_tag.label
FROM tags_taggeditem
INNER JOIN tags_tag ON tags_taggeditem.tag_id = tags_tag.id
WHERE tags_taggeditem.content_type_id = 11 AND tags_taggeditem.object_id = 1;

‚úÖ Uses INNER JOIN for efficient retrieval of related tags. ‚úÖ Ensures optimized querying for better database performance.



Key Takeaways
‚úî Custom managers improve code maintainability by centralizing query logic. 
‚úî get_tags_for() makes querying tags simple and removes repetitive code. 
‚úî Assign TaggedItemManager() to TaggedItem.objects to use the custom method. 
‚úî Optimized queries using select_related('tag') reduce extra database hits.

üöÄ Next Step: Implementing further custom managers for different query optimizations!















Understanding QuerySet:
-----------------------

Let's talk about the caching mechanism built into query sets.

queryset = Product.objects.all()

list(queryset)

queryset[0]

Now, you know that when we convert the queryset into a list, Django is going to evaluate the query set and that's when it's going to go to the database to get the result. Now, this is an expensive operation because reading data from the disk is always slower than reading it from the memory. So, when Django evaluates this query and gets the data from the database and it's going to store it somewhere in memory called the query set cache. So, the second time we convert the query set in to a list(say again list(queryset)), Django is not going to evaluate thhe query again. 
It's not going to go to the database. It's going to read the result from the query set cache. Now the same thing happens if you access an individual element from this query set. Again, Django is going to read this object from the query set cache. Now one thing you need to know about caching is that caching happens only if you evaluate the entire query set first. In contrast, if you accessed an individual element first(say queryset[0]), then converting our queryset into a list. you would end up with two queries to the database. 



SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product LIMIT 1

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product


We have two queries now, with the first query, we are reading the first product in the product table. And with the second query we're reading all our products. So keep this in mind. Even though caching is a great optimization technique, if you don't structure your code properly, Caching is gonna cost us. So this is all about caching. Next we're going to talk about creating objects.











Creating Objects:
-----------------

collection = Collection()
collection.title = 'Video Games'
collection.featured_product = Product(pk=1) or Product(id=1) #when you use pk, you don't have to remember what is the primary key name
collection.featured_product_id = 1 


Either way, the product should exists before we can create this collection. In other words, we cannot create this collection and this product(product 1) at the same time. And this is how the relational databases work, the parent record should exists before we create child record. 

 or 
 
collection = Collection(title='Video Games') --> this approach won't give IntelliSense
collection.save()


Hence dot operator (.) gives you the intellisense, but the keyword argument doesn't
Also in future if you have changed the field name, it will get reflected with the dot operator, but not with the keyword argument


collection = Collection.objects.create(name = 'a', featured_product_id = 1) # it will the call the save method automatically 

But again, intellisense doesn't work here and would not get updated if we have changed the field name 













Updating Objects: 
-----------------
Updating objects in Django requires careful handling to avoid unintended data loss. There are two main approaches: 
‚úî Updating an instance directly (recommended for selective updates). 
‚úî Using the update() method (useful for bulk updates, but requires caution).


1. Directly Updating an Instance
üöÄ Best practice: Retrieve the object from the database before modifying fields.

üìå Steps to update a collection:
collection = Collection.objects.get(pk=11)  # Fetch collection from DB
collection.title = 'Games'  # Modify title
collection.featured_product = None  # Modify featured product
collection.save()  # Save changes

‚úÖ Ensures all existing field values are preserved before updating.

üìå Generated SQL Query:
UPDATE store_collection 
SET title = 'Games', featured_product_id = NULL 
WHERE id = 11;


üõë Potential Issue: If we only want to update particular field instead of everything (say only the 'featured_product'):

collection = Collection(pk=11)  # Creates an empty instance, missing database values!
collection.featured_product = None  
collection.save()  # ‚ùå Data loss (title overwritten to empty string!)

üö® Why?
Django will set the Unset fields (like title) to some default to empty values and this causes data loss. 

Here's the reason. This collection object that we have in memory, by default, its 'title' is set to an empty string. So even if we don't explicitly update this field, Django is going to include it in our SQL statement. 
And this is where Django is different from some of the other ORMs you might have worked with. Some other ORMs out there have this feature called 'change tracking'. So, the SQL statement that is generated will be based on the fields that are updated. So, to properly update an object in Django applications, first we have to read it from the database. 


‚úÖ Solution: Always use .get() to fetch the existing record first!

collection = Collection.objects.get(pk=11)  
collection.featured_product = None  
collection.save()  





2. Updating Fields Without Reading the Object (update())
Django‚Äôs update() method allows updating database records without fetching them first.

üìå Steps to update a specific field without loading the object:
Collection.objects.filter(pk=11).update(featured_product=None)

‚úÖ Optimized: Avoids retrieving the object first. 

‚úÖ Generated SQL Query:
UPDATE store_collection 
SET featured_product_id = NULL 
WHERE id = 11;

The update() method directly modifies database records without loading model instances into memory.

üöÄ Use Case: ‚úî Works well when updating only one or a few fields on multiple records. ‚úî Should not be used if additional logic (e.g., validation, pre-save hooks) is needed.




3. When to Use Each Approach?
             	
.get() + save()	        
Best Use Case:
Selective updates, where maintaining existing field values is critical	

Avoid When:
Fetching unnecessary data for bulk updates


.update()
Best Use Case:	
Fast, direct updates to one or multiple fields
	
Avoid When:
When signals, hooks, or validation are needed



üöÄ Rule of Thumb: 
‚úî Use .get() + save() for individual object updates where all fields matter. 
‚úî Use .update() for bulk field modifications where only certain fields need updating.

Key Takeaways
‚úî Always use .get(pk=ID) before modifying fields to prevent unintended data loss. 
‚úî Use update() to modify specific fields directly, avoiding unnecessary queries. 
‚úî Avoid using Collection(pk=ID) for updates‚Äîit creates an empty instance, causing overwrites. 
‚úî Choose the right method (save() vs. update()) based on need and efficiency.








Deleting Objects:
-----------------

We can delete a single object or multiple objects in a query set. 

To delete a single object: 
collection = Collection(pk=11)
collection.delete()


Now to delete multiple objects, first we need to get a query set:
Collection.objects.filter(id__gt=5).delete()



Exercise: 

Creating, Updating and Removing Objects

write code to 
create a shopping cart with an item 
Update the quantity of an item in a shopping cart 
Remove a shopping cart with its items. 


Solutions: 
cart = Cart()
cart.save()

item1 = CartItem()
item1.cart = cart
item1.product_id = 1
item1.quantity = 1
item1.save()

#Updating the quantity of an item
item1 = CartIem.objects.get(pk=1)
item1.quantity = 2
item1.save()

#Removing a cart 
cart = Cart(pk=1) 
cart.delete()
# Because we've enabled cascading in the relationship between 
# cart and its items, deleting a cart automatically causes 
# deletion of its items. So, we don't need to delete each item
# individually 












Transactions:
-------------

Transactions ensure atomicity, meaning multiple database operations succeed together or fail together. This prevents data inconsistency when inserting related records like orders and order items.

1. Why Use Transactions?
üìå Problem:
When creating an order, we first insert the order record and then its associated order items.
If saving an order item fails, the order gets inserted without its items‚Äîcausing data inconsistency.

üìå Solution: ‚úî Wrap all dependent operations inside a transaction using transaction.atomic(). ‚úî If any operation fails, all changes get rolled back, preventing incomplete data.




2. Implementing Transactions in Django
Step 1: Import Transaction Module
from django.db import transaction

üìå Django‚Äôs transaction.atomic() ensures all database operations within it succeed together.

Step 2: Creating an Order and Order Item Safely
with transaction.atomic():  # Start a transaction
    order = Order(customer_id=1)  # Create an order
    order.save()  # Save the parent record first
    
    order_item = OrderItem(order=order, product_id=5, quantity=2, unit_price=50)  
    order_item.save()  # Save the child record

‚úÖ If saving order_item fails, order won't be saved.

üìå Generated SQL Query (If Successful):
INSERT INTO store_order (customer_id) VALUES (1);
INSERT INTO store_order_item (order_id, product_id, quantity, unit_price) VALUES (1001, 5, 2, 50);

üö® Preventing Data Loss:
If an exception occurs, all changes are rolled back, avoiding partial inserts.




3. Using transaction.atomic() as a Decorator:
Instead of wrapping operations manually, apply @transaction.atomic at the view level:
@transaction.atomic
def place_order(request):
    order = Order(customer_id=1)
    order.save()

    order_item = OrderItem(order=order, product_id=5, quantity=2, unit_price=50)
    order_item.save()
‚úÖ Ensures atomicity across the entire view function.





4. Demonstrating Rollback on Failure
üìå Example: Trying to Save an Invalid Order Item
with transaction.atomic():
    order = Order(customer_id=1)
    order.save()

    order_item = OrderItem(order=order, product_id=-1, quantity=2, unit_price=50)  
    order_item.save()  # ‚ùå Error: Product ID -1 does not exist!


üö® Integrity Error Occurs ‚Üí Transaction Rolls Back
IntegrityError: FOREIGN KEY constraint failed
‚úÖ Query rollback prevents the orphaned order from being saved.

üìå Verifying the Database:
SELECT * FROM store_order ORDER BY id DESC;  -- No new order is inserted




5. When to Use Transactions?
‚úî Multiple related inserts (e.g., orders and items). 
‚úî Bulk updates requiring consistency (e.g., updating product stock after purchase). 
‚úî Preventing incomplete data on errors.



üöÄ Key Takeaways 
‚úî Use transaction.atomic()  as a context manager to ensure multiple operations succeed together or fail together. 
‚úî If one operation fails, all changes are rolled back to maintain consistency. 
‚úî Can be used as a decorator for entire views (@transaction.atomic). 
‚úî Always test transactions by simulating failures (e.g., invalid foreign keys).













Executing Raw SQL Queries: 
--------------------------
Django ORM provides powerful query capabilities, but sometimes certain queries become overly complex using ORM filters and annotations. In such cases, you can execute raw SQL queries directly.

1. Using .raw() to Execute Raw SQL Queries
Django allows executing raw queries using the .raw() method.

üìå Example: Fetch all products using raw SQL
queryset = Product.objects.raw('SELECT * FROM store_product')

‚úÖ Result: Django executes the query and maps the retrieved columns to model fields. 
‚úÖ Returns a special raw query set, which does not support methods like .filter() or .annotate().

üìå Generated SQL Query:
SELECT * FROM store_product;

üöÄ When to Use .raw()? 
‚úî When Django ORM cannot efficiently generate complex queries. 
‚úî When manually writing SQL is more readable or performs better than the django generated one. ‚úî When optimizing database queries for speed.




2. Limiting Columns to Improve Performance
Instead of selecting all fields, specify only necessary columns:
queryset = Product.objects.raw('SELECT id, title FROM store_product')
‚úÖ Django loads only id and title, while other fields remain deferred (not fetched unless needed).

üìå Generated SQL Query:
SELECT id, title FROM store_product;
üöÄ Use Case: ‚úî Reduces memory usage and speeds up queries by fetching only required fields.




3. Using connection.cursor() for Full SQL Control
Sometimes, raw queries do not map directly to Django models. In such cases, access the database directly using connection.cursor().

üìå Example: Executing arbitrary SQL queries
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SELECT COUNT(*) FROM store_product")
    result = cursor.fetchone()  # Fetch single result
‚úÖ Allows executing SELECT, INSERT, UPDATE, DELETE, or any SQL operation. ‚úÖ Using with ensures cursor closure, preventing memory leaks.

üöÄ Advantages of Using connection.cursor() ‚úî Provides full SQL control, bypassing Django models. ‚úî Supports transaction handling and direct interactions with the database. ‚úî Helps in executing complex queries that ORM cannot handle efficiently.




4. Using Stored Procedures in Django
Django supports calling stored procedures using .callproc().

üìå Example: Executing a stored procedure
cursor.callproc('get_customers', [1, 2])  # Calls stored procedure with parameters

‚úÖ Encapsulates SQL logic inside stored procedures, making Python code cleaner. 
‚úÖ Optimizes performance when complex queries are frequently used.

üöÄ Best Practice: ‚úî Store complex query logic inside stored procedures, instead of writing SQL statements inside Python scripts.



Key Takeaways
‚úî Use .raw() for raw SQL queries, but only when ORM becomes inefficient. 
‚úî Specify only required columns to improve query performance. 
‚úî Use connection.cursor() for full database control (SELECT, INSERT, UPDATE, DELETE). 
‚úî Prefer stored procedures for reusable SQL logic, avoiding hardcoded queries. 
‚úî Always use the with statement with cursor to prevent memory leaks.


üöÄ Next Lesson: Exploring Django‚Äôs admin interface!















The Admin Site:
---------------

Here in this section we're gonna talk about setting up the admin interface for managing our data. 
We'll talk about various ways to customize the admin interface, how to add computed columns, load related objects, add searching and filtering, implement custom actions, add data validations and more. 
So by the end of this section, we'll have a full fledged admin interface for managing our data


Setting Up the Admin Site:
---------------------------
Django provides a built-in admin interface that allows managing users, models, and permissions efficiently. Below is a step-by-step guide to setting it up.

1. Accessing the Admin Panel
The Django admin interface is available at:

http://localhost:8000/admin
On first access, it shows the login screen.




2. Creating a Superuser for Admin Access
To log into the admin panel, create a superuser using the following command in the terminal:

python manage.py createsuperuser
You will be prompted for:

Username ‚Üí Example: admin
Email ‚Üí Example: admin@example.com
Password ‚Üí Example: 123123 (you may need to bypass security warnings by pressing Y)

‚úÖ Once created, you can log in using these credentials.




3. Fixing Session Errors
If the session app is missing, Django‚Äôs admin login may fail.

üìå Solution: Ensure django.contrib.sessions is added in INSTALLED_APPS in settings.py:

INSTALLED_APPS = [
    'django.contrib.sessions',
    # other installed apps...
]
‚úÖ After adding a new app, always run migrations to create necessary tables:


python manage.py migrate
üöÄ This creates the django_session table for session storage.





4. Exploring the Admin Dashboard
Once logged in:
Manage users and groups stored in Django‚Äôs auth tables.
Superuser permissions grant full access.
User passwords are stored in encrypted format.

üìå View user records in the database:

SELECT * FROM auth_user;
‚úÖ Displays admin user details, including login history and permissions.




5. Resetting Admin Password
If you forget your password, reset it using:

python manage.py changepassword admin
‚úÖ Allows setting a new password for the admin user.




6. Customizing the Admin Interface
You can personalize the admin site header and title.

üìå Modify admin.py or add customization in urls.py:
from django.contrib import admin
admin.site.site_header = "Storefront Admin"  # Custom header
admin.site.index_title = "Admin Dashboard"  # Custom title

‚úÖ Refresh the admin page to see updated branding.




Key Takeaways
‚úî Use createsuperuser to set up admin credentials. ‚úî Always run migrations after adding new apps. ‚úî Check django_session table to verify session functionality. ‚úî Use changepassword if admin credentials are lost. ‚úî Customize the admin branding using site_header and index_title.

üöÄ Next Lesson: Registering models in the Django admin panel!













Registering Models:
-------------------
Django's admin interface allows us to manage models from a graphical interface instead of running database commands manually. To make models accessible in the admin panel, we need to register them.



1. Registering Models in Django Admin
Each Django app has an admin.py module, where we configure which models appear in the admin panel.

üìå Steps to Register the Collection Model:
1. Open the store/admin.py file.
2. Import Django‚Äôs admin module and the models.
3. Register models using admin.site.register().

üìå Code Example:
from django.contrib import admin
from .models import Collection  # Import the model

admin.site.register(Collection)  # Register Collection in the admin panel

‚úÖ Once registered, Django lists the model in the admin panel.

üìå After refreshing localhost:8000/admin, you'll see "Store" with "Collections" listed.





2. Changing Object Representation in Admin Panel
By default, Django displays object instances as "Collection object" in the admin panel. To improve readability, override the __str__ method in the model.

üìå Modify Collection Model (models.py):
class Collection(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Show collection title in admin panel

‚úÖ Now, Django will display the collection name instead of "Collection object".






3. Sorting Objects in Admin Panel
By default, models are displayed unsorted in the admin panel. To sort collections alphabetically, define a Meta class inside the model.

üìå Modify Collection Model (models.py):
class Collection(models.Model):
    title = models.CharField(max_length=255)

	def __str__(self):
		return self.title
	
    class Meta:
        ordering = ['title']  # Sort collections alphabetically

‚úÖ All collections in the admin panel will now be ordered alphabetically.





4. Registering the Product Model in Admin
Follow the same process to register products in the admin panel.

üìå Modify admin.py to include Product:
from django.contrib import admin
from .models import Collection, Product  # Import both models

admin.site.register(Product)  # Register Product


üìå Modify Product Model (models.py):
class Product(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Show product title instead of "Product object"

    class Meta:
        ordering = ['title']  # Sort products alphabetically

‚úÖ Now, products will be listed in the admin panel and sorted by title.



Note:
Fixing Empty Collection Titles
- sometimes if a collection was mistakenly saved with an empty title, it will appear blank in the admin panel.
- We can delete such entries manually from the admin interface.



Key Takeaways
‚úî Use admin.site.register(ModelName) to register models in Django admin. 
‚úî Override __str__ in models to display meaningful names in the admin panel. 
‚úî Use the Meta class inside models to define default ordering. 
‚úî Register multiple models (Collection, Product, etc.) to manage them in the admin panel easily.

üöÄ Next Lesson: Customizing the Django admin list page!











Customizing the List Page:
--------------------------
Customizing the Django Admin List Page
Django's admin interface allows customization for how models are displayed and managed. You can add columns, make fields editable, control pagination, and define sorting behavior.


1. Creating a Custom Admin Class
Instead of using default settings, create a custom admin class for each model.

üìå Example: Customizing the Product model in admin.py
from django.contrib import admin
from .models import Product, Customer

@admin.register(Product)  # Alternative to admin.site.register(Product, ProductAdmin)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price']  # Display fields in the list view
    list_editable = ['unit_price']  # Allow editing unit price directly in the list view
    list_per_page = 10  # Show 10 products per page
    ordering = ['title']  # Sort products alphabetically by title


So, we are saying that the 'ProductAdmin' class is the admin model for the 'Product' class.  

	
‚úÖ Once registered, you can view and edit Product models in the admin panel.

üìå Generated SQL Query Example:
SELECT id, title, unit_price FROM store_product ORDER BY title LIMIT 10;

‚úÖ Ensures products are displayed alphabetically and paginated.




2. Sorting and Pagination in the Admin Panel
‚úî Sorting Columns
Click column headers to sort in ascending/descending order.
Default ordering can be set in ordering.

‚úî Pagination
list_per_page=10 ensures only 10 records are shown per page.
Django automatically generates pagination controls at the bottom.

üìå Example SQL Query for Pagination:
SELECT * FROM store_product ORDER BY title LIMIT 10 OFFSET 10;

üöÄ Optimizes performance by limiting database queries!





3. Creating a Custom Admin Class for Customer
Follow the same process to customize the Customer admin page.

üìå Example: Managing Customer records in admin.py
@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership']  # Show key fields
    list_editable = ['membership']  # Allow inline membership editing
    ordering = ['first_name', 'last_name']  # Default sorting order
    list_per_page = 10  # Show 10 customers per page

‚úÖ Now, customers appear sorted, with membership editable inline.


üìå Generated SQL Query Example:
SELECT id, first_name, last_name, membership FROM store_customer ORDER BY first_name, last_name LIMIT 10;




4. Additional Customization Options
Django provides many ModelAdmin customization attributes. 
To explore more: üîç Search "Django ModelAdmin" documentation: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/

‚úî Other useful options:
search_fields = ['title'] ‚Üí Adds a search bar for filtering records.
list_filter = ['membership'] ‚Üí Adds filter options for refining results.
actions = None ‚Üí Disables batch actions (delete, update).




Key Takeaways
‚úî Use @admin.register(Model) for cleaner admin registration. 
‚úî Define list_display to show relevant fields in the admin table. 
‚úî Use list_editable for inline editing of specific fields. 
‚úî Set ordering to define the default sorting behavior. 
‚úî Limit records per page using list_per_page for performance optimization. 
‚úî Refer to Django‚Äôs ModelAdmin docs for advanced options.

üöÄ Next Lesson: Adding computed columns in the Django admin panel!












Adding Computed Columns:
------------------------
Django allows adding computed columns to the admin list view. Instead of displaying raw field values, we can process the data dynamically and show user-friendly outputs.


1. Defining a Computed Column for Inventory Status:
We want to display an "Inventory Status" column that: 
‚úî Shows "Low" if inventory is less than 10. 
‚úî Shows "OK" otherwise.

üìå Modify admin.py to include a computed column:
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price', 'inventory_status']  # Show computed column

    @admin.display(ordering='inventory')  # Allow sorting by inventory
    def inventory_status(self, product):
        return 'Low' if product.inventory < 10 else 'OK'  # Compute inventory status dynamically

‚úÖ Now, instead of showing raw inventory numbers, Django displays Low or OK.





2. Making Computed Columns Sortable
By default, Django does not know how to sort computed columns. To enable sorting, use the @admin.display(ordering='inventory') decorator.

üìå Sorting Implementation:
@admin.display(ordering='inventory')
def inventory_status(self, product):
    return 'Low' if product.inventory < 10 else 'OK'
	
	
üöÄ Why This Works? 
‚úî Links the computed column (inventory_status) to inventory so sorting behaves correctly. 
‚úî Clicking the column header will sort in ascending or descending order.






3. Viewing Computed Column in Admin Panel

üìå Example Output in Django Admin:
Title	Unit Price	Inventory Status
Laptop	$999	    OK
Phone	$500	    Low
Tablet	$799	    OK

‚úÖ Clickable column headers allow sorting by inventory count.




Key Takeaways
‚úî Use computed columns in Django admin for better readability. 
‚úî Override list_display to include custom methods. 
‚úî Use @admin.display(ordering='inventory') to enable sorting on computed fields. 
‚úî Computed columns dynamically process values, improving clarity for admins.











Selecting Related Objects:
--------------------------
Django‚Äôs admin interface allows displaying related objects in list views. Instead of performing separate queries for related objects, we can optimize data retrieval using select_related.

1. Displaying Related Objects in Admin
To show product collections in the admin panel: üìå Modify list_display in admin.py

list_display = ['title', 'unit_price', 'inventory_status', 'collection']
‚úÖ This adds a "Collection" column to the product list page. ‚úÖ Django will automatically call __str__() from the Collection model to display its title.

üìå Collection Model with __str__() Method
class Collection(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Ensure proper display in the admin panel
		
‚úÖ Admin will show collection names instead of "Collection object".




2. Displaying Specific Fields from Related Models
If you want to display a specific field instead of the __str__() representation: üìå Define a method inside the admin class

def collection_title(self, product):
    return product.collection.title  # Display collection title instead of full object
	
üìå Update list_display
list_display = ['title', 'unit_price', 'inventory_status', 'collection_title']

‚úÖ Ensures that only the title field from Collection is displayed.




3. Reducing Extra Queries Using list_select_related
By default, Django queries related fields separately, increasing the query count. To optimize performance, use list_select_related.

üìå Enable eager loading for related fields
list_select_related = ['collection']

üöÄ What This Does? 
‚úî Reduces extra queries by fetching collection data along with products in a single query. 
‚úî Prevents Django from sending one query per product, improving speed.

üìå Before Optimization (Multiple Queries)
SELECT * FROM store_product;
SELECT title FROM store_collection WHERE id = 1;
SELECT title FROM store_collection WHERE id = 2;

üìå After Optimization (Single Query)
SELECT store_product.id, store_product.title, store_product.unit_price, store_product.inventory, 
       store_collection.title 
FROM store_product 
INNER JOIN store_collection ON store_product.collection_id = store_collection.id;

‚úÖ Efficiently loads related objects using INNER JOIN instead of separate queries.




4. Displaying Orders Along with Customers in Admin

üìå Define an admin class for orders
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'placed_at', 'customer']

‚úÖ Displays order details along with customer names.

üìå Modify Customer model for proper display
class Customer(models.Model):
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"  # Show full name in admin

‚úÖ Ensures customers appear as "John Doe" instead of "Customer object".

üìå Set default ordering inside Customer model
class Meta:
    ordering = ['first_name', 'last_name']

‚úÖ Sorts customers alphabetically by first and last name.

Key Takeaways
‚úî Use list_display to show related fields in admin. 
‚úî Define custom methods (collection_title) for displaying specific fields. 
‚úî Use list_select_related to optimize queries and reduce database calls. 
‚úî Override __str__() in models to customize object display in the admin panel. 
‚úî Set default ordering in Meta class to keep lists sorted properly.












Overriding the Base QuerySet:
-----------------------------
Django‚Äôs admin interface allows customizing how models are retrieved for list views. By overriding the base queryset, we can add computed columns such as counting related objects.

1. Adding a Computed Column for Product Count
üìå Objective:
Show the number of products in each collection inside the admin panel.
Add sorting functionality to the column.

üìå Steps:
Create a custom admin class for Collection.
Define a computed column (products_count) for counting related products.
Override the queryset to annotate collections with their product count.





2. Implementing the Computed Column

Step 1: Register Collection with a Custom Admin Class

üìå Modify admin.py to create CollectionAdmin:
from django.contrib import admin
from django.db.models import Count
from .models import Collection

@admin.register(Collection)  # Register Collection with a custom admin class
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']  # Show title and product count

    @admin.display(ordering='products_count')  # Enable sorting on this column
    def products_count(self, collection):
        return collection.products_count  # Return computed field

‚úÖ Now, the "Products Count" column appears in the admin panel. ‚úÖ Sorting functionality is enabled using @admin.display(ordering='products_count').




3. Overriding the QuerySet to Annotate Data
By default, Collection does not have a products_count field. To compute this dynamically, override get_queryset():

üìå Modify CollectionAdmin to annotate product count:
def get_queryset(self, request):
    return super().get_queryset(request).annotate(
        products_count=Count('product')  # Count related products
    )

üöÄ What This Does? ‚úî Fetches all collections with the number of related products. ‚úî Uses annotate() to attach a computed field (products_count). ‚úî Ensures sorting works properly in the admin panel.

üìå Generated SQL Query:
SELECT store_collection.id, store_collection.title, COUNT(store_product.id) AS products_count
FROM store_collection
LEFT JOIN store_product ON store_collection.id = store_product.collection_id
GROUP BY store_collection.id;

‚úÖ Uses LEFT JOIN to count products while ensuring collections with no products still appear.



4. Sorting the Computed Column
Without explicit sorting, Django doesn‚Äôt know how to sort products_count. üìå Solution: Use @admin.display(ordering='products_count'):
@admin.display(ordering='products_count')
def products_count(self, collection):
    return collection.products_count
‚úÖ This ensures sorting works properly in ascending and descending order.



The entire code looks like: 

@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']
	
	@admin.display(ordering='products_count')
	def products_count(self,collection):
		return collection.products_count
	
	
	def get_queryset(self, request):
	    return super().get_queryset(request).annotate(
		    products_count=Count('product')
		)


Key Takeaways
‚úî Use get_queryset() to override the base queryset and annotate data. 
‚úî Use Count() inside annotate() to compute related object counts dynamically. 
‚úî Use @admin.display(ordering='field_name') to enable sorting on computed columns. 
‚úî Register models with @admin.register(Model) for cleaner admin setup.


















Providing Links to Other Pages:
-------------------------------
Django allows adding hyperlinks inside the admin interface to navigate between pages. This is useful for linking related models‚Äîsuch as showing a collection's products inside the collection list view.

1. Adding Clickable Links in Django Admin
Instead of displaying just the number of products in a collection, we can convert it into a link that takes users to the product list filtered by that collection.

üìå Modify admin.py to include formatted HTML:
from django.utils.html import format_html
from django.urls import reverse

@admin.display(ordering='products_count')  # Enable sorting
def products_count(self, collection):
    url = reverse('admin:store_product_changelist')  # Generate product list URL dynamically  #Sytax is reverse('admin:app_model_page')
    return format_html('<a href="{}">{}</a>', url, collection.products_count)  # Create clickable link
	
‚úÖ Now, clicking the product count redirects to the product list page. ‚úÖ No hardcoding required‚ÄîDjango dynamically generates URLs.





2. Applying a Filter to Show Only Related Products
Clicking the link currently shows all products, but we need to filter products for that specific collection. To apply a filter, append a query string (?collection__id=1) to the URL.

üìå Modify admin.py to include filtering logic:
from django.utils.html import format_html, urlencode

def products_count(self, collection):
    url = (
        reverse('admin:store_product_changelist')  # Get product list URL
        + '?'  
        + urlencode({'collection__id': str(collection.id)})  # Append query parameters
    )
    return format_html('<a href="{}">{}</a>', url, collection.products_count)  # Format clickable link

‚úÖ Now, the product list page will only show products in the selected collection.

üìå Example URL Generated:

/admin/store/product/?collection__id=1
üöÄ This ensures clicking the collection‚Äôs product count links to the correct filtered list.





3. Creating Links for Customers to View Their Orders
As an exercise, you can implement a similar feature for customers. üìå Example: Add an "Orders" column in the Customer admin panel:

@admin.display(ordering='orders_count')  # Enable sorting
def orders_count(self, customer):
    url = (
        reverse('admin:store_order_changelist')  # Get order list page URL
        + '?'  
        + urlencode({'customer__id': str(customer.id)})  # Filter by customer ID
    )
    return format_html('<a href="{}">{}</a>', url, customer.orders_count)  # Create clickable link

‚úÖ Now clicking a customer‚Äôs order count shows only orders placed by that customer.



Key Takeaways
‚úî Use format_html() to create clickable links inside Django admin. 
‚úî Use reverse() to dynamically generate admin URLs, avoiding hardcoded paths. 
‚úî Append query strings using urlencode() to filter lists based on selected items. 
‚úî Enable sorting using @admin.display(ordering='field_name') to sort computed columns.















Adding Search to the List Page:
-------------------------------

Django‚Äôs admin interface allows adding a search bar to filter records based on specific fields. This improves user experience when managing large datasets.

1. Enabling Search in Django Admin
The search_fields attribute determines which fields can be searched.

üìå Modify admin.py for CustomerAdmin:
@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    search_fields = ['first_name', 'last_name']  # Enable search for these fields
    list_per_page = 10  # Show 10 records per page
	
‚úÖ Now, the admin panel displays a search bar. ‚úÖ Search results match records where first_name or last_name contains the query.




2. Improving Search Accuracy Using Lookup Types
By default, Django searches for partial matches anywhere within the field. To restrict searches to names starting with a query, use lookup types.

üìå Modify search_fields with startswith lookup:
search_fields = ['first_name__startswith', 'last_name__startswith']
‚úÖ Now, searching "M" will return names starting with "M", but results are case-sensitive.

üìå Example SQL Query Generated:
SELECT * FROM store_customer WHERE first_name LIKE 'M%' OR last_name LIKE 'M%';
üö® Issue: "m" (lowercase) does not match "M" (uppercase).





3. Making Searches Case-Insensitive
To ignore case differences, use istartswith instead:
üìå Modify search_fields to use case-insensitive lookup:
search_fields = ['first_name__istartswith', 'last_name__istartswith']

‚úÖ Now, searching "m" will correctly match "M" as well.

üìå Generated SQL Query:
SELECT * FROM store_customer WHERE LOWER(first_name) LIKE LOWER('m%') 
OR LOWER(last_name) LIKE LOWER('m%');

üöÄ Results are now case-insensitive, improving usability.



codes used in this lesson: 
search_fields = ['first_name', 'last_name']
search_fields = ['first_name__startswith', 'last_name__startswith']
search_fields = ['first_name__istartswith', 'last_name__istartswith']



Key Takeaways
‚úî Use search_fields to enable search functionality in Django admin. 
‚úî Use startswith for precise searches that match the beginning of fields. 
‚úî Use istartswith to make searches case-insensitive for better accuracy. 
‚úî Combine multiple fields in search_fields to allow searching across related attributes.


üöÄ Next Lesson: Adding filters for refining admin list views!











Adding Filtering to the List Page:
----------------------------------
Django‚Äôs admin panel provides built-in filtering options to refine search results efficiently. You can filter using existing model fields or create custom filters based on specific conditions.

1. Adding Built-In Filters for Standard Fields
Django allows filtering using simple fields like collections and last update.

üìå Modify admin.py to include list_filter:
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_filter = ['collection', 'last_update']  # Enable filtering by collection and last update

‚úÖ Now, the right panel in the admin interface shows filtering options. 
‚úÖ Selecting a collection filters products belonging to that collection. 
‚úÖ Filtering by last update allows selecting records from today, past 7 days, this month, etc.

üìå Example URL with filters applied:
/admin/store/product/?collection__id=3

üöÄ Django automatically generates query strings for filtering!




2. Creating a Custom Filter for Inventory Levels
If built-in filtering is not sufficient, you can create custom filters.

üìå Example: Filter products based on inventory levels

Step 1: Create a Custom Filter Class
Define a new filter by extending admin.SimpleListFilter:

class InventoryFilter(admin.SimpleListFilter):
    title = 'Inventory'  # Title displayed in the admin panel
    parameter_name = 'inventory'  # Query parameter in URL

    def lookups(self, request, model_admin):
        return [
            ('<10', 'Low')  # Filter option: products with inventory < 10
        ]

    def queryset(self, request, queryset):
        if self.value() == '<10':  # If filter is applied
            return queryset.filter(inventory__lt=10)  # Filter products with low inventory

‚úÖ Defines a filter that lets users view only "low inventory" products (<10).

Step 2: Add the Custom Filter to list_filter
üìå Modify ProductAdmin to include the new filter:

list_filter = ['collection', 'last_update', InventoryFilter]
üöÄ Now, filtering by "Low Inventory" shows only products with inventory < 10.

üìå Example URL after applying the filter:
/admin/store/product/?inventory=<10

‚úÖ Django applies query parameters automatically, filtering results dynamically.





Code References in this lesson:
list_filter = ['collection', 'last_update']


you can also create your own custom filter:

class InventoryFilter(admin.SimpleListFilter):
	title = 'inventory'
	parameter_name = 'inventory'
	
	def lookups(self, request, model_admin):
	    return[
		    ('<10', 'Low')
			]
			
	def queryset(self, request, querset):
		if self.value() == '10':
		    return queryset.filter(inventory__lt=10)
			
			
list_filter = ['collection', 'last_update', InventoryFilter]




Key Takeaways
‚úî Use list_filter to enable filtering on standard fields. 
‚úî Create custom filters using admin.SimpleListFilter for complex conditions. 
‚úî Use lookups() to define filter options in the UI. 
‚úî Use queryset() to apply filtering logic dynamically.













Creating Custom Actions:
------------------------

Django admin allows defining custom actions to perform bulk operations on selected objects. These actions appear in a dropdown list above the item list.

1. Defining a Custom Action:
let's say we want to define a custom action to clear the inventory of a bunch of products in one go. so we want set their inventory to zero.


üìå Step 1: Define a Method for the Custom Action
from django.contrib import admin

@admin.action(description='Clear inventory')  # Display name in the dropdown
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)  # Bulk update selected products
    self.message_user(
        request,
        f'{updated_count} products were successfully updated.',  # Success message
    )
	
‚úÖ Now, selecting multiple products and executing this action sets their inventory to 0.




2. Registering the Custom Action
To make this action available in the admin panel, add it to the actions list.

üìå Modify ProductAdmin in admin.py
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    actions = ['clear_inventory']  # Register the custom action
	
‚úÖ Now, "Clear Inventory" appears in the dropdown for bulk operations.




3. Displaying Messages to Users
Django allows showing status messages after executing an action.

üìå Using message_user()
self.message_user(
    request,
    f'{updated_count} products were successfully updated.',
    messages.ERROR  # Change message type (e.g., ERROR, SUCCESS, INFO)
)

‚úÖ Messages appear at the top of the admin panel after the action runs. ‚úÖ Different message types include ERROR, DEBUG, INFO, SUCCESS, WARNING.

üìå Example of an ERROR message:
from django.contrib import messages

self.message_user(
    request,
    f'{updated_count} products were successfully updated.',
    messages.ERROR
)
üöÄ Use error messages when an action needs extra attention or failed execution.





Code in this lesson: 

from django.contrib import admin, messages

@admin.action(description='Clear inventory')
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)
	self.message_user(
	    request,
		f'{updated_count} products were successfully updated.',
		messages.ERROR
		)


actions = ['clear_inventory']
	




Key Takeaways
‚úî Use @admin.action(description='Action Name') to define custom actions. ‚úî Bulk update selected objects using queryset.update(field=value). ‚úî Register actions using actions = ['action_name'] in ModelAdmin. ‚úî Use self.message_user() to display feedback messages after execution. ‚úî Change message type (messages.ERROR, messages.SUCCESS, etc.) based on context.














Customizing Forms:
------------------

Django‚Äôs admin interface automatically generates forms for adding and updating models. However, customizing these forms allows better user experience and control over displayed fields.

1. Controlling Displayed Fields
By default, Django displays all model fields in the form. ‚úî Use fields to explicitly define which fields should appear. ‚úî Use exclude to remove unnecessary fields.

üìå Example: Display Only Specific Fields in Admin Form
class ProductAdmin(admin.ModelAdmin):
    fields = ['title', 'slug']  # Show only Title & Slug fields
	
‚úÖ Now, only title and slug appear in the form.


üìå Example: Exclude Specific Fields
exclude = ['promotions']  # Hide the promotions field

‚úÖ Removes promotions from the form while keeping others.




2. Making Fields Read-Only
Some fields should be displayed but not editable, like unique identifiers.

üìå Example: Display title but make it read-only
readonly_fields = ['title']

‚úÖ Users see the title, but cannot modify it.





3. Auto-Populating Fields Using prepopulated_fields
Django can automatically generate values for fields based on other inputs.

üìå Example: Auto-generate slug based on title
prepopulated_fields = {
    'slug': ['title']  # Slug updates as the user types the title
}

‚úÖ The slug field updates dynamically while typing the title. 
üö® Note: Once edited manually, it will not auto-update again.





4. Using Autocomplete for Large Datasets
Some fields, like foreign keys, should be searchable instead of dropdowns, especially when they reference hundreds or thousands of records.

üìå Example: Convert collection field to autocomplete
autocomplete_fields = ['collection']

üö® Error Handling: Django requires the related model to define search_fields. ‚úî Fix by adding search_fields in CollectionAdmin:
class CollectionAdmin(admin.ModelAdmin):
    search_fields = ['title']  # Enable search functionality in autocomplete fields
	
‚úÖ Now, users can search for collections instead of scrolling through a long dropdown list.

üìå Query Sent When Searching for a Collection:
SELECT * FROM store_collection WHERE title LIKE '%query%'

üöÄ Optimizes performance by reducing page load time.





5. Understanding Missing Fields
‚úî Some fields (e.g., placed_at) may not appear in the form. 
‚úî Django automatically excludes fields with auto_now_add=True.

üìå Example: placed_at field does not appear because it auto-populates on creation.
class Order(models.Model):
    placed_at = models.DateTimeField(auto_now_add=True)  # Automatically set on creation
	
‚úÖ Solution: Remove auto_now_add=True to allow manual date selection.(but it is not recommended, since we have used 'auto_now_add' for reason)



code used in this lesson:
fields = ['title', 'slug']

exclude --> opposite of fields

exclude = ['promotions']

read_only = []


prepopulated_fields = {
   'slug': ['title']   
}

autocomplete_fields = ['collection']



ModelAdmin Options: 
So, these are few ways to customize the form, But again if you want to find all the options available to you, just search for 'Django modeladmin' 
https://docs.djangoproject.com/en/5.2/ref/contrib/admin/
--> ModelAdmin Options  --> on this page you can find all possible ways to customize the list and forms 



Key Takeaways
‚úî Use fields to explicitly control which fields appear in forms. 
‚úî Use exclude to hide unnecessary fields. 
‚úî Use readonly_fields for fields that should be displayed but not editable. 
‚úî Use prepopulated_fields to auto-fill fields dynamically. 
‚úî Use autocomplete_fields for foreign key relationships with large datasets. 
‚úî Missing fields are often due to auto_now_add=True‚Äîremove to make them visible.















Adding Data Validation:
-----------------------
Django automatically provides basic validation for model fields, ensuring required fields are filled and correct data types are used. However, custom validation rules can further refine input handling.

1. Understanding Built-In Validation
By default: 
‚úî Required fields must be filled (unless explicitly set as nullable). 
‚úî Number fields (e.g., DecimalField) enforce numerical input. 
‚úî Django prevents invalid data types automatically.

üìå Example: If a user submits a form without filling out required fields, Django displays validation errors.





2. Making Fields Optional in the Admin Interface
‚úî null=True ‚Üí Allows database storage of NULL values. 
‚úî blank=True ‚Üí Allows the field to be empty in forms.

üìå Modify models.py to allow an optional description field:
description = models.TextField(null=True, blank=True)

‚úÖ This ensures the description field can be left empty in both the database and admin forms.
üö® Important: null=True applies only to the database, but does not make the field optional in forms. To allow empty forms, you must also set blank=True.





3. Enforcing Minimum Values Using Validators
Numeric fields allow invalid values, such as 0 or negative numbers. To prevent this, use Django‚Äôs built-in validators.

üìå Example: Ensure unit_price is at least 1.00
from django.core.validators import MinValueValidator

unit_price = models.DecimalField(
    max_digits=6,
    decimal_places=2,
    validators=[MinValueValidator(1)]  # Restricts values to 1 or higher
)

‚úÖ Now, submitting a value below 1.00 triggers a validation error.

üìå Default error message shown:
Ensure this value is greater than or equal to 1.


üöÄ Other Validators: 
‚úî MaxValueValidator(100) ‚Üí Ensures value does not exceed 100. 
‚úî MinLengthValidator(5) ‚Üí Ensures text has at least 5 characters. 
‚úî RegexValidator(r'^\d+$') ‚Üí Restricts input to numeric characters only.

üîç Explore all validators: Django Validators




4. Making Fields Optional (Example: Promotions)
Fields like promotions should not be required.

üìå Modify models.py to make promotions optional:
promotions = models.ManyToManyField(Promotion, blank=True)

‚úÖ Now, promotions can be left empty while adding products in the admin panel.



Codes in this lesson:
in the model class -->

description = models.TextField(null=True)

we do still get after the above statement, to make this field optional in the admin interface 

description = models.TextField(null=True, blank=True)     

from django.core.validators import MinValueValidator

unit_price = models.DecimalField(
    max_digits=6,
	decimal_places=2,
	validators=[MinValueValidator(1)]
	)


In this module 'django.core.validators', we have bunch of built-in validators. If you want to see all of them, just google 'Django Validators'

https://docs.djangoproject.com/en/5.2/ref/validators/

On this page, you can see all these built-in validators  



Key Takeaways
‚úî Use null=True for database flexibility, but also set blank=True for forms. ‚úî Use MinValueValidator to enforce minimum values on numeric fields. ‚úî Apply validators=[...] inside model fields to restrict user inputs. ‚úî Make fields optional using blank=True in ManyToMany relationships. ‚úî Check Django‚Äôs built-in validators for additional validation options.


















Editing Children Using Inlines:
-------------------------------
Django allows managing related objects (children) directly from the parent model form using inlines in the admin interface. This is useful when handling Order Items inside Order Admin.

1. Creating an Inline for Order Items
To manage order items inside the order form, create an inline admin class.

üìå Define OrderItemInline in admin.py:
from django.contrib import admin
from .models import OrderItem

class OrderItemInline(admin.TabularInline):  # Display items in table format
    model = OrderItem
    extra = 0  # Remove default empty rows
    min_num = 1  # Require at least 1 item per order
    max_num = 10  # Limit maximum items per order
	
‚úÖ Allows editing order items directly inside the order form.




2. Register the Inline in OrderAdmin
Once the inline is created, register it inside OrderAdmin.

üìå Modify OrderAdmin to include the inline class:
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    autocomplete_fields = ['customer']  # Convert customer selection to autocomplete
    inlines = [OrderItemInline]  # Include order item inline in order form
    list_display = ['id', 'placed_at', 'customer']
	
‚úÖ Now, order items appear inside the order form in the Django admin panel.




3. Tabular vs. Stacked Inlines
Django provides two inline display styles: 
‚úî TabularInline ‚Üí Displays children as table rows (recommended for structured data like order items). 
‚úî StackedInline ‚Üí Displays children as separate forms (useful when each child has many fields).

üìå Example: Switching to StackedInline
class OrderItemInline(admin.StackedInline):
    model = OrderItem
	
‚úÖ Changes display style to stacked forms instead of a table.




4. Improving User Experience with Autocomplete Fields

Large dropdown lists can be slow and difficult to navigate. 

üìå Convert product selection to autocomplete inside inline:
class OrderItemInline(admin.TabularInline):
    model = OrderItem
    autocomplete_fields = ['product']  # Allow searching for products instead of dropdown

‚úÖ Enhances selection speed and usability, especially for large datasets.




codes in this lesson:
class OrderItemInline(admin.TabularInline):   or StackedInline
	model = models.OrderItem
	extra = 0
	min_num = 1
	max_ num = 10
	

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
	autocomplete_fields = ['customer']
	inlines = [OrderItemInline]
	list_display = ['id', 'placed_at', 'customer']
 




Key Takeaways:
‚úî Use TabularInline for structured data (recommended for order items). 
‚úî Use StackedInline for detailed entry forms (better for complex child models). 
‚úî Remove extra empty rows using extra = 0 to keep forms clean. 
‚úî Set autocomplete_fields = ['product'] for better UX in dropdown fields. 
‚úî Register inlines inside OrderAdmin using inlines = [OrderItemInline].






















Using Generic Relations:
------------------------
Generic relationships allow models to associate dynamically with multiple other models, making them highly reusable. In this case, we are managing tags for products inside the admin interface.

1. Registering the Tag Model in Admin
To manage tags via the Django admin panel, register the Tag model.

üìå Modify tags/admin.py:
from django.contrib import admin
from .models import Tag

admin.site.register(Tag)  # Register the Tag model


‚úÖ Now, "Tags" appears in the Django admin panel, allowing tag management.

üìå Modify Tag Model to Display Labels Properly
class Tag(models.Model):
    label = models.CharField(max_length=255)

    def __str__(self):
        return self.label  # Show tag label instead of "Tag object"
		
‚úÖ Ensures tags appear with meaningful names in admin lists and dropdowns.




2. Using Inlines to Manage Tags in the Product Form
Instead of manually linking tags to products, we embed tag management directly within the product form using generic inlines.

üìå Define an Inline Class for TaggedItem in store/admin.py
from django.contrib.contenttypes.admin import GenericTabularInline
from .models import TaggedItem

class TagInline(GenericTabularInline):  # Creates a table-like interface for tags
    model = TaggedItem
    autocomplete_fields = ['tag']  # Enable autocomplete for tag selection

‚úÖ Now, when adding or editing a product, tags can be modified directly in the same form.


üöÄ Why Use GenericTabularInline? 
‚úî Works for models with generic foreign keys, such as TaggedItem. 
‚úî Displays related objects in a compact tabular format.


üìå Alternative: Use GenericStackedInline if a form layout is preferred.
class TagInline(GenericStackedInline):  # Uses stacked form layout
    model = TaggedItem
	
‚úÖ Displays each tag as a separate form instead of a table.





3. Registering Inlines in ProductAdmin
To integrate TagInline into the product form, register it inside ProductAdmin.

üìå Modify ProductAdmin in store/admin.py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    inlines = [TagInline]  # Include tag management in the product form

‚úÖ Now, while editing a product, users can assign tags directly from the product page.

üöÄ Tags are directly editable within the product form!





4. Handling Autocomplete Errors
If autocomplete_fields = ['tag'] triggers an error, it‚Äôs because Django doesn‚Äôt know how to search for tags.

üìå Fix by Adding a Custom TagAdmin in tags/admin.py:
@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    search_fields = ['label']  # Enable searching by tag label
	
‚úÖ Now, autocomplete works properly, allowing users to search for tags instead of using dropdowns.

üìå Example Query Sent When Searching for Tags:
SELECT * FROM tags_tag WHERE label LIKE '%search_term%'

üöÄ Autocomplete dynamically retrieves matching tags, improving efficiency.




Codes used in this lesson:
tags/admin.py:
from django.contrib import admin
from .models import Tag

admin.site.register(Tag)



from django.contrib.contenttypes.admin import GenericTabularInline

class TagInLine(GenericTabularInline)
    autocomplete_fields = ['tag']
	model = TaggedItem
	
	
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
	inline=[TagInline]




Key Takeaways
‚úî Register models (admin.site.register) to manage them in Django admin. 
‚úî Use GenericTabularInline for compact inline editing of generic relationships. 
‚úî Use autocomplete_fields = ['tag'] for efficient tag selection in large datasets. 
‚úî Define search_fields = ['label'] inside TagAdmin to enable autocomplete functionality. 
‚úî Use __str__() in models for better representation in admin lists.














Extending Pluggable Apps:
-------------------------

In a well-architected Django project, each app should be self-contained and independent, allowing easy reuse in different projects. This means avoiding direct dependencies between pluggable apps.

For example, in a store app, we originally had a dependency on the tags app, making them tightly coupled. To solve this, we decouple them by creating a separate customization app (store_custom), which handles custom integrations while keeping both original apps reusable.

1. Why Extend Pluggable Apps?
‚úî Allows building apps independently without unnecessary dependencies. 
‚úî Enables plug-and-play flexibility, so each app can be reused easily. 
‚úî Keeps customizations separate while maintaining core functionality.

Before Decoupling
üö® Problem: store/admin.py was importing TaggedItem from tags/models.py, making store depend on tags.

üìå Example Dependency:
from tags.models import TaggedItem  # ‚ùå Causes tight coupling!

üöÄ Solution: Move customization logic into a separate app (store_custom).





2. Creating a Separate Customization App
A new store_custom app will manage cross-app integrations while keeping store and tags independent.

üìå Create a new Django app:
python manage.py startapp store_custom

‚úÖ Now, instead of modifying store or tags, customization happens inside store_custom.





3. Moving Custom Admin Logic to store_custom/admin.py
In store_custom/admin.py, we import admin configurations from both store and tags:

üìå Modify store_custom/admin.py
from django.contrib import admin
from store.admin import ProductAdmin  # Import default ProductAdmin
from tags.models import TaggedItem  # Import TaggedItem (generic model)
from django.contrib.contenttypes.admin import GenericTabularInline

Step 1: Create a Custom Inline for Tags
Move the TagInline class into store_custom to handle tag management inside product forms:

class TagInline(GenericTabularInline):  # Generic inline for tags
    autocomplete_fields = ['tag']
    model = TaggedItem
	
‚úÖ This ensures store no longer depends on tags.


Step 2: Extend ProductAdmin for Customization
Create a new ProductAdmin class (CustomProductAdmin), which extends the default ProductAdmin:

class CustomProductAdmin(ProductAdmin):  # Extend ProductAdmin from store
    inlines = [TagInline]  # Add inline functionality for tags

‚úÖ Stores all customization logic in a separate class, keeping the original ProductAdmin intact.




4. Unregistering and Replacing Default Admin Configuration
Before registering the customized ProductAdmin, remove the original:

üìå Unregister default ProductAdmin and register CustomProductAdmin
admin.site.unregister(Product)  # Remove default registration
admin.site.register(Product, CustomProductAdmin)  # Register the custom implementation

‚úÖ Now, the admin interface loads CustomProductAdmin instead of the default one.




5. Registering store_custom in INSTALLED_APPS
Finally, we register our customization app so Django recognizes it:

üìå Modify settings.py:
INSTALLED_APPS = [
    # Core pluggable apps
    'store',
    'tags',

    # Custom integration app
    'store_custom',
]

‚úÖ Now, Django loads the customization app, ensuring pluggable apps remain independent.





6. Verifying the Setup
To test, remove store_custom from INSTALLED_APPS and refresh the admin panel:

üöÄ Expected Result: 
‚úî Without store_custom: The product admin panel does not include tags. 
‚úî With store_custom: The product admin panel includes the tags section.




Codes in this lesson: 

create a new store_custom app
register it in INSTALLED_APPS

from django.contrib import admin
from store.admin import ProductAdmin
from tags.models import TaggedItem
from django.contrib.contenttypes.admin import GenericTabularInline

class TagInline(GenericTabularInline):
	autocomplete_fields = ['tag']
	model = TaggedItem
	
class CustomProductAdmin(ProductAdmin);
	inlines = [TagInLine]
	
	
admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)

	
	

Key Takeaways
‚úî Pluggable apps should be independent and free from cross-dependencies. 
‚úî Store customizations should be handled in a separate app (store_custom). 
‚úî Move admin customizations into a separate CustomProductAdmin to override built-in behavior. 
‚úî Unregister the default admin configuration (admin.site.unregister()) before replacing it. 
‚úî Register custom integration apps (store_custom) in INSTALLED_APPS for modular flexibility.






What's next: 
In the next part, we'll talk about the advanced Django concepts such as building RESTful APIs, authentication and authorization, logging, caching, sending emails, deployment and more. So if you're serious about learning Django and want to become a backend developer, don't miss the next part. 

====================================================================================================================================================================


Part -2 (Django Rest Framework)
--------------------------------
In this part, we're gonna continue our journey and build a restful API for this application. So by the end of this course, we'll have a complete production grade backend for an imaginary online store. 


In the first part, we have covered so many things like Models, Migrations, Querysets, Views, URLCONF


Building RESTful APIs with Django REST Framework:
-------------------------------------------------

So in this section, we'll be talking about RESTful APIs, what they are, and how they work. Then we'll install Django REST Framework, which is the most popular framework for building web APIs with Django. Once we do that, then we'll talk about some of the fundamental concepts such as creating API views, creating serializers, serializing and deserializing models, and much, much more. So by the end of this section, we'll have a basic API for managing our products and collections.










What are RESTful APIs?
----------------------
In the first part of this course, we built an admin panel to manage our data. However, this interface is only meant for admins and is not accessible to client applications. To expose our data to web and mobile applications, we need an API (Application Programming Interface).

1. Understanding APIs
An API acts as an interface that client applications (such as a web app or mobile app) can use to fetch or modify data remotely.

üìå Think of an API like a remote control: 
‚úî Each button provides specific functionality (e.g., fetching products, updating orders). 
‚úî Client apps send requests to API endpoints to retrieve or modify data.

üöÄ Example API Endpoints:
GET /products ‚Üí Fetch a list of products.
POST /products ‚Üí Create a new product.
PUT /products/{id} ‚Üí Update a product.
DELETE /products/{id} ‚Üí Remove a product.
GET /orders ‚Üí Retrieve orders placed by customers.
POST /cart ‚Üí Add items to a shopping cart.

‚úÖ APIs allow client applications to interact with backend data seamlessly.




2. What Makes an API RESTful?
‚úî REST (Representational State Transfer) is an architectural style that defines a set of rules for designing scalable, reliable, and maintainable APIs. 
‚úî RESTful APIs follow these principles to ensure efficient communication between clients and servers.

üìå Origin of REST:
Introduced in 2000 as part of a PhD thesis.
Helps build systems that are fast, easy to understand, and scalable.

üöÄ Why Follow REST Principles? 
‚úî Improves performance and scalability. 
‚úî Simplifies maintenance and evolves easily over time. 
‚úî Ensures standardized communication between client and server.




3. Core Concepts of RESTful APIs
To build a RESTful API, we must understand three key concepts:

Resources ‚Üí Entities like products, users, or orders. 
Resource Representations ‚Üí JSON or XML format used to describe resources. 
HTTP Methods ‚Üí Operations performed on resources (GET, POST, PUT, DELETE).

üöÄ Next Lessons: We'll explore each of these concepts in detail to understand how they shape RESTful APIs!

Key Takeaways
‚úî APIs allow client applications to interact with backend data via endpoints. 
‚úî RESTful APIs follow structured rules for scalability and efficiency. 
‚úî REST principles focus on resources, resource representations, and HTTP methods. 
‚úî Following REST ensures fast, reliable, and maintainable APIs.

üöÄ Next Lesson: Diving deeper into RESTful API concepts!












Resources:
----------
The first key concept in RESTful APIs is the idea of resources. A resource represents an entity within the application, such as products, collections, shopping carts, and more. These resources are accessible via URLs (Uniform Resource Locators), which serve as unique addresses on the web.

1. Accessing Resources with URLs:
In a RESTful API, each resource is exposed via a URL. üìå Example URLs for Managing Products:

moshbuy.com/products     ‚Üí Fetch all products
moshbuy.com/products/1   ‚Üí Fetch product with ID 1
‚úÖ Appending the resource ID to the URL allows access to specific objects.




2. Resources Can Contain Other Resources
Some resources may contain sub-resources. 
üìå Example: Accessing Reviews for a Product
moshbuy.com/products/1/reviews       ‚Üí Get all reviews for product 1
moshbuy.com/products/1/reviews/5     ‚Üí Get review with ID 5

‚úÖ This structure ensures clarity and consistency in API endpoints.
üö® Best Practice: Avoid deeply nested URLs beyond two levels, as they become complex and hard to manage.




3. Recognizing RESTful API Patterns
RESTful APIs follow a consistent URL structure, making them intuitive and easy to use. 
‚úî Clear hierarchy of resources. 
‚úî Logical organization of endpoints. 
‚úî Simple resource access patterns.

üöÄ Following these conventions ensures that APIs remain familiar, readable, and easy to work with.

Key Takeaways
‚úî Resources are core entities like products, collections, and orders. (is like an object in our application, like product, collection, shopping cart, and so on.)
‚úî URLs serve as resource locators, allowing easy access to data. 
‚úî Sub-resources should be structured efficiently (e.g., product reviews). 
‚úî Avoid deep nesting to maintain API simplicity.

üöÄ Next Lesson: Exploring resource representations in RESTful APIs!













Resource Representations:
-------------------------
Once a resource is identified via a URL, the server returns that resource in a specific format. This representation allows client applications to interpret and process the data efficiently.

1. Types of Resource Representations
A server may return data in different formats, such as: 
‚úî HTML ‚Üí Used for displaying web pages. 
‚úî XML (Extensible Markup Language) ‚Üí Older format for structured data. ‚úî
 JSON (JavaScript Object Notation) ‚Üí Modern, lightweight format replacing XML.

üìå Key Idea: The internal representation of a resource on the server is different from the format sent to the client.
On the server, resources exist as objects (e.g., Python instances).
When sending data to a client, it must be converted into a readable format like JSON or XML.




2. REST and Format Flexibility
üìå RESTful APIs do not enforce a specific format for resource representation. 
‚úî The API may support multiple formats (JSON, XML, etc.). 
‚úî The client should specify the desired format when requesting data.

üöÄ Example: A client can request a product in JSON or XML, depending on its preference.




3. What is JSON?
üìå JSON (JavaScript Object Notation) is the most widely used format for RESTful APIs.

‚úî Uses curly braces {} to define objects. 
‚úî Stores data in key-value pairs. 
‚úî Supports various data types, including strings, numbers, Booleans, arrays, and objects.

üìå Example: JSON Representation of a Product
json
{
    "name": "Laptop",
    "price": 999.99,
    "in_stock": true,
    "manufacturer": {
        "name": "TechCorp",
        "country": "USA"
    },
    "tags": ["electronics", "computers"]
}

üöÄ JSON Data Breakdown: 
‚úî Keys are always strings (e.g., "name", "price"). 
‚úî Values can be different types:

String ‚Üí "Laptop"
Number ‚Üí 999.99
Boolean ‚Üí true
Object ‚Üí "manufacturer"
Array ‚Üí "tags"

‚úÖ Throughout this course, JSON will be the preferred format for exchanging data between clients and servers.

Key Takeaways
‚úî Resource representations define how data is structured when sent to clients. 
‚úî Common formats include HTML, XML, and JSON (JSON is the most widely used). 
‚úî REST APIs allow multiple formats, with clients selecting their preferred representation. 
‚úî JSON uses key-value pairs to structure data in a readable way.

üöÄ Next Lesson: Exploring HTTP Methods for interacting with RESTful APIs!












HTTP Methods:
-------------
Understanding HTTP Methods in RESTful APIs:
In RESTful APIs, clients interact with endpoints to access or modify resources. Each endpoint may support different operations, and clients specify what they want to do using HTTP methods.

1. HTTP Methods for Resource Management
üìå Common HTTP methods used in RESTful APIs:
‚úî GET ‚Üí Retrieve a resource or collection of resources. 
‚úî POST ‚Üí Create a new resource. 
‚úî PUT ‚Üí Update an entire resource. 
‚úî PATCH ‚Üí Update part of a resource (a subset of properties). 
‚úî DELETE ‚Üí Remove a resource.




2. Practical Scenarios Using HTTP Methods

Creating a Product
üìå Client sends a POST request to create a new product:
Http:
POST /products

‚úî Product details are included in the request body (JSON format). 
‚úî Server reads the JSON object and stores it as a new product.

üìå Example JSON Data in Request Body:

json:
{
    "name": "Laptop",
    "price": 999.99,
    "in_stock": true
}


Updating a Product
üìå Updating ALL properties (PUT request):
Http:
PUT /products/1

‚úî Request body contains complete product details. 
‚úî Replaces all properties of product ID 1.


üìå Updating PART of a product (PATCH request):
Http:
PATCH /products/1

‚úî Request body contains only the modified fields. 
‚úî Useful for partial updates, e.g., changing only the price.

üìå Example JSON for Partial Update (PATCH):
json
{
    "price": 899.99
}


Deleting a Product
üìå Client sends a DELETE request to remove product ID 1:
http:
DELETE /products/1

‚úî No request body needed‚Äîserver deletes the specified product. 
‚úî ID in the URL is enough to identify the resource to delete.




3. Key Takeaways
‚úî GET retrieves data, POST creates data, PUT updates full data, PATCH updates partial data, and DELETE removes data. 
‚úî Always include JSON data in the request body when creating or updating resources. 
‚úî Use PUT for full updates, PATCH for partial updates. 
‚úî For deletions, the resource ID in the URL is sufficient‚Äîno request body is needed.

üöÄ Next Lesson: Installing Django REST Framework and building our first API!










Installing Django REST Framework:
---------------------------------
Django REST Framework (DRF) is a powerful extension of Django that simplifies the process of building RESTful APIs. It provides built-in tools for serializing data, handling authentication, and managing API views.

1. Installing Django REST Framework:
To install Django REST Framework, use pipenv in the terminal:

üìå Run the following command:
pipenv install djangorestframework

‚úÖ DRF will now be installed in the project environment.

üöÄ Alternative: If using a virtual environment directly, run:
pip install djangorestframework




2. Adding REST Framework to Installed Apps
Once installed, register Django REST Framework inside INSTALLED_APPS in settings.py.

üìå Modify settings.py:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Add Django REST Framework
    'rest_framework',

    # Custom apps
    'store',
    'tags',
]

‚úÖ Always place rest_framework right after Django‚Äôs built-in apps before any custom apps.




3. Verifying the Installation

üìå Check the installation by running:
python manage.py shell

Then, try importing REST Framework:
import rest_framework

‚úÖ If no errors appear, DRF is installed correctly!

Key Takeaways
‚úî Django REST Framework simplifies building RESTful APIs in Django. 
‚úî Use pipenv install djangorestframework or pip install djangorestframework to install DRF. 
‚úî Register rest_framework in INSTALLED_APPS inside settings.py. 
‚úî Verify installation using Python shell (import rest_framework).

üöÄ Next Lesson: Creating API views using Django REST Framework!











Creating API Views:
-------------------
In RESTful APIs, we define endpoints to expose data to client applications. Using Django REST Framework (DRF), we can create API views to retrieve, create, update, or delete data.

1. Creating a Basic API View
A view function processes HTTP requests and returns responses. üìå Example: Defining product_list() to fetch all products

from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):  # Handles GET requests for products
    return Response('ok')  # Temporary response
	
‚úÖ Uses DRF‚Äôs api_view() decorator to handle API requests. 
‚úÖ Returns an API response using Response().


üìå Defining URL Patterns
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),  # Maps `/store/products/` to product_list view
]

üöÄ Now, visiting /store/products/ returns a response!


Note: If we apply '@api_view()' decorator to our view function, the request object that we receive will be an instance of the request class that comes with the rest framework. So, it will replace the request object in Django with the newer request object that comes with the rest framework, which is simpler and more powerful. 
So, I made two simple changes. First, I applied 'api_view()' decorator and second, I replaced Httpresponse with response. Now, With these two simple changes, if we hit the URL, we get a beautiful page which is called the Browsable API. This Browsable API makes it incredibly easy to test our API endpoints in the browser. 
But note that we only see this page if we hit our endpoints in the browser. If a client app, like a mobile app, hits our endpoints, it's not going to see the Browsable API. It's only going to see the data in the response.




2. Using Django REST Framework‚Äôs Request and Response Objects
Instead of Django‚Äôs HttpResponse, we use DRF‚Äôs Response class for API responses.

üìå Changes Made: 
‚úî Applied @api_view() decorator to enable API functionality. 
‚úî Replaced HttpResponse with DRF‚Äôs Response() class.

üöÄ Why Use DRF‚Äôs Response? 
‚úî Provides automatic JSON formatting. 
‚úî Enables Browsable API, making endpoint testing easier.

üìå Example Response in Browsable API
json
{
    "message": "ok"
}

‚úÖ If accessed from a mobile app, only JSON data is returned.





3. Creating an API View for Product Details
We can define a new endpoint to fetch individual product details.


üìå Define product_detail() view
@api_view()
def product_detail(request, id):  # Handles GET requests for a specific product
    return Response(id)  # Returns the ID for verification
	
‚úÖ Receives an id parameter to identify products.


üìå Update urlpatterns to include product details

urls.py:
urlpatterns = [
    path('products/', views.product_list),  
    path('products/<int:id>/', views.product_detail),  # Uses integer URL converter
]

üöÄ Visiting /store/products/1/ returns 1 in the response!





4. Restricting Product ID to Integers
To ensure product IDs are always integers, use a URL converter:

üìå Modify URL pattern
path('products/<int:id>/', views.product_detail),

‚úÖ Now, non-numeric IDs (e.g., /store/products/A/) will trigger an error.



codes referred in this lesson:
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request): # replaces the request object that comes with django with the restframework request object 
    return Response('ok')

@api_view()
def product_detail(request, id):
	return Response(id)

#URLConf
urlpatterns = [
    path('products/', views.product_list),
	path('products/<int:id>/', views.product_detail),
]




Key Takeaways
‚úî Use @api_view() to define API views in Django REST Framework. 
‚úî Use Response() instead of Django‚Äôs HttpResponse to return API responses. 
‚úî Define URL patterns for API endpoints using path(). 
‚úî Use URL converters (<int:id>) to restrict parameters to integers. 
‚úî Browsable API improves endpoint testing in browsers.

üöÄ Next Lesson: Exploring serializers for formatting and structuring API data!














Creating Serializers: 
---------------------
In RESTful APIs, we need a way to convert model instances into JSON objects so that client applications can process the data. This is where serializers come into play.

1. What is a Serializer?
‚úî A serializer converts a Django model instance into a Python dictionary. ‚úî This dictionary is then converted into a JSON object for API responses. ‚úî Why is serialization important?

API responses should be structured and readable.
Some fields may contain sensitive data that should not be exposed.
Provides an external representation of resources separate from internal models.

üìå Process Flow:
Model Instance ‚Üí Python Dictionary ‚Üí JSON Renderer ‚Üí JSON Object




2. Defining a Serializer for the Product Model
To create a serializer, add a new file serializers.py in the store app.

üìå Modify serializers.py to define ProductSerializer:
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):  # Define serializer class
    id = serializers.IntegerField()  # Product ID
    title = serializers.CharField(max_length=255)  # Product title
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)  # Product price
	
‚úÖ Converts product objects into JSON-friendly dictionaries. ‚úÖ Includes only selected fields (id, title, unit_price) to exclude sensitive data.

üìå Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99
}




3. Understanding Serializer Fields
‚úî Similar to defining fields in a Django model but structured for external use. 
‚úî Django REST Framework provides various field types such as:

IntegerField() ‚Üí For numeric values.
CharField(max_length=255) ‚Üí For text fields.
BooleanField() ‚Üí For true/false values.
DecimalField(max_digits=6, decimal_places=2) ‚Üí For currency values.

üìå Check the full list of serializer fields: üîç Django REST Framework - Serializer Fields
# apiguide --> serializer fields in django-rest-framework.org
https://www.django-rest-framework.org/api-guide/fields/




4. Key Differences Between Models and Serializers
‚úî Models represent the internal data structure in the database. 
‚úî Serializers define the external representation of data returned to clients.

üöÄ Example: A product model may have an internal field called cost_price, but this field should not be exposed in the API response. Instead, the serializer only includes unit_price, title, and id.



Code References in this lesson:
JSONRenderer
render(dict)

serializer 
converts a model instance to a dictionary

model is the internal representation of a product. But what we return from our API is the external representation of a product. Sometimes you might have sensitive information here, we don't want to expose them to the outside world. 
That is why we need two separate representations of a product, an internal representation and an external representation.

model --> python dictionary(serializing helps us to convert model into dictionary) --> JSONRenderer(cls) render(dict) --> JSON Object

#serializers.py
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)     




Key Takeaways
‚úî Serializers convert Django model instances into structured JSON data. 
	Serializers convert Django model instances into Python dictionaries first‚Äînot directly into JSON.
	üìå Process Flow: 
	1. Serializer ‚Üí Converts a model instance into a Python dictionary. 
	2. JSON Renderer (render()) ‚Üí Converts the dictionary into a JSON object for API responses.
‚úî Defines an external representation of data separate from internal models. 
‚úî Uses serializers.Serializer to specify fields for API responses. 
‚úî Restricts API data exposure to relevant fields only (e.g., excluding sensitive details).

üöÄ Next Lesson: Using serializers to return product data in API responses!





   












Serializing Objects:
--------------------
Serializers in Django REST Framework (DRF) allow model instances to be converted into Python dictionaries, which are then transformed into JSON responses for client applications.

1. Using Serializers to Convert Models into JSON
Instead of returning a simple "ok" response, we now return actual product data.

üìå Modify product_detail to fetch product details:
from rest_framework.decorators import api_view
from rest_framework.response import Response
from store.models import Product
from store.serializers import ProductSerializer

@api_view()
def product_detail(request, id):
    product = Product.objects.get(pk=id)  # Fetch product by ID
    serializer = ProductSerializer(product)  # Convert product to dictionary
    return Response(serializer.data)  # Return JSON response
	
‚úÖ The serializer converts the model instance into a dictionary, which is automatically rendered into JSON.

üìå Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99
}

üöÄ How JSON Rendering Works: 
‚úî Django automatically applies a JSON renderer to convert dictionary data into JSON format. 
‚úî No need to explicitly use JSONRenderer().render()‚Äîit happens under the hood!




2. Fixing Decimal Formatting in JSON Responses
By default, Django REST Framework converts decimal fields into strings. To disable this behavior:

üìå Modify settings.py

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}

‚úÖ Now, decimal values appear as numbers instead of strings.

üìå Before Fix (Default Behavior)
json
{
    "unit_price": "999.99"
}

üìå After Fix
json
{
    "unit_price": 999.99
}




3. Handling Missing Products Gracefully
Instead of raising an exception when a product is not found, return a 404 status code.

üìå Using Exception Handling:
from rest_framework import status

try:
    product = Product.objects.get(pk=id)
except Product.DoesNotExist:
    return Response(status=status.HTTP_404_NOT_FOUND)

	
üöÄ Better Approach: Use Django‚Äôs shortcut function get_object_or_404() to simplify error handling.

üìå Modify product_detail()
from django.shortcuts import get_object_or_404

@api_view()
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)  # Automatically raises a 404 response if not found
    serializer = ProductSerializer(product)
    return Response(serializer.data)

‚úÖ Returns JSON response with error details instead of throwing an exception.

üìå Example JSON Response for Missing Product

json
{
    "detail": "Not found."
}




4. Serializing a List of Products
Instead of fetching a single product, we retrieve all products and return them as JSON.

üìå Modify product_list()
@api_view()
def product_list(request):
    queryset = Product.objects.all()  # Fetch all products
    serializer = ProductSerializer(queryset, many=True)  # Convert queryset to list of dictionaries
    return Response(serializer.data)

‚úÖ Setting many=True tells the serializer to process multiple objects in a queryset.

üìå Example JSON Response
json
[
    {"id": 1, "title": "Laptop", "unit_price": 999.99},
    {"id": 2, "title": "Phone", "unit_price": 499.99},
    {"id": 3, "title": "Tablet", "unit_price": 299.99}
]
üöÄ Django REST Framework automatically formats lists of objects into JSON arrays!



codes discussed in this lesson:

views.py:
import the respective model class from models.py
import the respective serializer class from from serializers.py

@api_view()
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	serializer = ProductSerializer(product)  #converts the model object into dictionary, we get our dictionary by 'serializer.data'
	return Response(serializer.data)  # under the hood -- at some point, Django is going to create a JSON render object and give this dictionary, the JSON 
	                                       renderer will convert that dictionary to a JSON object and that JSON Object will end up in the response
										   
										   										   
to avoid decimal to string in the response, in the settings.py
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
}	 


product doesnotexist:
from rest_framework import status

except Product.DoesNotExist:
	return Response(status=status.HTTP_404_NOT_FOUND) 


from django.shortcuts import get_object_or_404	
instead of try and except block --> use get_object_or_404:

product = get_object_or_404(Product, pk=id)


we can also pass queryset to the serializer:
@api_view()
def product_list(request):
	queryset = Product.objects.all()
	serializer = ProductSerializer(queryset, many=True)
	return(serializer.data)



Key Takeaways
‚úî Use serializers to convert model instances into dictionaries for JSON responses. ‚úî Fix decimal formatting with COERCE_DECIMAL_TO_STRING: False. ‚úî Use get_object_or_404() to handle missing resources gracefully (returns a 404 response). ‚úî Pass many=True to serialize multiple objects in a queryset. ‚úî DRF automatically applies JSON rendering‚Äîno need for manual conversion.












creating custom serializer fields:
----------------------------------
When designing a RESTful API, the data we return does not have to match the internal structure of our models. The API represents an external interface, while models define the internal implementation, which may evolve over time. To keep the API stable, we must carefully control the exposure of fields and even add computed fields.

1. Why API Representation is Different from Data Models
‚úî Our data models are implementation details‚Äîthey can change without affecting the API. 
‚úî The API should remain stable so existing clients continue to work properly. 
‚úî We may hide certain fields from our API or add computed fields that don‚Äôt exist in our models.

üìå Example Analogy: A remote control‚Äôs internal technology may change, but the external buttons remain the same for users. Similarly, our API interface remains stable even if the underlying model changes.




2. Adding a Computed Field in the Serializer
We can add new fields to the serializer that don‚Äôt exist in the model.

üìå Modify ProductSerializer to include price_with_tax:
from decimal import Decimal
from rest_framework import serializers
from store.models import Product  # Import Product model

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')  # Computed field

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)  # Apply 10% tax
		
‚úÖ Uses SerializerMethodField() to define a custom method for computation. ‚úÖ Tax calculation is handled separately from the model definition.

üìå Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "price_with_tax": 1099.99
}

üöÄ Now, products automatically include tax calculations in API responses!




3. Fixing Decimal Multiplication Errors
üö® Problem: Python automatically treats numbers like 1.1 as float, which can cause errors when multiplying with a DecimalField. üìå Solution: Convert floating numbers into Decimal objects.

from decimal import Decimal

def calculate_tax(self, product: Product):
    return product.unit_price * Decimal(1.1)  # Converts 1.1 to Decimal before multiplication

‚úÖ Ensures consistent calculations without type errors.




4. Renaming Fields in the API Response
Sometimes, we may want to rename fields in the API response without modifying the model.

üìå Example: Rename unit_price to price in the serializer
price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')

üöÄ What Happens Here? 
‚úî The API returns "price" instead of "unit_price". 
‚úî The serializer fetches data from "unit_price" but presents it as "price" externally.

üìå Updated JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "price": 999.99,
    "price_with_tax": 1099.99
}

‚úÖ This ensures a stable API while keeping internal data models flexible!





Codes learned in this lesson:
API Model(Interface) != Data Model(Implementation)


from decimal import Decimal

class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
	
	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)


if you want rename the field in the serializer class which is different from the model:
price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')




Key Takeaways
‚úî API models (external representation) are different from data models (internal implementation). 
‚úî Use SerializerMethodField() to define computed fields like price_with_tax. 
‚úî Always convert floating numbers to Decimal before performing calculations. 
‚úî Use source='field_name' to rename fields in API responses without changing the model. 
‚úî Keeping a stable API prevents breaking changes for existing clients.















serializing Relationships:
--------------------------
When returning a product in a RESTful API, we may need to include its related collection. Django REST Framework (DRF) provides multiple ways to serialize relationships, depending on the desired level of detail.

1. Four Ways to Serialize Relationships
‚úî Primary Key ‚Üí Include only the related object‚Äôs ID. 
‚úî String Representation ‚Üí Convert the related object into a string (e.g., collection title). 
‚úî Nested Object ‚Üí Include all details of the related object inside the response. 
‚úî Hyperlink ‚Üí Provide a URL to retrieve details of the related object.

üìå Example JSON Responses for Each Approach
json
// Primary Key Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": 3  // Only the collection ID
}

// String Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": "Electronics"  // Collection title as a string
}

// Nested Object Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": {
        "id": 3,
        "title": "Electronics"
    }
}

// Hyperlink Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": "http://api.example.com/collections/3/"  // Link to collection details
}

üöÄ Choosing the Best Approach depends on the level of detail required in API responses.




2. Primary Key Representation
‚úî Returns only the ID of the related object. 
‚úî Efficient, but requires additional requests to fetch full details.

üìå Modify ProductSerializer to include collection as a primary key
collection = serializers.PrimaryKeyRelatedField(
    queryset=Collection.objects.all()
)

üöÄ Use Case: Lightweight response where only IDs are needed.





3. String Representation
‚úî Converts the related object into a string representation. 
‚úî Typically returns the value from the __str__() method of the related model.

üìå Modify ProductSerializer to return the collection title
collection = serializers.StringRelatedField()

üöÄ Use Case: Readable response without requiring extra API calls.
üö® Performance Warning: By default, Django lazily loads related objects, causing extra database queries. 
‚úî Fix using select_related() in views:

üìå Optimize queries in views.py
@api_view(['GET', 'POST'])
def product_list(request):
    queryset = Product.objects.select_related('collection').all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
	
‚úÖ Now, collections are loaded efficiently with products in a single query.




4. Nested Object Representation
‚úî Includes full details of the related object inside the response. 
‚úî Allows retrieving related data without additional API calls.

üìå Step 1: Define a separate serializer for collections
class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
	
üìå Step 2: Modify ProductSerializer to use CollectionSerializer
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = CollectionSerializer()  # Includes full collection details

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
		
üöÄ Use Case: API responses that require full details in one request.




5. Hyperlinked Representation
‚úî Provides a URL to view related object details instead of embedding the object. 
‚úî Makes the API more RESTful by following resource linking principles.

üìå Modify ProductSerializer to return collection as a hyperlink
collection = serializers.HyperlinkedRelatedField(
    queryset=Collection.objects.all(),
    view_name='collection-detail'
)

üìå Step 2: Define the URL pattern for collection details
python
urlpatterns = [
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail')
]

üìå Step 3: Create the corresponding view function
@api_view()
def collection_detail(request, pk):
    return Response('ok')  # Later, return serialized collection data
	
üöÄ Use Case: When clients need URLs to retrieve detailed data separately.

üö® Fixing URL Resolution Errors: DRF expects the lookup field to be named pk, so update the parameter name in views:
def collection_detail(request, pk):  # Use 'pk' instead of 'id'

üìå Ensure the serializer knows the request context
serializer = ProductSerializer(queryset, many=True, context={'request': request})

‚úÖ Now, collection fields return hyperlinks instead of objects.




Codes learned in this lesson:

1. Primary key
2. String
3. Nested object
4. Hyperlink


way 1 -->
in the serializer class:
collection = serializers.PrimaryKeyRelatedField(
	queryset = Collection.objects.all()
)

way 2 -->
collection = serializers.StringRelatedField()   --> remember to use select_related/prefetch_related if necessary or else you'll end with more queries

@api_view(['GET', 'POST'])
def product_list(request):
	queryset = Product.objects.select_related('collection').all()
	serializer = ProductSerializer(queryset, many=True)
	return Response(serializer.data)



way 3 --> as a nested object

#define the respective serializer of the nested object
class CollectionSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length = 255)


#in ProductSerializer class:
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
	collection = CollectionSerializer()
	
	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)



way 4 --> hyperlink to an endpoint for viewing that object 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

urls.py:
path('collections/<int:pk>/', views.collection_detail, name='collection-detail')

views.py:
@api_view
def collection_detail(request, pk):
    return Response('ok')


in ProductSerializer class:
serializer = ProductSerializer(queryset, many=True, context={'request': request}) 



Key Takeaways
‚úî Use PrimaryKeyRelatedField for lightweight responses with IDs. 
‚úî Use StringRelatedField for readable responses, but optimize queries with select_related(). 
‚úî Use Nested Objects for detailed responses without requiring extra API calls. 
‚úî Use HyperlinkedRelatedField for fully RESTful responses with navigable resource links. 
‚úî Ensure the request context is passed to serializers when using hyperlinks.













Model Serializers:  
------------------
In previous lessons, we manually defined each field in the serializer, even though they were already present in the Django model. This led to redundancy, requiring us to update both the model and serializer separately whenever changes were made.

üöÄ Solution: Model Serializers eliminate this duplication by automatically pulling field definitions from the model.

1. What is a Model Serializer?
‚úî Model Serializers automatically retrieve fields and validation rules from Django models. ‚úî Reduces duplication and makes updates easier. ‚úî Provides a cleaner approach for maintaining consistency.

üìå Standard Serializer (Manual Field Definition)
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	
üö® Problem: Repeating field definitions in both the model and serializer.




2. Implementing a Model Serializer
Instead of defining fields manually, inherit from ModelSerializer.

üìå Modify ProductSerializer to use ModelSerializer:
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product  # Link serializer to model
        fields = ['id', 'title', 'unit_price', 'collection']  # Explicitly select fields
		
‚úÖ Django REST Framework now automatically handles field definitions. ‚úÖ If validation rules change in the model, the serializer updates automatically.

üìå Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3  // Uses primary key by default
}




3. Handling Related Fields
By default, ModelSerializer uses primary key representation for related fields. To change this behavior, override the related field.

üìå Option 1: Convert Related Field to Hyperlink
collection = serializers.HyperlinkedRelatedField(
    queryset=Collection.objects.all(),
    view_name='collection-detail'
)

‚úÖ Returns a URL instead of an ID.


üìå Option 2: Nest the Related Object
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title']

class ProductSerializer(serializers.ModelSerializer):
    collection = CollectionSerializer()  # Include full object
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']
		
‚úÖ Returns full collection details inside the product response.

üìå Example JSON Response for Nested Object:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": {
        "id": 3,
        "title": "Electronics"
    }
}




4. Adding Custom Fields (Computed Fields)
Model Serializers allow defining additional fields not present in the model.

üìå Example: Adding price_with_tax
class ProductSerializer(serializers.ModelSerializer):
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'price_with_tax', 'collection']

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)  # Add 10% tax

‚úÖ Now, price_with_tax is dynamically computed and included in responses.

üìå Updated JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "price_with_tax": 1099.99,
    "collection": 3
}




5. Avoiding Bad Practices (fields = '__all__')
üö® Do NOT use fields = '__all__' in Model Serializers. ‚úî Automatically exposing ALL fields in the model creates security risks. ‚úî New fields may unintentionally leak sensitive information.

üìå Bad Practice (Avoid This)
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'  # ‚ùå Exposes all fields automatically
		
‚úÖ Instead, always explicitly specify fields:
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']
		
üöÄ Keeps control over the API output and prevents unwanted exposure.



codes learned in this lesson:
(two places, in model and serializer, so a better way)

class ProductSerializer(serializer.ModelSerializer):
	class Meta:
		model = Product
		fields = ['id', 'title', 'unit_price', 'collection', 'price_with_tax']
	
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)
		
		

By default ModelSerializers use primary key related fields, if you don't want it. you can override it easily

example, in the same class above, define 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

also for custom serializers you can override it. 
    fields = ['id', 'title', 'price', 'collection']

price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



Key Takeaways
‚úî Model Serializers automatically map fields from models, reducing redundancy. 
‚úî Explicitly define fields to avoid exposing sensitive data. 
‚úî Customize related fields using HyperlinkedRelatedField, StringRelatedField, or nested serializers. 
‚úî Use SerializerMethodField() to add computed fields (e.g., price_with_tax). 
‚úî NEVER use fields = '__all__'‚Äîalways explicitly list fields.










Deserializing Objects:
-----------------------
Deserialization is the reverse of serialization‚Äîit occurs when the server receives data from the client in an API request and needs to convert it into a Django model instance for storage in the database.

üöÄ Use Case: 
‚úî A client sends a POST request to the /products/ endpoint. 
‚úî The request body contains product data in JSON format. 
‚úî The server reads and deserializes the JSON data into a Django model instance.

1. Enabling POST Requests in the API View
üìå Modify the @api_view decorator By default, API views only support GET requests. To allow POST requests, we need to explicitly define supported HTTP methods:

@api_view(['GET', 'POST'])  # Supports both GET and POST requests
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)  # ‚úÖ Returns serialized product data

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # ‚úÖ Begins deserialization process
        return Response('ok')  # Placeholder response for now
		
üöÄ Key Changes: ‚úî Added 'POST' to @api_view(['GET', 'POST']). ‚úî Used request.data to capture incoming JSON data for deserialization.




2. Understanding Deserialization Process
üìå Steps in Deserialization: 
1Ô∏è. Client sends JSON data in the request body. 
2Ô∏è. DRF converts JSON into a Python dictionary (request.data). 
3. Serializer processes this dictionary to create a Django model instance. 
4. Data validation ensures correctness before storing in the database.

üìå Example Incoming JSON Data (from client)
json
{
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3
}

üìå Using the Serializer for Deserialization
serializer = ProductSerializer(data=request.data)  # ‚úÖ Converts JSON into Python dictionary

‚úî Setting data=request.data tells the serializer to process incoming data instead of serializing an existing object.

üöÄ Under the Hood: 
‚úî The serializer automatically maps JSON fields to model fields. 
‚úî It performs validation checks before creating a model instance. 
‚úî The processed data becomes available in serializer.validated_data.




3. Validating Data Before Accessing validated_data
üö® Before we access serializer.validated_data, we must validate the data! 
‚úî This ensures incoming data matches the expected format and rules. 
‚úî Validation prevents incorrect or malicious input from being stored in the database.

üìå Validation will be handled in the next lesson. For now, we simply return "ok" in the response while preparing to implement data validation.




4. Testing API Requests in Browsable API
üöÄ Benefits of the Browsable API: 
‚úî Shows a box for sending content when POST requests are enabled. 
‚úî Allows testing API endpoints without needing external tools like Postman. 
‚úî Displays JSON formatting automatically when selecting "POST" requests.

üìå Example of Browsable API Request Box:
POST /products/
{
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3
}
üöÄ When submitted, Django REST Framework processes the request!




codes learned in this lesson:

@api_view(['GET', 'POST'])
def product_list(request):
	if request.method == 'GET':
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)
	elif request.method == 'POST':
		serializer = ProductSerializer(data=request.data)  
		   #the deserialized data will be available at serializer.validated_data, but before that we need to  validate the data
		



Key Takeaways
‚úî Deserialization converts incoming JSON data into Python objects for database storage. 
‚úî Enable POST requests using @api_view(['GET', 'POST']) in API views. 
‚úî Set data=request.data inside the serializer to process incoming data. 
‚úî Browsable API makes it easier to test API requests without external tools. 
‚úî Validation must occur before accessing serializer.validated_data to ensure data integrity.

üöÄ Next Lesson: Implementing data validation in Django REST Framework!










Data Validation:
----------------
Data validation is a critical step when processing incoming API requests. Before accessing validated_data, Django REST Framework (DRF) must verify that the submitted data meets the model‚Äôs constraints. Otherwise, an exception will be raised.

1. Why Validation is Necessary
‚úî Prevents malformed or incorrect data from being stored in the database. 
‚úî Ensures API clients adhere to expected data structure. 
‚úî Protects against missing required fields, incorrect data types, or logic errors.

üöÄ Example: Client sends an incomplete product object
json
POST /products/
{}

üö® Without validation, the database could receive invalid data, leading to errors!




2. Implementing Basic Validation in API Views

üìå Modify the product_list API view
from rest_framework import status

@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Begin deserialization

        if serializer.is_valid():  # ‚úÖ Validate incoming data
            return Response('ok')
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)  # Return errors
			
‚úÖ Validates the submitted data using serializer.is_valid(). 
‚úÖ Returns validation errors if the input is incorrect.

üìå Example Response for Invalid Input
json
{
    "title": ["This field is required."],
    "unit_price": ["This field is required."],
    "collection": ["This field is required."]
}

üöÄ HTTP 400 (Bad Request) ensures clients know their request is invalid.




3. A Cleaner Approach with raise_exception=True
Instead of manually handling validation errors, we can simplify this logic by enabling automatic error handling.

üìå Modify the API view
serializer.is_valid(raise_exception=True)  # ‚úÖ Automatically raises error response

üöÄ This removes the need for an explicit if-else block and reduces boilerplate code.

üìå Updated Code
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Begin deserialization
        serializer.is_valid(raise_exception=True)  # ‚úÖ Validation + automatic error handling
        return Response('ok')
		
‚úÖ If the request is invalid, DRF automatically returns a 400 Bad Request error response. ‚úÖ Less code, same result!

üìå Example Response
json
{
    "title": ["This field is required."],
    "unit_price": ["This field is required."],
    "collection": ["This field is required."]
}




4. Understanding validated_data
After successful validation, DRF provides a cleaned dictionary containing valid data.

üìå Example: Printing validated_data
print(serializer.validated_data)

üöÄ Example Output in Terminal
OrderedDict([
    ('title', 'Laptop'),
    ('unit_price', Decimal('999.99')),
    ('collection', <Collection: Electronics>)
])

‚úÖ DRF automatically converts collection from an ID into a model instance.
üöÄ This cleaned data is now ready for saving into the database.




5. Validating Objects at a Higher Level
By default, validation rules are derived from model field constraints. 
However, sometimes, we need to compare multiple fields together.

üìå Example: User Registration ‚úî A user submits a form with password and confirm_password. ‚úî We need to ensure both fields match before processing the request.

üìå Modify ProductSerializer to include custom validation

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['title', 'unit_price', 'collection']

    def validate(self, data):  # ‚úÖ Overriding the validate method of ModelSerializer
        if data['password'] != data['confirm_password']:
            raise serializers.ValidationError('Passwords do not match')
        return data  # Return validated data if correct

‚úÖ If passwords do not match, an error is returned before saving.

üìå Example Response for Invalid Input
json
{
    "non_field_errors": ["Passwords do not match"]
}
üöÄ Useful for validation logic that involves multiple fields together.




codes learned in this discussion:
from rest_framework import status

if serializer.is_valid():
    serializer.validated_data
	return Response('ok')
else:
	return Reponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


or by cleaner way
serializer.is_valid(raise_exception=True)  ---> we don't need if else block
serializer.validated_data   --> ordereddict


validated data : OrderedDict([('title', 'a'), ('unit_price', Decimal('1.00')), ('collection', <Collection: collection1>)]) 

by default, validation rules comes from the definition of model fields. So, if we need anything extra, we need to override the validate method in our serializer


So, in our product serializer class:
def validate(self, data): # this is defined in our ModelSerializer class, and we are overriding it here
	if data['password'] != data['confirm_password']:
		return serializers.ValidationError('Passwords do not match')
	return data




Key Takeaways
‚úî Always validate data before accessing validated_data to prevent errors. 
‚úî Use serializer.is_valid(raise_exception=True) for cleaner error handling. 
‚úî DRF automatically converts foreign key IDs to model instances in validated_data. 
‚úî Override validate(self, data) for object-level validation (e.g., comparing passwords). 
‚úî HTTP 400 ensures that clients know when their request fails validation.

üöÄ Next Lesson: Saving validated data into the database!














Saving Objects:
---------------
When processing incoming data from clients, we need to deserialize and store the data in the database. Django REST Framework (DRF) simplifies this process with the save() method, which creates or updates objects automatically based on the serializer state.

1. How the save() Method Works
‚úî save() automatically creates or updates a model instance. 
‚úî Uses data from validated_data (but we don‚Äôt need to access it directly). 
‚úî Calls either create() or update(), depending on whether the serializer has an instance.

üìå Example: Saving a Product After Validation
serializer.is_valid(raise_exception=True)  # ‚úÖ Validate incoming data
serializer.save()  # ‚úÖ Automatically creates or updates product

üöÄ We don‚Äôt need to touch validated_data‚ÄîDRF handles everything internally!




2. Creating a New Product
‚úî Clients send a POST request with JSON data to /products/. 
‚úî The serializer validates the data and creates a new product.

üìå Modify the API View to Handle POST Requests
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # Validate data
        serializer.save()  # ‚úÖ Save product to the database
        return Response(serializer.data, status=status.HTTP_201_CREATED)  # ‚úÖ Return the created product

‚úÖ Returns the created product instead of just "ok", following RESTful conventions.

üìå Example Request (Client sends POST request)
json
{
    "title": "Laptop",
    "slug": "laptop",
    "unit_price": 999.99,
    "collection": 1,
    "inventory": 50
}

üìå Example Response (Product created successfully)
json
{
    "id": 4,
    "title": "Laptop",
    "slug": "laptop",
    "unit_price": 999.99,
    "inventory": 50,
    "collection": 1
}

üöÄ DRF automatically assigns the product an id and stores it in the database.




3. Overriding create() for Custom Object Creation
Sometimes, we need to modify object creation behavior, such as adding computed fields.

üìå Example: Overriding create() in the Serializer
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['title', 'slug', 'unit_price', 'inventory', 'collection']

    def create(self, validated_data):  # ‚úÖ Override default creation behavior
        product = Product(**validated_data)  # Create product using validated data
        product.special_field = "Custom Value"  # ‚úÖ Set extra fields
        product.save()
        return product
		
üöÄ This ensures custom logic is applied before saving the product.




4. Updating a Product (PUT Requests)
‚úî Clients send a PUT request to update a product (e.g., /products/2/). 
‚úî The serializer identifies an existing product and updates its attributes.

üìå Modify the API View to Handle PUT Requests
@api_view(['GET', 'PUT'])
def product_detail(request, id):
    product = Product.objects.get(pk=id)  # ‚úÖ Retrieve product by ID

    if request.method == 'GET':  
        serializer = ProductSerializer(product)
        return Response(serializer.data)  # ‚úÖ Return product details

    elif request.method == 'PUT':  
        serializer = ProductSerializer(product, data=request.data)  # ‚úÖ Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # ‚úÖ Validate data
        serializer.save()  # ‚úÖ Update the product in the database
        return Response(serializer.data, status=status.HTTP_200_OK)  # ‚úÖ Return updated product
		
üöÄ If PUT is used, update() is triggered instead of create().

üìå Example Request (PUT /products/2/)
json
{
    "title": "Laptop+",
    "slug": "laptop-updated",
    "unit_price": 899.99,
    "inventory": 45,
    "collection": 1
}

üìå Example Response (Product updated successfully)
json
{
    "id": 2,
    "title": "Laptop+",
    "slug": "laptop-updated",
    "unit_price": 899.99,
    "inventory": 45,
    "collection": 1
}
‚úÖ The title and price are updated, and the response includes the modified product.




5. Overriding update() for Custom Update Behavior
‚úî If extra processing is needed while updating, override update() in the serializer. ‚úî update() receives:
instance ‚Üí The product being updated.
validated_data ‚Üí The incoming validated data.

üìå Example: Overriding update() of ModelSerializer

in the ProductSerializer:
def update(self, instance, validated_data):  # ‚úÖ Customize update behavior
    instance.unit_price = validated_data.get('unit_price', instance.unit_price)  # ‚úÖ Modify specific attributes
    instance.inventory = validated_data.get('inventory', instance.inventory)  
    instance.save()
    return instance
	
üöÄ Ensures product attributes are correctly updated without modifying other fields.




6. When to Use PUT vs. PATCH
‚úî PUT updates all fields, requiring the complete object. 
‚úî PATCH updates only the provided fields, ignoring the rest.

üìå Example API View for Both PUT and PATCH
@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
    product = Product.objects.get(pk=id)

    if request.method == 'GET':  
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    elif request.method in ['PUT', 'PATCH']:  
        serializer = ProductSerializer(product, data=request.data, partial=request.method == 'PATCH')  
        serializer.is_valid(raise_exception=True)  
        serializer.save()
        return Response(serializer.data, status=status.HTTP_200_OK)
		
üöÄ Setting partial=True ensures PATCH updates only provided fields.




codes in this lesson:

our Model serializer has save method ( used for creating or updating)

posting a product object like this:
{
	"title" : "a",
	"slug" : "a",
	"unit_price" : 1,
	"collection" : 1,
	"inventory" : 1
}

right after validating the data
serializer.save() and we don't need serializer.validated_data after this


Now there are situations where we want to override how a product is created

in serializer class:

def create(self, validated_data):
	product = Product(**validated_data)
	product.other = 1
	product.save()
	return product
	
we can override the update method:

def update(self, instance, validated_data):
	instance.unit_price = validated_data.get('unit_price')
	instance.save()
	return instance


The save method will call one of the above methods depending on the state of the serializer.

For updating:
@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)





Key Takeaways
‚úî Use save() to automatically create or update objects. 
‚úî DRF calls create() when saving new objects, and update() when modifying existing ones. 
‚úî Use validated_data inside create() and update() to apply custom logic. 
‚úî Always return the created or updated object in API responses. 
‚úî Enable both PUT and PATCH depending on whether full updates or partial updates are needed. 
‚úî Use HTTP 201 (CREATED) for newly created objects and HTTP 200 (OK) for updates.

üöÄ Next Lesson: Deleting objects from the database!











Deleting Objects:
-----------------
Deleting objects from the database is a critical operation in RESTful APIs. Proper handling ensures that deletions are safe, meaningful, and aligned with API conventions.

1. Implementing the DELETE Operation
‚úî The delete operation is implemented in the product_detail() function, as it applies to a specific product. 
‚úî Adding DELETE to the view allows clients to remove products via API requests.

üìå Modify the API View to Handle DELETE Requests
@api_view(['GET', 'PUT', 'DELETE'])
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)  # Fetch product by ID

    if request.method == 'GET':
        serializer = ProductSerializer(product)
        return Response(serializer.data)  # ‚úÖ Return product details

    elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    elif request.method == 'DELETE':
        if product.orderitems.count() > 0:  # ‚úÖ Prevent deletion if product is linked to orders
            return Response(
                {'error': 'Product cannot be deleted because it is associated with an order item.'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        product.delete()  # ‚úÖ Remove the product from the database
        return Response(status=status.HTTP_204_NO_CONTENT)  # ‚úÖ Return empty response with 204 status

üöÄ Now, DELETE requests remove products while preventing unintended deletions.




2. Testing Deletions Using Browsable API
‚úî Once DELETE is added to the view, the browsable API automatically shows a delete button. 
‚úî Clicking DELETE sends a request to remove the product.

üìå Example Request (DELETE /products/1/)
DELETE /products/1/

üìå Expected API Response
json
{
    "error": "Product cannot be deleted because it is associated with an order item."
}

üöÄ Ensures users get proper feedback when attempting deletions.




3. Handling Foreign Key Constraints
üö® Problem: Some products cannot be deleted because they are linked to order items. 
‚úî Django enforces this protection using Foreign Key relationships. 
‚úî If an attempt is made to delete a product that belongs to an order, an exception is raised.

üìå Fix: Check for Order Items Before Deletion
if product.orderitems.count() > 0:  
    return Response(
        {'error': 'Product cannot be deleted because it is associated with an order item.'},
        status=status.HTTP_405_METHOD_NOT_ALLOWED
    )
üöÄ This prevents application crashes and provides meaningful error responses.




4. Choosing the Correct HTTP Status Code
‚úî 204 No Content ‚Üí Standard RESTful convention for successful deletions. 
‚úî 405 Method Not Allowed ‚Üí Used when deletion is restricted due to dependencies. 
‚úî Use httpstatuses.com to find correct status codes.

üìå Example Response When Deletion is Blocked

json
{
    "error": "Product cannot be deleted because it is associated with an order item."
}

üöÄ Provides clarity to API consumers, ensuring safe request handling.




5. Renaming Foreign Key Related Attributes
‚úî Django defaults to orderitem_set for reverse relationships. ‚úî Renaming to orderitems makes the API more intuitive.

üìå Modify models.py
class OrderItem(models.Model):
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='orderitems')  # ‚úÖ Use a clearer related name
	
üìå Update product_detail() View
if product.orderitems.count() > 0:  # ‚úÖ Updated related name

üöÄ Now, accessing order items is more readable and intuitive.



codes learned in this lesson:
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
	elif request.method == 'DELETE':
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


httpstatus.com --> on this page, you can see all the standard HTTP status code. 





Key Takeaways
‚úî Use DELETE in the product_detail() view to remove specific products. 
‚úî Prevent deletion if the product is linked to existing orders (orderitems.count() > 0). 
‚úî Return 204 No Content for successful deletions, and 405 Method Not Allowed when deletion is restricted. 
‚úî Check HTTP status codes on httpstatuses.com for best practices. 
‚úî Rename default Django reverse relationship attributes (orderitem_set ‚Üí orderitems).










Exercise: Building the Collections API
--------------------------------------
This section focuses on implementing API endpoints for managing collections. 
These endpoints allow us to: 
‚úî Retrieve all collections and include the number of products in each collection. 
‚úî Create new collections via API requests. 
‚úî Perform CRUD operations (Get, Update, Delete) on individual collections.

1. Implementing collection_list() for Managing Multiple Collections
‚úî Handles GET requests to return all collections. 
‚úî Handles POST requests to create a new collection. 
‚úî Uses annotate(products_count=Count('products')) to include the number of products in each collection.

üìå Modify the API View
@api_view(['GET', 'POST'])
def collection_list(request):
    if request.method == 'GET':  
        queryset = Collection.objects.annotate(products_count=Count('products')).all()
        serializer = CollectionSerializer(queryset, many=True)  
        return Response(serializer.data)  # ‚úÖ Return serialized data

    elif request.method == 'POST':  
        serializer = CollectionSerializer(data=request.data)  # ‚úÖ Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # ‚úÖ Validate request data
        serializer.save()  # ‚úÖ Save new collection to the database
        return Response(serializer.data, status=status.HTTP_201_CREATED)  # ‚úÖ Return created collection

üöÄ Now, clients can retrieve and create collections via API requests.

üìå Example API Response (GET /collections/)
json
[
    {"id": 1, "title": "Electronics", "products_count": 10},
    {"id": 2, "title": "Clothing", "products_count": 5}
]

‚úÖ Includes product count inside each collection object.

üìå Example Request (POST /collections/)
json
{
    "title": "Furniture"
}

üìå Example Response (POST /collections/)
json
{
    "id": 3,
    "title": "Furniture",
    "products_count": 0
}

üöÄ New collections are created successfully!




2. Implementing collection_detail() for Managing Individual Collections
‚úî Handles GET requests ‚Üí Fetch details of a single collection. 
‚úî Handles PUT requests ‚Üí Update an existing collection. 
‚úî Handles DELETE requests ‚Üí Remove a collection if no products are linked. 
‚úî Uses get_object_or_404() to return a 404 error if the collection does not exist.

üìå Modify the API View
@api_view(['GET', 'PUT', 'DELETE'])
def collection_detail(request, pk):
    collection = get_object_or_404(
        Collection.objects.annotate(products_count=Count('products')), pk=pk)

    if request.method == 'GET':  
        serializer = CollectionSerializer(collection)  
        return Response(serializer.data)  # ‚úÖ Return collection details

    elif request.method == 'PUT':  
        serializer = CollectionSerializer(collection, data=request.data)  
        serializer.is_valid(raise_exception=True)  
        serializer.save()  
        return Response(serializer.data)  # ‚úÖ Return updated collection

    elif request.method == 'DELETE':
        if collection.products.count() > 0:  # ‚úÖ Prevent deletion if collection has products
            return Response(
                {'error': 'Collection cannot be deleted because it includes one or more products.'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        collection.delete()  # ‚úÖ Remove collection
        return Response(status=status.HTTP_204_NO_CONTENT)  # ‚úÖ Return empty response
		
üöÄ Clients can now retrieve, update, and delete individual collections via API.

üìå Example Request (GET /collections/1/)
json
GET /collections/1/

üìå Example Response (GET /collections/1/)
json
{
    "id": 1,
    "title": "Electronics",
    "products_count": 10
}
üöÄ Returns full details, including product count.

üìå Example Request (DELETE /collections/1/)
json
DELETE /collections/1/

üöÄ Prevents deletion if products are linked and returns error.

üìå Example Response (DELETE /collections/1/)
json
{
    "error": "Collection cannot be deleted because it includes one or more products."
}

üöÄ Ensures safe deletion by preventing accidental removals.




3. Updating URL Routing (urls.py)
‚úî Register collection endpoints in the URL configuration. 
‚úî Define routes for both list and detail views.

üìå Modify urls.py
# URLConf
urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/', views.collection_list),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
üöÄ Ensures proper API routing for collections.




4. Modifying Collection Model to Improve Related Names (models.py)
‚úî Use related_name='products' to rename the default reverse relationship in Django.

üìå Modify models.py
class Product(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    description = models.TextField(null=True, blank=True)
    unit_price = models.DecimalField(
        max_digits=6, decimal_places=2, validators=[MinValueValidator(1)])
    inventory = models.IntegerField(validators=[MinValueValidator(0)])
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(
        Collection, on_delete=models.PROTECT, related_name='products')  # ‚úÖ Custom related name
		
üöÄ Now, accessing collection products is more intuitive (collection.products).




5. Updating Admin Module for Improved Product Count (admin.py)
‚úî Modify get_queryset() to reflect the updated field name (products instead of product_set).

üìå Modify admin.py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    autocomplete_fields = ['featured_product']
    list_display = ['title', 'products_count']
    search_fields = ['title']

    @admin.display(ordering='products_count')
    def products_count(self, collection):
        url = (
            reverse('admin:store_product_changelist')
            + '?'
            + urlencode({'collection__id': str(collection.id)}))
        return format_html('<a href="{}">{} Products</a>', url, collection.products_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(products_count=Count('products'))  # ‚úÖ Updated field name
		
üöÄ Ensures that collection product counts appear correctly in the admin panel.


Note on get_queryset():
The get_queryset() method in this context is specifically for the Django admin interface. It modifies the default queryset used by the Django admin panel when displaying the Collection model.

üöÄ Purpose of get_queryset() in CollectionAdmin 
‚úî Annotates collections with the number of products ‚Üí Adds a products_count field dynamically using Count('products'). 
‚úî Ensures product count appears in the admin interface ‚Üí Used in the list_display column for better visibility. 
‚úî Optimizes queries ‚Üí Instead of running a separate query for each collection's product count, it fetches them efficiently in a single query.

üìå Comparison: Django ORM vs. Admin Interface Usage
In Django ORM (Views, API, Templates) ‚Üí Used for querying database objects within views or API endpoints.
In Django Admin (CollectionAdmin) ‚Üí Used inside the admin panel to modify how data is fetched/displayed.

üöÄ In Action (Admin Panel)
The product count appears in the admin list page (list_display = ['title', 'products_count']).
The custom method products_count() uses this annotation to generate clickable product links.

üìå If this method was missing, the admin panel would require separate queries for each collection‚Äôs product count, reducing efficiency!





Key Takeaways
‚úî collection_list() handles retrieving all collections and creating new ones. 
‚úî collection_detail() manages individual collections (GET, PUT, DELETE). 
‚úî Collections are annotated using Count('products') to include product counts. 
‚úî Prevent collection deletion if products are linked, ensuring data integrity. 
‚úî Define proper URL routes (/collections/ for all collections, /collections/{id}/ for a specific collection). 
‚úî Use related_name='products' for a more intuitive reverse relationship. 
‚úî Update the admin panel to reflect correct product counts.

üöÄ Next Lesson: Exploring advanced API concepts in Django REST Framework!












Advanced API Concepts:
----------------------

In this section, we'll be talking about advanced API concepts that help us build APIs faster with less code. We'll be talking about Class-based views, Generic views, Viewsets, Routers, as well as Searching, Filtering and Pagination. So by the end of this section, our products endpoint will be in a much better shape and our code, as you will see, will be cleaner and more concise. 


Class-based Views:
------------------
Django REST Framework (DRF) supports class-based views (CBVs), which make the code cleaner, more reusable, and maintainable compared to function-based views. Instead of using multiple if statements, CBVs automatically dispatch requests to the appropriate method (GET, POST, PUT, DELETE).

1. Benefits of Class-Based Views
‚úî Cleaner Code ‚Üí No need for multiple if conditions within a single function. 
‚úî Reusability ‚Üí Allows inheritance and customization. 
‚úî Object-Oriented Features ‚Üí Uses standard Python class structures. 
‚úî Built-in Methods ‚Üí Provides better API structure with built-in support.

üìå Function-Based vs. Class-Based View Example 

üö® Function-Based View (before conversion)
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':  
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)  

    elif request.method == 'POST':  
        serializer = ProductSerializer(data=request.data)  
        serializer.is_valid(raise_exception=True)  
        serializer.save()  
        return Response(serializer.data, status=status.HTTP_201_CREATED)
		
üöÄ Class-Based View (after conversion)
from rest_framework.views import APIView

class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

‚úÖ Cleaner, more structured, and reusable!

üìå Updating urls.py to use Class-Based View
path('products/', views.ProductList.as_view()),  # ‚úÖ Converts class into a function-based view internally

üöÄ as_view() method converts the class into a Django view function.




2. Implementing a Class-Based View for Individual Products
‚úî **Handles GET, PUT, and DELETE requests for a single product. 
‚úî Uses get_object_or_404() to fetch the product and return a 404 if not found.

üìå Modify the View Class (ProductDetail)
class ProductDetail(APIView):
    def get(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    def put(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, id):
        product = get_object_or_404(Product, pk=id)
        if product.orderitems.count() > 0:
            return Response(
                {'error': 'Product cannot be deleted'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

üöÄ Requests automatically dispatch to the correct method (get(), put(), or delete()).

üìå Update urls.py to use Class-Based View
path('products/<int:id>/', views.ProductDetail.as_view()),  # ‚úÖ Converts class into a function-based view

üöÄ Now, requests to /products/{id}/ are correctly handled by the corresponding method in ProductDetail.




3. Fixing Unexpected Keyword Argument ID Error
üö® Issue: Missing id in method parameters. 
‚úî Solution: Each method (get, put, delete) must explicitly include id as a parameter.

üìå Example Fix
class ProductDetail(APIView):
    def get(self, request, id):  # ‚úÖ Include ID parameter
üöÄ Without this fix, Django will not recognize id in the request URL.




4. Key Differences Between Function-Based and Class-Based Views
‚úî Function-Based Views (FBVs)
Simple and easy to understand.
Good for small applications with fewer endpoints.
Requires nested if conditions to handle multiple request types (GET, POST, PUT, DELETE).

‚úî Class-Based Views (CBVs)
More structured and reusable.
Uses separate methods (get(), post(), put(), delete()) to cleanly handle request types.
Easier to extend and customize with inheritance.

üìå Choosing the Right Approach 
‚úî Use FBVs for simple API views. 
‚úî Use CBVs for complex, reusable views with multiple request types.

üöÄ Now that our API is structured using class-based views, we can further refine it using Django's built-in generic views!




Codes learned in this lesson:
Django provides more features over class based views

from rest_framework.views import APIView

class ProductList(APIView):
	def get(self, request):
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)

	def post(self, request):
		serializer = ProductSerializer(data=request.data) 
        serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
						
in urls.py:
path('products/', views.ProductList.as_view()),  # at the end of day, there is a function under the hood that gets called. 
						
class productDetail(APIView):
	def get(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product)
		return Response(serializer.data)
		
	def put(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data) 
		
	def delete(self, request, id):
		product = get_object_or_404(Product, pk=id)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)

in urls.py:
path('products/<int:id>/', views.ProductDetail.as_view()),




Key Takeaways
‚úî Class-Based Views improve code structure, reusability, and maintainability. ‚úî Requests automatically dispatch to methods (get(), post(), put(), delete()) without nested if statements. ‚úî Use APIView as a base class for defining class-based views in Django REST Framework. ‚úî Fix Unexpected Keyword Argument ID error by explicitly adding id as a parameter in each method. ‚úî Class-Based Views are ideal for complex applications requiring multiple request types. ‚úî Use as_view() in urls.py to register CBVs as Django views.

üöÄ Next Lesson: Leveraging Django‚Äôs Generic API Views for even more streamlined development!



		
		
		
		
		
		

Mixins:
-------
Mixins are reusable components that encapsulate common patterns used in API views. They help reduce duplication and improve code maintainability.

üöÄ Why Use Mixins? 
‚úî Avoid Repetitive Code ‚Üí Eliminates redundant logic across multiple views. 
‚úî Encapsulation ‚Üí Groups common behaviors into reusable classes. 
‚úî Scalability ‚Üí Simplifies adding new API endpoints. 
‚úî Easy Customization ‚Üí Extend and override methods when needed.

1. Identifying Repetitive Code Patterns
‚úî When listing products (ProductList) and collections (CollectionList), both views follow the same structure: 
   - Create a queryset (database query). 
   - Create a serializer to transform data. 
   - Return serialized data in a response.
   
So, the main differences, when you compare across the models are:
1. how they are creating a queryset
2. the serializers they are using
   

‚úî Similarly, when creating products or collections, both views: 
   - Instantiate a serializer with request data. 
   - Validate the data. 
   - Save the model instance. 
   - Return the serialized object in the response.


üöÄ This duplication suggests that mixins can help streamline the implementation!




2. Understanding Django REST Framework‚Äôs Built-in Mixins
Django REST Framework provides generic mixins to handle common API operations.

üìå Available Mixins (API Guide ‚Üí Generic Views)
ListModelMixin ‚Üí Handles listing objects.
CreateModelMixin ‚Üí Handles resource creation.
RetrieveModelMixin ‚Üí Handles fetching a single resource (detail view).
UpdateModelMixin ‚Üí Handles full or partial updates (PUT, PATCH).
DestroyModelMixin ‚Üí Handles deletion (DELETE).




3. Exploring Built-in Mixins in DRF
‚úî ListModelMixin ‚Üí Encapsulates the logic for listing models.

üìå Implementation
class ListModelMixin:
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())  # ‚úÖ Retrieve queryset

        page = self.paginate_queryset(queryset)  
        if page is not None:
            serializer = self.get_serializer(page, many=True)  # ‚úÖ Serialize paginated data
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)  # ‚úÖ Serialize data
        return Response(serializer.data)

üöÄ DRF handles filtering, pagination, serialization, and response formation‚Äîeverything in one method!

‚úî CreateModelMixin ‚Üí Encapsulates logic for creating a resource.

üìå Implementation
class CreateModelMixin:
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)  # ‚úÖ Deserialize request data
        serializer.is_valid(raise_exception=True)  # ‚úÖ Validate data
        self.perform_create(serializer)  # ‚úÖ Save the instance
        headers = self.get_success_headers(serializer.data)  
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()  # ‚úÖ Saves the model instance

    def get_success_headers(self, data):
        try:
            return {'Location': str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}
			
üöÄ Handles validation, serialization, saving, and response formation effortlessly.




4. Applying Mixins to Our Class-Based Views

üìå Refactor ProductList to use Mixins
from rest_framework.mixins import ListModelMixin, CreateModelMixin
from rest_framework.generics import GenericAPIView

class ProductList(ListModelMixin, CreateModelMixin, GenericAPIView):
    queryset = Product.objects.select_related('collection').all()  # ‚úÖ Define default queryset
    serializer_class = ProductSerializer  # ‚úÖ Define serializer class

üöÄ Now, ProductList automatically supports both GET and POST, removing redundant code!

üìå Refactor ProductDetail
from rest_framework.mixins import RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin

class ProductDetail(RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin, GenericAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
	
üöÄ Now, ProductDetail automatically supports GET, PUT, and DELETE without additional methods!

üìå Update urls.py
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ‚úÖ Handles list and creation
    path('products/<int:id>/', views.ProductDetail.as_view()),  # ‚úÖ Handles retrieve, update, delete
]

üöÄ Now our API views are fully optimized and scalable!




5. How Mixins Improve Code Structure
üöÄ Before (Manual Code Handling)
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

üöÄ After (Using Mixins)
class ProductList(ListModelMixin, CreateModelMixin, GenericAPIView):
    queryset = Product.objects.select_related('collection').all()
    serializer_class = ProductSerializer
	
‚úÖ Less code, same functionality!




codes referred in this discussion:
from rest_framework.mixins import ListModelMixin, CreateModelMixin

class ListModelMixin:
    """
    List a queryset.
    """
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class CreateModelMixin:
    """
    Create a model instance.
    """
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return {'Location': str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}



django rest framework --> https://www.django-rest-framework.org/ --> API Guide --> Generic views --> 




Key Takeaways
‚úî Mixins remove redundant code and streamline API views. 
‚úî ListModelMixin encapsulates logic for retrieving lists of objects. 
‚úî CreateModelMixin handles resource creation, including validation and saving. 
‚úî Other mixins (RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin) handle object retrieval, updates, and deletion. 
‚úî Refactoring views with mixins makes APIs scalable and maintainable. 
‚úî Use GenericAPIView to combine mixins and customize behavior when needed.












Generic Views:
--------------
Now, most of the time, we are not going to use these mixins directly. Instead, we're going to use concrete classes that combine one or more mixins. We call these classes generic views. 

Generic views simplify API development by combining mixins to provide reusable, structured functionalities. They reduce boilerplate code and make API views more scalable.

üöÄ Why Use Generic Views?
‚úî Less Boilerplate Code ‚Üí Eliminates repetitive logic across views. 
‚úî Encapsulation ‚Üí Groups related behaviors into concrete classes. 
‚úî Scalability ‚Üí Makes adding new API endpoints easier. 
‚úî Customization ‚Üí Easily override methods when needed.




1. Identifying Common Patterns in API Views
‚úî When listing products (ProductList) and collections (CollectionList), both views perform similar operations:
Define a queryset (fetch database records).
Assign a serializer for data transformation.
Return serialized data in the API response.

So, the main differences across models are: 
 - How they create a queryset. 
 - The serializer classes they use.

‚úî Similarly, when creating products or collections, the views:
 - Instantiate a serializer with request data.
 - Validate the data.
 - Save the model instance.
 - Return the serialized object in the API response.

üöÄ This repetition indicates generic views can streamline the implementation!




2 .Understanding Django REST Framework‚Äôs Generic Views
Django REST Framework provides built-in generic views that combine one or more mixins to handle API actions.

üìå Built-in Generic Views 
‚úî ListCreateAPIView ‚Üí Handles listing and creation. 
‚úî ListAPIView ‚Üí Handles only listing (GET). 
‚úî RetrieveAPIView ‚Üí Handles retrieving single resources (GET). 
‚úî RetrieveUpdateAPIView, RetrieveDestroyAPIView, RetrieveUpdateDestroyAPIView ‚Üí Supports update, delete, and retrieve.




3. Exploring Built-in Generic Views in DRF
‚úî ListCreateAPIView ‚Üí Encapsulates logic for listing and creating objects.

üìå Implementation
from rest_framework.generics import ListCreateAPIView

class ListCreateAPIView(mixins.ListModelMixin,
                        mixins.CreateModelMixin,
                        GenericAPIView):
    """
    Concrete view for listing a queryset or creating a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)

üöÄ DRF automatically handles listing (GET) and creation (POST), removing redundant code!

‚úî GenericAPIView ‚Üí The base class for all generic views. It provides key methods to override: 
üìå get_queryset() ‚Üí Defines the queryset. 
üìå get_serializer_class() ‚Üí Specifies the serializer. 
üìå get_serializer_context() ‚Üí Provides request data in serializer context.




4. Applying Generic Views in Our API

üìå Refactor ProductList to use Generic Views
from rest_framework.generics import ListCreateAPIView

class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related('collection').all()  # ‚úÖ Define queryset
    serializer_class = ProductSerializer  # ‚úÖ Assign serializer class

	def get_serializer_context(self):
		return {'request': self.request}
		
üöÄ Now, ProductList supports both GET and POST without needing separate methods!

üìå Refactor CollectionList
class CollectionList(ListCreateAPIView):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer
	
‚úî Now, collections can be listed or created using the same optimized view.




5. Handling Read-Only Fields in Serializers
üöÄ Problem: products_count should not be included when creating/updating a collection. üöÄ Solution: Mark the field as read-only in the serializer.

üìå Implementation
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title', 'products_count']

    products_count = serializers.IntegerField(read_only=True)
	
‚úî Prevents products_count from appearing in POST requests, avoiding unnecessary validation errors.




6. How Generic Views Improve Code Structure

üöÄ Before (Manual API Logic)
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

üöÄ After (Using Generic Views)
class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related('collection').all()
    serializer_class = ProductSerializer
	
‚úÖ Less code, same functionality!

üìå Updating urls.py
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ‚úÖ Handles list and creation
    path('collections/', views.CollectionList.as_view()),  # ‚úÖ Handles list and creation
]

üöÄ Our API views are now optimized and scalable!




Codes referred in this discussion:

from rest_framework.generics import ListCreateAPIView

class ListCreateAPIView(mixins.ListModelMixin,
                        mixins.CreateModelMixin,
                        GenericAPIView):
    """
    Concrete view for listing a queryset or creating a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)



class ProductList(ListCreateAPIView):
	def get_queryset(self):
		return Product.objects.select_related('collection').all()
		
	def get_serializer_class(self):
		return ProductSerializer
		
	def get_serializer_context(self):
		return {'request': self.request}



class ProductList(ListCreateAPIView):
	queryset = Product.objects.select_related('collection').all()
	serializer_class = ProductSerializer
		
	def get_serializer_context(self):
		return {'request': self.request}


For collection:
class CollectionList(ListCreateAPIView):
	queryset = Collection.objects.annotate(products_count=Count('products')).all()
	serializer_class = CollectionSerializer


make 'product_count' as read_only:
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title', 'products_count']

    products_count = serializers.IntegerField(read_only=True)




üìå Key Takeaways
‚úî Generic views remove redundant code and streamline API development. 
‚úî ListCreateAPIView handles both listing and creation efficiently. 
‚úî RetrieveAPIView, UpdateAPIView, and DestroyAPIView encapsulate retrieval, updates, and deletion. 
‚úî Using queryset and serializer class attributes simplifies API views. 
‚úî Refactoring with generic views makes APIs more maintainable and scalable. 
‚úî Use GenericAPIView when more customization is needed.











Customizing Generic Views:
--------------------------
Generic views provide powerful abstractions, but sometimes we need custom logic that they don‚Äôt directly support. This section explores how to customize Django REST Framework (DRF) generic views.

üöÄ Why Customize Generic Views?
‚úî Handle complex logic ‚Üí Some functionalities (e.g., conditional deletion) are specific to your application. 
‚úî Optimize code structure ‚Üí Removing redundant view logic while keeping custom behavior intact. 
‚úî Maintain DRY principles ‚Üí Use built-in mixins while overriding only necessary parts.

1. Understanding RetrieveUpdateDestroyAPIView
We use RetrieveUpdateDestroyAPIView when we need GET (retrieve), PUT (update), and DELETE (remove) operations in a view.

üìå Built-in Class Structure
class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,
                                   mixins.UpdateModelMixin,
                                   mixins.DestroyModelMixin,
                                   GenericAPIView):
    """
    Concrete view for retrieving, updating or deleting a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
‚úî Provides default implementations for GET, PUT, PATCH, and DELETE. ‚úî We can override specific methods if needed.




2. Customizing ProductDetail View
The ProductDetail view provides retrieving, updating, and deleting products.

üìå Implementation
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
üöÄ Why override delete()? 
‚úî DestroyModelMixin doesn‚Äôt understand business rules. 
‚úî Our app needs to check if a product is linked to an order before deletion. 
‚úî Returns an error if deletion isn‚Äôt allowed.




3. Handling URL Parameter Naming (pk vs. id)
By default, DRF expects the URL parameter pk, but our URL pattern uses id.

üìå Incorrect URL pattern
path('products/<int:id>/', views.ProductDetail.as_view()),

üöÄ Fix: Change id to pk OR use lookup_field in the view.

üìå Using lookup_field
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    lookup_field = 'id'  # Overrides default 'pk'
	
‚úî Now DRF correctly identifies the URL parameter.

üöÄ Best Practice: Stick to Django‚Äôs convention (pk) for consistency.




4. Testing Deletion Errors
Possible Errors When Deleting a Product
üìå Error: Unexpected keyword argument pk in delete() 
‚úî Cause: The method expected id, but URLs use pk. 
‚úî Fix: Rename id to pk inside delete().

üìå Error: Product cannot be deleted because it is associated with an order item. 
‚úî Cause: Business rule prevents deleting a product linked to an order. 
‚úî Fix: Validate relationships before deletion.




5. Customizing CollectionDetail View
Like ProductDetail, the CollectionDetail view also requires a custom delete method.

üìå Implementation
class CollectionDetail(RetrieveUpdateDestroyAPIView):
    queryset = Collection.objects.annotate(products_count=Count('products'))
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
		
üöÄ What‚Äôs Different? 
‚úî Prevents collections containing products from being deleted. 
‚úî Uses annotate(products_count=Count('products')) to count related products efficiently.

6. Updating urls.py for Generic Views
We need to register our optimized views in the URLs.

üìå Updated URL Configuration
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ‚úÖ Handles listing and creation
    path('products/<int:pk>/', views.ProductDetail.as_view()),  # ‚úÖ Handles retrieve, update, delete
    path('collections/', views.CollectionList.as_view()),  # ‚úÖ Handles listing and creation
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),  # ‚úÖ Handles collection actions
]

üöÄ Now our API follows a clean, scalable structure.




Codes discussed in this lesson:

class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,
                                   mixins.UpdateModelMixin,
                                   mixins.DestroyModelMixin,
                                   GenericAPIView):
    """
    Concrete view for retrieving, updating or deleting a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)

class ProductDetail(RetrieveUpdateDestroyAPIView):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def delete(self, request, pk):
		product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

class CollectionDetail(RetrieveUpdateDestroyAPIView):
	queryset = Collection.objects.annotate(products_count=Count('products'))
	serializer_class = CollectionSerializer
	
	def delete(self, request, pk):
		collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

# URLConf
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:pk>/', views.ProductDetail.as_view()),
    path('collections/', views.CollectionList.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
]




üìå Key Takeaways
‚úî Generic views provide efficient API development but may need customization. 
‚úî Override delete() when business rules require additional validation. 
‚úî Use lookup_field to match URL parameter names (default is pk). 
‚úî Collection deletion should prevent removing collections that contain products. 
‚úî Stick to DRF conventions (pk) unless a strong reason exists to modify them.













class based views --> to avoid duplication(to combine multiple operations) --> mixins --> combined mixins with GenericView --> to avoid duplication(to combine multiple views) --> ViewSets

ViewSets:
---------
ViewSets combine multiple related views into a single class, reducing code duplication and improving maintainability.

üöÄ Why Use ViewSets?
‚úî Eliminates redundancy ‚Üí Combines similar views into a single class. 
‚úî Encapsulation ‚Üí Groups all logic related to a resource (e.g., products). 
‚úî Scalability ‚Üí Makes API endpoints more manageable and structured. 
‚úî Less boilerplate ‚Üí No need for separate classes for listing, creating, updating, and deleting.

1. Identifying Code Duplication in API Views
üìå Current Issue: 
‚úî We have two separate views for ProductList (listing & creating) and ProductDetail (retrieving, updating, deleting). 
‚úî Both views share similar querysets and the same serializer_class.

üìå Solution: ‚úî Use ViewSets to merge related views into a single class.

üöÄ What Changes? 
‚úî No need for ProductList and ProductDetail as separate classes. 
‚úî ProductViewSet will handle listing, creating, updating, and deleting in one class.




2. Understanding ViewSet Structure
üìå Import ViewSets
from rest_framework.viewsets import ModelViewSet

üìå Implementation of ModelViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, pk):  # ‚úÖ Note: `destroy()` is used in `ModelViewSet`, not `delete()`
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
üöÄ How does this improve our code? 
‚úî Combines listing, creating, retrieving, updating, and deleting into one class. 
‚úî Overrides destroy() to add business logic (prevent deletion of linked products). 
‚úî Uses queryset & serializer_class attributes, reducing redundant method definitions.




3. Refactoring Collection Views Using ViewSets
üìå Implementation
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):  # ‚úÖ Custom delete logic for collections
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT
		
üöÄ What changed?
‚úî Merged CollectionList & CollectionDetail into CollectionViewSet.
‚úî Prevent deletion of collections with associated products.




4. Read-Only ViewSets (ReadOnlyModelViewSet)
Sometimes, we only need to retrieve data without allowing creation, updates, or deletions.

üìå Using ReadOnlyModelViewSet
from rest_framework.viewsets import ReadOnlyModelViewSet

class ReadOnlyCollectionViewSet(ReadOnlyModelViewSet):
    queryset = Collection.objects.all()
    serializer_class = CollectionSerializer
	
üöÄ Effect: 
‚úî API only supports GET operations (list and retrieve). 
‚úî No POST, PUT, or DELETE‚Äîideal for read-only endpoints.

5. Updating urls.py for ViewSets
Since ViewSets don‚Äôt work with regular path() routes, we will use routers to register them dynamically.

üìå Basic URL Mapping
urlpatterns = [
    path('products/', views.ProductViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('products/<int:pk>/', views.ProductViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'})),
    path('collections/', views.CollectionViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('collections/<int:pk>/', views.CollectionViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
]


üöÄ What changed? 
‚úî We replaced ProductList and ProductDetail with ProductViewSet. 
‚úî We replaced CollectionList and CollectionDetail with CollectionViewSet.

üöÄ Next Step: Using routers for automatic route management (covered in the next lesson).


Codes in this lesson:
Using a view set, we can combine the logic for multiple related views inside a single class. 

from rest_framework.viewsets import ModelViewSet

class ProductViewSet(ModelViewSet):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}
	
	def destroy(self, request, pk):      #note modelViewSet has destroy method not delete method
		if OrderItem.objects.filter(product_id=kwargs['pk']).count > 0   (changing the logic, since self. fetching product already)
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		return super().destroy(request, *args, **kwargs)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(
        products_count=Count('products')).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


Go through ReadOnlyModelViewSet and other viewsets




üìå Key Takeaways
‚úî ViewSets merge multiple related views into a single class, improving code structure. 
‚úî ModelViewSet provides full CRUD functionality (list, create, retrieve, update, delete). 
‚úî ReadOnlyModelViewSet restricts endpoints to only GET operations. 
‚úî Customizing destroy() in ViewSets lets us enforce business rules before deletion. 
‚úî Routers will help us automate URL handling (covered in the next lesson).











Routers:
--------
Routers automatically generate URL patterns for ViewSets, eliminating the need for manually defining each route.

üöÄ Why Use Routers?
‚úî Simplifies URL management ‚Üí No need to manually define path() for ViewSets. 
‚úî Ensures consistency ‚Üí Standardized routes for API resources. 
‚úî Handles ViewSets dynamically ‚Üí Registers all view logic within a single router. 
‚úî Supports additional features ‚Üí Default Router provides API navigation and JSON formatting.

1Ô∏è. Understanding Router Mechanism in DRF

üìå Manually Defining ViewSet URLs (Before Using Routers)
urlpatterns = [
    path('products/', views.ProductViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('products/<int:pk>/', views.ProductViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'})),
    path('collections/', views.CollectionViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('collections/<int:pk>/', views.CollectionViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
]

üöÄ Problem: 
‚úî Manually specifying routes is redundant and requires updates for every new ViewSet. 
‚úî Solution: Use Routers to automate URL generation.




2. Using SimpleRouter to Register ViewSets
üìå Import and Register ViewSets

from rest_framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)  # ‚úÖ Registers ProductViewSet
router.register('collections', views.CollectionViewSet)  # ‚úÖ Registers CollectionViewSet

# URL configuration
urlpatterns = router.urls  # ‚úÖ Automatically generates routes for ViewSets

üöÄ Effect: 
‚úî Eliminates the need for manual URL definitions. 
‚úî Maps ViewSets automatically to routes.

üìå Generated URL Patterns (router.urls)

[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>]
 
üöÄ What changed? 
‚úî product-list ‚Üí Handles listing (GET) and creation (POST). 
‚úî product-detail ‚Üí Handles retrieving (GET), updating (PUT), and deleting (DELETE). 
‚úî collection-list & collection-detail work similarly.




3. Handling Additional URL Patterns
If our project includes custom routes, we use include() to merge router-generated URLs with additional patterns.

üìå Example: Including Router URLs With Custom Paths
from django.urls import path, include

urlpatterns = [
    path('', include(router.urls)),  # ‚úÖ Registers all ViewSet URLs
    path('custom-path/', views.CustomView.as_view()),  # ‚úÖ Additional custom routes
]

üöÄ Effect: ‚úî Allows merging router-generated URLs with manually defined patterns.




4. Using DefaultRouter for Additional Features

üìå Replacing SimpleRouter with DefaultRouter
from rest_framework.routers import DefaultRouter

router = DefaultRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

urlpatterns = router.urls

üöÄ What extra features does DefaultRouter provide? 
‚úî API Root Navigation ‚Üí Visiting /store/ shows a page listing all available endpoints. 
‚úî JSON Browsing Support ‚Üí Appending .json to an endpoint returns JSON-formatted data.

üìå Example: JSON Output
GET /store/products.json  
# Returns all products in JSON format

üöÄ When to Use DefaultRouter? 
‚úî Use DefaultRouter if you want API navigation and JSON formatting. 
‚úî Use SimpleRouter if you prefer a clean, minimal API without extra endpoints.




5. Fixing Issues With destroy() Instead of delete()
üìå Problem: Delete Button Appearing on the Wrong View 
‚úî Cause: When converting ProductDetail to ProductViewSet, the delete() method was not replaced with destroy().

üìå Fix: Override destroy() Instead of delete()
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def destroy(self, request, *args, **kwargs):  # ‚úÖ Correct method for ViewSets
        if OrderItem.objects.filter(product_id=pk).count() > 0:
            return Response({'error': 'Product cannot be deleted'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        return super().destroy(request, *args, **kwargs)
		
üöÄ Effect: 
‚úî Ensures delete functionality only appears on individual product pages. 
‚úî Prevents unnecessary database queries by using get_object() from DestroyModelMixin.

üìú Code References Used
from rest-framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

Now the urls will be available at --> router.urls


when you print router.urls: 
[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk[^/.]+)/$' [name='collection-detail']>]


so, 
#URLCONF
urlpatterns = router.urls

if you have other urls

urlpatterns = [
 path('', include(router.urls)),
]


from rest-framework.routers import DefaultRouter


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
	
    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):  
        if OrderItem.objects.filter(product_id=pk).count() > 0:
            return Response({'error': 'Product cannot be deleted'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        return super().destroy(request, *args, **kwargs)




üìå Key Takeaways
‚úî Routers simplify URL handling by automatically registering ViewSet endpoints. 
‚úî SimpleRouter generates standard API routes for ViewSets. 
‚úî DefaultRouter adds API root navigation and JSON formatting. 
‚úî Use include(router.urls) if additional custom paths are needed. 
‚úî Always override destroy() instead of delete() in ViewSets. 
‚úî Routers eliminate the need for manual URL definitions, making API maintenance easier.











Building the Reviews API:
-------------------------
We are introducing reviews in our API, allowing products to have associated customer feedback. ‚úî Each product can have multiple reviews. ‚úî We need to implement nested resources for managing product reviews.

üöÄ Steps to Build the Reviews API
1. Define the Model
‚úî Create a model class to represent reviews. 
‚úî Generate a migration for database schema changes. 
‚úî Apply the migration to update the database.

üìå Implementation (models.py)
from django.db import models

class Review(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='reviews')  # ‚úÖ Link to Product
    name = models.CharField(max_length=255)  # ‚úÖ Name of the reviewer
    description = models.TextField()  # ‚úÖ Review content (unlimited length)
    date = models.DateField(auto_now_add=True)  # ‚úÖ Timestamp when review was created
	
üöÄ Key Features: 
‚úî Foreign Key (product) ‚Üí Links reviews to products. 
‚úî Cascade delete (on_delete=models.CASCADE) ‚Üí If a product is deleted, its reviews are also removed. 
‚úî Related Name (reviews) ‚Üí Allows access via product.reviews. 
‚úî Auto timestamp (auto_now_add=True) ‚Üí Automatically sets review date on creation.




2. Generate & Apply Migrations
‚úî Step 1: Create a migration file for the model changes.
python manage.py makemigrations

‚úî Step 2: Apply the migration to update the database schema.
python manage.py migrate

üöÄ Best Practice:
‚úî Always run migrations after modifying models to prevent accumulating untracked changes.




3. Create the Serializer
‚úî Transform Review objects into JSON format for API responses. 
‚úî Define fields that should be exposed to clients.

üìå Implementation (serializers.py)

from rest_framework import serializers
from .models import Review

class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description', 'product']  # ‚úÖ Fields exposed in API response

üöÄ Key Features: 
‚úî Uses ModelSerializer for automatic field mapping. 
‚úî Includes ID, date, name, description, and product attributes.




4. Create the ViewSet
‚úî Use ModelViewSet ‚Üí Combines listing, creating, updating, and deleting reviews into a single class.

üìå Implementation (views.py)
from rest_framework.viewsets import ModelViewSet
from .models import Review
from .serializers import ReviewSerializer

class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()  # ‚úÖ Retrieve all reviews
    serializer_class = ReviewSerializer  # ‚úÖ Serialize review objects
	
üöÄ Why use ModelViewSet? 
‚úî Eliminates redundant code ‚Üí Handles CRUD operations in one class. 
‚úî Provides flexibility ‚Üí Can override methods if custom logic is needed.




5. Register the Route
‚úî Use nested routers ‚Üí Reviews belong to specific products, requiring URLs like /products/{id}/reviews/.

üìå Basic Router Registration (urls.py)
from rest_framework.routers import SimpleRouter
from .views import ReviewViewSet

router = SimpleRouter()
router.register('reviews', ReviewViewSet)  # ‚úÖ Register review endpoints

urlpatterns = router.urls  # ‚úÖ Auto-generates URL patterns for reviews

üöÄ Next Step: ‚úî Implement nested routers to integrate reviews within product endpoints (covered in the next lesson).

üìú Code References Used

Building the Model:
create a model model class
create a migration
apply a migration

models.py:
class Review(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='reviews')
    name = models.CharField(max_length=255)
    description = models.TextField()
    date = models.DateField(auto_now_add=True)


Building the API:
create a serializer
create a view
register a route

serializers.py:
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']


üìå Key Takeaways
‚úî Reviews are nested resources inside products. 
‚úî Foreign key with on_delete=models.CASCADE ensures dependent deletion. 
‚úî Serializers convert model instances into JSON for API responses. 
‚úî ViewSets simplify API logic by combining multiple operations in one class. 
‚úî Using routers eliminates manual route definitions. 
‚úî Next step: Implementing nested routers for /products/{id}/reviews/.










Nested Routers:
---------------
When working with nested resources (e.g., reviews belonging to products), we use nested routers to maintain structured, hierarchical API endpoints.

üöÄ Why Use Nested Routers?
‚úî Organized API Structure ‚Üí Keeps child resources under their parent. 
‚úî Automatic Route Management ‚Üí Generates routes dynamically using routers. 
‚úî Efficient Lookups ‚Üí Fetch child resources based on parent relationships (/products/{id}/reviews). 
‚úî Reduces Manual URL Configuration ‚Üí No need to manually define nested paths.

1. Desired URL Structure
üìå Example: Domains & NameServers in a Nested Router (GitHub Reference)

/domains/                  <- Domains list
/domains/{pk}/             <- Retrieve specific domain
/domains/{domain_pk}/nameservers/  <- List name servers for a specific domain
/domains/{domain_pk}/nameservers/{pk}  <- Retrieve a specific name server for a domain

üöÄ We apply this logic for Products and Reviews: 
‚úî /products/ ‚Üí Lists all products. 
‚úî /products/{pk}/ ‚Üí Retrieves a specific product. 
‚úî /products/{product_pk}/reviews/ ‚Üí Lists reviews only for a specific product. 
‚úî /products/{product_pk}/reviews/{pk}/ ‚Üí Retrieves a specific review of a product.




2. Installing & Importing drf-nested-routers
üìå Install Nested Routers
pipenv install drf-nested-routers

üìå Import Required Classes (urls.py)
from rest_framework_nested import routers




3. Configuring Nested Routers for Products & Reviews
üìå Step 1: Create the Parent Router
router = routers.SimpleRouter()
router.register(r'products', ProductViewSet)  # ‚úÖ Registers product endpoints

üìå Step 2: Create the Nested Router
products_router = routers.NestedSimpleRouter(router, r'products', lookup='product')
products_router.register(r'reviews', ReviewViewSet, basename='product-reviews')  # ‚úÖ Registers review endpoints inside products

üöÄ How It Works: 
‚úî Parent Prefix (products) ‚Üí Defines products/ as the base. 
‚úî Lookup Parameter (product) ‚Üí Creates {product_pk} in nested routes. 
‚úî Child Prefix (reviews) ‚Üí Maps /products/{product_pk}/reviews/ to ReviewViewSet. 
‚úî Basename (product-reviews) ‚Üí Generates URL patterns like product-reviews-list & product-reviews-detail.

üìå Step 3: Include Routers in URL Patterns
urlpatterns = [
    path('', include(router.urls)),          # ‚úÖ Registers top-level product routes
    path('', include(products_router.urls)), # ‚úÖ Registers nested review routes inside products
]

or 

urlpatterns = router.urls + products_router.urls

üöÄ Result: 
‚úî /products/ ‚Üí Lists all products. 
‚úî /products/{product_pk}/reviews/ ‚Üí Lists reviews for a specific product. 
‚úî /products/{product_pk}/reviews/{pk}/ ‚Üí Retrieves, updates, or deletes a review inside a product.




4. Fixing Review Creation Without product_id in Request
üöÄ Problem: 
‚úî When posting a review, we shouldn't pass product_id in the request body. 
‚úî Instead, we should extract it from the URL.

üìå Step 1: Modify ReviewSerializer to Remove product_id
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']
		
üöÄ Effect: 
‚úî API no longer requires product_id in the request body. 
‚úî Now, we must fetch product_id from the URL within ReviewViewSet.

üìå Step 2: Pass product_id in Serializer Context (views.py)
class ReviewViewSet(ModelViewSet):
    serializer_class = ReviewSerializer

    def get_queryset(self):
        return Review.objects.filter(product_id=self.kwargs['product_pk'])  # ‚úÖ Filters reviews based on product_pk

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}  # ‚úÖ Pass product ID from URL to serializer
		
üöÄ Effect: 
‚úî product_pk is extracted from the nested URL and passed to the serializer. 
‚úî Ensures only reviews for a specific product are displayed.

üìå Step 3: Override create() Method in ReviewSerializer
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']

    def create(self, validated_data):
        product_id = self.context['product_id']  # ‚úÖ Retrieve product ID from context
        return Review.objects.create(product_id=product_id, **validated_data)  # ‚úÖ Create review with extracted product ID
		
üöÄ Effect: 
‚úî product_id is automatically assigned when creating a review. 
‚úî Removes the need for manually specifying product_id in request payload.





5. Fixing Review Visibility Issue
üöÄ Problem: 
‚úî All reviews were shown, regardless of product ID in the URL. 
‚úî Reviews must be filtered based on the specific product in the request.

üìå Fix: Override get_queryset() in ReviewViewSet
class ReviewViewSet(ModelViewSet):
    serializer_class = ReviewSerializer

    def get_queryset(self):
        return Review.objects.filter(product_id=self.kwargs['product_pk'])  # ‚úÖ Ensures only reviews of the requested product are shown
		
üöÄ Effect: 
‚úî /products/2/reviews/ only displays reviews for product 2. 
‚úî Prevents showing reviews from other products incorrectly.




üìú Code References Used
nested routers --> https://github.com/alanjds/drf-nested-routers

The desired URL signatures are:
/domains/ <- Domains list
/domains/{pk}/ <- One domain, from {pk}
/domains/{domain_pk}/nameservers/ <- Nameservers of domain from {domain_pk}
/domains/{domain_pk}/nameservers/{pk} <- Specific nameserver from {pk}, of domain from {domain_pk}

How to do it (example):
# urls.py
from rest_framework_nested import routers
from views import DomainViewSet, NameserverViewSet
(...)

router = routers.SimpleRouter()
router.register(r'domains', DomainViewSet)

domains_router = routers.NestedSimpleRouter(router, r'domains', lookup='domain')
domains_router.register(r'nameservers', NameserverViewSet, basename='domain-nameservers')
# 'basename' is optional. Needed only if the same viewset is registered more than once
# Official DRF docs on this option: http://www.django-rest-framework.org/api-guide/routers/

urlpatterns = [
    path(r'', include(router.urls)),
    path(r'', include(domains_router.urls)),
]



pipenv install drf-nested-routers

from rest_framework_nested import routers




Note: In the view class, we have access to URL parameters, eg. we can read the product_id from the URL and using a context object, we can pass it to the serializer. So, Remember that we use a context object to provide additional data  to the serializer. 
So, if you want pass anything from the request(from the user) in viewset to the serializer, we use context 

class ReviewViewSet(ModelViewSet):
	serializer_class = ReviewSerializer
	
	def get_queryset(self):
		return Review.objects.filter(product_id=self.kwargs['product_pk'])
	
	def get_serializer_context(self):
		return{'product_id': self.kwargs['product_pk']}

class ReviewSerializer(serializer.ModelSerializer):
	class Meta:
		model = Review
		fields = ['id', 
		
	def create(self, validated_data):
	    product_id = self.context['product_id']
		return Review.objects.create(product_id=product_id, **validated_data) 





üìå Key Takeaways
‚úî Nested routers organize API endpoints hierarchically (/products/{id}/reviews/). 
‚úî drf-nested-routers automates nested route management. 
‚úî Parent-child relationships are reflected in generated URL patterns. 
‚úî Extract product_id from URL instead of requiring it in request payload. 
‚úî Modify get_queryset() to ensure reviews are filtered by the parent product. 










Quick QnA session:
------------------
Here's a quick note to clarify where resource creation, updating, and deletion happens in Django REST Framework (DRF):

üìå What happens in the Serializer?
The create() method inside ReviewSerializer handles object creation based on validated data.
This method does not handle updates or deletions‚Äîit only creates a new review instance.
The validated_data dictionary contains fields passed in the request.
The product_id is extracted from self.context, ensuring the review is associated with the correct product.




üöÄ Where are updates and deletions handled? 
‚úî Updates (PUT, PATCH) ‚Üí Handled in the ViewSet, specifically via update() (from UpdateModelMixin). 
‚úî Deletions (DELETE) ‚Üí Managed in the ViewSet, via destroy() (from DestroyModelMixin). 
‚úî The ViewSet interacts with the queryset, retrieving objects and performing updates/deletes.

üìå Summary: 
‚úî Creation happens inside the create() method in the serializer. 
‚úî Updates & deletions are performed inside the ViewSet (not the serializer).
‚úî Serializers primarily validate and format data for API requests and responses.



Is this common in django, don't we have viewset for create, update and delete. Or creation happens in serializers and rest of the operations like update, delete, get happens in the viewset. clarify me

Great question! Here's a clear breakdown of how create, update, and delete operations work in Django REST Framework (DRF):

üöÄ Where Do CRUD Operations Happen in Django REST Framework?
‚úî Creation (POST) ‚Üí Usually handled inside the serializer (create() method). 
‚úî Update (PUT, PATCH) ‚Üí Handled inside the ViewSet, using built-in mixins. 
‚úî Delete (DELETE) ‚Üí Managed inside the ViewSet, using destroy(). 
‚úî Retrieve (GET) ‚Üí Handled inside the ViewSet, using retrieve() or list().


1. Why Does Creation Happen in the Serializer?
üìå When a POST request is sent, DRF calls the create() method of the serializer. 
‚úî Serializers validate data before saving it. 
‚úî They define how a model instance is created with validated_data. 
‚úî If extra logic is needed (like assigning a foreign key from context), we override create().

üìå Example: create() inside a serializer
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']

    def create(self, validated_data):
        product_id = self.context['product_id']  # ‚úÖ Extract from context
        return Review.objects.create(product_id=product_id, **validated_data)  # ‚úÖ Create the review instance
		
üöÄ Effect: 
‚úî create() automatically saves a new instance using validated data. 
‚úî Used when creating new records instead of handling it inside ViewSet.


2. Where Do Update and Delete Happen?
Unlike create(), updates and deletions are handled inside the ViewSet because: 
‚úî Updating requires fetching an existing record first. 
‚úî Deletion should ensure conditions before removing an object.

üìå Example: Overriding destroy() inside ViewSet
class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def destroy(self, request, pk):  # ‚úÖ Override delete logic
        review = get_object_or_404(Review, pk=pk)
        review.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
üöÄ Effect: 
‚úî destroy() first fetches the object, applies any business rules, then deletes it. 
‚úî Update (PUT, PATCH) works similarly but modifies the existing object instead.

üìå Example: Overriding update() inside ViewSet
class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def update(self, request, pk):  # ‚úÖ Handles update logic
        review = get_object_or_404(Review, pk=pk)
        serializer = ReviewSerializer(review, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()  # ‚úÖ Update the review instance
        return Response(serializer.data)
		
üöÄ Effect: 
‚úî Ensures the existing review is fetched, validated, and updated correctly. 
‚úî Calls serializer.save() to commit changes to the database.



3. Summary: Where CRUD Operations Happen?
‚úî Create (POST) ‚Üí Inside the serializer (create()). 
‚úî Update (PUT, PATCH) ‚Üí Inside the ViewSet (update()). 
‚úî Delete (DELETE) ‚Üí Inside the ViewSet (destroy()). 
‚úî Retrieve (GET) ‚Üí Inside the ViewSet (retrieve() or list()).


üöÄ Why this structure?
‚úî Serializers focus on data validation & transformation. 
‚úî ViewSets focus on managing requests and database operations.












Filtering:
----------
Currently, the /products/ endpoint returns all products in the database. However, we need filtering functionality, such as filtering products by collection using query parameters (collection_id).

Example: üìå /store/products?collection_id=1 ‚Üí Returns products only in collection 1.

üöÄ Steps to Implement Filtering in ViewSet
1. Override get_queryset() Instead of Using queryset
Since filtering depends on user input (collection_id), we cannot set a static queryset. Instead, we override get_queryset() to dynamically filter products.

üìå Implementation (views.py)
class ProductViewSet(ModelViewSet):
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        queryset = Product.objects.all()  # ‚úÖ Start with all products
        collection_id = self.request.query_params.get('collection_id')  # ‚úÖ Retrieve query parameter
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)  # ‚úÖ Apply filter dynamically
        return queryset  # ‚úÖ Return filtered queryset
		
üöÄ Effect: 
‚úî Retrieves collection_id from the query parameters. 
‚úî Filters products dynamically based on user input (GET request). 
‚úî If no filter is applied, returns all products.




2. Explicitly Set basename in Router
üöÄ Problem: 
‚úî Django REST Framework automatically determines the basename from the queryset attribute. 
‚úî Since we overrode get_queryset(), DRF cannot infer the base name automatically. 
‚úî This leads to an error during API loading.

üìå Solution: Define basename explicitly in urls.py
router.register('products', views.ProductViewSet, basename='products')  # ‚úÖ Explicitly set base name

üöÄ Effect: 
‚úî Fixes API error where DRF cannot determine basename automatically. 
‚úî Generates proper URL names (e.g., products-list, products-detail).




3. Handling Query Parameter Errors
üöÄ Problem: 
‚úî If collection_id is not present in query parameters, the API throws a multi-value dictionary key error. 
‚úî This happens when trying to access a non-existent key using bracket notation (self.request.query_params['collection_id']).

üìå Solution: Use .get() Instead of []
collection_id = self.request.query_params.get('collection_id')  # ‚úÖ Returns None if key doesn‚Äôt exist
üöÄ Effect: 
‚úî .get('collection_id') ‚Üí Returns None if the key doesn‚Äôt exist, avoiding dictionary key errors. 
‚úî Prevents unnecessary crashes when no filtering is applied.




4. Testing the Implementation
‚úî Visit /store/products/ ‚Üí Returns all products. 
‚úî Visit /store/products?collection_id=1 ‚Üí Returns filtered products only in collection 1. 
‚úî Remove collection_id ‚Üí API defaults back to returning all products.




üìú Code References Used
127.0.0.1:8000/store/products?collection_id=1

in the ProductViewSet:
overriding the get_queryset function:
def get_queryset(self):
	queryset= Product.objects.all()
	collection_id = self.request.query_params.get('collection_id')
	if collection_id is not None:
		queryset = queryset.filter(collection_id=collection_id)
	
	return queryset  


also remember to add basename to the respective router since we overridden the get_queryset, django will unable to set the basename

in urls.py --> router.register('products', views.ProductViewSet, basename='products')




üìå Key Takeaways
‚úî Filter products dynamically using query parameters (collection_id). 
‚úî Override get_queryset() to apply filters based on user requests. 
‚úî Use .get() instead of brackets ([]) to avoid missing key errors. 
‚úî Explicitly set basename in urls.py to prevent DRF errors. 
‚úî Next steps: Implement more advanced filtering techniques using Django Filters!





Explanation of 2nd point (setting the basename, since queryset is overrode by get_queryset()):
---------------------------------------------------------------------------------------------
üöÄ What is basename in Django REST Framework?
‚úî basename is used internally by DRF to generate the names of URL patterns. 
‚úî These names are essential when referring to named routes in Django. 
‚úî Typically, DRF automatically determines the basename from the queryset inside a ViewSet.


Example URL names DRF generates: 
üìå products-list ‚Üí Handles /products/ (GET request for listing products). 
üìå products-detail ‚Üí Handles /products/{pk}/ (GET request for a single product).


üöÄ Why Does basename Become a Problem?
When you register a ViewSet using a router, DRF automatically assigns a basename. 
‚úî Normally, it uses the model name from the queryset to generate URLs (products-list, products-detail). 
‚úî BUT when we override get_queryset(), DRF can no longer infer the base name automatically.


üöÄ Effect: 
‚úî DRF throws an error during API loading because it doesn't know the basename. 
‚úî Your API fails to work properly without explicitly defining it.


üöÄ Solution: Explicitly Define basename in Router
‚úî Since DRF cannot determine it on its own, we must manually set it when registering the ViewSet.


üìå Fix this by explicitly defining basename in urls.py:
router.register('products', views.ProductViewSet, basename='products')
üöÄ Effect: 
‚úî Prevents errors when DRF cannot infer basename. 
‚úî Generates correct URL patterns (products-list, products-detail). ‚úî Your API works smoothly without confusion.


üöÄ Summary (Why basename Matters)
‚úî When you override get_queryset(), DRF loses automatic basename detection. 
‚úî Explicitly setting basename fixes errors and allows DRF to generate correct URL names. 
‚úî This ensures proper route handling (products-list, products-detail).




How it detects the basename from the queryset initially.

Great question! Django REST Framework (DRF) detects the basename automatically using the queryset attribute in a ViewSet. Let me explain step by step.

üöÄ How DRF Determines basename Automatically
‚úî When you register a ViewSet using router.register(), DRF tries to infer the basename from the ViewSet's queryset. 
‚úî The default detection method follows this logic:

üìå Step 1: Check if queryset exists in the ViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ‚úÖ Defined queryset
    serializer_class = ProductSerializer
	
‚úî Since queryset is defined, DRF extracts the model name (Product) automatically. 
‚úî The model name is converted to lowercase and pluralized, resulting in: ‚úÖ basename = "product" (or "products", depending on the router).


üìå Step 2: Generates URL names using basename 
‚úî DRF then appends standard suffixes (-list, -detail) to create URL pattern names: 
‚úÖ products-list ‚Üí Handles /products/ (GET request for listing). 
‚úÖ products-detail ‚Üí Handles /products/{pk}/ (GET request for retrieving a single object).


üöÄ What Happens If queryset Is Missing?
‚úî If you override get_queryset() instead of defining queryset as an attribute, DRF cannot infer the model name anymore.

üìå Example of Overriding get_queryset()
class ProductViewSet(ModelViewSet):
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        queryset = Product.objects.all()
        collection_id = self.request.query_params.get('collection_id')
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)
        return queryset
		
		
üöÄ Problem: 
‚úî DRF no longer has a direct queryset attribute to extract the model name. 
‚úî As a result, basename detection fails, leading to an error.


üìå Solution: Explicitly Set basename
router.register('products', views.ProductViewSet, basename='products')
üöÄ Effect: 
‚úî Manually assigns the correct basename, ensuring DRF generates proper URL names (products-list, products-detail). 
‚úî Prevents API errors caused by missing automatic detection.


üöÄ Summary (How DRF Detects basename)
‚úî If queryset is defined, DRF automatically extracts the model name (Product ‚Üí "products"). 
‚úî If queryset is missing or overridden, DRF cannot infer the basename‚Äîso we must set it manually. 
‚úî Basename helps DRF generate named routes (products-list, products-detail) for linking views.












Generic Filtering:
------------------
Filtering helps refine API responses based on specific criteria. While basic filtering works for a single field, generic filtering allows filtering across multiple fields effortlessly using Django Filter, eliminating manually coded filters.

üöÄ Why Use Django Filter?
‚úî Simplifies filtering logic ‚Üí No need for manual query manipulation. 
‚úî Supports multiple fields ‚Üí Filter data by any attributes dynamically. 
‚úî Allows range filtering ‚Üí Query data greater or less than a value (e.g., unit price filtering). 
‚úî Enhances API usability ‚Üí Browsable API UI shows interactive filtering options.



1. Installing and Configuring Django Filter
üìå Step 1: Install Django Filter Library
pipenv install django-filter

üìå Step 2: Add Django Filter to Installed Apps (settings.py)
INSTALLED_APPS = [
    ...
    'django_filters',  # ‚úÖ Important: Use `django_filters`, not `django-filter`
]

üìå Step 3: Import DjangoFilterBackend in ViewSet (views.py)
from django_filters.rest_framework import DjangoFilterBackend




2. Implementing Basic Filtering in ViewSet
Instead of manually filtering within get_queryset(), we assign filter backends to DjangoFilterBackend.

üìå Basic Filtering (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ‚úÖ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]  # ‚úÖ Enable Django Filter
    filterset_fields = ['collection_id']  # ‚úÖ Allow filtering by `collection_id`
	
üöÄ Effect: 
‚úî Enables filtering by collection_id using query parameters. 
‚úî /store/products?collection_id=1 ‚Üí Returns products only in collection 1.

üìå Browsable API Enhancement: 
‚úî Adds "Filters" UI Button, allowing users to select filtering criteria interactively.




3. Implementing Advanced Filtering Using a Custom FilterSet
üöÄ Problem: 
‚úî Basic filtering only supports exact matches (collection_id=1). 
‚úî Need range-based filtering for numeric fields (e.g., unit price).

üìå Solution: Create a Custom FilterSet (filters.py)
from django_filters.rest_framework import FilterSet
from .models import Product

class ProductFilter(FilterSet):
    class Meta:
        model = Product
        fields = {
            'collection_id': ['exact'],  # ‚úÖ Filter by exact collection ID
            'unit_price': ['gt', 'lt']   # ‚úÖ Allow filtering by unit price range
        }
		
üöÄ Effect: 
‚úî Users can filter products greater or less than a specific price. 
‚úî /store/products?unit_price__gt=10 ‚Üí Returns products greater than $10. 
‚úî /store/products?unit_price__lt=20 ‚Üí Returns products less than $20.

üìå Step 2: Integrate ProductFilter in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter  # ‚úÖ Apply the custom filter class

üöÄ Effect: 
‚úî Encapsulates filtering logic inside ProductFilter. 
‚úî Supports range queries (unit_price__gt, unit_price__lt).




4. Testing Advanced Filtering in Browser API
üìå Apply Filters for Collection and Price Range 
‚úî All products: /store/products/ 
‚úî Filter by collection ID: /store/products?collection_id=1 
‚úî Filter by unit price greater than $10: /store/products?unit_price__gt=10 
‚úî Filter by unit price less than $20: /store/products?unit_price__lt=20 
‚úî Filter products between $10 - $20: /store/products?unit_price__gt=10&unit_price__lt=20

üìå Browsable API Enhancements 
‚úî Interactive "Filters" button allows users to select conditions. 
‚úî Query parameters automatically update based on UI selections.




üìú Code References Used
pipenv install django-filter

add it in the list of installed apps, remember while adding, it is 'django_filters'

from django_filters.rest_framework import DjangoFilterBackend


in ProductViewSet -->

filter_backends = [DjangoFilterBackend]
filterset_fields = ['collection_id']

and bring back the queryset to 
queryset = Product.objects.all()

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/


filters.py:
from django_filters.rest_framework import FilterSet
from .models import Product

class ProductFilter(FilterSet):
  class Meta:
    model = Product
    fields = {
      'collection_id': ['exact'],
      'unit_price': ['gt', 'lt']
    }


views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)





üìå Key Takeaways
‚úî Django Filter automates filtering logic, eliminating manual query manipulations. 
‚úî Use DjangoFilterBackend to enable generic filtering in ViewSets. 
‚úî Encapsulate filtering logic inside a FilterSet for advanced queries. 
‚úî Filtering by numeric ranges (gt, lt) allows more flexibility. 
‚úî Browsable API provides an interactive UI for filtering queries. 
‚úî Next steps: Implementing search functionality!















Searching:
----------
Searching allows users to find products by title or description dynamically. Unlike filtering, which works with specific field values, searching is designed for text-based queries.

üöÄ Why Use Searching?
‚úî Find products easily ‚Üí Users can search by keywords instead of exact field values. 
‚úî Supports multiple fields ‚Üí Search across title, description, and related fields. 
‚úî Case-insensitive ‚Üí Queries match text regardless of letter casing. 
‚úî Browsable API Enhancement ‚Üí Adds a search bar for interactive search functionality.


1. Adding Search Functionality in ViewSet
üìå Step 1: Import SearchFilter in Views (views.py)
from rest_framework.filters import SearchFilter

üìå Step 2: Enable Search Filtering in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ‚úÖ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter]  # ‚úÖ Add SearchFilter to filter backends
    search_fields = ['title', 'description']  # ‚úÖ Allow searching in `title` & `description`
	
üöÄ Effect: 
‚úî Enables search queries via query parameters. 
‚úî /store/products/?search=coffee ‚Üí Returns products containing "coffee" in title or description.

üìå Browsable API Enhancement: ‚úî Adds interactive search box in the browsable API UI. ‚úî Users can type a keyword, and results automatically filter without needing exact matches.




2. Searching Across Related Fields
üöÄ Problem: 
‚úî Searching works only on direct fields (title, description). 
‚úî What if we need to search within related fields, like collection__title?

üìå Solution: Reference Related Fields in search_fields
search_fields = ['title', 'description', 'collection__title']  # ‚úÖ Enables searching within related model fields

üöÄ Effect: 
‚úî Users can now search products by their collection name (collection__title). 
‚úî /store/products/?search=Summer Collection ‚Üí Returns all products belonging to "Summer Collection".




3. Multi-Keyword Search
‚úî Users can search using multiple keywords separated by spaces or commas.

üìå Example Queries: 
‚úî /store/products/?search=coffee ‚Üí Finds all products containing "coffee". 
‚úî /store/products/?search=coffee 10 ounce ‚Üí Finds products containing both "coffee" and "10 ounce". 
‚úî /store/products/?search=coffee, 10 ounce ‚Üí Works similarly, separating words with a comma.

üöÄ Effect: ‚úî Flexible search options make it easier for users to refine results.




4. Testing the Implementation in Browser API
üìå Step 1: Visit /store/products/ 
	‚úî Displays all products initially.
üìå Step 2: Try Searching 
	‚úî Enter "coffee" ‚Üí Returns products where "coffee" appears in title or description. 
	‚úî Enter "10 ounce" ‚Üí Filters products matching "10 ounce". 
	‚úî Enter "coffee 10 ounce" ‚Üí Returns products containing both words.
üìå Step 3: Search Across Related Fields 
	‚úî Enter "Summer Collection" ‚Üí Finds products linked to that collection title.
üìå Step 4: Ensure Case-Insensitive Matching 
	‚úî Try searching "COFFEE" ‚Üí Results should match even though uppercase is used.




5. Extending Search With Sorting & Pagination
üöÄ Enhancement: ‚úî Combine searching, sorting, and pagination for better user experience.

üìå Final ProductViewSet Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']
	
üöÄ Effect: ‚úî Users can search, sort, and paginate results dynamically.




Codes referenced in this lesson:
from rest_framework.filters import SearchFilter

in ProductViewSet -->

filter_backends = [DjangoFilterBackend, SearchFilter]
search_fields = ['title', 'description'] also we can reference fields in related classes 'collection__title'


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)




üìå Key Takeaways
‚úî Searching allows text-based queries on title & description. 
‚úî Supports searching within related fields (collection__title). 
‚úî Case-insensitive matching ensures better search usability. 
‚úî Multi-keyword search enables refined filtering. 
‚úî Browsable API provides interactive search functionality. 
‚úî Combining search with ordering & pagination improves user experience. 
‚úî Next steps: Implementing sorting functionality!










Sorting:
--------
Sorting allows users to organize API results dynamically based on specific fields, such as unit price or last update.

üöÄ Why Use Sorting?
‚úî Improves data readability ‚Üí Users can easily rank products by price or recent updates. 
‚úî Supports ascending & descending order ‚Üí Prefix fields with - for descending sort. 
‚úî Allows multi-field sorting ‚Üí Sort by multiple attributes simultaneously. 
‚úî Browsable API Enhancement ‚Üí Adds interactive sorting options to the UI.


1. Adding Sorting Functionality in ViewSet
üìå Step 1: Import OrderingFilter in Views (views.py)
from rest_framework.filters import OrderingFilter

üìå Step 2: Enable Ordering Filter in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ‚úÖ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]  # ‚úÖ Add OrderingFilter
    ordering_fields = ['unit_price', 'last_update']  # ‚úÖ Enable sorting by unit price & last update
	
üöÄ Effect: 
‚úî Sorting can now be performed dynamically via query parameters. 
‚úî /store/products/?ordering=unit_price ‚Üí Returns products sorted by unit price (ascending). 
‚úî /store/products/?ordering=-unit_price ‚Üí Returns products sorted by unit price (descending).

üìå Browsable API Enhancement: 
‚úî Adds an interactive sorting option to the browsable API UI. 
‚úî Users can select sorting criteria easily without needing query parameters.




2. Sorting by Multiple Fields
üöÄ Problem: 
‚úî Single-field sorting works, but what if we want to sort by multiple attributes? 
‚úî Example: Sort by unit price in descending order, then by last update in ascending order.

üìå Solution: Pass Multiple Fields in ordering Parameter(in the url)
/store/products/?ordering=-unit_price,last_update

üöÄ Effect: ‚úî First, sorts products by unit price in descending order. ‚úî Then, sorts products by last update in ascending order.




3. Testing Sorting in Browser API
üìå Step 1: Visit /store/products/ ‚úî Displays all products initially.

üìå Step 2: Sort Using Query Parameters 
‚úî /store/products/?ordering=unit_price ‚Üí Products sorted from cheapest to most expensive. 
‚úî /store/products/?ordering=-unit_price ‚Üí Products sorted from most expensive to cheapest.

üìå Step 3: 
Multi-field Sorting ‚úî /store/products/?ordering=-unit_price,last_update ‚Üí Sorts by unit price in descending order, then last update in ascending order.




4. Extending Sorting With Searching & Pagination
üöÄ Enhancement: ‚úî Combine sorting, searching, and pagination for improved API usability.

üìå Final ProductViewSet Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']
    pagination_class = DefaultPagination
	
üöÄ Effect: ‚úî Users can search, sort, and paginate results dynamically.




Codes learned in this lesson:
from rest_framework.filters import SearchFilter, OrderingFilter

filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
ordering_fields = ['unit_price', 'last_update']

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

Multiple field sorting:
127.0.0.1:8000/store/products/?ordering=-unit_price,last_update







üìå Key Takeaways
‚úî Sorting allows dynamic organization of API results. 
‚úî Prefix fields with '-' for descending order (ordering=-unit_price). 
‚úî Supports multi-field sorting (ordering=-unit_price,last_update). 
‚úî Browsable API provides interactive sorting functionality. 
‚úî Combining search, sorting & pagination enhances user experience. 
‚úî Next steps: Implementing pagination functionality!















Pagination:
-----------
Pagination allows users to retrieve API results in smaller, manageable chunks instead of loading all data at once.

üöÄ Why Use Pagination?
‚úî Improves API performance ‚Üí Loads a limited number of records per request. 
‚úî Enhances user experience ‚Üí Users navigate pages instead of handling large data sets. 
‚úî Supports multiple pagination styles ‚Üí Page-based (page=1,2) or offset-based (limit=10, offset=10). 
‚úî Browsable API Enhancement ‚Üí Displays pagination controls for easier navigation.

1. Adding Pagination Using Page Numbers
üìå Step 1: Import PageNumberPagination in Views (views.py)
from rest_framework.pagination import PageNumberPagination

üìå Step 2: Assign Pagination Class in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ‚úÖ Retrieve all products
    serializer_class = ProductSerializer
    pagination_class = PageNumberPagination  # ‚úÖ Enable page-based pagination
	
üöÄ Effect: 
‚úî Products will be paginated, displaying a limited number per request. 
‚úî API results now return page links (next, previous). 
‚úî Users navigate pages using query parameters (page=1, page=2).




2. Configuring Page Size in Settings
üìå Step 1: Set Global Pagination Settings (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10  # ‚úÖ Limits results per page to 10
}

üöÄ Effect: 
‚úî Ensures pagination is applied to all API endpoints. 
‚úî Automatically sets default page size to 10 records per page.

üìå Browsable API Enhancement: ‚úî API results now return metadata:
json
{
    "count": 50,
    "next": "/store/products/?page=2",
    "previous": null,
    "results": [ ... list of products ... ]
}
‚úî count ‚Üí Total products. 
‚úî next ‚Üí Link to next page. 
‚úî previous ‚Üí Link to previous page. 
‚úî results ‚Üí Products for the current page.




3. Using Limit-Offset Pagination
üöÄ Alternative Pagination Style: ‚úî Instead of page numbers, use limit-offset pagination (limit=10, offset=10).

üìå Step 1: Change Pagination Type in Settings (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 10
}

üöÄ Effect: 
‚úî API now supports limit-based navigation: ‚úî /store/products/?limit=10&offset=10 ‚Üí Returns next 10 records after skipping 10.

üìå Browsable API Adjustment: 
‚úî Query parameters change from page=1 to limit=10, offset=10. 
‚úî Provides better flexibility for paginating large datasets.




4. Setting Pagination Per View Instead of Globally
üöÄ Problem: 
‚úî Global pagination affects all API endpoints. 
‚úî Need pagination only for specific views (ProductViewSet).

üìå Solution: Define Pagination Only in ProductViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    pagination_class = PageNumberPagination  # ‚úÖ Pagination applied only to this view
	
üöÄ Effect: 
‚úî Pagination applies only to the product endpoint (/store/products). 
‚úî Other endpoints (e.g., /store/collections) remain unpaginated.




5. Fixing Pagination Warning When Removing Global Settings
üöÄ Problem: 
‚úî Removing 'PAGE_SIZE' from settings.py causes a warning: ‚ùå "You have specified a default PAGE_SIZE setting without also specifying a DEFAULT_PAGINATION_CLASS"

üìå Solution: Use a Custom Pagination Class
üìå Step 1: Create a Custom Pagination Class (pagination.py)
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
    page_size = 10  # ‚úÖ Define page size inside the class

	
üìå Step 2: Use Custom Pagination in ViewSet (views.py)
from store.pagination import DefaultPagination

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    pagination_class = DefaultPagination  # ‚úÖ Use custom pagination class
	
üöÄ Effect: 
‚úî Fixes pagination warning by defining page size inside a custom class. 
‚úî Prevents unnecessary global pagination settings in settings.py.




6. Testing Pagination in Browser API
üìå Step 1: Visit /store/products/ ‚úî Displays first page of products.
üìå Step 2: Navigate to Next Page ‚úî Click "Next" ‚Üí Loads page 2 (/store/products/?page=2).
üìå Step 3: Test Offset-Based Pagination ‚úî /store/products/?limit=10&offset=10 ‚Üí Loads next 10 records.
üìå Step 4: Check API Response Structure ‚úî Includes pagination metadata (count, next, previous, results).





Codes learned in this lesson:
from rest_framework.pagination import PageNumberPagination

in the ProductViewSet class:
pagination_class = PageNumberPagination


To specify the pagesize:
in the settings.py -->
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.pagination.PageNumberPagination',  #pagination applied to all endpoints
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.LimitOffsetPagination',  #if you want limit and offset type pagination instead of page number
	 'PAGE_SIZE': 10
}	 

Now with this, we don't need to specify the pagination class per view or per view set. So, back to our views module, we can delete the line 'pagination_class = PageNumberPagination'


to surpass the error: 'you have specified a default PAGE_SIZE pagination rest_framework setting, without specifying also a DEFAULT_PAGINATION_CLASS':


setting the custom pagination class: 
pagination.py:
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
	page_size = 10
	
	
and now you can remove the PAGE_SIZE in the settings.py
and in the ProductViewSet --> pagination_class = DefaultPagination


views.py/ProductViewSet:
from store.pagination import DefaultPagination

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)






üìå Key Takeaways
‚úî Pagination ensures API results load in smaller, manageable chunks. 
‚úî Page-based (page=1,2) and limit-offset (limit=10, offset=10) pagination styles available. 
‚úî Browsable API provides pagination controls for easy navigation. 
‚úî Global pagination affects all endpoints; use pagination_class for specific views. 
‚úî Custom pagination class prevents unnecessary global settings. ‚úî Next steps: Building a Shopping Cart API!











Designing and Implementing a Shopping Cart API:
-----------------------------------------------
In this section, we're going to put everything together and build a shopping cart API from A to Z. This is a fantastic opportunity for you to practice everything you have learned so far. So, let's jump in and get started.



Designing the API:
------------------
üöÄ Designing a Shopping Cart API in Django REST Framework**
A shopping cart API allows users to add items, update quantities, remove items, and retrieve cart details without requiring authentication.

üöÄ Operations Supported in the API:
‚úî Create a cart ‚Üí Generate a new cart for storing items.  
‚úî Add items to a cart ‚Üí Specify products and quantities.  
‚úî Update item quantity ‚Üí Modify existing cart items.  
‚úî Remove items from a cart ‚Üí Delete items individually.  
‚úî Get cart details ‚Üí Retrieve cart contents and metadata.  
‚úî Delete the entire cart ‚Üí Remove all items from a cart.  



1. Endpoints Required for Shopping Cart API**  

üìå Cart Management Endpoints  :

| Action          | HTTP Method     | Endpoint           | Request Body     | Response |
|-----------------|-----------------|------------------- |------------------|-------------|
| Create Cart     |  POST           |  /carts/           |  {}              |  cart       |
| Get Cart        |  GET            |  /carts/{id}/      |  {}              |  cart       |
| Delete Cart     |  DELETE         |  /carts/{id}/      |  {}              |  {}         |


üìå Cart Item Management Endpoints  

| Action          | HTTP Method     | Endpoint                | Request Body          | Response |
|-----------------|-----------------|-------------------------|-----------------------|----------|
| Add Item        |  POST           | /carts/{id}/items/      |  { product_id, qty }  |  item    |
| Update Item     |  PATCH          | /carts/{id}/items/{id}/ |  { qty }              | { qty }  |
| Delete Item     |  DELETE         | /carts/{id}/items/{id}/ |  {}                   |  {}      |


üöÄ How It Works:  
‚úî Creating a cart: generates a cart ID stored on the client side.  
‚úî Adding items to a cart: requires specifying `product_id` and `quantity`.  
‚úî Updating a cart item supports only `PATCH`, since we modify quantity instead of replacing the item.  





2. ViewSet Classes for Implementation:

üöÄ CartViewSet: Handles cart-related operations 
‚úî /carts/ ‚Üí Create a cart  
‚úî /carts/{id}/ ‚Üí Retrieve or delete a cart  

üöÄ CartItemViewSet: Handles cart item-related operations  
‚úî /carts/{id}/items/ ‚Üí Add an item to a cart  
‚úî /carts/{id}/items/{id}/ ‚Üí Update or delete a cart item  


Class Definitions:
class CartViewSet(ModelViewSet):
    queryset = Cart.objects.all()
    serializer_class = CartSerializer

class CartItemViewSet(ModelViewSet):
    queryset = CartItem.objects.all()
    serializer_class = CartItemSerializer


üöÄ Effect:
‚úî Encapsulates all shopping cart logic within two ViewSets.  
‚úî Creates a structured and reusable API design.  




3. Next Steps: Revisiting Data Models:  
‚úî Before implementing these endpoints, we need to refine our cart and cart item models to support the API structure.  
‚úî Define relationships between carts, items, and products.  
‚úî Ensure each cart has a unique identifier for anonymous tracking.  

üöÄ Next Topic: Revisiting the data model to structure cart relationships effectively.  



üìå Key Takeaways
‚úî Designed a structured API for shopping cart operations. 
‚úî POST, GET, DELETE methods handle cart creation, retrieval, and removal.  
‚úî Cart items are managed via `/carts/{id}/items/`.  
‚úî PATCH request updates quantity instead of replacing items. 
‚úî Two ViewSets (`CartViewSet`, `CartItemViewSet`) simplify API logic.  
‚úî Next steps: Refining the cart data model! 













Revisiting the Data Model:
--------------------------
Before implementing the API, we need to refine our data model to ensure security, efficiency, and proper structure.

üöÄ Why Modify the Cart Model?
‚úî Prevent unauthorized access ‚Üí Using predictable cart IDs (e.g., /carts/1) allows hackers to guess and manipulate carts. 
‚úî Improve security ‚Üí A GUID (Globally Unique Identifier) makes it extremely hard to guess cart IDs. 
‚úî Optimize database relationships ‚Üí Ensure cart-item uniqueness and improve query efficiency.

1. Changing the Primary Key to a UUID
üìå Problem: 
‚úî Django automatically assigns an integer primary key (cart_id = 1, 2, 3...). 
‚úî Hackers can easily guess cart IDs and modify carts they don‚Äôt own.

üìå Solution: Use a GUID Instead of an Integer ‚úî GUIDs are randomly generated 32-character strings, making guessing cart IDs nearly impossible.

üìå Implementation (models.py)
from uuid import uuid4
from django.db import models

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)  # ‚úÖ Assigns a random UUID as the primary key
    created_at = models.DateTimeField(auto_now_add=True)  # ‚úÖ Tracks cart creation time
	
	
üöÄ Effect: 
‚úî /store/carts/{guid}/ ‚Üí More secure, preventing easy cart manipulation. 
‚úî Each cart gets a random unique identifier, instead of an easily guessable number.

üìå Important: 
‚úî Do NOT call uuid4() directly ‚Üí Doing so will hardcode a GUID in the migration file, making all carts use the same ID. 
‚úî Pass uuid4 as a reference ‚Üí This ensures Django dynamically generates a new GUID for each cart.




2. Checking Migration for UUID Change
üìå Step 1: Create Migration
python manage.py makemigrations

üìå Step 2: Verify Migration File 
‚úî Ensure the migration does NOT contain a hardcoded GUID. 
‚úî Expected result:
default=uuid4  # ‚úÖ Reference, not a hardcoded GUID

üìå Step 3: Apply Migration
python manage.py migrate

üöÄ Effect: 
‚úî The cart table now uses UUIDs instead of integers. 
‚úî Cart IDs are more secure and harder to guess.




3. Addressing Performance Considerations
üìå Problem: GUIDs require more storage space than integers. 
‚úî Integer keys: Use 8 bytes (BIGINT). 
‚úî GUIDs: Use 32 bytes, three times larger than an integer.

üìå Assessing the Impact: 
‚úî If cart_items table has 1 million records, extra GUID storage is only 22MB. 
‚úî Since shopping carts are temporary, data is eventually moved to orders, reducing long-term database size. 
‚úî Regular cleanup (e.g., delete carts older than 3 months) prevents excessive growth.

üöÄ Conclusion: 
‚úî GUIDs offer better security, and storage increase is negligible. 
‚úî Using UUIDs for temporary data is reasonable, but orders can still use integer keys for efficiency.




4. Applying Unique Constraints in Cart Items
üìå Problem: 
‚úî A customer might add the same product multiple times, creating duplicate cart items. 
‚úî Instead of multiple records, quantity should be updated when the same product is added again.

üìå Solution: Enforce a Unique Constraint for cart + product Combination 
‚úî Ensures each cart contains a product only once.

üìå Implementation (models.py)
class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')  # ‚úÖ Establish cart-item relationship
    product = models.ForeignKey(Product, on_delete=models.CASCADE)  # ‚úÖ Reference the product
    quantity = models.PositiveSmallIntegerField(validators=[MinValueValidator(1)])  # ‚úÖ Ensure valid quantity

    class Meta:
        unique_together = [['cart', 'product']]  # ‚úÖ Prevent duplicate items in the same cart
		
üöÄ Effect: ‚úî A single record per product exists for each cart. ‚úî Adding the same product updates quantity, instead of creating duplicates.




5. Running Migration for Cart Item Constraints
üìå Step 1: Create Migration for Unique Constraint
python manage.py makemigrations

üìå Step 2: Apply Migration
python manage.py migrate

üöÄ Effect: 
‚úî cart_items table prevents duplicate products in a cart. 
‚úî Customers cannot add the same product multiple times‚Äîquantity updates instead.




6. Verifying Database Changes
üìå Check Database Schema for Updates 
‚úî cart table now uses a UUID (char(32)) instead of an integer. 
‚úî cart_items table has a unique constraint on (cart_id, product_id). 
‚úî cart_items are linked to carts via related_name='items' for easier queries.




Codes learned in this lesson:
models.py(initially):
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()


127.0.0.1:8000/store/carts/1

models.py:
from uuid import uuid4

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class CartItem(models.Model):
    cart = models.ForeignKey(
        Cart, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField(
        validators=[MinValueValidator(1)]
    )

    class Meta:
        unique_together = [['cart', 'product']]





üìå Key Takeaways
‚úî Replaced integer cart IDs with UUIDs for enhanced security. 
‚úî Ensured cart items store only one instance of each product using a unique constraint. 
‚úî Verified storage impact of using UUIDs‚Äîminimal increase, negligible concern. 
‚úî Regular cleanup of abandoned carts prevents excess database growth. 
‚úî Next steps: Implementing API endpoints for shopping cart operations.


Explanation of 'unique_together':
--------------------------------
The unique_together constraint is applied to both cart and product, rather than just product, because the uniqueness of a product should be enforced within the context of a specific cart‚Äînot globally across all carts. Let me break it down step by step.

üöÄ Why Include cart in unique_together?
‚úî If only product were unique, a product could appear only once across all carts, which doesn't make sense. 
‚úî A product should be allowed in multiple carts, but within each cart, it should appear only once. 
‚úî Using unique_together=['cart', 'product'] ensures that each cart can contain a product only once, preventing duplicates within a specific cart.

üöÄ How unique_together Works in Cart Items
üìå Example Scenario Without unique_together ‚ùå If a customer adds Product A twice to the same cart: ‚úî Two separate records would be created:

Cart ID | Product ID | Quantity
--------|-----------|---------
1       | 101       | 2
1       | 101       | 3

üöÄ Problem: ‚úî Multiple rows exist for the same product in the same cart, which is redundant.

üìå Example Scenario With unique_together=['cart', 'product']
‚úî When a customer adds Product A again, instead of creating a new row, the quantity increases in the existing row:

Cart ID | Product ID | Quantity
--------|-----------|---------
1       | 101       | 5  ‚úÖ Updated Quantity

üöÄ Effect: ‚úî Ensures only one entry per product per cart, improving efficiency.


üöÄ When Would unique_together=['product'] Make Sense?
‚úî If you wanted to enforce product uniqueness across all carts (which isn't useful in a shopping cart scenario). 
‚úî Use case: A product catalog where each product must have a unique SKU or name, regardless of carts.

üöÄ Conclusion: ‚úî We need both cart and product in the constraint to enforce uniqueness within the scope of each cart, not globally across all carts.















Creating a Cart:
----------------
Creating a cart involves defining a serializer, a view, and a route to handle API requests effectively.

üöÄ Steps to Implement Creating a Cart
‚úî Step 1: Define the serializer ‚Üí Converts cart model data into JSON. 
‚úî Step 2: Create the view ‚Üí Handles incoming requests to create a cart. 
‚úî Step 3: Register the route ‚Üí Maps the view to an API endpoint (/carts/).

1. Building the Cart Serializer
üìå Purpose: 
‚úî Converts Cart model into JSON format for API responses. 
‚úî Exposes only the cart ID (no unnecessary server-side metadata).

üìå Implementation (serializers.py)

class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)  # ‚úÖ Ensures ID is generated server-side  # as it is read only, we don't need it to be present in the UI
    class Meta:
        model = Cart
        fields = ['id']  # ‚úÖ Only return the cart ID in API response
			
üöÄ Effect: 
‚úî The API automatically generates a cart ID, ensuring security using UUIDs instead of integers. 
‚úî Clients only receive the cart ID, reducing unnecessary data exposure.




2. Creating the Cart ViewSet
üìå Problem: 
‚úî ModelViewSet supports all operations (list, retrieve, create, update, delete). 
‚úî A cart does not need list (GET /carts/) or update (PATCH /carts/{id}/). (as it applies only for cart items, a cart is simply a cart)
‚úî Only create (POST), retrieve (GET /carts/{id}), and delete (DELETE /carts/{id}) are needed.

üìå Solution: Use a Custom ViewSet Without Unnecessary Operations ‚úî Extend GenericViewSet instead of ModelViewSet. ‚úî Include only mixins needed (CreateModelMixin).

üìå Implementation (views.py)
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import GenericViewSet

class CartViewSet(CreateModelMixin, GenericViewSet):
    queryset = Cart.objects.all()
    serializer_class = CartSerializer

üöÄ Effect: 
‚úî The API only supports creating a cart (POST /carts/). 
‚úî No list or update operations, ensuring carts remain private.




3. Registering the Route for Cart Creation
üìå Purpose:
‚úî Maps /carts/ endpoint to CartViewSet, allowing clients to send requests.

üìå Implementation (urls.py)
router.register('carts', views.CartViewSet)  # ‚úÖ Register `/carts/` endpoint

üöÄ Effect: ‚úî Clients can POST to /carts/ to create a new cart.




4. Testing Cart Creation in API
üìå Step 1: Visit API Root (/store/) 
‚úî /carts/ is now registered as an available endpoint.
	
üìå Step 2: Send POST Request to /carts/ 
‚úî Request Body: {} (Empty object, since cart ID is auto-generated). 
‚úî Expected Response:
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013"
}

üöÄ Effect: 
‚úî The API creates a cart and returns its unique ID. 
‚úî Clients can store this cart ID for future operations (adding items, retrieving the cart, etc.).


üìå Step 3: Prevent Sending ID in Request Body 
‚úî If the request accidentally includes ID (null), API should ignore it. 
‚úî Solution: Mark ID as read_only in the serializer.

üìå Fix (serializers.py)
id = serializers.UUIDField(read_only=True)  # ‚úÖ Ensures ID is read-only
üöÄ Effect: ‚úî API generates the cart ID automatically, preventing clients from modifying it.



codes learned in this lesson:

Building an API:
Serializer
View
Route

serializer.py:
class CartSerializer(serializers.ModelSerializer):
	id = serializers.UUIDField(read_only=True)
    class Meta:
        model = Cart
        fields = ['id']

views.py:
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import ModelViewSet, GenericViewSet

class CartViewSet(CreateModelMixin, GenericViewSet):
	queryset = Cart.objects.all()
	serializer_class = CartSerializer


urls.py:
router.register('carts', views.CartViewSet)




üìå Key Takeaways
‚úî Implemented cart creation using a serializer, a custom viewset, and a registered route. 
‚úî Avoided unnecessary operations (list, update) by using GenericViewSet with CreateModelMixin. 
‚úî Ensured security using UUIDs instead of easily guessable integer IDs. 
‚úî Prevented clients from modifying cart IDs using read_only=True in the serializer. 
‚úî Next steps: Implementing retrieval (GET /carts/{id}/) for accessing cart details.











Getting a Cart:
---------------
Retrieving a cart involves returning all cart items, each with its product details and total price calculations.

üöÄ Steps to Implement Getting a Cart
‚úî Step 1: Modify the serializer to include cart items and total price. 
‚úî Step 2: Extend the viewset to support retrieving (GET /carts/{id}/). 
‚úî Step 3: Optimize queries using eager loading (prefetch_related).

1. Updating the Cart Serializer to Include Items
üìå Problem: ‚úî Currently, retrieving a cart (GET /carts/{id}/) does not return items. ‚úî We must include cart items and their respective product details in the response.

üìå Solution: Modify CartSerializer to Include Items
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)  # ‚úÖ Secure unique ID
    items = CartItemSerializer(many=True, read_only=True)  # ‚úÖ Include all cart items
    total_price = serializers.SerializerMethodField()  # ‚úÖ Calculate total cart price

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])  # ‚úÖ Sum of item totals

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']
		
üöÄ Effect: 
‚úî API now returns cart items in the response. 
‚úî Total cart price is dynamically calculated.

üìå Expected API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        }
    ],
    "total_price": 17.98
}

üöÄ Effect: ‚úî Includes all cart items with product details and total price calculations.




2. Improving Product Representation Using a Separate Serializer
üìå Problem: 
‚úî Including entire product details might expose unnecessary fields. 
‚úî Future updates in ProductSerializer might introduce unwanted data in carts.

üìå Solution: Use a Separate Simplified Product Serializer
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']  # ‚úÖ Restrict fields to essential ones

üöÄ Effect: 
‚úî Returns only relevant product details (ID, title, price). 
‚úî Prevents future serializer changes from affecting cart responses.

üìå Modify CartItemSerializer to Use SimpleProductSerializer
class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()  # ‚úÖ Restrict product fields in cart response
    total_price = serializers.SerializerMethodField()  # ‚úÖ Calculate total item price

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price  # ‚úÖ Quantity * Unit Price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']
üöÄ Effect: ‚úî API returns only necessary product details in cart items.




3. Adding Retrieve Functionality in CartViewSet
üìå Problem: 
‚úî CartViewSet only supports POST (CreateModelMixin). 
‚úî We need to extend it to support GET /carts/{id}/ for retrieval.

üìå Solution: Include RetrieveModelMixin in CartViewSet
from rest_framework.mixins import RetrieveModelMixin, CreateModelMixin, DestroyModelMixin

class CartViewSet(CreateModelMixin, RetrieveModelMixin, DestroyModelMixin, GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()  # ‚úÖ Optimize database queries
    serializer_class = CartSerializer
	
üöÄ Effect: 
‚úî API now supports retrieving a cart and its items (GET /carts/{id}/). 
‚úî Queries are optimized using eager loading (prefetch_related).




4. Optimizing Database Queries Using prefetch_related
üìå Problem: ‚úî Without optimization, Django makes multiple separate queries for each cart item. ‚úî Example:
1 query to retrieve cart
1 query per cart item
1 query per product for each cart item

üìå Solution: Use prefetch_related in queryset
queryset = Cart.objects.prefetch_related('items__product').all()

üöÄ Effect: 
‚úî Retrieves all cart items and product details in fewer queries. 
‚úî Reduces N+1 query problem, significantly improving performance.

üìå Comparison Before vs. After Optimization

Action	           Without Optimization	     With prefetch_related
Retrieve Cart	      1 query	                 1 query
Retrieve Items	      1 query per item	         1 query for all items
Retrieve Products	  1 query per product	     1 query for all products
Total Queries	      N+1 (High)	             3 (Optimized)

üöÄ Performance Improvement: ‚úî Queries drop from ~13 to ~7, improving API efficiency.




5. Testing Cart Retrieval in API
üìå Step 1: Manually Add Cart Items to Database ‚úî Insert test products into cart item table.
üìå Step 2: Send GET Request to /carts/{id}/ ‚úî Expected Response:

json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        }
    ],
    "total_price": 17.98
}

‚úî Confirms items, products, and total prices are correctly retrieved.

üìå Step 3: Check Query Performance with Debug Toolbar ‚úî Should show only 7 optimized queries instead of unnecessary multiple queries.



codes in this lesson:
serializers.py:
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True)
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']


views.py:
class CartViewSet(CreateModelMixin,
                  RetrieveModelMixin,
                  DestroyModelMixin,
                  GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()
    serializer_class = CartSerializer







üìå Key Takeaways
‚úî Implemented retrieving a cart with all its items and product details. 
‚úî Used a dedicated SimpleProductSerializer to return minimal product information. 
‚úî Ensured total price calculations for each item and the entire cart. 
‚úî Optimized queries using prefetch_related to improve performance. 
‚úî Next steps: Implementing cart item operations (POST /carts/{id}/items/).









Quick QnA Session:
------------------

Q1: In the CartSerializer class: what is the many parameter means, to serialize all the items ? items = CartItemSerializer(many=True, read_only=True)
Great question! The many=True parameter in CartItemSerializer(many=True, read_only=True) is telling Django REST Framework (DRF) that this field contains multiple items instead of just a single one.

üöÄ What Does many=True Mean?
‚úî Normally, a ModelSerializer expects a single object to serialize. 
‚úî If a field contains a list of objects (like multiple cart items in a shopping cart), we need to set many=True. 
‚úî This ensures DRF properly serializes each item in the queryset as an individual JSON object inside an array.

üìå Example Without many=True:
items = CartItemSerializer(read_only=True)

üöÄ Problem: 
‚ùå DRF expects only one item instead of a list. 
‚ùå Causes errors when trying to serialize multiple cart items.

üìå Example With many=True:
items = CartItemSerializer(many=True, read_only=True)

üöÄ Effect: 
‚úî Correctly serializes multiple items into an array format. 
‚úî Ensures the response includes all cart items, not just one.

üìå Expected Behavior in API Response
When a cart contains multiple items, the many=True parameter ensures they are properly structured.

üìå API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [  
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        },
        {
            "id": 13,
            "product": {
                "id": 8,
                "title": "T-Shirt",
                "unit_price": 25.00
            },
            "quantity": 1,
            "total_price": 25.00
        }
    ],
    "total_price": 42.98
}

üöÄ Effect: 
‚úî Each cart item is serialized individually inside the items array. 
‚úî Total price calculations can now be done easily across all cart items.

üìå Why Use read_only=True?
‚úî Prevents clients from modifying cart items directly via the cart serializer. 
‚úî Cart items must be managed separately via CartItemViewSet (adding/updating/deleting). 
‚úî Ensures only the server can modify cart items‚Äîclients can only read them.

üìå Effectively, This Line Means: ‚úî "items" contains multiple cart items (many=True). ‚úî Clients can read them but cannot modify them directly (read_only=True).

üöÄ Conclusion: 
‚úî many=True ensures serialization of all cart items in a list. 
‚úî read_only=True prevents modifications via CartSerializer.




Q2: In the CartItemSerializer, in the method signature get_total_price, 'cart_item' is an instance of CartItem, right?

Yes, exactly! In the get_total_price method, the parameter cart_item represents an instance of the CartItem model.

‚úî How it Works:
DRF automatically passes the current instance of CartItem to the method when serializing data.
Since total_price is defined as serializers.SerializerMethodField(), it looks for a method named get_total_price in the serializer.
The method takes in the current 'cart item' instance and calculates the total price based on quantity * unit_price.

‚úî Example in Execution: If there is a CartItem instance like this:
cart_item = CartItem(product=Product(unit_price=10.00), quantity=2)

When DRF calls get_total_price(cart_item), it will return:
cart_item.quantity * cart_item.product.unit_price  # ‚úÖ 2 * 10.00 = 20.00

üöÄ Effect: ‚úî Ensures each cart item‚Äôs total price is correctly computed and included in the API response.




Q3:explanation of method 'get_total_price()' in the CartSerializer


üöÄ Purpose of get_total_price
‚úî Calculates the total price of all items in the shopping cart. 
‚úî Multiplies the quantity of each item by its unit price. 
‚úî Sums up all those individual totals to get the cart's total price.

üöÄ Step-by-Step Breakdown
üìå Step 1: Get All Items in the Cart
cart.items.all()
‚úî cart.items is the related name for the cart's items (related_name="items" in CartItem). 
‚úî .all() retrieves all items belonging to this cart.

üìå Step 2: Loop Through Each Item and Calculate Price
[item.quantity * item.product.unit_price for item in cart.items.all()]
‚úî Loops through each cart item using list comprehension. 
‚úî item.quantity ‚Üí Number of units for the product in the cart. 
‚úî item.product.unit_price ‚Üí Price of one unit of the product. 
‚úî Multiplying quantity * unit_price gives the total price for each item.

üìå Example Calculation ‚úî If the cart contains:
CartItem(product=Product(unit_price=10), quantity=2)  # ‚úÖ Total = 2 * 10 = 20
CartItem(product=Product(unit_price=5), quantity=3)   # ‚úÖ Total = 3 * 5 = 15

Then, the list comprehension will return:
[20, 15]  # ‚úÖ List of individual item totals

üìå Step 3: Sum Up All Item Totals
sum([item.quantity * item.product.unit_price for item in cart.items.all()])

‚úî Takes the list of item totals and adds them together using sum().

üìå Example Final Calculation
sum([20, 15])  # ‚úÖ 20 + 15 = 35
üöÄ Effect: ‚úî The final total price for the cart is $35.


üöÄ Example API Response
When retrieving a cart (GET /carts/{id}/), this method ensures the total price is dynamically calculated.

üìå API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        },
        {
            "id": 13,
            "product": {
                "id": 8,
                "title": "T-Shirt",
                "unit_price": 25.00
            },
            "quantity": 1,
            "total_price": 25.00
        }
    ],
    "total_price": 42.98
}


üöÄ Effect: 
‚úî Each cart item has its own total price (quantity * unit_price). 
‚úî The cart itself has a total price (sum of all item totals).

üìå Summary
‚úî Retrieves all items in the cart (cart.items.all()). 
‚úî Calculates total price for each item (quantity * unit_price). 
‚úî Sums up all individual totals to get the final cart price. 
‚úî Ensures cart price updates dynamically whenever items change.





Q4: what is the difference between cart time total price and cart's total price. Both places, we are calculating the total price. Also, in 'cart.items.all()', is it supposed to be 'cart.items.objects.all()'

Great questions! Let's break them down one by one.

üöÄ Difference Between Cart Item Total Price & Cart's Total Price

‚úî Cart Item Total Price (CartItemSerializer)
Calculates the total price for ONE specific item in the cart.
Formula: quantity * unit_price

Example:
def get_total_price(self, cart_item: CartItem):
    return cart_item.quantity * cart_item.product.unit_price
	
If a customer adds 2 coffee mugs priced at $8.99 each, the cart item total price is:
2 * 8.99 = 17.98  # ‚úÖ Total price for this single cart item


‚úî Cart's Total Price (CartSerializer)
Calculates the total price for the ENTIRE cart (sum of all cart items).
Formula: sum(quantity * unit_price for each cart item)

Example:
def get_total_price(self, cart):
    return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

If the cart contains:
2 coffee mugs ($8.99 each) ‚Üí $17.98
1 T-shirt ($25.00 each) ‚Üí $25.00
Total cart price = 17.98 + 25.00 = $42.98


üöÄ Key Difference: 
‚úî CartItemSerializer.get_total_price() ‚Üí Calculates per-item total price. 
‚úî CartSerializer.get_total_price() ‚Üí Summarizes all item totals to compute cart price.



üöÄ Understanding cart.items.all() vs. cart.items.objects.all()

‚úî Correct Usage:
cart.items.all()
üöÄ Why? 
‚úî cart.items is a related manager that automatically handles database queries. 
‚úî Since items is a related field (from related_name="items" in CartItem), it already behaves like a queryset. 
‚úî Calling .all() retrieves all cart items without needing .objects.


‚ùå Incorrect Usage:
cart.items.objects.all()
üöÄ Why is this incorrect? 
‚úî cart.items is already a manager, not an individual model instance. 
‚úî .objects.all() is used only for directly querying models, not related fields.

üìå Example Comparisons: 
‚úî CartItem.objects.all() ‚Üí ‚úÖ Correct for retrieving all cart items from the database. 
‚úî cart.items.all() ‚Üí ‚úÖ Correct for retrieving items related to a specific cart. 
‚úî cart.items.objects.all() ‚Üí ‚ùå Incorrect‚Äîitems is already a manager, no need for .objects.

üöÄ Summary
‚úî Cart item total price ‚Üí Price of one cart item (quantity * unit_price). 
‚úî Cart's total price ‚Üí Sum of all cart item prices (sum of all item totals). 
‚úî Use cart.items.all(), not cart.items.objects.all() ‚Äî items is already a manager.





Q5. 
‚úî cart.items is already a manager, not an individual model instance. 
‚úî .objects.all() is used only for directly querying models, not related fields. 
Explain these two lines. So objects.all() is used for direct instance of the particular model whereas .all() is used directly when related field is used right, which means foreign instance


Yes, you‚Äôve got the right idea! Let me clarify it further to ensure full understanding.

üöÄ Understanding objects.all() vs. cart.items.all()
‚úî .objects.all() is used for querying the entire model table. ‚úî .all() is used when accessing related fields via ForeignKey (or related_name).

üìå What Does objects.all() Do?
The .objects attribute exists in model classes and provides access to the database query manager.

üìå Example: Getting all records of CartItem
CartItem.objects.all()

üöÄ Effect: 
‚úî Retrieves all cart items in the entire database. 
‚úî Used when querying the main model directly, not through a relationship.

üìå What Does cart.items.all() Do?
‚úî cart.items is a manager object that automatically manages related records. 
‚úî .all() retrieves only the cart items associated with this specific cart.

üìå Example: Getting cart items for a specific cart instance
cart = Cart.objects.get(id="some-cart-id")  # ‚úÖ Get a specific cart
cart.items.all()  # ‚úÖ Get all cart items related to THIS cart

üöÄ Effect: 
‚úî Retrieves only items linked to this specific cart, instead of querying the entire table.

üöÄ Key Difference
Usage	                   What It Does	                            Example
.objects.all()	           Retrieves all records of a model	        CartItem.objects.all()
.all() (on FK)	           Retrieves related records for one item	cart.items.all() (cart‚Äôs items)


üöÄ Final Takeaway: 
‚úî Use .objects.all() when querying the full model table. 
‚úî Use .all() on related fields when retrieving associated records via ForeignKey.














Deleting a Cart:
----------------
Deleting a cart allows users to remove an entire cart, clearing all its items.

üöÄ Steps to Implement Cart Deletion
‚úî Step 1: Add DestroyModelMixin to CartViewSet to enable DELETE requests. 
‚úî Step 2: Mark items field as read_only in CartSerializer to prevent inclusion when creating a cart. 
‚úî Step 3: Verify that deleting a cart removes all associated cart items.

1. Enabling Cart Deletion in ViewSet
üìå Problem: 
‚úî Currently, CartViewSet does not support the DELETE method (DELETE /carts/{id}/). 
‚úî The API needs to allow users to remove their cart entirely.

üìå Solution: Add DestroyModelMixin to CartViewSet
from rest_framework.mixins import DestroyModelMixin

class CartViewSet(CreateModelMixin,
                  RetrieveModelMixin,
                  DestroyModelMixin,  # ‚úÖ Enable DELETE operations
                  GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()
    serializer_class = CartSerializer
	
üöÄ Effect: 
‚úî The API now supports deleting a cart using DELETE /carts/{id}/. 
‚úî When a cart is deleted, all associated cart items are automatically removed (on_delete=models.CASCADE).




2. Fixing Items Field in CartSerializer
üìå Problem: 
‚úî When creating a cart (POST /carts/), the API unexpectedly includes the items field. 
‚úî Since items should be added separately, this field must be read_only.

üìå Solution: Mark items Field as read_only=True in CartSerializer
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True)  # ‚úÖ Ensure `items` can only be read, not modified
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']
		
üöÄ Effect: 
‚úî items field will no longer appear when creating a cart. 
‚úî Clients cannot modify cart items directly‚Äîthey must manage them via separate requests.




3. Testing Cart Deletion in API
üìå Step 1: Create a New Cart Using /carts/ 
‚úî Expected Response:
json
{
    "id": "5f7b36b4-3d48-43b2-92b7-12a3d2e2e567",
    "items": [],
    "total_price": 0
}

üöÄ Effect: ‚úî The cart is created successfully.

üìå Step 2: Delete the Cart Using /carts/{id}/ 
‚úî Send a DELETE request to /carts/5f7b36b4-3d48-43b2-92b7-12a3d2e2e567/. 
‚úî Expected Response:
json
{}

‚úî Now, refreshing /carts/{id}/ returns a 404 Not Found error. üöÄ Effect: ‚úî The cart is deleted, and all associated items are removed automatically.




üìå Key Takeaways
‚úî Enabled cart deletion using DestroyModelMixin in CartViewSet. 
‚úî Marked items as read_only in CartSerializer to prevent modification during cart creation. 
‚úî Deleting a cart also removes all associated cart items due to on_delete=models.CASCADE. 
‚úî Next steps: Implementing retrieval of individual cart items (GET /carts/{id}/items/).














Getting Cart Items:
-------------------
Retrieving cart items allows users to view all items inside a specific shopping cart.

üöÄ Steps to Implement Retrieving Cart Items
‚úî Step 1: Define CartItemViewSet to handle retrieving cart items. 
‚úî Step 2: Override get_queryset() to ensure only items from the requested cart are fetched. 
‚úî Step 3: Register a nested router for cart items. 
‚úî Step 4: Optimize queries using select_related to improve performance.

1. Creating CartItemViewSet for Cart Items
üìå Problem: 
‚úî We need a separate viewset for handling cart items, apart from the main CartViewSet. 
‚úî Cart items must be filtered to ensure only items from the requested cart are retrieved.

üìå Solution: Implement CartItemViewSet with Query Filtering
class CartItemViewSet(ModelViewSet):
    serializer_class = CartItemSerializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ‚úÖ Optimize queries
				
üöÄ Effect: 
‚úî The API now supports retrieving cart items from a specific cart (GET /carts/{id}/items/). 
‚úî cart_pk is extracted dynamically from the URL using self.kwargs['cart_pk']. 
‚úî select_related('product') optimizes queries by reducing extra database lookups.




2. Registering Cart Items Route Using Nested Routers
üìå Problem: 
‚úî Cart items are nested resources under carts (/carts/{id}/items/). 
‚úî The API must structure URLs correctly to reflect this relationship.

üìå Solution: Use NestedDefaultRouter for Correct URL Structure

router.register('carts', views.CartViewSet)

carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')  # ‚úÖ Sets `cart_pk` as a URL parameter
carts_router.register('items', views.CartItemViewSet, basename='cart-items')  # ‚úÖ Registers cart items under `/carts/{id}/items/`

urlpatterns = router.urls + carts_router.urls

üöÄ Effect: 
‚úî /carts/{id}/items/ retrieves all items for a specific cart. 
‚úî /carts/{id}/items/{item_id}/ retrieves a specific cart item. 
‚úî Nested routing ensures a clean and intuitive API structure.

üìå Example API Requests 
‚úî Retrieve all cart items: /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/ 
‚úî Retrieve a specific cart item: /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/3/




3. Testing Cart Items Retrieval in API
üìå Step 1: Retrieve All Items in a Cart (GET /carts/{id}/items/) 
‚úî Expected Response:
json
[
    {
        "id": 3,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 2,
        "total_price": 17.98
    },
    {
        "id": 4,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

üöÄ Effect: 
‚úî Returns only items from the specified cart. 
‚úî Includes product details and total price calculations.

üìå Step 2: Retrieve a Specific Cart Item (GET /carts/{id}/items/{item_id}/) 
‚úî Expected Response:
json
{
    "id": 3,
    "product": {
        "id": 5,
        "title": "Coffee Mug",
        "unit_price": 8.99
    },
    "quantity": 2,
    "total_price": 17.98
}
üöÄ Effect: ‚úî Retrieves only the requested cart item using its ID.

üìå Step 3: Handle Non-Existent Cart Items (GET /carts/{id}/items/30/) 
‚úî Expected Response: 404 Not Found üöÄ Effect: ‚úî Ensures non-existent items return correct error responses.




4. Optimizing SQL Queries Using select_related
üìå Problem: ‚úî Without optimization, Django performs extra queries for each cart item‚Äôs product details.

üìå Solution: Use select_related in get_queryset()
def get_queryset(self):
    return CartItem.objects \
            .filter(cart_id=self.kwargs['cart_pk']) \
            .select_related('product')  # ‚úÖ Optimize queries
			
üöÄ Effect: 
‚úî Reduces database queries from ~5 per request to ~2. 
‚úî Ensures efficient retrieval of cart items without excessive lookups.

üìå Checking Queries via Debug Toolbar 
‚úî Before Optimization: 5 queries 
‚úî After Optimization: 2 queries (inner join between cart_items and products) 
‚úî Performance Boost ‚Üí Less database overhead, faster API responses.




Codes learned in this lesson:
items endpoint:
127.0.0.1:8000/store/carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items

particular item endpoint:
127.0.0.1:8000/store/carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/3

views.py:
class CartItemViewSet(ModelViewSet):
	serializer_class = CartItemSerializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')



urls.py:
router.register('carts', views.CartViewSet)
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart') #So, once we set this lookup='cart', we have a URL parameter called 'cart_pk'
                                                                           #That's how we we extracted this URL parameter in ViewSet as self.kwargs['cart_pk']
carts_router.register('items', views.CartItemViewSet, basename='cart-items')


# URLConf
urlpatterns = router.urls + products_router.urls + carts_router.urls




üìå Key Takeaways
‚úî Implemented retrieving all cart items (GET /carts/{id}/items/). 
‚úî Implemented retrieving a single cart item (GET /carts/{id}/items/{item_id}/). 
‚úî Used NestedDefaultRouter to properly structure cart item URLs. 
‚úî Optimized queries using select_related to minimize extra lookups. 
‚úî Next steps: Implementing adding items to a cart (POST /carts/{id}/items/).






Quick QnA session:
------------------
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart') #So, once we set this lookup='cart', we have a URL parameter called 'cart_pk' 
                                                                           #That's how we we extracted this URL parameter in ViewSet as self.kwargs['cart_pk'] 

carts_router.register('items', views.CartItemViewSet, basename='cart-items') 

What does the lookup and basename parameter does. why it is used. where it appears and what is the outcome.



üöÄ Understanding lookup in Nested Routers
‚úî The lookup parameter defines the URL variable name used in views. ‚úî
 When registering a nested router, it ensures a dynamic path for retrieving child resources.

üìå Example Usage
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')

üöÄ Effect: 
‚úî Defines 'cart' as the lookup parameter in URLs. 
‚úî Creates a URL variable called cart_pk that can be accessed in views.

üìå How It Affects URLs 
‚úî When a request is made to /carts/{id}/items/, the {id} value is mapped as cart_pk. 
‚úî In the view, we retrieve it using:
cart_id = self.kwargs['cart_pk']

‚úî Without lookup='cart', Django wouldn't generate the proper nested structure.



üöÄ Understanding basename in Router Registration
‚úî basename defines the name prefix for generated URL patterns. 
‚úî Django uses basename to create named routes for referencing in reverse lookups.

üìå Example Usage
carts_router.register('items', views.CartItemViewSet, basename='cart-items')

üöÄ Effect: 
‚úî Assigns 'cart-items' as the prefix for generated named routes. 
‚úî Ensures the API generates correctly named URLs for list and detail views.

üìå Resulting Named Routes 
‚úî For listing cart items (GET /carts/{cart_pk}/items/):
cart-items-list

‚úî For retrieving a specific cart item (GET /carts/{cart_pk}/items/{item_id}/):
cart-items-detail

‚úî These names can be used in Django‚Äôs reverse URL resolution:
reverse('cart-items-detail', kwargs={'cart_pk': 'some-cart-id', 'pk': 3})

‚úî Without basename, Django REST Framework wouldn't generate route names properly, leading to errors in reverse lookups.

üöÄ Summary
‚úî lookup='cart' ‚Üí Creates a dynamic URL parameter (cart_pk) for views. 
‚úî basename='cart-items' ‚Üí Defines named routes for referencing cart item endpoints. 
‚úî Used when registering nested resources (cart items under carts). 
‚úî Ensures correct API structure and dynamic routing.







üöÄ What Is basename in DRF Routers?
‚úî basename is a unique name assigned to viewsets when registering them in Django REST Framework (DRF) routers. 
‚úî It is used internally by DRF to generate named URL patterns that can be referenced elsewhere in the application.

üìå Example Without basename: If we register a viewset without specifying basename, DRF automatically tries to infer it from the viewset‚Äôs queryset. But if queryset is missing or overridden (like in get_queryset()), DRF cannot determine it, causing errors.

üìå Example With basename:
carts_router.register('items', views.CartItemViewSet, basename='cart-items')
üöÄ Effect: 
‚úî DRF manually assigns cart-items as the prefix for URL pattern names. 
‚úî This ensures URLs can be referenced without errors, even if queryset is overridden in the viewset.

üöÄ Where Does basename Appear?
‚úî The basename is used in DRF to generate named URL patterns, which can be referenced in views or templates.

üìå Generated Named Routes for cart-items:

DRF Named Route	                Corresponding Endpoint
cart-items-list	         /carts/{cart_pk}/items/ (list view)
cart-items-detail	    /carts/{cart_pk}/items/{item_id}/ (single item)

‚úî These names allow Django to generate URLs dynamically using the reverse() function.




üöÄ How Does basename Affect reverse()?
‚úî In Django, we use reverse() to dynamically generate URLs based on view names.

üìå Example Without basename (Would Cause Error If queryset Is Overridden):
reverse('items-list', kwargs={'cart_pk': '123'})
‚ùå Error: DRF cannot determine the correct URL pattern, because the viewset lacks a default queryset.

üìå Example With basename (Correct Usage):
reverse('cart-items-list', kwargs={'cart_pk': '123'})
üöÄ Effect: ‚úî DRF knows exactly which viewset this belongs to, avoiding errors. 
‚úî URLs remain consistent even if queryset is overridden in the viewset.

üöÄ Summary
‚úî basename manually sets the prefix for named URL patterns in DRF. 
‚úî Required when queryset is overridden to prevent errors. 
‚úî Used in reverse() to generate URLs dynamically.

üöÄ Final Takeaway: 
‚úî Without basename, DRF cannot generate named routes properly, leading to errors. 
‚úî Always use basename when registering nested or dynamic routes to ensure smooth URL resolution.












Adding a Cart Item:
-------------------
Adding an item to a shopping cart involves dynamically handling product selection, quantity updates, and validation.

üöÄ Steps to Implement Adding a Cart Item
‚úî Step 1: Define a separate serializer (AddCartItemSerializer) for handling cart item creation. 
‚úî Step 2: Dynamically select the serializer in CartItemViewSet based on request method. 
‚úî Step 3: Override save() in AddCartItemSerializer to handle existing item updates. 
‚úî Step 4: Validate product selection and ensure quantity is always greater than zero.

1. Creating AddCartItemSerializer for Adding Cart Items
üìå Problem: 
‚úî When adding a product, the API currently expects a product object, which is unnecessary. 
‚úî Instead, only product_id and quantity should be passed in the request.

üìå Solution: Define a Separate Serializer for Adding Items
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()  # ‚úÖ Accept product ID instead of a full product object

    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No product with the given ID was found.')  # ‚úÖ Ensure the product exists
        return value

    def save(self, **kwargs):
        cart_id = self.context['cart_id']
        product_id = self.validated_data['product_id']
        quantity = self.validated_data['quantity']

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity  # ‚úÖ Increment quantity if item already exists
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)  # ‚úÖ Create new item
        
        return self.instance

    class Meta:
        model = CartItem
        fields = ['id', 'product_id', 'quantity']
		
üöÄ Effect: 
‚úî Accepts product_id instead of requiring a full product object. 
‚úî Updates quantity if the product already exists instead of creating duplicates. 
‚úî Validates product selection to prevent errors.




2. Dynamically Selecting the Serializer in CartItemViewSet
üìå Problem: ‚úî CartItemViewSet must use different serializers for different actions:
Adding (POST) ‚Üí Uses AddCartItemSerializer.
Updating (PATCH) ‚Üí Uses UpdateCartItemSerializer.
Retrieving (GET) ‚Üí Uses CartItemSerializer.

üìå Solution: Override get_serializer_class() to Select the Correct Serializer
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ‚úÖ Restrict allowed HTTP methods

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer  # ‚úÖ Use specialized serializer for adding items
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer  # ‚úÖ Use different serializer for updating items
        return CartItemSerializer  # ‚úÖ Default for retrieval and deletion

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}  # ‚úÖ Pass cart ID from URL to serializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ‚úÖ Optimize queries
				
üöÄ Effect: 
‚úî Automatically selects the correct serializer based on request type. 
‚úî Ensures cart ID is passed via context for proper reference in serializers.





3. Testing Cart Item Creation in API
üìå Step 1: Create a New Cart Using /carts/ ‚úî Expected Response:
json
{
    "id": "5f7b36b4-3d48-43b2-92b7-12a3d2e2e567",
    "items": [],
    "total_price": 0
}
üöÄ Effect: ‚úî The cart is created successfully.


üìå Step 2: Add a New Item to the Cart (POST /carts/{id}/items/) ‚úî Request Body:
json
{
    "product_id": 1,
    "quantity": 10
}

‚úî Expected Response:
json
{
    "id": 12,
    "product_id": 1,
    "quantity": 10
}

üöÄ Effect: ‚úî The item is successfully added to the cart.


üìå Step 3: Add the Same Product Again (Quantity Should Update) ‚úî Request Body:

json
{
    "product_id": 1,
    "quantity": 10
}

‚úî Expected Response:
json
{
    "id": 12,
    "product_id": 1,
    "quantity": 20
}

üöÄ Effect: ‚úî Quantity updates instead of creating a duplicate entry.


üìå Step 4: Handle Invalid Product Selection (POST /carts/{id}/items/) ‚úî Request Body:

json
{
    "product_id": 999,
    "quantity": 1
}
‚úî Expected Response:

json
{
    "product_id": ["No product with the given ID was found."]
}

üöÄ Effect: ‚úî Prevents adding non-existent products.


üìå Step 5: Handle Invalid Quantity (POST /carts/{id}/items/)
‚úî Request Body:
json
{
    "product_id": 1,
    "quantity": 0
}

‚úî Expected Response:
json
{
    "quantity": ["The quantity should be at least 1."]
}

üöÄ Effect: ‚úî Prevents adding items with zero or negative quantities.






codes learned in this lesson:

serializers.py:
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No product with the given ID was found.')
        return value

    def save(self, **kwargs):
        cart_id = self.context['cart_id']
        product_id = self.validated_data['product_id']
        quantity = self.validated_data['quantity']

        try: 
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        
        return self.instance

    class Meta:
        model = CartItem
        fields = ['id', 'product_id', 'quantity']


views.py:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')






üìå Key Takeaways
‚úî Created a separate serializer (AddCartItemSerializer) for handling cart item creation. 
‚úî Overrode save() to handle quantity updates instead of creating duplicates. 
‚úî Dynamically selected the appropriate serializer in CartItemViewSet. 
‚úî Validated product selection and enforced a minimum quantity limit. 
‚úî Next steps: Implementing updating a cart item (PATCH /carts/{id}/items/{item_id}/).















Updating a Cart Item:
---------------------

Updating a cart item allows users to modify the quantity of an item in their shopping cart.

üöÄ Steps to Implement Updating a Cart Item
‚úî Step 1: Define a separate serializer (UpdateCartItemSerializer) for updating cart items. 
‚úî Step 2: Dynamically select the serializer in CartItemViewSet based on request method (PATCH). 
‚úî Step 3: Restrict allowed HTTP methods to prevent unnecessary operations. 
‚úî Step 4: Verify API functionality for updating quantities.


1. Creating UpdateCartItemSerializer for Updating Cart Items
üìå Problem: 
‚úî By default, CartItemSerializer expects an entire cart item object to be sent for updates. 
‚úî Instead, only quantity should be updated‚Äînot the full object.

üìå Solution: Define a Separate Serializer for Updating Quantity
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ['quantity']  # ‚úÖ Only allow updating quantity
		
üöÄ Effect: 
‚úî Ensures only quantity is sent in the request, avoiding unnecessary fields. 
‚úî Prevents modifications to other attributes (like product ID).




2. Dynamically Selecting the Serializer in CartItemViewSet
üìå Problem: ‚úî CartItemViewSet needs to use different serializers for different actions:
Adding (POST) ‚Üí Uses AddCartItemSerializer.
Updating (PATCH) ‚Üí Uses UpdateCartItemSerializer.
Retrieving (GET) ‚Üí Uses CartItemSerializer.

üìå Solution: Override get_serializer_class() to Select the Correct Serializer
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ‚úÖ Restrict allowed HTTP methods

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer  # ‚úÖ Use specialized serializer for adding items
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer  # ‚úÖ Use different serializer for updating items
        return CartItemSerializer  # ‚úÖ Default for retrieval and deletion

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}  # ‚úÖ Pass cart ID from URL to serializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ‚úÖ Optimize queries
				
üöÄ Effect: 
‚úî Automatically selects the correct serializer based on request type. 
‚úî Ensures cart ID is passed via context for proper reference in serializers.




3. Restricting Allowed HTTP Methods
üìå Problem: 
‚úî ModelViewSet supports all HTTP methods by default, including PUT. 
‚úî However, we only want to allow PATCH, because updating only affects quantity.

üìå Solution: Explicitly Define Allowed HTTP Methods
http_method_names = ['get', 'post', 'patch', 'delete']  # ‚úÖ Exclude `PUT`

üöÄ Effect: 
‚úî Removes PUT method from API, ensuring updates are handled via PATCH instead. 
‚úî Prevents clients from replacing the entire cart item object.

üìå Browsable API Adjustment: 
‚úî Before refresh ‚Üí Shows PUT button (incorrect behavior). 
‚úî After refresh ‚Üí PUT button disappears, only PATCH remains (correct behavior).




4. Testing Cart Item Updates in API
üìå Step 1: Retrieve a Specific Cart Item (GET /carts/{id}/items/{item_id}/) 
‚úî Expected Response Before Update:
json
{
    "id": 12,
    "product": {
        "id": 5,
        "title": "Coffee Mug",
        "unit_price": 8.99
    },
    "quantity": 20,
    "total_price": 179.80
}

üöÄ Effect: ‚úî Displays current quantity before updating.


üìå Step 2: Update Quantity (PATCH /carts/{id}/items/{item_id}/) 
‚úî Request Body:
json
{
    "quantity": 10
}

‚úî Expected Response After Update:
json
{
    "id": 12,
    "quantity": 10
}

üöÄ Effect: ‚úî Successfully updates only quantity, without modifying other fields.

üìå Step 3: Verify Quantity in Cart (GET /carts/{id}/items/) 
‚úî Expected Response:
json
[
    {
        "id": 12,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 10,
        "total_price": 89.90
    }
]

üöÄ Effect: ‚úî Updated quantity is correctly reflected in cart items list.


üìå Step 4: Handle Invalid Quantity Update (PATCH /carts/{id}/items/{item_id}/) 
‚úî Request Body:
json
{
    "quantity": -5
}

‚úî Expected Response:
json
{
    "quantity": ["Ensure this value is greater than or equal to 1."]
}

üöÄ Effect: ‚úî Prevents negative values, enforcing a minimum quantity of 1.




codes learned in this lesson:

serializers.py:
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ['quantity']
		
		
views.py:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')





üìå Key Takeaways
‚úî Created a separate serializer (UpdateCartItemSerializer) for handling quantity updates. 
‚úî Overrode get_serializer_class() in CartItemViewSet to select the correct serializer. 
‚úî Restricted HTTP methods to exclude PUT, ensuring only PATCH is allowed. 
‚úî Verified functionality by updating a cart item via API calls. 
‚úî Next steps: Implementing deletion of cart items (DELETE /carts/{id}/items/{item_id}/).
















Deleting a Cart Item:
---------------------

Deleting a cart item allows users to remove individual items from their shopping cart, ensuring unwanted items are no longer stored.

üöÄ Steps to Implement Deleting a Cart Item
‚úî Step 1: Ensure DELETE functionality is enabled in CartItemViewSet. 
‚úî Step 2: Verify that allowed HTTP methods are correctly defined. 
‚úî Step 3: Test deletion to confirm that cart items are removed properly. 
‚úî Step 4: Ensure API returns correct responses (204 No Content for success, 404 Not Found for missing items).

1. Verifying DELETE Functionality in CartItemViewSet
üìå Problem: 
‚úî Since CartItemViewSet extends ModelViewSet, all CRUD operations (including DELETE) are automatically supported. 
‚úî However, we need to explicitly allow the DELETE method to ensure proper routing.

üìå Solution: Ensure http_method_names Includes DELETE
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ‚úÖ Allow only necessary HTTP methods
	
üöÄ Effect: 
‚úî Restricts allowed HTTP methods to prevent unsupported operations (e.g., PUT). 
‚úî Ensures that cart items can be deleted (DELETE /carts/{id}/items/{item_id}/).

üìå Important Note: 
‚úî Method names in http_method_names must be lowercase. 
‚úî If delete is capitalized, the API will not recognize it, causing the DELETE button to disappear in the browsable API UI.




2. Testing Cart Item Deletion in API
üìå Step 1: Retrieve Cart Items (GET /carts/{id}/items/) 
‚úî Expected Response (Before Deletion):
json
[
    {
        "id": 12,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 2,
        "total_price": 17.98
    },
    {
        "id": 15,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

üöÄ Effect: ‚úî Shows all items currently in the cart, ready for deletion.


üìå Step 2: Delete a Cart Item (DELETE /carts/{id}/items/{item_id}/) 
‚úî Sending DELETE /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/12/. 
‚úî Expected Response:
json
{}

‚úî Status Code: 204 No Content üöÄ Effect: ‚úî Cart item is successfully deleted.


üìå Step 3: Verify That Item No Longer Exists (GET /carts/{id}/items/{item_id}/) 
‚úî Sending GET /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/12/. 
‚úî Expected Response:
json
{
    "detail": "Not found."
}
‚úî Status Code: 404 Not Found üöÄ Effect: ‚úî Confirms that the item no longer exists on the server.


üìå Step 4: Refresh Cart Items (GET /carts/{id}/items/) 
‚úî Expected Response (After Deletion):
json
[
    {
        "id": 15,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

üöÄ Effect: ‚úî The deleted item is removed from the list, confirming successful deletion.



Codes used in this lesson:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')




üìå Key Takeaways
‚úî Verified DELETE functionality using ModelViewSet in CartItemViewSet. 
‚úî Ensured DELETE method was explicitly allowed via http_method_names. 
‚úî Confirmed deletion success (204 No Content) and missing item response (404 Not Found). 















Django Authentication System:
-----------------------------


In this section, you will learn about Django's authentication system for identifying users. So we'll start off by talking about how the authentication system works under the hood, so you understand all its building blocks. We'll then talk about the user model and how to customize it to fit the requirements of your application. So as part of this, we'll look at extending the user model and creating profiles. Next, we'll talk about permissions and groups for controlling users access.

- How the authentication system works
- user model and customizing it
- Extending the User model
- Creating Profiles
- Managing groups and permissions





Django Authentication System:
-----------------------------

Django comes with a built-in authentication system that provides user management, login, logout, password handling, and access control.

üöÄ Overview of Django's Authentication System
‚úî User management ‚Üí Create, modify, and authenticate users. 
‚úî Permissions & Groups ‚Üí Assign different levels of access.
‚úî Secure password storage ‚Üí Uses hashing algorithms for security. 
‚úî Authentication middleware ‚Üí Automatically detects the logged-in user.


1. Installed Authentication Apps
üìå Django's Authentication System Comes Preinstalled 
‚úî Defined inside INSTALLED_APPS in settings.py:
INSTALLED_APPS = [
    ...
    'django.contrib.auth',  # ‚úÖ Provides user authentication and permissions management
]

üöÄ Effect: 
‚úî Enables user models (User, Group, Permission) for authentication.




2. Database Tables for Authentication

üìå Django Auth System Uses the Following Tables:
Table Name	                   Purpose
auth_user	                   Stores user information (username, password, etc.).
auth_group	                   Defines user groups for role-based access.
auth_permission	               Handles individual permissions for models.
auth_user_groups	           Links users to groups.
auth_user_user_permissions	   Links users to specific permissions.

üöÄ Effect: ‚úî Provides fine-grained user access control using groups and permissions.

üìå Example User Table Fields (auth_user) 
‚úî User ID ‚Üí Unique identifier for the user. 
‚úî Password ‚Üí Encrypted storage to protect credentials. 
‚úî Last login ‚Üí Tracks the last authentication timestamp. 
‚úî Superuser status (is_superuser) ‚Üí Grants full admin access. 
‚úî Username, first name, last name, email ‚Üí Stores basic user details. 
‚úî Staff status (is_staff) ‚Üí Determines admin panel access. 
‚úî Active status (is_active) ‚Üí Enables or disables user accounts. 
‚úî Date joined ‚Üí Stores user registration timestamp.

üöÄ Effect: ‚úî Django automatically manages authentication-related tables to ensure security and scalability.




3. Authentication Middleware: How Django Detects Users
üìå Middleware is a Function That Processes Requests Before They Reach a View 
‚úî Middleware modifies the request object before passing it to a view function. 
‚úî AuthenticationMiddleware is responsible for attaching the user to the request.

üìå Defined in MIDDLEWARE (settings.py)
MIDDLEWARE = [
    ...
    "django.contrib.auth.middleware.AuthenticationMiddleware",  # ‚úÖ Detects the logged-in user
]

üöÄ Effect: 
‚úî Ensures each incoming request contains a user attribute. 
‚úî The request‚Äôs user is either:
	An actual user object (if logged in).
	An instance of AnonymousUser (if not logged in).

üìå Usage in Views (views.py)
def delete_collection(request):
    if request.user.is_authenticated:
        print(f"User {request.user.username} is deleting a collection")

üöÄ Effect: 
‚úî request.user identifies the logged-in user. 
‚úî If a user is authenticated, request.user holds their user object. 
‚úî If not logged in, Django assigns AnonymousUser.



code references in this lesson:
INSTALLED_APPS -->	'django.contrib.auth' -->  contains this

tables --> auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions

MIDDLEWARE --> "django.contrib.auth.middleware.AuthenticationMiddleware" -->

request.user




üìå Key Takeaways
‚úî Django‚Äôs authentication system provides built-in user management and security. 
‚úî The auth_user table stores user details, including encrypted passwords. 
‚úî Authentication middleware ensures requests contain user information (request.user). 
‚úî Users can be assigned roles (is_staff, is_superuser) for access control. 
‚úî Next steps: Customizing the User model for additional fields and advanced authentication!














Customizing the User Model:
---------------------------
Django provides a default User model, but sometimes applications need additional attributes for user management. There are two main approaches to customizing the user model:


1. Extending the User Model (Inheritance) ‚Üí Creates a custom user model with extra authentication-related attributes. 
2. Creating a Profile Model (Composition) ‚Üí Stores additional user-related information in a separate table.


üöÄ Two Approaches to Customizing the User Model

1. Approach: Extending the User Model (Inheritance)
‚úî Create a custom user model that inherits from Django‚Äôs AbstractUser. 
‚úî This approach modifies the main user table directly. 
‚úî Used only for authentication-related attributes, like login behavior.

üìå Example Implementation:
from django.contrib.auth.models import AbstractUser
from django.db import models

class AppUser(AbstractUser):  
    phone_number = models.CharField(max_length=15, blank=True, null=True)  # ‚úÖ Example additional field
	
üöÄ Effect: 
‚úî Adds extra fields directly to the auth_user table. 
‚úî Allows for custom authentication logic.

üìå When to Use This Approach? 
‚úî If modifying login behavior (e.g., using email instead of username). 
‚úî If storing authentication-related fields (e.g., password reset settings). 
‚úî Not recommended in an existing project‚Äîswitching models mid-project is complex.




2. Approach: Creating a Profile Model (Composition)
‚úî Create a separate profile model linked to Django‚Äôs default User. 
‚úî This approach keeps authentication logic in Django‚Äôs default user system. 
‚úî Best for storing user-related data that is not authentication-specific.

üìå Example Implementation:
from django.contrib.auth.models import User
from django.db import models

class Profile(models.Model):  
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")  # ‚úÖ Establishes link with User
    birth_date = models.DateField(blank=True, null=True)
    address = models.CharField(max_length=255, blank=True, null=True)
	
üöÄ Effect: 
‚úî Keeps authentication logic separate from user attributes. 
‚úî Allows each app to define its own user profile concept.

üìå When to Use This Approach? 
‚úî If storing general user information (e.g., birthdate, address). 
‚úî If multiple apps need different user profiles (HR, sales, training). 
‚úî Best for existing projects‚Äîdoes not require replacing Django‚Äôs default user model.




üöÄ Practical Differences Between Inheritance and Composition
Feature	                                   Extending User Model (Inheritance)	                 Creating a Profile Model (Composition)

Database Structure	                       Extra fields stored in auth_user table	             Separate table with a one-to-one link to auth_user
Authentication Use Case	                   ‚úÖ Ideal for modifying login/authentication logic	     ‚ùå Not suitable for authentication changes
General User Info (Address, Birthdate)	   ‚ùå Not recommended	                                 ‚úÖ Best for storing profile data
Multiple User Profile Types	               ‚ùå Hard to manage multiple roles	                     ‚úÖ Each app can define different profiles

üöÄ Conclusion: 
‚úî Use Inheritance for authentication-related modifications. 
‚úî Use Composition for general user attributes. 
‚úî Most projects use the Profile approach due to flexibility.



üìå Key Takeaways
‚úî Django‚Äôs default user model can be customized using inheritance or composition. 
‚úî Use inheritance (AbstractUser) only for authentication-related attributes. 
‚úî Use a separate profile model (OneToOneField) for general user information. 
‚úî Switching to a custom user model mid-project is complex‚Äîcomposition is preferred for flexibility. 
‚úî Next steps: Exploring these approaches in detail with real-world use cases!



Further Refining this:
---------------------
Django comes with a built-in User model that stores basic authentication details like usernames, passwords, and login status. However, many applications need extra user information‚Äîsuch as phone numbers, addresses, or birthdays.

We have two main ways to customize the user model:

1. Approach: Extending the User Model (Inheritance)
‚úî We create a new user model that inherits from Django‚Äôs AbstractUser. 
‚úî This allows us to add extra authentication-related fields directly to the user table in the database.

üìå Example: Adding a phone_number field
from django.contrib.auth.models import AbstractUser
from django.db import models

class AppUser(AbstractUser):  
    phone_number = models.CharField(max_length=15, blank=True, null=True)  # ‚úÖ New field added directly to user table
	
üöÄ Effect: 
‚úî Adds the phone_number field directly inside the auth_user table. 
‚úî Customizes authentication logic, such as logging in with a phone number instead of a username.

üìå When to Use This Approach? 
‚úî If modifying authentication (e.g., using email or phone instead of username). 
‚úî If storing authentication-related attributes (e.g., login method changes). 
‚ùå Not recommended for an existing project‚Äîreplacing Django‚Äôs default user model mid-project is complex.




2. Approach: Creating a Separate Profile Model (Composition)
‚úî We keep Django‚Äôs default User model but create an extra table for storing additional user details. 
‚úî The profile model is linked to Django‚Äôs User model using a OneToOneField.

üìå Example: Creating a Profile Table
from django.contrib.auth.models import User
from django.db import models

class Profile(models.Model):  
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")  # ‚úÖ Linked to User
    birth_date = models.DateField(blank=True, null=True)
    address = models.CharField(max_length=255, blank=True, null=True)

üöÄ Effect: 
‚úî Stores general user details in a separate table (profile). 
‚úî The Profile table is linked to User, so each user has exactly one profile.

üìå When to Use This Approach? 
‚úî If storing personal information like birthdate, address, or preferences. 
‚úî If multiple apps need different types of user profiles (e.g., customers, employees, students). 
‚úî Best for existing projects‚Äîavoids the complexity of changing Django‚Äôs built-in user model.




üöÄ Practical Differences Between Inheritance and Composition
Feature	Extending User Model (Inheritance)	Creating a Profile Model (Composition)
Database Structure	Extra fields inside auth_user table	Separate profile table linked to auth_user
Authentication Changes	‚úÖ Ideal for modifying login behavior	‚ùå Not meant for authentication changes
General User Info (Address, Birthdate)	‚ùå Not recommended	‚úÖ Best for storing profile data
Multiple User Profile Types	‚ùå Hard to manage	‚úÖ Each app can define different profiles
üöÄ Conclusion: ‚úî Use Inheritance if changing authentication logic (e.g., login method). ‚úî Use Composition if storing general user details (e.g., address, birthdate). ‚úî Most projects prefer the profile approach for flexibility.




üìå Key Takeaways
‚úî Django‚Äôs default user model stores authentication details. 
‚úî We can customize it using inheritance (AbstractUser) or composition (Profile). 
‚úî Use inheritance if modifying authentication behavior. 
‚úî Use a profile table for storing personal user details. 
‚úî Switching to a custom user model mid-project is difficult ‚Äî composition is the safer option. 
‚úî Next steps: Implementing these approaches in real-world applications!









Extending the User Model:
-------------------------
Django provides a default User model, but sometimes projects need extra authentication features‚Äîsuch as logging in with an email instead of a username. In such cases, we extend the User model to customize authentication.

üöÄ Why Extend the User Model?
‚úî Modify authentication logic (e.g., using email instead of username). 
‚úî Add authentication-specific fields (e.g., phone number, login preferences). 
‚úî Ensure flexibility for future authentication changes.

üìå Example Change: 
‚úî By default, Django requires a unique username, but email is not unique. 
‚úî If we want users to log in with their email, we must add a unique constraint.

1. Creating a Custom User Model
üìå Steps to Extend the User Model: 
‚úî Create a new User model that inherits from Django‚Äôs AbstractUser. 
‚úî Redefine the email field to enforce uniqueness.

üìå Implementation (core/models.py):
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    email = models.EmailField(unique=True)  # ‚úÖ Enforce unique emails
	
	
üöÄ Effect: 
‚úî A new User model is created with a unique email field. 
‚úî Existing authentication logic remains unchanged.




2. Informing Django About the Custom User Model

üìå Django Needs to Know Which User Model to Use 
‚úî Modify settings.py to reference the new User model.

üìå Implementation (settings.py):
AUTH_USER_MODEL = 'core.User'  # ‚úÖ Tell Django to use the custom User model

üöÄ Effect: 
‚úî Ensures Django uses the new User model instead of the default. 
‚úî All future references to User will now point to core.User.




3. Resolving Foreign Key Issues in Other Apps

üìå Problem: 
‚úî Other apps (e.g., likes) may reference the default auth_user model. 
‚úî Since we changed the user model, we must update these references.

üìå Solution: Use settings.AUTH_USER_MODEL Instead of Hardcoding User 
‚úî Modify apps that have foreign keys to User.

üìå Implementation (likes/models.py):
from django.conf import settings
from django.db import models

class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)  # ‚úÖ Dynamically reference user model
	
üöÄ Effect: 
‚úî Prevents direct dependency on auth_user. 
‚úî Ensures compatibility with future authentication changes.




4. Handling Migrations and Database Updates
üìå Problem: 
‚úî Since we changed the user model, existing migrations may not apply correctly. 
‚úî Django may throw errors related to user dependencies.

üìå Solution: 
Create Fresh Migrations and Reinitialize the Database

üìå Steps: 
‚úî Create migrations for the new User model:
python manage.py makemigrations

‚úî Apply migrations:
python manage.py migrate

üöÄ Effect: 
‚úî The database now uses the new User model.

üìå If Migration Errors Occur: 
‚úî Some applications depend on the default user model, causing errors. 
‚úî If necessary, drop and recreate the database (only if changing mid-project).




5. Registering Custom User Model in Django Admin
üìå Problem: 
‚úî The Django Admin panel does not automatically recognize the new User model. 
‚úî We must register it manually.

üìå Solution: Register the Model in core/admin.py
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib import admin
from .models import User

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'password1', 'password2', 'email', 'first_name', 'last_name'),
        }),
    )
	
üöÄ Effect: 
‚úî Users can now be managed in Django Admin. 
‚úî Adds email, first name, and last name to user creation form.

üìå Testing:
‚úî Create a new user via Django Admin. 
‚úî Ensure email is now required and unique.




codes in this lesson:
core/models.py:
from django.contrib.auth.models import AbstractUser
from django.db import models

# Create your models here.
class User(AbstractUser):
  email = models.EmailField(unique=True)


settings.py:
AUTH_USER_MODEL = 'core.User'

likes/models.py:
from django.conf import settings
from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()


core/admin.py:
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'password1', 'password2', 'email', 'first_name', 'last_name'),
        }),
    )





üìå Key Takeaways
‚úî Extended the User model to support unique email authentication.
‚úî Modified settings to reference the new user model. 
‚úî Updated foreign key references to ensure compatibility. 
‚úî Handled migrations to apply changes safely. 
‚úî Registered the new user model in Django Admin for easy management. 
‚úî Next steps: Exploring different authentication mechanisms and login methods!













Creating User Profiles:
-----------------------
A user profile allows applications to store extra user information beyond authentication details. Instead of modifying the authentication system, we create a separate model for user profiles.

üöÄ Why Create a User Profile?
‚úî Keeps authentication separate from user details ‚Üí The built-in User model handles authentication only. 
‚úî Makes applications reusable ‚Üí The profile model can adapt to different user models across projects. 
‚úî Ensures flexibility ‚Üí Multiple apps (Sales, HR, Training) can have different profiles linked to users.

üìå Example Use Case: 
‚úî A customer profile in an e-commerce app should store details like membership, phone number, and birthdate. 
‚úî These do not belong in the authentication system, so they are stored separately.

1. Creating the User Profile Model
üìå Steps: 
‚úî Define a Customer model as a one-to-one relationship with the User model. 
‚úî Reference settings.AUTH_USER_MODEL instead of hardcoding the User model.

üìå Implementation (models.py):
from django.conf import settings
from django.db import models
from django.contrib import admin

class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE
    )
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )  # ‚úÖ Establish one-to-one link with User

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
		
üöÄ Effect: 
‚úî Customer stores additional details for each user, without modifying the User model. 
‚úî Uses one-to-one relationship (OneToOneField) to link each customer to a user. 
‚úî Ensures flexibility‚Äîworks with any user model across different projects.




2. Updating the Django Admin Panel
üìå Problem: 
‚úî The Customer model is not automatically registered in Django Admin. 
‚úî Sorting by first and last name does not work properly.

üìå Solution: 
‚úî Register the model in admin.py. 
‚úî Optimize sorting using admin.display.

üìå Implementation (admin.py):
from django.contrib import admin
from .models import Customer
from django.urls import reverse
from django.utils.http import urlencode
from django.utils.html import format_html
from django.db.models import Count

@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership', 'orders']  # ‚úÖ Display first & last name dynamically
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']  # ‚úÖ Optimize queries
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']

    @admin.display(ordering='orders_count')
    def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist') + '?' + urlencode({'customer__id': str(customer.id)})
        )
        return format_html('<a href="{}">{} Orders</a>', url, customer.orders_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(orders_count=Count('order'))
		
üöÄ Effect: 
‚úî Enables customer management in Django Admin. 
‚úî Allows sorting customers by first and last name. 
‚úî Optimizes queries using list_select_related to prevent redundant lookups.




3. Handling Migrations and Database Updates
üìå Problem: 
‚úî Adding user as a non-nullable field requires default values for existing customers. 
‚úî Without a default, Django will not apply migrations properly.

üìå Solution: 
‚úî Provide a temporary default value when running migrations.

üìå Steps: 
‚úî Create a migration for adding the user field:
python manage.py makemigrations

‚úî Django will prompt for a default value ‚Üí Choose 1 (Admin User ID). 
‚úî Apply the migration:
python manage.py migrate

üöÄ Effect: 
‚úî The Customer model now links each user to their profile. 
‚úî Older customers are temporarily assigned to Admin (ID = 1).

üìå Verifying Changes in the Database: 
‚úî Refresh the customer table ‚Üí user_id is now a foreign key to the user table. 
‚úî First name, last name, and email columns are removed (handled via the linked user model).




4. Testing in Django Admin
üìå Step 1: Create a New Customer 
‚úî Go to Admin ‚Üí Customers ‚Üí Add Customer. 
‚úî Provide phone, membership level, and select a user from the dropdown. 
‚úî Save ‚Üí A new customer profile is linked to the selected user.

üìå Step 2: Sorting Customers by Name 
‚úî Before fixing ‚Üí Sorting does not work by first or last name. 
‚úî After fixing ‚Üí Sorting works correctly, allowing admin users to organize customers efficiently.

üìå Step 3: Verify Customer List in Admin 
‚úî Customers now display first name and last name dynamically. 
‚úî Sorting, searching, and linking to orders work as expected.





Codes in this lesson:
models.py:
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
		
		
admin.py:
@admin.register(models.Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name',  'membership', 'orders']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']

    @admin.display(ordering='orders_count')
    def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist')
            + '?'
            + urlencode({
                'customer__id': str(customer.id)
            }))
        return format_html('<a href="{}">{} Orders</a>', url, customer.orders_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(
            orders_count=Count('order')
        )
		




üìå Key Takeaways
‚úî Created a user profile model (Customer) with a one-to-one relationship to User. 
‚úî Used settings.AUTH_USER_MODEL to ensure compatibility with any user model. 
‚úî Registered the profile model in Django Admin with optimized sorting and search functionality. 
‚úî Handled database migrations safely to link existing customers to users. 
‚úî Next steps: Implementing authentication features with Django‚Äôs built-in login system!












Groups and Permissions:
-----------------------
Django provides a built-in permissions system, allowing users to manage access rights across different models. Instead of assigning permissions individually, groups help organize users into roles with predefined permissions.

üöÄ What Are Groups and Permissions?
‚úî Permissions ‚Üí Define what users can and cannot do (e.g., view, add, change, delete). 
‚úî Groups ‚Üí Collections of permissions that can be assigned to multiple users for easier management.

üìå Example Use Case: 
‚úî Instead of manually assigning permissions to each customer service representative, we create a Customer Service Group with permissions to manage customers and orders. 
‚úî Users added to this group inherit these permissions automatically.




1. Understanding Django's Built-in Permissions System
üìå Django Automatically Creates Permissions for Each Model 
‚úî When a model is migrated, Django generates four permissions:

Permission	    Purpose
add_<model>	    Allows adding new records
change_<model>	Allows modifying records
delete_<model>	Allows removing records
view_<model>	Allows reading records

üöÄ Effect: ‚úî Every model has its own set of permissions, stored in the auth_permission table.

üìå Locating Permissions in the Database (auth_permission Table) ‚úî Each permission includes:
id ‚Üí Unique identifier.
name ‚Üí Human-readable name (Can view user).
codename ‚Üí Unique string for referencing in code (view_user).
content_type_id ‚Üí Links permission to a specific model (via django_content_type).

‚úî Example Record:
id | name         | codename    | content_type_id
---|-------------|------------|----------------
32 | Can view user | view_user  | 19  # Linked to "User" model

üöÄ Effect: ‚úî Ensures permissions are tied to specific models, allowing precise access control.




2. Creating a Group in Django Admin
üìå Steps to Create a "Customer Service" Group 
‚úî Navigate to Django Admin ‚Üí Groups ‚Üí Add Group. 
‚úî Name the group Customer Service. 
‚úî Select permissions for managing customers and orders:
	view_customer, add_customer, change_customer, delete_customer
	view_order, add_order, change_order, delete_order ‚úî Save the group.

üöÄ Effect: ‚úî The Customer Service Group now has predefined permissions, making role management easier.




3. Assigning a User to a Group
üìå Steps to Assign "John Smith" to Customer Service Group 
‚úî Navigate to Django Admin ‚Üí Users ‚Üí John Smith. 
‚úî Mark John as a Staff Member (needed for admin access). 
‚úî Select Customer Service Group under "Groups". ‚úî Save changes.

üöÄ Effect: 
‚úî John now inherits all group permissions, allowing him to manage customers and orders. 
‚úî Admin users do not need individual permission assignments.

üìå Verifying Permissions 
‚úî Log out and log in as John Smith. 
‚úî John can now access Django Admin, but only manage customers and orders‚Äîno extra permissions.




4. Where Are Groups Stored in the Database?
üìå Django Stores Groups in the auth_group Table 
‚úî Groups are assigned to users via the auth_user_groups Table.

Table Name	             Purpose
auth_group	             Stores group names
auth_group_permissions	 Stores permissions assigned to groups
auth_user_groups	     Links users to groups

üöÄ Effect: 
‚úî Each user can belong to multiple groups for flexible role management. 
‚úî Groups streamline permission assignments, reducing manual effort.




üìå Key Takeaways
‚úî Permissions allow granular control over user actions. 
‚úî Groups simplify user management by bundling permissions together. 
‚úî Django automatically generates permissions for each model. 
‚úî Users assigned to groups inherit permissions dynamically. 
‚úî Next steps: Creating custom permissions for specific business needs!















Creating Custom Permissions: 
----------------------------
Django provides built-in permissions (add, change, delete, view), but sometimes certain actions don‚Äôt fit these categories. Custom permissions allow fine-grained control over user actions.

üöÄ Why Create Custom Permissions?
‚úî Certain operations don‚Äôt fit into add, change, or delete (e.g., canceling an order). 
‚úî Users should have permission for specific actions (e.g., canceling orders without full update access). 
‚úî Fine-grained control over user access ‚Üí Assign permissions without affecting broader roles.

üìå Example Use Case: 
‚úî We want users to cancel orders, but not edit other order details. 
‚úî Built-in update permission (change_order) allows too much access ‚Äî we need a custom permission.

1. Defining Custom Permissions in a Model
üìå Steps: 
‚úî Add a Meta class inside the model. 
‚úî Set permissions as a list of tuples (codename, human-readable name).

üìå Implementation (models.py):
class Order(models.Model):
    status = models.CharField(max_length=20)

    class Meta:
        permissions = [
            ("cancel_order", "Can cancel order"),  # ‚úÖ Custom permission for order cancellation
        ]
		
üöÄ Effect: 
‚úî Creates a new permission (cancel_order). 
‚úî Users can be assigned permission to cancel orders, without broader update access.




2. Applying Migrations to Save Custom Permissions
üìå Steps: 
‚úî Generate a migration for the new permission:
python manage.py makemigrations

‚úî Apply migrations:
python manage.py migrate

üöÄ Effect: 
‚úî The new permission appears in the database (auth_permission table).

üìå Verifying in Database (auth_permission Table) 
‚úî Open permission table in the database. 
‚úî Look for the newly created permission record:
id	name	            codename	    content_type_id
35	Can cancel order	cancel_order	21 (linked to Order)

üöÄ Effect: ‚úî The permission is correctly linked to the Order model using content_type_id.




3. Assigning Custom Permissions to Users
üìå Steps: 
‚úî Navigate to Django Admin ‚Üí Users ‚Üí John Smith. 
‚úî Search for "cancel order" in the permissions list. 
‚úî Select and assign this permission to John Smith. 
‚úî Save changes.

üöÄ Effect: 
‚úî John now has permission to cancel orders, but cannot modify other order details.

üìå Verifying Permissions 
‚úî John should be able to cancel orders but not fully update them. 
‚úî Next step: Apply permission checks in the API.





Codes in this lession:

models.py:
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

    class Meta:
        permissions = [
            ('cancel_order', 'Can cancel order')
        ]




üìå Key Takeaways
‚úî Custom permissions allow fine-grained control over user actions. 
‚úî Defined in the Meta class inside models using permissions list. 
‚úî Stored in the auth_permission table after migrations are applied. 
‚úî Assigned to users via Django Admin or programmatically. 
‚úî Next steps: Implementing permission checks in the API to enforce security!













Securing APIs:
--------------
Introduction:

In this section, you're going to learn how to secure your API endpoints using permissions. So we'll start off by talking about token-based authentication, which is the de facto standard for authenticating users with RESTful APIs. Then we'll add authentication endpoints to our API and allow users to register, log in, log out, and so on. And finally, we'll apply a bunch of permissions to some of our API endpoints so they are not accessible by just anyone. So now let's jump in and get started.

In this section: 
Token-based authentication
Adding authentication endpoints
Registering, logging in, etc
Applying permissions






Token-based Authentication:
---------------------------
Token-based authentication is the standard approach for securing RESTful APIs. It allows clients to authenticate and access protected resources using tokens instead of session-based authentication.

üöÄ How Token-Based Authentication Works
‚úî Step 1: User Registration ‚Üí The client sends user details to the server, which creates an account. 
‚úî Step 2: User Login ‚Üí The client sends credentials (username & password) to the authentication endpoint. 
‚úî Step 3: Token Generation ‚Üí If credentials are valid, the server returns a token to the client. 
‚úî Step 4: Client Stores Token ‚Üí The token is stored locally (in memory, local storage, or cookies). 
‚úî Step 5: Accessing Protected Resources ‚Üí The client sends requests with the token in the header. 
‚úî Step 6: Token Validation ‚Üí The server verifies the token before granting access.

üöÄ Effect: ‚úî Users authenticate once, then use a token for future requests instead of re-entering credentials.


1. Registering a New User
üìå Client Request (POST /users/) 
‚úî The client sends registration details to the server:
json
{
    "username": "johnsmith",
    "email": "john@example.com",
    "password": "securepassword"
}

üöÄ Effect: ‚úî The server stores user details and creates an account.




2. Logging In & Obtaining a Token
üìå Client Request (POST /auth/login/) 
‚úî The client sends credentials to the authentication endpoint:
json
{
    "username": "johnsmith",
    "password": "securepassword"
}

üìå Server Response (200 OK) 
‚úî If credentials are valid, the server returns a token:
json
{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

üöÄ Effect: 
‚úî The client stores this token locally for future authentication.




3. Accessing Protected Resources

üìå Client Request (GET /users/profile/) 
‚úî The client sends a request with the token in the header:

http
GET /users/profile/
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

üöÄ Effect: ‚úî The server validates the token and grants access if it‚Äôs valid and not expired.




4. Token Expiration & Validation
üìå Token Validation Process on Server 
‚úî The server checks:
Is the token correctly formatted?
Has the token expired?
Is the token issued for this user?

üìå Server Response for Invalid Token (401 Unauthorized) 
‚úî If the token is expired or invalid, access is denied:
json
{
    "detail": "Token is invalid or expired."
}

üöÄ Effect: ‚úî Users must log in again to obtain a new token.




üìå Key Takeaways
‚úî Token-based authentication eliminates the need for repeated logins. 
‚úî Clients send a token in the header to access protected resources. 
‚úî Tokens must be validated on the server before granting access. 
‚úî Expired or invalid tokens require re-authentication. 
‚úî Next steps: Implementing token-based authentication in Django REST Framework!











Adding the Authentication Endpoints:
------------------------------------

Django provides a full-fledged authentication system, but it does not include an API layer. This means there are no built-in endpoints for user registration, login, logout, or password reset. Instead of building this manually, we use Djoser, a RESTful authentication implementation.

üöÄ What Is Djoser?
‚úî Djoser extends Django‚Äôs authentication system with a set of API endpoints. 
‚úî Provides ready-made views for user registration, login, logout, password reset, and account management. 
‚úî Eliminates the need to manually implement authentication APIs.

üìå Example Endpoints Added by Djoser: 
‚úî /auth/users/ ‚Üí Manage users 
‚úî /auth/users/me/ ‚Üí Get current user 
‚úî /auth/token/login/ ‚Üí Login 
‚úî /auth/token/logout/ ‚Üí Logout 
‚úî /auth/users/reset_password/ ‚Üí Password reset

üöÄ Effect: 
‚úî All authentication-related functionality is available via API. 
‚úî The backend does the heavy lifting, while frontend apps simply call these endpoints.

üîó Djoser Documentation: https://djoser.readthedocs.io/en/latest/




1. Installing Djoser and Required Libraries
üìå Step 1: Install Djoser
pipenv install djoser

üöÄ Effect: 
‚úî Djoser is added to the project, enabling authentication APIs.


üìå Step 2: Add Djoser to INSTALLED_APPS (settings.py)
INSTALLED_APPS = [
    ...
    'rest_framework',  # ‚úÖ REST Framework
    'djoser',  # ‚úÖ Djoser authentication API
]

üöÄ Effect: ‚úî The app recognizes Djoser, enabling built-in authentication endpoints.




2. Choosing an Authentication Backend
Djoser does not handle authentication directly‚Äîit relies on an authentication backend to validate credentials.

‚úî Two Options: 
1.Token-Based Authentication (rest_framework.authtoken) ‚Üí Stores authentication tokens in the database. 
2. JSON Web Token (JWT) Authentication (rest_framework_simplejwt) ‚Üí Uses signed tokens, eliminating database queries.

üöÄ JWT Authentication Is Preferred 
‚úî Does not require a database lookup for token validation. 
‚úî Uses digital signatures to verify authenticity.

üìå Step 1: Install Simple JWT Library
pipenv install djangorestframework-simplejwt

üìå Step 2: Configure JWT Authentication in Django (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
}
üöÄ Effect: ‚úî The backend now uses JWT tokens for authentication.

üìå Step 3: Configure JWT Settings (settings.py)
SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),  # ‚úÖ Prefix authentication tokens with 'JWT'
}

üöÄ Effect: ‚úî When sending a request, tokens must be prefixed with JWT in the header. 
‚úî Example:
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...




3. Registering Authentication Routes in Django URLs
üìå Step 1: Add Djoser Routes to urls.py
from django.urls import path, include

urlpatterns = [
    ...
    path('auth/', include('djoser.urls')),  # ‚úÖ Core authentication endpoints
    path('auth/', include('djoser.urls.jwt')),  # ‚úÖ JSON Web Token endpoints
]

üöÄ Effect: 
‚úî Users can register, login, logout, and reset passwords via API calls. 
‚úî JWT tokens can be generated and validated via the authentication routes.

üìå Step 2: Test Endpoints in Browser 
‚úî Visit /auth/users/ ‚Üí Should return 401 Unauthorized (protected). 
‚úî Visit /auth/token/login/ ‚Üí Users can authenticate.




4. Validating Authentication API
üìå Step 1: Attempt to Access /auth/users/ Without Authentication 
‚úî Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: 
‚úî Users must log in and obtain a JWT token to access protected endpoints.


üìå Step 2: Login and Obtain a Token (POST /auth/token/login/) 
‚úî Request Body:
json
{
    "username": "johnsmith",
    "password": "securepassword"
}

‚úî Expected Response:
json
{
    "auth_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
üöÄ Effect: ‚úî Token is generated‚Äînow the client can authenticate future requests.


üìå Step 3: Access /auth/users/ Using Token 
‚úî Request Header:
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

üöÄ Effect: 
‚úî The request is authenticated, and the user can retrieve their account details.



codes/notes in this lesson:

https://djoser.readthedocs.io/en/latest/


pipenv install djoser


AUTH Engines:
Token-based Authentication
JSON Web Token Authentication



üìå Key Takeaways
‚úî Django‚Äôs authentication system lacks an API layer‚ÄîDjoser provides it. 
‚úî Djoser simplifies user registration, login, logout, and password reset via API. 
‚úî Authentication backend choices: Token-based (authtoken) vs. JWT-based (simplejwt). 
‚úî JWT authentication eliminates database queries, improving performance. 
‚úî Protected endpoints require authentication tokens in the request header. 
‚úî Next steps: Registering users and implementing authentication workflows!












Registering the Users:
----------------------

Djoser provides a ready-to-use API layer for Django‚Äôs authentication system, allowing users to register, login, and manage accounts via RESTful endpoints.

üöÄ Steps for User Registration
‚úî Step 1: Users send a POST request to /auth/users/ with their registration details. 
‚úî Step 2: Django validates the input, including password strength checks. 
‚úî Step 3: Upon successful registration, a new user ID is returned. 
‚úî Step 4: Users can customize registration by extending the serializer to include additional fields.


1. Validating User Registration
üìå Client Request (POST /auth/users/)
json
{
    "email": "user1@domain.com",
    "username": "user1",
    "password": "ILoveDjango"
}

üöÄ Effect: 
‚úî The request is processed, and a new user is created. 
‚úî Password strength checks validate security requirements.

üìå Password Validation (AUTH_PASSWORD_VALIDATORS in settings.py)
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

üöÄ Effect: 
‚úî Ensures passwords meet minimum security criteria.

üìå Common Validation Errors 
‚úî Too short ‚Üí "Ensure this value has at least 8 characters." 
‚úî Too common ‚Üí "This password is too common." 
‚úî Entirely numeric ‚Üí "This password is entirely numeric."




2. Customizing the Registration Serializer
üìå Problem: 
‚úî By default, Djoser does not capture first name & last name in registration. 
‚úî To include additional fields, we need to override Djoser‚Äôs serializer.

üìå Solution: Extend Djoser‚Äôs Default Serializer (UserCreateSerializer) 
‚úî Create a new serializer in core/serializers.py 
‚úî Add fields for first name, last name 
‚úî Register the serializer in settings.py

üìå Implementation (core/serializers.py)
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer

class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password', 'email', 'first_name', 'last_name']  # ‚úÖ Includes additional fields
		
üöÄ Effect: 
‚úî First name & last name are now included in registration requests.

üìå Register the Custom Serializer (settings.py)
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
    }
}

üöÄ Effect: 
‚úî Djoser now uses our custom serializer for handling user registration.




3. Testing Registration with Custom Fields
üìå Client Request (POST /auth/users/)
json
{
    "username": "user2",
    "password": "ILoveDjango",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

‚úî Expected Response:
json
{
    "id": 4,
    "username": "user2",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

üöÄ Effect: 
‚úî User is successfully created with first & last name included.




4. Handling Profile Data Separately
üìå Why Not Include Profile Fields in Registration? 
‚úî The User model handles authentication, while the Customer model manages profile details. 
‚úî Mixing profile fields violates separation of concerns‚Äîeach component should handle one responsibility.

üìå Correct Approach: Two Separate API Calls 
‚úî First request: Register user (POST /auth/users/) ‚Üí Handles authentication fields. 
‚úî Second request: Create a profile (POST /profiles/) ‚Üí Stores profile-specific data (e.g., birthdate, address).

üöÄ Effect: 
‚úî More maintainable API ‚Üí Authentication and profile management remain independent. 
‚úî Better flexibility ‚Üí Profile features can evolve separately from authentication logic.




codes and other notes in this lesson:

127.0.0.1:8000/auth/users/


AUTH_PASSWORD_VALIDATORS = {....}

POST:
{
	"email":"user1@domain.com",
	"username":"user1",
	"password":"ILoveDjango"
}
	
	
core/serializers.py:
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer


class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password',
                  'email', 'first_name', 'last_name']




settings.py:
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
    }
}


POST:
{    
	"username":"user2",
	"password":"ILoveDjango",
	"email":"user2@domain.com",
	"first_name": "Joe", 
	"last_name": "Smith"
}
	





üìå Key Takeaways
‚úî Djoser provides an easy way to register users via REST API. 
‚úî Password validation ensures strong security standards. 
‚úî Custom serializers allow capturing additional user fields. 
‚úî User authentication and profile management should remain separate for scalability. 
‚úî Next steps: Implementing the profile API for managing user details!












Building the Profile API:
-------------------------
Djoser handles user authentication, but user profiles are specific to an application. Since Djoser does not provide profile-related endpoints, we need to build a customer profile API ourselves.

üöÄ Steps to Implement the Profile API
‚úî Step 1: Create a serializer for the Customer model to expose relevant fields. 
‚úî Step 2: Define a viewset with only necessary operations (create, retrieve, update). 
‚úî Step 3: Register the endpoint in urls.py to make it accessible via API. 
‚úî Step 4: Ensure that user profiles are linked to authenticated users.

1. Creating the Customer Serializer
üìå Purpose: 
‚úî The CustomerSerializer controls data representation, ensuring only essential profile fields are exposed. 
‚úî Explicitly define user_id since Django does not automatically include it in model serializers.

üìå Implementation (serializers.py):
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)  # ‚úÖ Ensures `user_id` is correctly referenced

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']  # ‚úÖ Exposes profile data

üöÄ Effect: 
‚úî Displays user ID, phone number, birth date, and membership status when retrieving customer data. 
‚úî Prevents user_id from being modified directly‚Äîuser is assigned via authentication.




2. Defining the Customer ViewSet
üìå Purpose: 
‚úî We don‚Äôt need all CRUD operations‚Äîonly create, retrieve, and update are necessary. 
‚úî Users should manage their own profiles, not see a list of all customers.

üìå Implementation (views.py):
class CustomerViewSet(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet):
    queryset = Customer.objects.all()  # ‚úÖ Retrieves customer records
    serializer_class = CustomerSerializer  # ‚úÖ Uses the serializer to structure responses
	
üöÄ Effect: 
‚úî Ensures users can create, retrieve, and update their profiles. 
‚úî Does not allow deleting customers, as profiles should be automatically removed when users are deleted. 
‚úî Does not return a list of all customers, preventing unnecessary exposure of user data.




3. Registering the Profile API Route
üìå Purpose: 
‚úî Adds a /customers/ endpoint for managing user profiles. 
‚úî Ensures API clients can interact with user profiles via structured requests.

üìå Implementation (urls.py):
router.register('customers', views.CustomerViewSet)  # ‚úÖ Registers `/customers/` endpoint

üöÄ Effect: 
‚úî POST /customers/ ‚Üí Creates a customer profile. 
‚úî GET /customers/{id}/ ‚Üí Retrieves a specific profile. 
‚úî PATCH /customers/{id}/ ‚Üí Updates profile details.

üìå Accessing the API in Browser: 
‚úî Visit 127.0.0.1:8000/store/customers/ ‚Üí Shows profile management options.




4. Testing the Profile API
üìå Step 1: Creating a Profile (POST /customers/) 
‚úî Client Request:
json
{
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

‚úî Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}
üöÄ Effect: ‚úî A profile is created for User 4 with the specified attributes.


üìå Step 2: Retrieving the Profile (GET /customers/1/) 
‚úî Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

üöÄ Effect: 
‚úî Users can retrieve their profile details via API.


üìå Step 3: Updating the Profile (PATCH /customers/1/) 
‚úî Client Request:
json
{
    "phone": "9876"
}

‚úî Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "9876",
    "birth_date": "2000-01-01",
    "membership": "B"
}

üöÄ Effect: 
‚úî Users successfully update profile details.




5. Improving API Security
üìå Problem: 
‚úî Right now, anyone can manually specify a user_id when creating a profile. 
‚úî Authenticated users should automatically be linked to their profile, removing the need for user_id input.

üìå Solution: Extract user_id From JWT Token Instead of Request Body 
‚úî Authenticate users before allowing profile creation. 
‚úî Retrieve user_id from token instead of passing it manually in the request.

üöÄ Effect: 
‚úî Only authenticated users can manage their own profile. 
‚úî Prevents unauthorized users from modifying other users‚Äô profiles.

üìå Next Steps: 
‚úî Implement authentication checks to secure the profile API. 
‚úî Use JWT tokens to link users without requiring user_id in requests.





Codes/Notes in this lesson:
serializers.py:
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']        




views.py:
class CustomerViewSet(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet):
	queryset = Customer.objects.all()
	serializer_class = CustomerSerializer
	
	
	
urls.py:
router.register('customers', views.CustomerViewSet)



POST:
{
	"user_id" : 4,
	"phone": "1234"
	"birth_date": 2000-01-01"
	"membership": "B"
}




üìå Key Takeaways
‚úî Djoser manages authentication, but profiles must be implemented separately. 
‚úî The Profile API enables users to manage personal details. 
‚úî The ViewSet only includes necessary actions (create, retrieve, update). 
‚úî User authentication should be enforced to prevent unauthorized profile modifications. 
‚úî Next steps: Implementing authentication checks to secure the profile API!













Logging In:
-----------

Django REST Framework provides two authentication backends: 
1. Token-Based Authentication ‚Üí Requires a database lookup for each request. 
2. JWT Authentication ‚Üí Uses digitally signed tokens, eliminating the need for a database query.

In this implementation, we use JWT for authentication since it's more efficient.

üöÄ Steps for Logging In
‚úî Step 1: Users send a POST request to /auth/jwt/create/ with credentials. 
‚úî Step 2: If credentials are valid, the server responds with two tokens (Access & Refresh). 
‚úî Step 3: The client stores the access token to authenticate future requests. 
‚úî Step 4: If the access token expires, the client requests a new one using the refresh token.

üìå Login Endpoint
http
POST /auth/jwt/create/

üöÄ Effect: ‚úî Authenticates the user and provides tokens for securing API calls.




1. Authenticating Users via API
üìå Client Request (POST /auth/jwt/create/) 
‚úî Users send their username and password for authentication:
json
{
    "username": "user1",
    "password": "ILoveDjango"
}

üìå Possible Responses: ‚úî Success (200 OK)
json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

‚úî Failure (401 Unauthorized)
json
{
    "detail": "No active account found with the given credentials."
}

üöÄ Effect: 
‚úî The server verifies credentials, returning tokens if valid. 
‚úî Incorrect credentials result in a 401 Unauthorized error.




2. Understanding Access & Refresh Tokens
üìå Access Token 
‚úî Short-lived token (~5 minutes by default). 
‚úî Used to authenticate API requests. 
‚úî Expires quickly for security reasons.

üìå Refresh Token 
‚úî Long-lived token (~1 day by default). 
‚úî Used to generate a new access token once expired.

üöÄ Effect: 
‚úî Clients use the access token for authentication. 
‚úî When the access token expires, the refresh token generates a new one instead of logging in again.




3. Configuring Token Expiration in Django
üìå Default Token Lifetimes (SIMPLE_JWT in settings.py)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),  # ‚úÖ Access token expires in 5 minutes
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),  # ‚úÖ Refresh token expires in 1 day
}

üìå Increasing Access Token Lifetime (Example)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),  # ‚úÖ Extends validity to 1 day
}

üöÄ Effect: 
‚úî The access token now remains valid for 1 day, reducing re-authentication overhead.




4. Storing Tokens on the Client
üìå Problem: 
‚úî The server does not store JWT tokens ‚Äî clients must manage authentication.

üìå Solution: 
‚úî Web apps store tokens inside browser local storage. 
‚úî Mobile apps store tokens in secure local storage provided by the platform.

üöÄ Effect: 
‚úî Clients send the stored token in every API request header for authentication.

üìå Example Request Using JWT
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

‚úî Sent in every request to protected endpoints.

üìå How to Logout? 
‚úî Remove the tokens from local storage. 
‚úî No need to call an API ‚Äî JWT tokens are not stored on the server. (Because these tokens are not stored in a database. That's why we're using JSON web tokens.) 




Codes and other notes in this lesson:
loggin endpoint:
127.0.0.1:8000/auth/jwt/create/


POST:
{
	"username": "user1",
	"password": "ILoveDjango"
}



google django rest framework simplejwt : https://django-rest-framework-simplejwt.readthedocs.io/en/latest/




üìå Key Takeaways
‚úî Users authenticate via /auth/jwt/create/ by sending credentials. 
‚úî If valid, Django returns an access and refresh token. 
‚úî Tokens must be stored by the client for future authentication requests. 
‚úî Access tokens expire quickly (~5 minutes), requiring a refresh token to generate a new one. 
‚úî Logging out is handled on the client by deleting stored tokens. 
‚úî Next steps: Securing API endpoints using JWT authentication!

üîó Reference: Django REST Framework Simple JWT Documentation:  https://django-rest-framework-simplejwt.readthedocs.io/en/latest/







Inspecting a JSON Web Token: 
----------------------------
JSON Web Tokens (JWT) are widely used for secure authentication in web applications. A JWT consists of three main components: Header, Payload, and Signature‚Äîeach serving a specific function.

üöÄ JWT Components
‚úî Header ‚Üí Specifies metadata, including the token type (JWT) and the hashing algorithm (HS256). 
‚úî Payload ‚Üí Contains user-related claims (e.g., user ID, expiration time). 
‚úî Signature ‚Üí Ensures data integrity, preventing unauthorized modifications.

üìå Example JWT Structure
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

üöÄ Effect: ‚úî Encapsulates authentication details in a compact, encoded format.




1. Exploring JWTs with jwt.io
üîó JWT Debugger (jwt.io) ‚Üí Allows decoding and inspecting JSON Web Tokens.
üìå Using the Debugger 
‚úî Paste a JWT in the left panel. 
‚úî The decoded structure appears on the right, showing Header, Payload, and Signature.

üìå Example Decoded JWT
json
{
    "typ": "JWT",
    "alg": "HS256"
}
‚úî typ ‚Üí Token type (JWT). ‚úî alg ‚Üí Algorithm used (HS256).

üöÄ Effect: ‚úî Helps visualize how JWT data is structured.




2. Understanding the JWT Payload
‚úî Contains user-specific claims (e.g., user ID, expiration time). 
‚úî Used to identify authenticated users.

üìå Example JWT Payload
json
{
    "token_type": "access",
    "exp": 1712345678,
    "jti": "unique-id-123",
    "user_id": 4
}

‚úî token_type ‚Üí Specifies access or refresh token. 
‚úî exp ‚Üí Expiration timestamp (Unix time). 
‚úî jti ‚Üí Unique identifier for this token. 
‚úî user_id ‚Üí Identifies the authenticated user.

üöÄ Effect: ‚úî The token automatically carries user credentials, eliminating the need for additional lookups.




3. Why Is the Signature Important?
‚úî Prevents token manipulation ‚Äî ensures integrity. 
‚úî Created using a secret key, stored only on the server.

üìå Formula for Signature Generation
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

üöÄ Effect: 
‚úî If a hacker modifies the payload, the signature must be regenerated. 
‚úî Servers reject tokens with mismatched signatures, blocking unauthorized access.

üìå Example Attack Scenario ‚ùå Changing user_id in JWT
json
{
    "user_id": 1  # Trying to change from "4" to "1"
}

üöÄ Outcome: 
‚úî The signature does not match, making the token invalid. 
‚úî Hacker cannot regenerate the correct signature without access to the server's secret key.




üìå Key Takeaways
‚úî JWT consists of Header, Payload, and Signature. 
‚úî Payload contains user-specific claims (e.g., user_id, exp). 
‚úî The signature prevents unauthorized modifications. 
‚úî JWT.io allows debugging and inspecting tokens. 
‚úî Next steps: Using JWTs to secure API endpoints!

















Refreshing Tokens:
------------------
JSON Web Tokens expire after a set duration to enhance security. To maintain access to protected resources, clients must refresh their expired access tokens using a refresh token.

üöÄ Overview of Token Refreshing
‚úî Access Token ‚Üí Short-lived (~5 minutes by default). Used for making authenticated requests. 
‚úî Refresh Token ‚Üí Longer-lived (~1 day by default). Used to generate a new access token. 
‚úî Token Expiration Process ‚Üí If the access token is expired, the client must request a new access token using the refresh token. 
‚úî No Need to Re-login ‚Üí Instead of asking users to enter credentials again, the refresh token renews the session silently.

üöÄ Effect: 
‚úî Users stay authenticated without repeatedly logging in. 
‚úî The system remains secure by ensuring access tokens expire periodically.


1. Accessing the Refresh Endpoint
üìå Client Request (POST /auth/jwt/refresh/) 
‚úî The client sends the refresh token to the server.
json
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

üìå Expected Server Response (200 OK) ‚úî The server returns a new access token.
json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

üöÄ Effect: ‚úî The client can now use the new access token for future API requests.

üìå Refresh Token Endpoint:
http
POST 127.0.0.1:8000/auth/jwt/refresh/




2. Token Expiration & Renewal Process
üìå Scenario: Calling a Protected API With an Expired Token 
‚úî If a request is made with an expired access token, the server responds with:
json
{
    "detail": "Token is invalid or expired."
}

‚úî HTTP Status Code: 401 Unauthorized

üìå How to Fix It? 
‚úî The client must call /auth/jwt/refresh/ with the refresh token. 
‚úî A new access token is issued. 
‚úî The client retries the request using the new access token.

üöÄ Effect: ‚úî Users seamlessly renew authentication without needing to log in again.




3. Configuring Token Expiration in Django
üìå Default Token Expiration Settings (SIMPLE_JWT in settings.py)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),  # ‚úÖ Access tokens expire in 5 minutes
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),  # ‚úÖ Refresh tokens expire in 1 day
}

üìå Extending Access Token Lifetime (Example)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),  # ‚úÖ Keeps access token valid for 1 day
}
üöÄ Effect: ‚úî Reduces the frequency of token renewals, making authentication more user-friendly.

üìå Import Required Modules in settings.py
from datetime import timedelta  # ‚úÖ Enables custom token lifetimes




Notes in this discussion:
127.0.0.1:8000/auth/jwt/refresh


üìå Key Takeaways
‚úî Access tokens expire quickly (~5 minutes) to enhance security. 
‚úî Refresh tokens allow clients to obtain new access tokens without logging in.
‚úî Expired access tokens trigger a 401 Unauthorized error, requiring renewal. 
‚úî Django REST Framework Simple JWT provides configurable token expiration settings. 














Getting the Current User: 
-------------------------

Djoser provides an endpoint for retrieving the authenticated user's details, but requires authentication via an access token.

üöÄ Steps to Retrieve the Current User
‚úî Step 1: Authenticate the user by logging in (POST /auth/jwt/create/). 
‚úî Step 2: Obtain the access token from the login response. 
‚úî Step 3: Send a request to /auth/users/me/ with the access token in the request header. 
‚úî Step 4: The server responds with the user‚Äôs details.

üìå Current User Endpoint (GET /auth/users/me/)http
GET 127.0.0.1:8000/auth/users/me/
Authorization: JWT <access_token>

üöÄ Effect: ‚úî The server returns authenticated user information.

1. Handling Unauthorized Access
üìå Problem: ‚úî If no access token is provided, the server returns a 401 Unauthorized error:
json
{
    "detail": "Authentication credentials were not provided."
}

üìå Solution: ‚úî Include Authorization: JWT <access_token> in the request header.

üöÄ Effect: ‚úî The request is authenticated, allowing access to user details.




2. Adding Authorization Header in Browser (ModHeader Plugin)
üìå Problem: 
‚úî Browsers do not allow adding custom headers by default. 
‚úî A plugin like ModHeader (Chrome) allows modifying headers for API requests.

üìå Steps to Install ModHeader Plugin: 
‚úî Install ModHeader Extension in Chrome. 
‚úî Pin the extension for easy access. 
‚úî Add the following header:

Name: Authorization
Value: JWT <access_token>

üöÄ Effect: ‚úî Requests include authentication tokens automatically.
üìå Important Security Note: ‚úî Remove the authorization header after testing to prevent authentication issues on other websites.




3. Customizing the Response to Include Additional Fields
üìå Problem: ‚úî By default, /auth/users/me/ does not include first & last name.
üìå Solution: ‚úî Extend Djoser‚Äôs UserSerializer to include these fields.

üìå Implementation (core/serializers.py)
from djoser.serializers import UserSerializer as BaseUserSerializer

class UserSerializer(BaseUserSerializer):
    class Meta(BaseUserSerializer.Meta):
        fields = ['id', 'username', 'email', 'first_name', 'last_name']  # ‚úÖ Include additional fields
		
üìå Register the Custom Serializer in settings.py
DJOSER = {
    'SERIALIZERS': {
        'current_user': 'core.serializers.UserSerializer',
    }
}

üöÄ Effect: ‚úî The API now returns first & last name for authenticated users.




4. Testing the Updated Endpoint
üìå Client Request (GET /auth/users/me/) 
‚úî With authentication token in header:
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

‚úî Expected Response:
json
{
    "id": 4,
    "username": "user2",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

üöÄ Effect: ‚úî Users successfully retrieve their personal account details.





codes/notes in this lesson:
127.0.0.1:8000/auth/users/me 


modheader

SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1)
}



core/serializers.py:
from djoser.serializers import UserSerializer as BaseUserSerializer, UserCreateSerializer as BaseUserCreateSerializer

class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password',
                  'email', 'first_name', 'last_name']


class UserSerializer(BaseUserSerializer):
    class Meta(BaseUserSerializer.Meta):
        fields = ['id', 'username', 'email', 'first_name', 'last_name']
		
		
settings.py:
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
        'current_user': 'core.serializers.UserSerializer',
    }
}





üìå Key Takeaways
‚úî Authenticated users retrieve their details via /auth/users/me/. 
‚úî Requests require an access token for authentication. 
‚úî Unauthorized requests (401) must include the Authorization header. 
‚úî Custom serializers allow returning extra fields like first and last name. 
‚úî Remove authorization headers in ModHeader after use for security. 











Getting Current User's Profile:
------------------------------
Now that users can register and authenticate, they need a way to retrieve and update their profile details via an API endpoint.

üöÄ Steps to Implement the Profile API
‚úî Step 1: Define a custom action (me) in CustomerViewSet. 
‚úî Step 2: Retrieve the authenticated user's profile using request.user.id. 
‚úî Step 3: Allow users to update their profile information via PUT. 
‚úî Step 4: Ensure that only authenticated users can access this endpoint.

üìå Current User Profile Endpoint (GET /store/customers/me/)
http
GET 127.0.0.1:8000/store/customers/me/
Authorization: JWT <access_token>

üöÄ Effect: ‚úî The server returns the authenticated user's profile details.




1. Implementing the me Action in CustomerViewSet
üìå Purpose: 
‚úî Retrieves the customer profile linked to the authenticated user. 
‚úî Allows users to update their profile details (phone, birth date, membership).

üìå Implementation (views.py)
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)

        if request.method == 'GET':  # ‚úÖ Retrieve current user's profile
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)

        elif request.method == 'PUT':  # ‚úÖ Update profile details
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
üöÄ Effect: 
‚úî Users can retrieve their profile (GET) or update it (PUT). 
‚úî Ensures only authenticated users can access the endpoint.




2. Implementing the CustomerSerializer
üìå Purpose: 
‚úî Defines which fields are exposed in the profile API. 
‚úî Ensures user_id is read-only, preventing users from associating their profile with another account.

üìå Implementation (serializers.py)
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)  # ‚úÖ Prevents user ID modification

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']
		
üöÄ Effect: ‚úî Users can update only their profile details (phone, birth date, membership).




3. Testing the Profile API

üìå Step 1: Retrieve Current User‚Äôs Profile (GET /store/customers/me/) ‚úî Client Request:
http
Authorization: JWT <access_token>
GET 127.0.0.1:8000/store/customers/me/

‚úî Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}
üöÄ Effect: ‚úî Users successfully retrieve their profile details.

üìå Step 2: Updating the Profile (PUT /store/customers/me/) 
‚úî Client Request:
json
{
    "phone": "9876",
    "birth_date": "1998-05-15",
    "membership": "G"
}

‚úî Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "9876",
    "birth_date": "1998-05-15",
    "membership": "G"
}
üöÄ Effect: ‚úî Users successfully update profile details.

üìå Step 3: Ensuring Unauthorized Users Cannot Access Profile (GET /store/customers/me/ Without Token) 
‚úî Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: ‚úî Users must authenticate before accessing profile details.






codes/notes in this lesson:
The endpoint: 127.0.0.1:8000/store/customers/me


views.py:
from rest_framework.decorators import action


class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
			
serializers.py:
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']    






üìå Key Takeaways
‚úî The /store/customers/me/ endpoint allows authenticated users to retrieve & update their profile. 
‚úî Users must send an access token in the request header for authentication. 
‚úî Only authorized users can modify their profile‚Äîuser_id is read-only. 
‚úî Requests without authentication fail with 401 Unauthorized. 
‚úî Next steps: Implementing permission checks to fully secure the API!











Applying Permissions: 
---------------------
Permissions control who can access API endpoints. By default, Django REST Framework allows unrestricted access (AllowAny), but we can restrict endpoints globally or per view.

üöÄ Types of Permission Classes
‚úî AllowAny ‚Üí Open access (default setting). 
‚úî IsAuthenticated ‚Üí Requires users to be logged in. 
‚úî IsAdminUser ‚Üí Grants access only to admin users. 
‚úî IsAuthenticatedOrReadOnly ‚Üí Authenticated users can modify data, others can only read. 
‚úî Custom Permissions ‚Üí Define custom rules for access control.

üìå Reference: Django REST Framework - Permissions https://www.django-rest-framework.org/api-guide/permissions/

üöÄ Effect: ‚úî Ensures API endpoints remain secure and accessible only to authorized users.

1. Applying Permissions Globally
üìå Purpose: 
‚úî Restricts all API endpoints to authenticated users. 
‚úî Ensures every request must be logged in.

üìå Implementation (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated'  # ‚úÖ Requires authentication globally
    ]
}

üöÄ Effect: 
‚úî All API requests require authentication (except explicitly overridden views). 
‚úî Requests without authentication return 401 Unauthorized.

üìå Example Unauthorized Request (GET /store/products/ Without Token)
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: 
‚úî Anonymous users cannot access any API endpoints.




2. Applying Permissions to Specific Views
üìå Purpose: 
‚úî Restricts access to specific views, overriding global permissions.

üìå Implementation (views.py)
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAuthenticated]  # ‚úÖ Requires login for customer-related actions
	
üöÄ Effect: ‚úî Only authenticated users can interact with customer profiles.




3. Defining Different Permissions for Each Action
üìå Problem: ‚úî Some actions should be public (GET requests) while others require authentication (PUT, POST).

üìå Solution: ‚úî Override get_permissions() in the viewset. 
‚úî Apply different permissions based on the request method.

üìå Implementation (views.py)
from rest_framework.permissions import AllowAny, IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    def get_permissions(self):
        if self.request.method == 'GET':  # ‚úÖ Public access for retrieving customer data
            return [AllowAny()]
        return [IsAuthenticated()]  # ‚úÖ Authentication required for modifying customer data

üöÄ Effect: ‚úî GET requests are open to everyone. 
‚úî POST, PUT, DELETE require authentication.

üìå Example Scenario (GET /store/customers/2/ Without Token) 
‚úî Expected Response (Success):
json
{
    "id": 2,
    "user_id": 5,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

üìå Example Scenario (PUT /store/customers/2/ Without Token) 
‚úî Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: ‚úî Ensures public read access but restricts modifications to authenticated users.




4. Applying Permissions to Specific Actions
üìå Purpose: ‚úî Ensures fine-grained access control for individual actions.

üìå Implementation (views.py)
from rest_framework.decorators import action

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ‚úÖ Restricts access to authenticated users
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)

üöÄ Effect: 
‚úî Ensures only authenticated users can retrieve or modify their profile.

üìå Example Scenario (GET /store/customers/me/ Without Token) 
‚úî Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}
üöÄ Effect: ‚úî Secures user profile endpoints, preventing anonymous access.








Codes/notes in this lesson:

Django rest framework website:  https://www.django-rest-framework.org/ --> API Guide --> Permissions


settings.py:

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False,
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
	'DEFAULT_PERMISSION_CLASSES': [
		'rest_framework.permissions.IsAuthenticated'
	]
}


views.py:
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAuthenticated]
	
	def get_permissions(self):
		if self.request.method == 'GET':
			return [AllowAny()]
		return [IsAuthenticated()]


    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)







üìå Key Takeaways
‚úî Permissions control access to API endpoints. 
‚úî Global permissions (DEFAULT_PERMISSION_CLASSES) apply across all views. 
‚úî View-specific permissions override global settings. 
‚úî Different actions (GET, POST, PUT) can have customized permissions. 
‚úî Next steps: Creating custom permission classes for advanced access control!












Applying Custom Permissions:
----------------------------

Django REST Framework provides built-in permissions like IsAuthenticated and IsAdminUser, but sometimes we need fine-grained control‚Äîsuch as allowing admins to modify data while letting anonymous users view it.

In this case, we create a custom permission class: IsAdminOrReadOnly.

üöÄ Steps to Implement Custom Permissions
‚úî Step 1: Define a new permission class (IsAdminOrReadOnly). 
‚úî Step 2: Apply it to specific viewsets (Products, Collections, Customers). 
‚úî Step 3: Ensure admin users can modify, while anonymous users can only view. 
‚úî Step 4: Override permissions for special cases (e.g., user profiles).

üìå Reference: Django REST Framework - Permissions

1. Creating a Custom Permission Class
üìå Purpose: 
‚úî Admins should be able to modify data. 
‚úî Everyone (including anonymous users) should be able to read data.

üìå Implementation (permissions.py)
from rest_framework import permissions

class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:  # ‚úÖ Allows GET, HEAD, OPTIONS requests for everyone
            return True
        return bool(request.user and request.user.is_staff)  # ‚úÖ Only admins can modify data
		
üöÄ Effect: 
‚úî GET, HEAD, OPTIONS ‚Üí Open to everyone. 
‚úî POST, PUT, DELETE ‚Üí Restricted to admin users.

üìå Using Django REST Framework‚Äôs SAFE_METHODS
permissions.SAFE_METHODS  # Contains ['GET', 'HEAD', 'OPTIONS']

üöÄ Effect: 
‚úî Ensures read-only methods are unrestricted, while modifying data requires admin access.




2. Applying Custom Permissions to the Product API
üìå Purpose: ‚úî Anyone can view products, but only admins can modify them.

üìå Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [IsAdminOrReadOnly]  # ‚úÖ Enforce custom permission
	
üöÄ Effect: 
‚úî GET /store/products/ ‚Üí Open to everyone. 
‚úî POST /store/products/ ‚Üí Restricted to admin users. 
‚úî PUT /store/products/{id}/ ‚Üí Restricted to admin users.

üìå Example Unauthorized Request (POST /store/products/ Without Admin Access)
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî Prevents unauthorized users from modifying product data.




3. Securing Collections Endpoint
üìå Purpose: ‚úî Apply the same rules for managing collections.

üìå Implementation (views.py)
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer
    permission_classes = [IsAdminOrReadOnly]  # ‚úÖ Apply custom permission

üöÄ Effect: 
‚úî Ensures consistency across product and collection endpoints.




4. Handling Customer API Permissions
üìå Problem: ‚úî Customers should only manage their own profile‚Äîadmins should manage all users.

üìå Solution: 
‚úî Use IsAdminUser for managing customers in general. 
‚úî Override permissions for the /store/customers/me/ endpoint.

üìå Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ‚úÖ Admins can manage customers

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ‚úÖ Authenticated users can modify their own profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
üöÄ Effect: 
‚úî Admins manage all customers (GET /store/customers/). 
‚úî Authenticated users manage their own profile (GET /store/customers/me/).

üìå Example Unauthorized Request (GET /store/customers/me/ Without Token) 
‚úî Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: ‚úî Prevents anonymous users from accessing private profile data.








codes/notes learned in this lesson:
permissions.py:
from rest_framework import permissions

class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:
            return True
        return bool(request.user and request.user.is_staff)



views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
		
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(
        products_count=Count('products')).all()
    serializer_class = CollectionSerializer
    permission_classes = [IsAdminOrReadOnly]

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)



class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






üìå Key Takeaways
‚úî Custom permissions allow fine-grained control over API access. 
‚úî Admins can modify products & collections, while anonymous users can only view them. 
‚úî Customer data is secured ‚Äî admins manage all users, while users handle their own profiles. 
‚úî Django REST Framework‚Äôs permission system ensures API security. 
‚úî Next steps: Implementing role-based access control (RBAC) for even better security!










Applying Model Permissions:
---------------------------
Django model permissions provide fine-grained access control based on user groups and assigned permissions. This ensures that only authorized users can perform specific actions on model objects.

üöÄ Steps to Implement Model-Based Permissions
‚úî Step 1: Assign relevant permissions to user groups (e.g., Customer Service). 
‚úî Step 2: Use DjangoModelPermissions to enforce model-level access control. 
‚úî Step 3: Extend permissions to handle custom scenarios (e.g., allowing read-only access for anonymous users).

üìå Reference: Django REST Framework - Permissions https://www.django-rest-framework.org/api-guide/permissions/

üöÄ Effect: ‚úî Ensures that users must have specific model-level permissions to modify data.




1. Understanding DjangoModelPermissions
üìå Purpose: 
‚úî Requires authentication and specific model permissions for CRUD operations.

üìå Default Permission Mapping (DjangoModelPermissions):

HTTP Method	   Required Permission
GET	           No permission required
POST	       add_<model>
PUT/PATCH	   change_<model>
DELETE	       delete_<model>

üöÄ Effect: ‚úî Authenticated users must have the appropriate permission to modify data.

üìå Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [DjangoModelPermissions]  # ‚úÖ Enforces model-level permissions
	
üöÄ Effect: ‚úî Users must be logged in and have model permissions to modify customer records.

üìå Example Unauthorized Request (POST /store/customers/ Without Permission)
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî Users cannot create or update customers unless explicitly granted permissions.




2. Assigning Model Permissions to User Groups
üìå Problem: 
‚úî The default implementation allows only admin users to modify customers. 
‚úî Users in the "Customer Service" group should also manage customers.

üìå Solution: 
‚úî Assign specific model permissions to the Customer Service group via Django Admin.

üìå Steps in Django Admin: 
‚úî Navigate to Admin ‚Üí Users ‚Üí John Smith. 
‚úî Assign Customer Service group to the user. 
‚úî Ensure the group has add_customer, change_customer, delete_customer permissions. 
‚úî Save changes.

üöÄ Effect: ‚úî Customer Service representatives can now manage customer records.

üìå Testing the Changes 
‚úî Before Removing Customer Service Group:
John Smith can create, update, and delete customers. 

‚úî After Removing Customer Service Group:
John Smith can only view customer records (GET requests).

üöÄ Effect: ‚úî User permissions are dynamically enforced based on group assignments.




3. Creating a Custom Model Permission Class
üìå Problem: 
‚úî The default DjangoModelPermissions does not enforce view permissions for GET requests. 
‚úî Anonymous users should NOT see customer records.

üìå Solution: 
‚úî Create FullDjangoModelPermissions, extending DjangoModelPermissions. 
‚úî Ensure view permissions (view_<model>) are required for GET requests.

üìå Implementation (permissions.py)
from rest_framework import permissions

class FullDjangoModelPermissions(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET'] = ['%(app_label)s.view_%(model_name)s']  # ‚úÖ Requires "view" permission for read access
		
üöÄ Effect: ‚úî Only authorized users with "view" permission can access customer data.

üìå Applying Custom Permissions (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [FullDjangoModelPermissions]  # ‚úÖ Enforces view permission for `GET`
	
üöÄ Effect: ‚úî Users must have "view_customer" permission to retrieve customer records.

üìå Example Unauthorized Request (GET /store/customers/ Without Permission)
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî Prevents unauthorized users from accessing customer records.




4. Using DjangoModelPermissionsOrAnonReadOnly
üìå Purpose: 
‚úî Extends DjangoModelPermissions but allows anonymous users read-only access.

üìå Implementation
permission_classes = [DjangoModelPermissionsOrAnonReadOnly]  # ‚úÖ Read-only for anonymous users

üöÄ Effect: 
‚úî Anonymous users can view data (GET requests) but cannot modify anything.

üìå Example Scenario (GET /store/customers/ Without Token) 
‚úî Expected Response (Success):
json
[
    {
        "id": 2,
        "user_id": 5,
        "phone": "1234",
        "birth_date": "2000-01-01",
        "membership": "B"
    }
]

üöÄ Effect: ‚úî Anonymous users have read-only access but cannot modify records.




5. Final Implementation for Customer API
üìå Solution: 
‚úî Use admin-only access for managing customers. 
‚úî Restrict /store/customers/me/ to authenticated users.

üìå Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ‚úÖ Restricts access to admin users

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ‚úÖ Only authenticated users manage their own profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
üöÄ Effect: 
‚úî Admins manage all customers (GET /store/customers/). 
‚úî Authenticated users manage their own profile (GET /store/customers/me/).



codes learned in this lesson:
permission_classes = [DjangoModelPermissions]

permissions.py:
class FullDjangoModelPermissions(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET'] = ['%(app_label)s.view_%(model_name)s']
		
			
views.py:
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [FullDjangoModelPermissions]

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






üìå Key Takeaways
‚úî Django model permissions ensure users can modify data only if they have explicit permissions. 
‚úî Assigning users to groups dynamically controls access. 
‚úî Extending DjangoModelPermissions enables fine-grained permission handling. 
‚úî Using DjangoModelPermissionsOrAnonReadOnly allows read-only access for anonymous users. 











Quick QnA Session:
------------------
So the Django Model permission, refers the permission based on the user_groups in and not by the permission_classes parameter on each view_set. Is my understanding, correct?

Almost! Let me clarify.
Django Model Permissions work in combination with both:
1. User Groups & Assigned Permissions ‚Üí Permissions are granted based on the user's membership in groups and the specific model permissions assigned to those groups.
2. permission_classes in ViewSets ‚Üí The permission class determines when and how those model permissions are enforced.

Here's how it works:
 - Model permissions (add_<model>, change_<model>, delete_<model>, view_<model>) are assigned to individual users or groups in Django Admin.
 - If a user belongs to a group (e.g., "Customer Service") that has change_customer permission, Django allows that user to modify customers.
 - Viewsets use permission_classes to enforce model permissions globally. 
   For example:
   permission_classes = [DjangoModelPermissions]

This ensures that only users with the right model permissions can perform actions on the API.

üöÄ Key Takeaway: 
‚úî Django Model Permissions reference user groups and assigned model-level permissions. 
‚úî But permission enforcement depends on permission_classes in each ViewSet. 
‚úî If permission_classes = [AllowAny], model permissions are ignored, and anyone can access the API! 
‚úî If permission_classes = [DjangoModelPermissions], then only users with assigned permissions can modify models.

Your understanding was close, but it‚Äôs both the user‚Äôs assigned permissions AND the viewset‚Äôs permission_classes that determine access.






















Applying Custom Model Permissions:
----------------------------------
Django allows us to define custom permissions within models, ensuring that specific users can access certain features. In this case, we create and apply a custom permission (view_history) for accessing customer history.

üöÄ Steps to Implement Custom Model Permissions
‚úî Step 1: Define custom permissions in the model (view_history). 
‚úî Step 2: Apply migrations to register the permission in the database. 
‚úî Step 3: Create a custom permission class (ViewCustomerHistoryPermission). 
‚úî Step 4: Apply the permission in CustomerViewSet. 
‚úî Step 5: Grant permission via Django Admin and test the behavior.

üìå Reference: Django REST Framework - Permissions

üöÄ Effect: ‚úî Ensures only authorized users can view customer history.

1. Defining a Custom Model Permission
üìå Purpose: 
‚úî The customer model should have a "view history" permission.

üìå Implementation (models.py)
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
        permissions = [
            ('view_history', 'Can view history')  # ‚úÖ Defines custom permission
        ]
üöÄ Effect: 
‚úî Registers a new permission called view_history. 
‚úî Allows us to grant access to specific users or groups.

üìå Applying Migrations
python manage.py makemigrations
python manage.py migrate

üöÄ Effect: ‚úî The view_history permission is now stored in the database.




2. Creating a Custom Permission Class
üìå Purpose: 
‚úî Restricts access to customer history only to users with the view_history permission.

üìå Implementation (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ‚úÖ Enforces permission check
		
üöÄ Effect: 
‚úî Users must have view_history permission to access customer history.




3. Creating the history Action in CustomerViewSet
üìå Purpose: 
‚úî Adds an API endpoint (GET /store/customers/{id}/history/) for retrieving customer history.

üìå Implementation (views.py)
from rest_framework.decorators import action
from rest_framework.response import Response

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ‚úÖ Admin users manage customers

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ‚úÖ Restricts access to users with `view_history` permission
    def history(self, request, pk):
        return Response('ok')

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ‚úÖ Allows authenticated users to manage their profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
üöÄ Effect: ‚úî Users without view_history permission cannot access the endpoint.

üìå Testing the Endpoint (GET /store/customers/1/history/) 
‚úî Expected Response (403 Forbidden for unauthorized users):
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: 
‚úî Prevents users without view_history permission from accessing customer history.




4. Granting Permissions via Django Admin
üìå Problem: ‚úî John Smith cannot access the history endpoint because he lacks the view_history permission.
üìå Solution: ‚úî Assign view_history permission to John Smith via Django Admin.
üìå Steps in Django Admin: 
‚úî Navigate to Admin ‚Üí Users ‚Üí John Smith. 
‚úî Assign store.view_history permission manually. 
‚úî Save changes.

üöÄ Effect: ‚úî John Smith now has access to /store/customers/{id}/history/.

üìå Testing Access After Permission Assignment 
‚úî Expected Response (200 OK):
json
"ok"

üöÄ Effect: 
‚úî Permission enforcement works as expected.

üìå Best Practice: Use Groups Instead of Ad-Hoc Permissions 
‚úî Instead of manually assigning permissions, create a Customer Service group. 
‚úî Assign view_history to the group, then add users to the group. 
‚úî Groups allow filtering by role, making management easier.

üöÄ Effect: ‚úî Ensures structured permission management, avoiding chaos in large projects.





codes learned in this lesson:

models.py:
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
        permissions = [
            ('view_history', 'Can view history')
        ]


permissions.py:
class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # <app_label>.<permission_codename>


views.py:
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])
    def history(self, request, pk):
        return Response('ok')

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






üìå Key Takeaways
‚úî Custom model permissions (view_history) allow fine-grained access control. 
‚úî Only users with explicit permission can access restricted endpoints (GET /store/customers/{id}/history/). 
‚úî Permissions should be managed via groups instead of individual users. 
‚úî Next steps: Implementing advanced role-based access control (RBAC) across the API!










Quick QnA Session:
------------------

üöÄ Understanding Groups and Model Permissions in Django
Django allows us to control user access using Groups (assigned in the admin panel) and Model Permissions (defined in the code).

Think of Groups as roles (e.g., ‚ÄúCustomer Service,‚Äù ‚ÄúManagers‚Äù). 
Think of Model Permissions as rules about what users in those roles can do.

Now, let‚Äôs go through both concepts separately, then see how they work together.

1. Groups in Django Admin
üìå What are Groups? 
‚úî Groups let us manage permissions for multiple users at once. 
‚úî Instead of manually assigning permissions to each user, we create a group (e.g., ‚ÄúCustomer Service‚Äù) and assign permissions to that group. 
‚úî Users added to that group automatically inherit those permissions.

üìå Steps to Assign Groups in Django Admin: 
‚úî Navigate to Admin ‚Üí Groups. 
‚úî Click ‚ÄúAdd Group‚Äù and name it (e.g., Customer Service). 
‚úî Assign permissions to the group (e.g., add_customer, change_customer, view_customer). 
‚úî Save the group. 
‚úî Go to Admin ‚Üí Users and add users (e.g., ‚ÄúJohn Smith‚Äù) to the group.

üöÄ Effect: ‚úî Now, everyone in the ‚ÄúCustomer Service‚Äù group can manage customers without needing individual permission assignments.

üìå Example Scenario:
John Smith belongs to ‚ÄúCustomer Service‚Äù ‚Üí He inherits the ability to manage customers.
Alice is NOT in any group ‚Üí She cannot manage customers unless manually assigned permissions.




2. Model Permissions in Code
üìå What are Model Permissions? 
‚úî Model permissions define what actions can be performed on a database model (e.g., Customer). 
‚úî These are assigned at the model level in Django‚Äôs code. 
‚úî They determine what users (or groups) can do‚Äîview, add, edit, or delete records.

üìå Defining Model Permissions in Code (models.py)
class Customer(models.Model):
    class Meta:
        permissions = [
            ('view_history', 'Can view history')  # ‚úÖ Defines custom permission
        ]
		
üöÄ Effect: 
‚úî A new permission (‚Äúview_history‚Äù) is now available in the admin panel. 
‚úî Admins can assign this permission to specific users or groups.

üìå Applying Migrations to Store Permissions in the Database
python manage.py makemigrations
python manage.py migrate

üöÄ Effect: ‚úî Permissions are now available in the admin panel for assignment.




3. Applying Model Permissions in Code (Checking Access)
üìå Now that the permission exists, we need to enforce it in our API. 
‚úî This is done using custom permission classes.

üìå Example Custom Permission Class (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ‚úÖ Checks user permission
		
üöÄ Effect: ‚úî Users must have the ‚Äúview_history‚Äù permission to access the endpoint.

üìå Using This Permission in the API (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ‚úÖ Restricts access
    def history(self, request, pk):
        return Response('ok')
		
üöÄ Effect: ‚úî The API checks whether the user has view_history permission before allowing access.




4. Connecting Groups and Model Permissions
üìå How do groups and model permissions work together? 
‚úî Groups are used in Django Admin to manage permissions for multiple users at once. 
‚úî Model Permissions are defined in code, allowing us to restrict API access programmatically.

üìå Example Process: 
1. Create ‚ÄúCustomer Service‚Äù group in Admin. 
2. Assign ‚Äúview_history‚Äù permission to the group. 
3. Add users (e.g., John Smith) to the group. 
4. API checks if a user has view_history permission when accessing /store/customers/{id}/history/.

üìå Testing Results: 
‚úî Before John is added to the group: ‚Üí He cannot access customer history (403 Forbidden). 
‚úî After John is added to the group: ‚Üí He can access customer history (200 OK).

üöÄ Effect: 
‚úî Groups manage who gets permissions. 
‚úî Model permissions enforce API restrictions in code.


üìå Key Takeaways
‚úî Groups (assigned in Django Admin) organize users and permissions. 
‚úî Model Permissions (defined in code) control API access. 
‚úî Groups inherit model permissions‚Äîusers in a group automatically get assigned permissions. 
‚úî Django Admin makes permission management scalable. 
‚úî Next steps: Implementing role-based access control (RBAC) with Django‚Äôs permission system!
			
			
			
			
			
			
			
			
			
			
Crystal clear explanation of permissions:
-----------------------------------------

üöÄ Do We Have Two Types of Permissions?
‚úî Yes! There are TWO types of permissions in Django:

1. Admin Interface Permissions ‚Üí These are assigned manually via Django Admin. 
2. Backend (Code-Based) Permissions ‚Üí These are defined in code and enforced via the API.

üí° Both types work together ‚Äî Admin permissions control what users can do, and Backend permissions enforce rules in the API.



1. Admin Interface Permissions
‚úî These are manually assigned in Django Admin. 
‚úî No coding required ‚Äî you just click buttons in the Admin interface.

üìå Where to Find Them? 
‚úî Navigate to Admin ‚Üí Users ‚Üí Select a user. 
‚úî Assign permissions or groups to the user. 
‚úî Save changes.

üìå How Do They Work? 
‚úî Users get access to models (database objects) based on permissions like:
add_customer ‚Üí Allows creating a customer.
change_customer ‚Üí Allows editing a customer.
delete_customer ‚Üí Allows removing a customer.
view_customer ‚Üí Allows reading customer data.

üöÄ Example Scenario: 
1. You create a ‚ÄúCustomer Service‚Äù group in Django Admin. 
2. You assign permissions to manage customers to that group. 
3. You add John Smith to the Customer Service group. 
4. John Smith can now create, update, and delete customer records!

üí° Why Use Groups? 
‚úî Instead of manually assigning permissions to every user, you group users into roles (Customer Service, Managers, etc.), and permissions apply to everyone in the group.




2. Backend (Code-Based) Permissions
‚úî These are defined in code and enforced via API rules. 
‚úî Used to protect API endpoints (e.g., only authenticated users can access certain routes).

üìå How Do We Define Permissions in Code? 
‚úî Permissions are defined in Django models (models.py) or as custom permission classes (permissions.py).

üìå Example: Defining Permissions in a Model (models.py)
class Customer(models.Model):
    class Meta:
        permissions = [
            ('view_history', 'Can view history')  # ‚úÖ Custom model permission
        ]
		
‚úî This creates a new permission (view_history). 
‚úî Admin users can now assign this permission to specific users or groups.

üìå Example: Enforcing Permission in Code (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ‚úÖ Checks if the user has the right permission
		
‚úî This checks if the user has view_history permission before allowing access to certain API routes.


üìå Example: Applying the Custom Permission in API (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ‚úÖ Enforces custom permission
    def history(self, request, pk):
        return Response('ok')
		
üöÄ Effect: ‚úî Users must have the ‚Äúview_history‚Äù permission to access /store/customers/{id}/history/.

üìå Testing Results: 
‚úî Before John is assigned view_history: ‚Üí He cannot access /store/customers/{id}/history/ (403 Forbidden). 
‚úî After assigning view_history: ‚Üí He can access /store/customers/{id}/history/ (200 OK).




3. How Admin & Backend Permissions Work Together
‚úî Admin Permissions ‚Üí Determine who has access (groups & individual users). 
‚úî Backend Permissions ‚Üí Enforce rules via API (e.g., allow only authenticated users).

üìå How the System Works End-to-End? 
1. Define permissions in models (models.py) ‚Üí (e.g., view_history). 
2. Create a group in Django Admin ‚Üí (e.g., ‚ÄúCustomer Service‚Äù). 
3. Assign permissions to the group in Admin ‚Üí (e.g., view_history). 
4. Add users to the group ‚Üí (e.g., John Smith). 
5. API checks permissions using code (permissions.py).

üöÄ Final Outcome: ‚úî Users must be in the right group AND pass API rules to access protected data.


üìå Key Takeaways
‚úî Django has TWO types of permissions: Admin-based and Backend (code-based). 
‚úî Admin permissions are manually assigned via Django Admin. 
‚úî Backend permissions are defined in code and enforced via API rules. 
‚úî Best practice: Use Django groups to manage permissions instead of individual user assignments. 
‚úî Next steps: Implementing role-based access control (RBAC) for large-scale applications!














Designing and Building the Orders API:
--------------------------------------
In this section, we'll take our application to the next level and build the orders API. Once again, this is a great opportunity for you to get your hands dirty in code and practice a lot of stuff you have learned so far. So let's jump in and get started.

 
 
 
Designing the API:
------------------
We are building an API for managing orders in an e-commerce application. This endpoint will allow users to create, view, update, and delete orders, with permissions varying based on user roles.

üöÄ Orders API Overview
‚úî Authenticated users can create orders by providing their cart ID. 
‚úî Users can view their own orders, while admins can access all orders. 
‚úî Users can update or delete their orders, but only if permitted.

üìå Orders Endpoint Mapping:

HTTP Method	       URL	      Request Body	    Response
POST	        /orders/	   {cartID}	     order (created)
GET	            /orders/	     {}	         order[] (list of orders)
GET	            /orders/1	     {}	         order (single order)
PATCH	        /orders/1	     {}	        (update order details)
DELETE	        /orders/1	     {}	        (delete order)

üöÄ Effect: 
‚úî Users can create, view, and manage orders based on authentication & permissions.




1. Creating an Order (POST /orders/)
üìå Purpose: 
‚úî Users submit their cart ID to create a new order. 
‚úî The system automatically assigns the authenticated user using their JWT token.

üìå Request Example
json
{
    "cartID": 12
}

üìå Expected Response (201 Created)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "pending",
    "created_at": "2025-05-09T13:45:00Z"
}

üöÄ Effect: ‚úî A new order is created for the authenticated user.

2. Viewing Orders (GET /orders/)
üìå Permission-Based Access: 
‚úî Regular users ‚Üí Can only view their own orders. 
‚úî Admins ‚Üí Can view all orders.

üìå Request Example (GET /orders/) 
‚úî No request body needed ‚Äî only authentication is required.

üìå Expected Response (200 OK) 
‚úî If regular user (GET /orders/)
json
[
    {
        "id": 2,
        "cart_id": 7,
        "status": "shipped",
        "created_at": "2025-05-08T12:30:00Z"
    },
    {
        "id": 5,
        "cart_id": 12,
        "status": "pending",
        "created_at": "2025-05-09T13:45:00Z"
    }
]

‚úî If admin (GET /orders/)
json
[
    {
        "id": 1,
        "user_id": 3,
        "cart_id": 6,
        "status": "delivered"
    },
    {
        "id": 2,
        "user_id": 4,
        "cart_id": 7,
        "status": "shipped"
    },
    {
        "id": 5,
        "user_id": 4,
        "cart_id": 12,
        "status": "pending"
    }
]

üöÄ Effect: ‚úî Users can see their own orders, while admins can view all orders.





3. Viewing a Specific Order (GET /orders/1)
üìå Rules: 
‚úî Regular users ‚Üí Can only view their own orders. 
‚úî Admins ‚Üí Can view any order.

üìå Expected Response (200 OK)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "pending",
    "created_at": "2025-05-09T13:45:00Z"
}

üöÄ Effect: ‚úî Users can see order details, but only for their own orders unless they are admins.




4. Updating an Order (PATCH /orders/1)
üìå Purpose: 
‚úî Allows order status updates (e.g., processing ‚Üí shipped ‚Üí delivered). 
‚úî Restricted to authenticated users. 
‚úî Admins can update any order.

üìå Request Example (PATCH /orders/1)
json
{
    "status": "shipped"
}

üìå Expected Response (200 OK)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "shipped",
    "created_at": "2025-05-09T13:45:00Z"
}

üöÄ Effect: 
‚úî Orders can be updated, but only by users with correct permissions.




5. Deleting an Order (DELETE /orders/1)
üìå Rules: 
‚úî Users can delete their own orders. 
‚úî Admins can delete any order.

üìå Expected Response (204 No Content) 
‚úî Order is successfully deleted.

üöÄ Effect: ‚úî Users can remove their own orders, while admins can manage all orders.




üìå Key Takeaways
‚úî Users create orders by sending their cart ID. 
‚úî Regular users can only view their own orders ‚Äî admins can access all orders. 
‚úî Orders can be updated based on permissions. 
‚úî Admins can delete any order, users can delete their own. 
‚úî Next steps: Implementing the actual API endpoints in Django!













Getting the Orders:
-------------------

We are starting with retrieving orders from the database before handling creation, updates, and deletions. This ensures we build a strong foundation before dealing with more complex logic.

üöÄ Steps to Implement Order Retrieval
‚úî Step 1: Define serializers to format order and order item data. 
‚úî Step 2: Create a viewset (OrderViewSet) to handle order retrieval. 
‚úî Step 3: Register the endpoint in urls.py. 
‚úî Step 4: Test the endpoint by manually adding order data to the database. 
‚úî Step 5: Ensure order items are nested within orders, including product details.

üìå Orders Endpoint:
http
GET /orders/      ‚Üí Retrieve all orders  
GET /orders/{id}/ ‚Üí Retrieve a single order  

üöÄ Effect: ‚úî Users can retrieve orders, including related order items and product details.



1. Creating the Order Serializer
üìå Purpose: 
‚úî The OrderSerializer formats order data, including nested order items.

üìå Implementation (serializers.py)
from rest_framework import serializers
from store.models import Order, OrderItem

class OrderSerializer(serializers.ModelSerializer):
    items = serializers.SerializerMethodField()  # ‚úÖ Retrieves order items

    class Meta:
        model = Order
        fields = ['id', 'customer', 'placed_at', 'payment_status', 'items']

    def get_items(self, obj):
        return OrderItemSerializer(obj.items.all(), many=True).data  # ‚úÖ Ensures order items are nested
		
üöÄ Effect: 
‚úî Orders now include nested order items when retrieved via API.

üìå Expected Response (GET /orders/)
json
[
    {
        "id": 2,
        "customer": 3,
        "placed_at": "2021-09-01",
        "payment_status": "P",
        "items": [
            {
                "id": 5,
                "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
                "quantity": 1,
                "unit_price": 1000
            },
            {
                "id": 6,
                "product": {"id": 2, "title": "Mouse", "unit_price": 50},
                "quantity": 2,
                "unit_price": 50
            }
        ]
    }
]

üöÄ Effect: 
‚úî Orders include related order items and product details.




2. Creating the OrderItem Serializer
üìå Purpose: 
‚úî The OrderItemSerializer formats each order item with nested product details.

üìå Implementation (serializers.py)
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()  # ‚úÖ Ensures nested product details

    class Meta:
        model = OrderItem
        fields = ['id', 'product', 'unit_price', 'quantity']
		
üöÄ Effect: 
‚úî Each order item contains detailed product information.

üìå Example Nested Order Item Response
json
{
    "id": 5,
    "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
    "quantity": 1,
    "unit_price": 1000
}
üöÄ Effect: ‚úî The API returns complete order details, reducing extra API calls.




3. Implementing the Order ViewSet
üìå Purpose: 
‚úî Handles retrieving orders, including user-based access restrictions.

üìå Implementation (views.py)
from rest_framework.viewsets import ModelViewSet
from store.models import Order
from store.serializers import OrderSerializer

class OrderViewSet(ModelViewSet):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer

		
üöÄ Effect: 
‚úî Users can retrieve orders without authentication checks (permissions will be added later).

üìå Testing Order Retrieval 
‚úî Request ‚Üí GET /orders/ 
‚úî Expected Response ‚Üí List of orders with nested order items & product details




4. Registering the Orders Endpoint

üìå Implementation (urls.py)
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

üöÄ Effect: 
‚úî The API now supports order retrieval (GET /orders/).




5. Testing Orders API with Seed Data

üìå Setting Up Test Orders 
‚úî Open PostgreSQL Query Console and insert sample orders manually:
sql
INSERT INTO store_order (placed_at, payment_status, customer_id)
VALUES ('2021-09-01', 'P', 3);

INSERT INTO store_orderitem (order_id, product_id, quantity, unit_price)
VALUES (2, 1, 1, 1000), (2, 2, 2, 50);

üöÄ Effect: ‚úî Orders exist in the database for API testing.

üìå Verifying API Response (GET /orders/) 
‚úî Expected JSON Output:
json
[
    {
        "id": 2,
        "customer": 3,
        "placed_at": "2021-09-01",
        "payment_status": "P",
        "items": [
            {
                "id": 5,
                "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
                "quantity": 1,
                "unit_price": 1000
            },
            {
                "id": 6,
                "product": {"id": 2, "title": "Mouse", "unit_price": 50},
                "quantity": 2,
                "unit_price": 50
            }
        ]
    }
]

üöÄ Effect: ‚úî Users can successfully retrieve orders via API.






Codes in this lesson:
serializers.py:
class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id', 'customer', 'placed_at', 'payment_status', 'items']
		
				
views.py:
class OrderViewSet(ModelViewSet):
	queryset = Order.objects.all()
	serializer_class = OrderSerializer

					
urls.py:
router.register('orders', views.OrderViewSet)


serializers.py:
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()

    class Meta:
        model = OrderItem
        fields = ['id', 'product', 'unit_price', 'quantity']







üìå Key Takeaways
‚úî Orders include nested order items and product details. 
‚úî Admins see all orders, while users only see their own. 
‚úî The API handles authentication & permissions properly. 












Applying Permissions:
---------------------
Right now, anyone (including anonymous users) can access the orders endpoint. This is a security issue. 
We need to ensure that: 
‚úî Only authenticated users can access orders. 
‚úî Regular users can only see their own orders. 
‚úî Admins can access all orders.

üöÄ Steps to Implement Order Permissions
‚úî Step 1: Restrict order access to authenticated users (IsAuthenticated). 
‚úî Step 2: Ensure only admins see all orders, while regular users see their own orders. 
‚úî Step 3: Register a proper basename in the URL configuration. 
‚úî Step 4: Handle cases where a user does not have a customer record.

üìå Orders Endpoint Rules:
User Type	      Can Access All Orders?	Can Access Own Orders?
Admin	               ‚úÖ Yes	                 ‚úÖ Yes
Regular User	        ‚ùå No	                 ‚úÖ Yes
Anonymous	            ‚ùå No	                 ‚ùå No

üöÄ Effect: ‚úî Orders are only accessible to authenticated users, with different rules for admins vs regular users.




1. Restricting Access to Authenticated Users
üìå Problem: 
‚úî Currently, anyone (even anonymous users) can view orders. 
‚úî We need to restrict access to only logged-in users.

üìå Solution: Apply IsAuthenticated Globally (views.py)
from rest_framework.permissions import IsAuthenticated
from store.models import Order
from store.serializers import OrderSerializer

class OrderViewSet(ModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]  # ‚úÖ Only authenticated users can access orders
	
üöÄ Effect: 
‚úî Anonymous users can no longer access orders. 
‚úî If a user is not authenticated, they get 401 Unauthorized.

üìå Testing (GET /orders/ Without Authentication) 
‚úî Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

üöÄ Effect: 
‚úî Unauthenticated users are blocked from accessing the endpoint.




2. Ensuring Admins See All Orders, Regular Users See Their Own
üìå Problem: 
‚úî Admins should see all orders, but regular users should only see their own. 
‚úî Right now, everyone sees all orders, which is incorrect.

üìå Solution: Override get_queryset() to Filter Orders (views.py)
class OrderViewSet(ModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:  # ‚úÖ Admins see all orders
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get_or_create(user_id=user.id)  # ‚úÖ Ensure user has a customer record
        return Order.objects.filter(customer_id=customer_id)  # ‚úÖ Regular users see only their orders
		
üöÄ Effect: 
‚úî Admins see all orders, while regular users only see their own orders.

üìå Testing Access Control 
‚úî Regular User (GET /orders/) ‚Üí Sees only their own orders. 
‚úî Admin (GET /orders/) ‚Üí Sees all orders.




3. Setting the basename in URL Configuration
üìå Problem: 
‚úî Because we overrode get_queryset(), Django cannot infer the correct view name (orders-list, orders-detail). 
‚úî This leads to errors in the API.

üìå Solution: Explicitly Set basename in urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet, basename='orders')  # ‚úÖ Explicitly setting `basename`

urlpatterns = [
    path('', include(router.urls)),
]

üöÄ Effect: 
‚úî The API can correctly generate names for endpoints (orders-list, orders-detail).

üìå Testing API ‚úî If the basename was missing, we‚Äôd get an error like:
"Base name argument not specified"

üöÄ Effect: ‚úî API now works correctly without errors.




4. Handling Missing Customer Records Gracefully
üìå Problem: 
‚úî If a user does not have a customer record, get_queryset() will fail. 
‚úî The get() method expects exactly one result, but if the customer record is missing, it throws an exception.

üìå Solution: Use get_or_create() to Avoid Errors (views.py)

python
(customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)

üöÄ Effect: ‚úî If the user does not have a customer profile, a new record is created without breaking the system.

üìå Testing Edge Case (User Without a Customer Record) 
‚úî Before Fix ‚Üí Customer matching query does not exist. 
‚úî After Fix ‚Üí API still works without errors.

üí° Issue With get_or_create(): 
‚úî This solution automatically creates customer profiles when a user accesses their orders. 
‚úî This violates Command Query Separation ‚Üí The system is modifying data while retrieving it.

üìå A Better Approach (Fixing Command Query Separation) 
‚úî Instead of automatically creating a customer record, return an empty result if the user has no profile.



Codes in this lesson:
in the OrderViewSet class ==> permission_classes = [IsAuthenticated]

class OrderViewSet(ModelViewSet):
	serializer_class = OrderSerializer
	permission_classes = [IsAuthenticated]
	

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)


urls.py:
router.register('orders', views.OrderViewSet, basename='orders')  #orders-list #orders-detail




üìå Key Takeaways
‚úî Orders are now restricted to authenticated users (IsAuthenticated). 
‚úî Regular users can only see their own orders, while admins see all orders. 
‚úî URL basename must be explicitly set to avoid API errors. 
‚úî get_or_create() prevents missing customer issues, but should be improved for better separation. 
‚úî Next steps: Implementing order creation (POST /orders/)!















Creating an Order: 
------------------

We are now implementing order creation. Since creating an order involves moving items from the shopping cart, this requires custom logic that Django cannot handle automatically.

üöÄ Steps to Implement Order Creation
‚úî Step 1: Define a new serializer (CreateOrderSerializer) to handle cart ID input. 
‚úî Step 2: Use custom logic inside the serializer to create an order. 
‚úî Step 3: Ensure customer data is linked properly to the order. 
‚úî Step 4: Override get_serializer_class() in the viewset to choose the correct serializer. 
‚úî Step 5: Test the API to verify order creation.

üìå Orders Endpoint (POST /orders/) ‚úî Users send only a cart ID, and the system automatically retrieves the user ID from the authentication token.

üöÄ Effect: ‚úî Orders are created properly, and cart items will be transferred to order items later.



1. Defining the Order Creation Serializer
üìå Purpose: 
‚úî CreateOrderSerializer allows users to send only the cart_id, simplifying the API request. 
‚úî We override save() to implement custom order creation logic.

üìå Implementation (serializers.py)
from rest_framework import serializers
from store.models import Order, Customer

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()  # ‚úÖ Accepts cart ID as input

    def save(self, **kwargs):
        print(self.validated_data['cart_id'])  # ‚úÖ Displays cart ID for debugging
        print(self.context['user_id'])  # ‚úÖ Retrieves user ID from request context

        # ‚úÖ Ensure customer exists before creating order
        (customer, created) = Customer.objects.get_or_create(user_id=self.context['user_id'])

        # ‚úÖ Create the order
        order = Order.objects.create(customer=customer)
        return order
		
üöÄ Effect: 
‚úî Users only need to send cart_id, and the system automatically assigns the customer. 
‚úî Next step: Transfer cart items to order items (covered later).

üìå Request Example (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

üöÄ Effect: ‚úî A new order is created for the authenticated user.




2. Choosing the Correct Serializer for Each Request
üìå Problem: 
‚úî OrderSerializer retrieves order details, but we need CreateOrderSerializer for order creation.

üìå Solution: Override get_serializer_class() in OrderViewSet (views.py)
class OrderViewSet(ModelViewSet):
    permission_classes = [IsAuthenticated]  # ‚úÖ Only authenticated users can create orders

    def get_serializer_class(self):
        if self.request.method == 'POST':  # ‚úÖ Use special serializer for creating orders
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':  # ‚úÖ Use another serializer for updating orders (later)
            return UpdateOrderSerializer
        return OrderSerializer  # ‚úÖ Default serializer for retrieving orders
		
üöÄ Effect: 
‚úî CreateOrderSerializer handles POST requests, ensuring the correct data format. 
‚úî Order creation logic works independently from order retrieval logic.




3. Passing User ID to the Serializer
üìå Problem: ‚úî The serializer does not have direct access to the request object, so we cannot access user_id easily.

üìå Solution: Use get_serializer_context() to Pass User ID (views.py)
class OrderViewSet(ModelViewSet):
    def get_serializer_context(self):
        return {'user_id': self.request.user.id}  # ‚úÖ Pass authenticated user ID to serializer
		
üöÄ Effect: 
‚úî User ID is available in the serializer via self.context['user_id']. 
‚úî Orders are automatically linked to the correct customer.




4. Registering the Orders Endpoint
üìå Implementation (urls.py)

python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet, basename='orders')  # ‚úÖ Registers `/orders/` endpoint

urlpatterns = [
    path('', include(router.urls)),
]
üöÄ Effect: ‚úî The API now supports order creation (POST /orders/).




5. Testing Order Creation
üìå Step 1: Create a Shopping Cart (POST /carts/) 
‚úî First, create a cart to retrieve a valid cart ID.
json
{
    "id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Step 2: Send Order Creation Request (POST /orders/) 
‚úî Use the retrieved cart_id to create an order.
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

üöÄ Effect: ‚úî A new order is successfully created and linked to the correct user.




üìå Step 3: Verify Order Exists in Database (SELECT * FROM store_order;) 
‚úî Expected Result:
sql
id | customer_id | placed_at           | payment_status
---|-------------|---------------------|---------------
5  | 4           | 2025-05-09 13:45:00 | pending

üöÄ Effect: ‚úî The order is correctly stored in the database.









Codes/notes in this lesson:

POST     /orders/        {cartID}      order

serializers.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()


	def save(self, **kwargs):
		print(self.validated_data['cart_id'])
		print(self.context['user_id'])

		(customer, created) = Customer.objects.get_or_create(user_id=self.context['user_id'])
		Order.objects.create(customer=customer)

views.py:
in OrderViewSet:
class OrderViewSet(ModelViewSet):
	permission_classes = [IsAuthenticated]
	
    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
	
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer
		
	def get_serializer_context(self):
		return {'user_id': self.request.user.id}
	
	





üìå Key Takeaways
‚úî Users only send cart_id ‚Äî the system handles everything else. 
‚úî Orders are correctly linked to the authenticated user via user_id. 
‚úî Custom logic in the serializer ensures proper order creation. 
‚úî Next steps: Transferring cart items to order items.














Creating Order Items:
---------------------



Now that we have an order creation endpoint, we need to convert cart items into order items and store them in the database. Additionally, we must delete the shopping cart once the order is created. Since multiple database operations occur, we use transactions to ensure consistency.

üöÄ Steps to Implement Order Item Creation
‚úî Step 1: Retrieve all cart items from the user's shopping cart. 
‚úî Step 2: Convert cart items into order items using list comprehension. 
‚úî Step 3: Save all order items in bulk using bulk_create(). 
‚úî Step 4: Delete the shopping cart once order creation is completed. 
‚úî Step 5: Wrap all operations inside a transaction to ensure atomicity.

üìå Orders Endpoint (POST /orders/) 
‚úî Users send a cart ID, and the system automatically: 
1. Creates an order. 
2. Converts cart items to order items. 
3. Saves order items in bulk. 
4. Deletes the shopping cart.

üöÄ Effect: ‚úî Orders and their corresponding items are successfully stored in the database.





1. Retrieving Cart Items for the Given Cart ID
üìå Purpose: 
‚úî Retrieve all cart items from the specified cart_id. 
‚úî Use select_related('product') to eager load products, avoiding extra queries.

üìå Implementation (serializers.py)
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()  # ‚úÖ Accepts cart ID as input

    def save(self, **kwargs):
        with transaction.atomic():  # ‚úÖ Ensures atomic execution
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])  # ‚úÖ Get customer object
            order = Order.objects.create(customer=customer)  # ‚úÖ Create order

            cart_items = CartItem.objects \
                .select_related('product') \  # ‚úÖ Avoids extra queries when accessing products
                .filter(cart_id=cart_id)  # ‚úÖ Retrieves cart items for the given cart ID
				
üöÄ Effect: 
‚úî Retrieves all cart items efficiently. 
‚úî Ensures product data is preloaded, reducing extra queries.




2. Converting Cart Items Into Order Items Using List Comprehension
üìå Purpose: 
‚úî Convert cart items into order items using list comprehension. 
‚úî Extract product details, quantity, and unit price at the time of order placement.

üìå Implementation (serializers.py)
order_items = [
    OrderItem(
        order=order,
        product=item.product,
        unit_price=item.product.unit_price,  # ‚úÖ Stores product price at order time
        quantity=item.quantity
    ) for item in cart_items
]

üöÄ Effect: 
‚úî Each cart item is mapped into an order item. 
‚úî Order items retain product details from the time of purchase.

üìå Example Before List Comprehension 
‚úî Without list comprehension, we'd have to manually iterate:
order_items = []
for item in cart_items:
    order_items.append(OrderItem(order=order, product=item.product, quantity=item.quantity))

üöÄ Effect: ‚úî Using list comprehension simplifies code readability and efficiency.




3. Saving Order Items in Bulk
üìå Problem: ‚úî Inserting order items one-by-one generates multiple queries, slowing performance.

üìå Solution: Use bulk_create() to Insert All Order Items At Once
OrderItem.objects.bulk_create(order_items)

üöÄ Effect: ‚úî Saves all order items with a single query, reducing database overhead.




4. Deleting the Shopping Cart After Order Placement
üìå Problem: 
‚úî Once an order is created, the user's cart is no longer needed. 
‚úî Leaving it in the database may cause unnecessary clutter.

üìå Solution: Delete the Cart After Order Is Created
Cart.objects.filter(pk=cart_id).delete()

üöÄ Effect: ‚úî Removes the shopping cart, ensuring users start fresh for their next order.




5. Using Transactions to Ensure Data Consistency
üìå Problem: 
‚úî If the database goes offline in the middle of processing, some data may save while others fail. 
‚úî This causes inconsistent records (e.g., orders without items).

üìå Solution: Wrap Operations Inside transaction.atomic()
from django.db import transaction

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():  # ‚úÖ Ensures all operations succeed together
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)
            order_items = [
                OrderItem(order=order, product=item.product, unit_price=item.product.unit_price, quantity=item.quantity)
                for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order

üöÄ Effect: ‚úî Guarantees that all operations are either fully completed or rolled back in case of failure.

üìå What Happens If the Database Crashes Midway? 
‚úî Without transactions ‚Üí Order may exist, but items may be missing. 
‚úî With transactions ‚Üí Everything is rolled back, preventing corruption.





6. Testing Order Item Creation
üìå Step 1: Add Items to Shopping Cart (POST /carts/{cart_id}/items/) 
‚úî Add two products to the cart before creating an order.
json
[
    {
        "product_id": 1,
        "quantity": 10
    },
    {
        "product_id": 2,
        "quantity": 20
    }
]

üìå Step 2: Send Order Creation Request (POST /orders/) 
‚úî Convert cart items into order items using this request.
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Step 3: Verify Order Items in Database (SELECT * FROM store_orderitem;) ‚úî Expected Result:
sql
id | order_id | product_id | quantity | unit_price
---|---------|------------|---------|------------
5  | 4       | 1          | 10      | 1000
6  | 4       | 2          | 20      | 50
üöÄ Effect: ‚úî Order items are correctly stored with their respective order IDs.








codes/notes in this lesson:

serializers.py:
from django.db import transaction

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()


    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





üìå Key Takeaways
‚úî Cart items are successfully converted into order items. 
‚úî Bulk insertion (bulk_create) optimizes database performance. 
‚úî The shopping cart is deleted after order placement. 
‚úî Transactions ensure atomic operations, preventing data inconsistency. 
‚úî Next steps: Updating & canceling orders (PATCH /orders/{id}/).
















Quick QnA session:

Yes! Your understanding is correct‚Äîlet me break it down step by step in the clearest way possible.

üöÄ Understanding the Order Creation Process
When a user wants to place an order, they first need a cart to store items. This process follows a sequence of steps, each serving a specific purpose.

üìå Step-by-Step Flow of Order Creation
1. Creating an Empty Shopping Cart (POST /carts/)
‚úî A user creates an empty cart first. 
‚úî The system generates a Cart ID (UUID) to uniquely identify the cart.

üìå Example Request:
json
POST /carts/

üìå Example Response:
json
{
    "id": "550e8400-e29b-41d4-a716-446655440000"
}
üöÄ Effect: ‚úî The user now has a cart, ready to store items.




2. Adding Items to the Shopping Cart (POST /carts/{cart_id}/items/)
‚úî Users add products to the cart using the cart_id. ‚úî Each item includes a product ID and quantity.

üìå Example Request:
json
POST /carts/550e8400-e29b-41d4-a716-446655440000/items/
{
    "product_id": 1,
    "quantity": 10
}

üìå Example Response:
json
{
    "id": 1,
    "cart_id": "550e8400-e29b-41d4-a716-446655440000",
    "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
    "quantity": 10
}

üöÄ Effect: ‚úî The shopping cart now contains items that the user wants to purchase.





3. Creating an Order (POST /orders/)
‚úî Users send only the cart_id, and the system: 
1. Creates a new order linked to the user. 
2. Retrieves all cart items to be added to the order. 
3. Transfers cart items to order items. 
4. Deletes the shopping cart once the order is finalized.

üìå Example Request:
json
POST /orders/
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Example Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

üöÄ Effect: ‚úî The order is successfully created, and the cart will be deleted.





4. Converting Cart Items to Order Items (OrderItem.objects.bulk_create())
‚úî After creating the order, the system retrieves all cart items. 
‚úî Each cart item is transformed into an order item, storing:
	Product ID
	Quantity
	Unit price at the time of order placement

üìå Example Data Transformation:
json
Cart Items:
[
    {"product_id": 1, "quantity": 10, "unit_price": 1000},
    {"product_id": 2, "quantity": 20, "unit_price": 50}
]

üöÄ Effect: ‚úî These cart items are transferred into the order items table.

üìå Database Query (SELECT * FROM store_orderitem;)
sql
id | order_id | product_id | quantity | unit_price
---|---------|------------|---------|------------
5  | 4       | 1          | 10      | 1000
6  | 4       | 2          | 20      | 50

üöÄ Effect: ‚úî Order items are now properly stored in the database.




5. Deleting the Shopping Cart (Cart.objects.filter(pk=cart_id).delete())
‚úî Once cart items are converted into order items, the cart is no longer needed. 
‚úî The system deletes the cart, ensuring users start fresh for future orders.

üìå Database Check (SELECT * FROM store_cart;) 
‚úî Before deletion ‚Üí Cart exists. 
‚úî After deletion ‚Üí Cart is removed.

üöÄ Effect: ‚úî The cart is deleted, leaving only the order and its items.




üìå Final Summary
‚úî Users create an empty cart (POST /carts/). 
‚úî Users add items to the cart (POST /carts/{cart_id}/items/). 
‚úî Users submit cart_id to create an order (POST /orders/). 
‚úî The system converts cart items into order items (bulk_create). 
‚úî The shopping cart is deleted after order placement.

üöÄ Next steps: Updating & canceling orders (PATCH /orders/{id}/).













Returning the Created Order:
----------------------------
After creating an order, the API should return the complete order details instead of just the cart_id. To achieve this, we need to: 
‚úî Use two different serializers: one for receiving data (CreateOrderSerializer), and another for returning order details (OrderSerializer). 
‚úî Override the create method in OrderViewSet.

üöÄ Steps to Implement Proper Order Creation Response
‚úî Step 1: Identify why only cart_id is returned instead of an order object. 
‚úî Step 2: Override the create method in OrderViewSet. 
‚úî Step 3: Ensure the serializer returns the complete order object after creation. 
‚úî Step 4: Remove unnecessary methods (get_serializer_context). 
‚úî Step 5: Test the implementation to verify correct order details are returned.

üìå Orders Endpoint (POST /orders/) 
‚úî Users send a cart ID, and the system: 
1.Creates an order. 
2.Converts cart items into order items. 
3.Deletes the shopping cart. 
4.Returns the full order object instead of just cart ID.

üöÄ Effect: ‚úî The API correctly returns order details after creation.



1. Understanding Why Only cart_id Is Returned
üìå Problem: 
‚úî The CreateOrderSerializer only defines cart_id, so Django returns only this field. 
‚úî The create method in ModelViewSet relies on the serializer itself to generate the response.

üìå Default Behavior in ModelViewSet 
‚úî Before Fix (create method uses the same serializer to return the response):
serializer = CreateOrderSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
serializer.save()
return Response(serializer.data)  # üö® Returns only `cart_id`, not the order object

üöÄ Effect: 
‚úî The API returns only cart_id, instead of a full order object.





2. Overriding the create Method to Return the Full Order Object
üìå Solution: 
‚úî Use CreateOrderSerializer to validate and process input. 
‚úî Use OrderSerializer to return the newly created order.

üìå Updated create Method (views.py)
from rest_framework.response import Response

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})  # ‚úÖ Use correct serializer
        serializer.is_valid(raise_exception=True)
        order = serializer.save()  # ‚úÖ Save and retrieve order object
        serializer = OrderSerializer(order)  # ‚úÖ Serialize order object for returning response
        return Response(serializer.data)  # ‚úÖ API now returns the full order object
		
üöÄ Effect: ‚úî The API now correctly returns the newly created order with all details.

üìå Example Request (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending",
    "items": [
        {
            "id": 6,
            "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
            "quantity": 1
        },
        {
            "id": 7,
            "product": {"id": 2, "title": "Mouse", "unit_price": 50},
            "quantity": 2
        }
    ]
}

üöÄ Effect: ‚úî The API now correctly returns full order details after creation.




3. Removing Unnecessary Methods (get_serializer_context)
üìå Problem: 
‚úî get_serializer_context() was only useful when using Django's default create method. 
‚úî Now that we override create, this method is no longer necessary.

üìå Solution: Remove get_serializer_context & Replace With Direct Context Assignment 
‚úî Before (Unnecessary Method):
def get_serializer_context(self):
    return {'user_id': self.request.user.id}
	
‚úî After (Direct Context Assignment in create Method):
serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})

üöÄ Effect: ‚úî Removes unnecessary abstraction, making the code cleaner and more readable.




4. Ensuring Proper Queryset Handling
üìå Problem: ‚úî Admin users should see all orders, but regular users should only see their own orders.

üìå Updated get_queryset() (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:  # ‚úÖ Admin users see all orders
        return Order.objects.all()

    customer_id = Customer.objects.only('id').get(user_id=user.id)  # ‚úÖ Retrieve customer ID
    return Order.objects.filter(customer_id=customer_id)  # ‚úÖ Regular users see only their orders
	
üöÄ Effect: ‚úî Admins see all orders, regular users see only their own orders.




5. Validating Cart ID Before Processing
üìå Problem: ‚úî If the user provides an invalid or empty cart, the system should return a validation error instead of failing silently.

üìå Solution: Validate Cart ID in CreateOrderSerializer (serializers.py)
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError('No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id
		
üöÄ Effect: ‚úî Prevents processing invalid carts, ensuring reliable order creation.

üìå Example Invalid Request (POST /orders/)
json
{
    "cart_id": "invalid-cart-id"
}
üìå Expected Response (400 Bad Request)

json
{
    "cart_id": ["No cart with the given ID was found."]
}

üöÄ Effect: ‚úî Ensures only valid carts can be processed.





codes in this lesson:
codes learned in this lesson:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)


views.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





üìå Key Takeaways
‚úî The API now returns full order details instead of just cart ID. 
‚úî Two serializers are used: One for receiving data (CreateOrderSerializer), one for returning data (OrderSerializer). 
‚úî Admin users see all orders, while regular users see only their own. 
‚úî Cart validation prevents errors when processing invalid data. 
















Data Validation:
----------------
We have implemented the happy path, where we process valid data correctly. Now, we need to handle invalid data scenarios to prevent errors and ensure reliability.

üöÄ Scenarios That Require Validation
‚úî Scenario 1: The user provides an invalid cart ID (cart does not exist). 
‚úî Scenario 2: The user provides an empty cart (a cart with no items).

üöÄ Effect: ‚úî The system should reject invalid cart IDs and prevent empty orders from being created.

1. Handling Invalid Cart IDs
üìå Problem: ‚úî Right now, the system creates an order even if the cart ID is invalid. 
‚úî This results in orders with no items, which is incorrect.

üìå Solution: Use Field Validation for cart_id (serializers.py)
from rest_framework import serializers
from django.db import transaction
from store.models import Cart, CartItem, Order, OrderItem, Customer

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        """Ensures the provided cart ID exists in the database."""
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.'
            )
        return cart_id
		
üöÄ Effect: ‚úî If a user sends a cart ID that does not exist, the system raises a validation error before processing the order.

üìå Example Invalid Request (POST /orders/)
json
{
    "cart_id": "invalid-cart-id"
}

üìå Expected Response (400 Bad Request)
json
{
    "cart_id": ["No cart with the given ID was found."]
}

üöÄ Effect: ‚úî Prevents processing non-existent carts, ensuring data integrity.





2. Handling Empty Carts (No Items)
üìå Problem: 
‚úî The system should not allow creating an order if the cart has no items. 
‚úî Without this check, the system creates empty orders, leading to data inconsistency.

üìå Solution: Add a Check for Empty Carts in validate_cart_id (serializers.py)
def validate_cart_id(self, cart_id):
    """Ensures the provided cart ID exists and contains items."""
    if not Cart.objects.filter(pk=cart_id).exists():
        raise serializers.ValidationError('No cart with the given ID was found.')

    if CartItem.objects.filter(cart_id=cart_id).count() == 0:
        raise serializers.ValidationError('The cart is empty.')

    return cart_id
	
üöÄ Effect: ‚úî If a user sends an empty cart, the system raises a validation error before processing the order.

üìå Example Invalid Request (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

üìå Expected Response (400 Bad Request)
json
{
    "cart_id": ["The cart is empty."]
}

üöÄ Effect: ‚úî Prevents creating orders without items, ensuring proper validation.




3. Updating the save Method to Process Orders
üìå Purpose: 
‚úî Ensures only valid orders are processed by checking cart validity first. 
‚úî Uses a transaction to keep operations atomic.

üìå Updated save() Implementation (serializers.py)
def save(self, **kwargs):
    with transaction.atomic():  # ‚úÖ Ensures all database operations happen together
        cart_id = self.validated_data['cart_id']

        customer = Customer.objects.get(user_id=self.context['user_id'])
        order = Order.objects.create(customer=customer)

        cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)

        order_items = [
            OrderItem(
                order=order,
                product=item.product,
                unit_price=item.product.unit_price,
                quantity=item.quantity
            ) for item in cart_items
        ]
        OrderItem.objects.bulk_create(order_items)  # ‚úÖ Saves all order items in bulk

        Cart.objects.filter(pk=cart_id).delete()  # ‚úÖ Deletes shopping cart after order creation

        return order
		
üöÄ Effect: ‚úî Ensures orders are created only when valid carts exist. ‚úî Uses bulk insert (bulk_create) for better performance. ‚úî Deletes the shopping cart once the order is finalized.




4. Testing Order Validation
üìå Test 1: Sending an Invalid Cart ID (POST /orders/) 
‚úî Expected Response (400 Bad Request):
json
{
    "cart_id": ["No cart with the given ID was found."]
}

üìå Test 2: Sending an Empty Cart (POST /orders/) 
‚úî Expected Response (400 Bad Request):
json
{
    "cart_id": ["The cart is empty."]
}

üìå Test 3: Sending a Valid Cart ID (POST /orders/) 
‚úî Expected Response (201 Created):
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending",
    "items": [
        {
            "id": 6,
            "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
            "quantity": 1
        },
        {
            "id": 7,
            "product": {"id": 2, "title": "Mouse", "unit_price": 50},
            "quantity": 2
        }
    ]
}

üöÄ Effect: ‚úî Invalid carts are blocked, and valid carts successfully create orders.






Codes/Notes in this lesson:

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





üìå Key Takeaways
‚úî The system now properly validates cart IDs before processing orders. 
‚úî Empty carts cannot be processed, preventing invalid orders. 
‚úî Orders are created only when valid carts exist, ensuring data integrity. 
‚úî Next steps: Implementing order updates (PATCH /orders/{id}/).















Revisiting the Permissions:
---------------------------

Currently, all authenticated users can update and delete orders, which is incorrect. We need to: 
‚úî Restrict order modification (PATCH, DELETE) to admin users only. 
‚úî Allow regular users to view their own orders (GET) but not modify them. 
‚úî Enable HEAD and OPTIONS methods for API clients to check available operations.

üöÄ Effect: ‚úî Only admins can modify orders, regular users can only retrieve orders.

üöÄ Steps to Fix Permissions
‚úî Step 1: Override get_permissions() to restrict modifications (PATCH, DELETE). 
‚úî Step 2: Remove PUT since orders should only be partially updated. 
‚úî Step 3: Explicitly set allowed HTTP methods (http_method_names). 
‚úî Step 4: Verify the API correctly hides the delete and update options for non-admins.

üìå Updated Order Management Rules:

User Type	  Can Modify Orders? (PATCH, DELETE)	Can View Orders? (GET)
Admin	                 ‚úÖ Yes	                    ‚úÖ Yes
Regular User	         ‚ùå No	                    ‚úÖ Yes
Anonymous	             ‚ùå No	                    ‚ùå No


üöÄ Effect: ‚úî Admins can modify orders, but regular users can only retrieve them.

1. Restricting Order Modifications to Admins
üìå Problem: ‚úî Right now, any authenticated user can update or delete orders.

üìå Solution: Override get_permissions() (views.py)
from rest_framework.permissions import IsAuthenticated, IsAdminUser

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'patch', 'delete', 'head', 'options']
    permission_classes = [IsAuthenticated]

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:  # ‚úÖ Restrict updates & deletions to admins
            return [IsAdminUser()]
        return [IsAuthenticated()]  # ‚úÖ Regular users can only retrieve orders
		
üöÄ Effect: ‚úî Non-admins can no longer update or delete orders.

üìå Testing (PATCH /orders/1/ as a regular user) 
‚úî Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî The system blocks unauthorized modifications.





2. Removing PUT to Prevent Full Order Updates
üìå Problem: ‚úî PUT allows complete replacement of an order, but we only need partial updates (PATCH).

üìå Solution: Remove PUT From Allowed Methods (views.py)
http_method_names = ['get', 'patch', 'delete', 'head', 'options']  # ‚úÖ Removes `PUT`

üöÄ Effect: ‚úî Ensures orders are only updated partially (PATCH) rather than fully (PUT).





3. Explicitly Defining Allowed HTTP Methods
üìå Problem: ‚úî Some API clients need HEAD and OPTIONS to discover available operations.

üìå Solution: Include HEAD and OPTIONS in http_method_names

http_method_names = ['get', 'patch', 'delete', 'head', 'options']

üöÄ Effect: ‚úî API clients can now check supported methods before making a request.

üìå Testing (OPTIONS /orders/) ‚úî Expected Response (200 OK):
json
{
    "allow": ["GET", "PATCH", "DELETE", "HEAD", "OPTIONS"]
}

üöÄ Effect: ‚úî Clients can now inspect available operations before making requests.




4. Verifying Admin Access to Order Modification
üìå Problem: ‚úî Admins should still be able to update and delete orders.

üìå Solution: Test admin access (PATCH /orders/1/) 
‚úî Expected Response (200 OK):
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "completed"
}

üöÄ Effect: ‚úî Admins can modify orders as expected.




5. Ensuring Proper Queryset Handling
üìå Problem: ‚úî Regular users should only see their own orders, but admins should see all orders.

üìå Updated get_queryset() (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:  # ‚úÖ Admin users see all orders
        return Order.objects.all()

    customer_id = Customer.objects.only('id').get(user_id=user.id)  # ‚úÖ Retrieve customer ID
    return Order.objects.filter(customer_id=customer_id)  # ‚úÖ Regular users see only their orders
	
üöÄ Effect: ‚úî Admins see all orders, regular users see only their own orders.








Codes/Notes in this lesson:

views.py:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)








üìå Key Takeaways
‚úî Admin users can modify orders, but regular users cannot (PATCH, DELETE). 
‚úî Regular users can only retrieve their orders (GET). 
‚úî PUT is removed ‚Äî only partial updates (PATCH) are allowed. 
‚úî API clients can use HEAD and OPTIONS to inspect available operations. 
















Updating an Order:
------------------

Updating an order should be restricted to only changing the payment status, ensuring that critical fields (customer, order items, placed_at) remain read-only.

üöÄ Steps to Implement Order Updates
‚úî Step 1: Ensure only admin users can update orders (PATCH). 
‚úî Step 2: Prevent full updates (PUT) ‚Äî only allow partial updates (PATCH). 
‚úî Step 3: Create a new serializer (UpdateOrderSerializer) to control which fields can be modified. 
‚úî Step 4: Ensure get_serializer_class() dynamically switches between serializers. 
‚úî Step 5: Test the update functionality to verify restricted updates.

üìå Orders Endpoint (PATCH /orders/{id}/) 
‚úî Admins send a partial update request, modifying only payment_status.

üöÄ Effect: ‚úî Orders are updated correctly, while preventing unintended modifications.

1. Creating a Serializer for Updating Orders
üìå Problem: ‚úî Right now, updating an order allows modifying all fields, which is incorrect.

üìå Solution: Create UpdateOrderSerializer with Only payment_status (serializers.py)
from rest_framework import serializers
from store.models import Order

class UpdateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = ['payment_status']  # ‚úÖ Restrict updates to only payment status
		
üöÄ Effect: ‚úî Only payment_status can be modified, ensuring critical fields remain unchanged.

üìå Testing PATCH /orders/{id}/ 
‚úî Request (PATCH /orders/1/)
json
{
    "payment_status": "C"
}

‚úî Expected Response (200 OK)
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "C"
}

üöÄ Effect: ‚úî The order is successfully updated, but only payment status is modified.




2. Ensuring Only Admins Can Modify Orders
üìå Problem: ‚úî Right now, all authenticated users can modify orders. 
‚úî We need to restrict updates (PATCH, DELETE) to admin users only.

üìå Solution: Override get_permissions() in OrderViewSet (views.py)
from rest_framework.permissions import IsAuthenticated, IsAdminUser

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:  # ‚úÖ Restrict updates & deletions to admins
            return [IsAdminUser()]
        return [IsAuthenticated()]  # ‚úÖ Regular users can only retrieve orders
		
üöÄ Effect: ‚úî Admins can modify orders, but regular users can only retrieve them.

üìå Testing as a Non-Admin (PATCH /orders/1/) 
‚úî Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî Unauthorized modifications are blocked, ensuring security.





3. Dynamically Switching Serializers in ViewSet
üìå Problem: 
‚úî Right now, OrderSerializer handles both retrieving and updating orders, leading to potentially unsafe modifications. 
‚úî We need to switch between different serializers dynamically.

üìå Solution: Override get_serializer_class() in OrderViewSet (views.py)
class OrderViewSet(ModelViewSet):
    def get_serializer_class(self):
        if self.request.method == 'POST':  # ‚úÖ Use `CreateOrderSerializer` for new orders
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':  # ‚úÖ Use `UpdateOrderSerializer` for updates
            return UpdateOrderSerializer
        return OrderSerializer  # ‚úÖ Default serializer for retrieving orders
		
üöÄ Effect: ‚úî Uses the correct serializer based on request type (POST, PATCH, GET).

üìå Testing PATCH /orders/{id}/ 
‚úî Request ‚Üí API correctly applies UpdateOrderSerializer, ensuring only payment_status can be modified.





4. Removing PUT From Allowed Methods
üìå Problem: ‚úî PUT allows complete replacement of an order, but we only need partial updates (PATCH).

üìå Solution: Remove PUT From http_method_names (views.py)
http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']  # ‚úÖ Removes `PUT`

üöÄ Effect: ‚úî Ensures orders are only updated partially (PATCH) rather than fully (PUT).

üìå Testing PUT /orders/{id}/ 
‚úî Expected Response (405 Method Not Allowed):
json
{
    "detail": "Method \"PUT\" not allowed."
}

üöÄ Effect: ‚úî Prevents unintended full order modifications, ensuring integrity.





5. Testing Order Update Functionality
üìå Test 1: Updating Payment Status (PATCH /orders/{id}/) 
‚úî Expected Response (200 OK):
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "completed"
}

üìå Test 2: Trying to Update Non-Editable Fields (PATCH /orders/{id}/) 
‚úî Request:
json
{
    "customer": 5,
    "payment_status": "C"
}
‚úî Expected Response (400 Bad Request):

json
{
    "customer": ["This field cannot be modified."]
}

üìå Test 3: Unauthorized User Trying to Update Order (PATCH /orders/{id}/) ‚úî Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

üöÄ Effect: ‚úî Only valid updates are processed, while unauthorized modifications are blocked.






Codes/Notes in this lesson:
serializers.py:
class UpdateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = ['payment_status']



views.py:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)






üìå Key Takeaways
‚úî Orders can only be updated by admin users (PATCH /orders/{id}/). 
‚úî Regular users can only retrieve orders (GET /orders/{id}/). 
‚úî Only payment_status is editable ‚Äî other fields remain read-only. 
‚úî Full updates (PUT) are disabled‚Äîonly partial updates (PATCH) are allowed. 
‚úî Next steps: Implementing order cancellations (DELETE /orders/{id}/).










Signals:
--------



Django signals allow apps to communicate without direct dependencies, making the system more modular and maintainable. They help ensure event-driven responses, such as automatically creating a customer record when a new user registers.

üöÄ Steps to Implement Signals for Customer Creation
‚úî Step 1: Identify the violation of the Command Query Separation principle. 
‚úî Step 2: Use signals (post_save) to automatically create a customer when a new user registers. 
‚úî Step 3: Define the signal handler function (create_customer_for_new_user). 
‚úî Step 4: Register the signal in Django's app initialization (apps.py). 
‚úî Step 5: Ensure signals are correctly triggered and tested.

üìå Real-Life Application: 
‚úî Previously, the get_queryset() method was incorrectly modifying data while querying. 
‚úî Using signals, we can separate these concerns, triggering customer creation when a user registers.

üöÄ Effect: 
‚úî When a new user registers, a customer record is automatically created. 
‚úî The OrderViewSet no longer needs to modify data during queries, ensuring correctness.



1. Understanding the Problem in get_queryset()
üìå Problem: 
‚úî The get_queryset() method was responsible for both retrieving and modifying data, violating Command Query Separation. 
‚úî When querying orders, it sometimes had to create a customer record, which is incorrect.

üìå Example Before Fix (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:
        return Order.objects.all()

    (customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)  # üö® This modifies data!
    return Order.objects.filter(customer_id=customer_id)
	
üöÄ Effect: ‚úî Every time a user accessed orders, a customer record was created if missing, leading to unwanted side effects.

üìå Fix: Use Signals Instead 
‚úî Automatically create customer records when users register, preventing modifications in get_queryset().





2. Creating a Signal to Automatically Create Customers
üìå Solution: 
‚úî Define a function (create_customer_for_new_user) to handle customer creation when a user is saved. 
‚úî Use Django‚Äôs post-save signal for event-driven execution.

üìå Implementation (signals.py)
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from store.models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
    """Automatically create a customer when a new user registers."""
    if kwargs['created']:  # ‚úÖ Ensure the user was newly created
        Customer.objects.create(user=kwargs['instance'])  # ‚úÖ Create the customer linked to this user
		
üöÄ Effect: 
‚úî Every time a new user registers, a customer record is automatically created. 
‚úî OrderViewSet no longer needs to create customer records when querying orders.

üìå What is Happening? 
‚úî Django listens for a post_save signal when a new user is created. 
‚úî The create_customer_for_new_user function executes immediately, ensuring proper customer creation.

üìå Example When a New User Registers (POST /users/) 
‚úî A new user is created, automatically triggering customer creation.

üöÄ Effect: ‚úî The system ensures every registered user has a corresponding customer record.





3. Registering the Signal in Django‚Äôs App Initialization
üìå Problem: 
‚úî Django does not run signals unless they are explicitly imported. 
‚úî We need to ensure the signal is registered when the app starts.

üìå Solution: Import Signals in apps.py
from django.apps import AppConfig

class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals  # ‚úÖ Ensure signals are loaded when the app starts
		
üöÄ Effect: ‚úî Django now listens for user creation events automatically.

üìå Testing the Signal: 
Creating a User ‚úî Expected Behavior: 
1.User registers (POST /users/). 
2.Signal is triggered (post_save). 
3.Customer record is automatically created.

üìå Verifying in the Database (SELECT * FROM store_customer;)
sql
id | user_id
---|--------
1  | 6

üöÄ Effect: ‚úî User ID 6 now has an associated customer record, confirming that signals work correctly.




4. Fixing Queryset Retrieval in OrderViewSet
üìå Problem: ‚úî Previously, get_queryset() had to create a customer if missing, which is incorrect.

üìå Solution: Remove Data Modification in get_queryset() (views.py)
class OrderViewSet(ModelViewSet):
    def get_queryset(self):
        user = self.request.user

        if user.is_staff:  # ‚úÖ Admin users see all orders
            return Order.objects.all()

        customer_id = Customer.objects.only('id').get(user_id=user.id)  # ‚úÖ Query only‚Äîno modifications!
        return Order.objects.filter(customer_id=customer_id)  # ‚úÖ Ensures correct access control
		
üöÄ Effect: ‚úî The function now purely retrieves data, following Command Query Separation.




5. Applying the Fix to Other Modules
üìå Problem: 
‚úî Other methods still call get_or_create(), modifying data unintentionally. 
‚úî We need to fix them to only query customer records.

üìå Solution: 
Replace get_or_create() With get() in Related Places 

‚úî Before (Modifies Data)
(customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)  # üö® Modifies Data!

‚úî After (Only Queries Data)
customer_id = Customer.objects.only('id').get(user_id=user.id)  # ‚úÖ Retrieves customer ID without modifications

üöÄ Effect: ‚úî The system no longer creates customers in unexpected places.

üìå Places Updated: 
‚úî Order creation serializer (serializers.py) 
‚úî User profile retrieval (views.py - me action)

üöÄ Effect: ‚úî The store app correctly handles customer creation through signals, preventing side effects.





Codes/Notes in this lesson:
pre_save
post_save
pre_delete
post_delete


signals.py:
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
	if kwargs['created']:
		Customer.objects.create(user=kwargs['instance'])
		
		
apps.py:
from django.apps import AppConfig


class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals.handlers		
		
		



üìå Key Takeaways
‚úî Signals automate customer creation when a new user registers (post_save). 
‚úî User creation is now properly separated from other app concerns. 
‚úî OrderViewSet no longer modifies data during queries‚Äîonly retrieves data. 
‚úî Next steps: Implementing custom signals for real-time event handling.












Creating Custom Signals: 
------------------------

üöÄ Creating Custom Signals in Django:
Django signals allow different parts of an application to communicate without being tightly coupled. Now, we are creating a custom signal (order_created), which notifies other apps whenever a new order is placed.

üöÄ Steps to Implement Custom Signals
‚úî Step 1: Define a new custom signal (order_created). 
‚úî Step 2: Fire this signal when an order is created (CreateOrderSerializer). 
‚úî Step 3: Set up a signal handler to respond to this event (core/signals/handlers.py). 
‚úî Step 4: Register the signal handler in Django‚Äôs app initialization (apps.py). 
‚úî Step 5: Test the signal to verify that external apps receive order updates.

üìå Real-Life Application: 
‚úî The store app fires an event when an order is created (order_created). 
‚úî The core app listens for this event and handles order-related actions. 
‚úî Other apps (e.g., email notifications, analytics) can also subscribe to this signal, reacting when an order is placed.

üöÄ Effect: ‚úî The store app does not need to directly depend on the core app, keeping the system modular and scalable.




1. Defining the Custom Signal
üìå Problem: 
‚úî Right now, Django only provides built-in signals (post_save, post_delete). 
‚úî We need a custom signal (order_created), so that external apps can listen for order placements.

üìå Solution: Define order_created in signals/__init__.py
from django.dispatch import Signal

order_created = Signal()  # ‚úÖ Custom signal for order creation event

üöÄ Effect: ‚úî We now have a custom signal that can be triggered when an order is placed.

üìå What Happens Now? ‚úî Other parts of the system can subscribe to order_created and respond accordingly.




2. Triggering the Custom Signal When an Order Is Created
üìå Problem: ‚úî When an order is placed, we need to fire the custom signal (order_created).

üìå Solution: Trigger the Signal in CreateOrderSerializer (serializers.py)
from store.signals import order_created

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)
            order_items = [
                OrderItem(order=order, product=item.product, unit_price=item.product.unit_price, quantity=item.quantity)
                for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)
            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)  # ‚úÖ Send signal with order details

            return order
			
üöÄ Effect: 
‚úî Every time an order is created, the signal (order_created) is fired, notifying other apps that need this data.

üìå Why send_robust Instead of send? 
‚úî If one handler fails, send_robust ensures other handlers still receive the signal.




3. Creating a Signal Handler to Respond to the Event
üìå Problem: 
‚úî The core app needs to listen for the order_created event and perform additional actions.

üìå Solution: Define a Handler in core/signals/handlers.py
from django.dispatch import receiver
from store.signals import order_created

@receiver(order_created)
def on_order_created(sender, **kwargs):
    print(kwargs['order'])  # ‚úÖ Logs order details in the core app
	
üöÄ Effect: ‚úî The core app now listens for the order_created event, handling it when an order is placed.

üìå What Happens Now? 
‚úî The store app fires the signal (order_created). 
‚úî The core app receives the signal and prints the order details. 
‚úî Other apps can also subscribe to order_created, handling order events as needed.

üìå Potential Expansions: 
‚úî Send confirmation emails after an order is placed. 
‚úî Update inventory stock when an order is received. 
‚úî Log analytics data for sales tracking.




4. Registering the Signal Handler in Django‚Äôs App Initialization
üìå Problem: 
‚úî Django does not execute signals unless they are explicitly imported. 
‚úî We need to ensure the signal handler is loaded when the app starts.

üìå Solution: Import the Signal Handler in core/apps.py
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self) -> None:
        import core.signals.handlers  # ‚úÖ Load signal handlers when the app starts
		
üöÄ Effect: ‚úî Signal handlers are now active when the core app is initialized.

üìå Now, when an order is created, the core app automatically gets notified!




5. Testing the Custom Signal
üìå Step 1: Create an Order (POST /orders/) 
‚úî Expected Request:
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}


üìå Step 2: Verify That Signal Was Received in core/signals/handlers.py 
‚úî Expected Output in Terminal:
bash
<Order: id=5, customer=4, placed_at=2025-05-09T13:45:00Z>
üöÄ Effect: ‚úî Confirms that the signal fired and was received by the core app.


üìå Step 3: Add Another App to Listen for order_created 
‚úî The email app or inventory app can also subscribe to this signal, further decoupling the system.

üöÄ Effect: ‚úî The system is now modular‚Äînew apps can easily react to order placements.







Codes/Notes in this lesson:

handlers.py:
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from store.models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
  if kwargs['created']:
    Customer.objects.create(user=kwargs['instance'])
	
	
apps.py:
from django.apps import AppConfig


class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals.handlers
	


signals/__init__.py:
from django.dispatch import Signal

order_created = Signal()

	
	
serializers.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order



core/signals/handlers.py:
from django.dispatch import receiver
from store.signals import order_created

@receiver(order_created)
def on_order_created(sender, **kwargs):
  print(kwargs['order'])
  
  
  
core/apps.py:
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self) -> None:
        import core.signals.handlers 


üìå Key Takeaways
‚úî Custom signals (order_created) allow apps to react to events asynchronously. 
‚úî Signal handlers (@receiver(order_created)) process events without direct dependencies. 
‚úî The store app fires an order event, while other apps (core, email, analytics) subscribe to it. 
‚úî Django apps remain modular and scalable‚Äînew features can be added without modifying existing code. 



-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Django Part - 3



üî∞ Getting Started

‚úÖ Purpose  
This is the final part of a 3-part Django series. Parts 1 & 2: built a REST API for an online store.  
In this part ‚Üí focus on real-world, production-ready features.

üì¶ Topics Covered  
- File Uploads : How to accept and manage file input in forms, store files in the server, and serve uploaded files securely.  
- Email Support ('send_mail'): Techniques to send emails using Django's built-in send_mail() function and configuring email backends.  
- Background Tasks (Celery + Redis): Leveraging tools like Celery + Redis to offload long-running tasks for performance.  
- Automated Testing ('unittest', coverage): Writing unit tests using Django's test client, unittest, and coverage analysis.  
- Performance Testing (Locust, JMeter): Measuring system responsiveness using tools like Locust or Apache JMeter.  
- Caching (Redis, Memcached, file-based cache): Implementing caching via Memcached, Redis, or Django‚Äôs file-based cache for optimizing load times.

‚ö†Ô∏è Pre-requisite  
Requires completion of Parts 1 & 2:  
- Project architecture  
- DRF concepts  
- Authentication  
- Shortcuts & best practices






















2. Setting Up the Project:



üöÄ Project Setup ‚Äì Storefront Part 3

This phase lays the groundwork for working with advanced Django features. Even if you‚Äôve cloned the repo, make sure to follow all steps precisely to avoid configuration issues.



‚úÖ Step-by-Step Setup Guide:

1. Create a New MySQL Database
Open DataGrip (or your preferred DB tool) and create a fresh database:

'''sql
CREATE DATABASE storefront3;
'''

This ensures you're working in isolation from previous project phases.



2. Download the Project Starter Files
Download the '.zip' file attached with the course and extract it. Inside:

'''
üìÇ code/
   ‚îî‚îÄ‚îÄ üìÇ section-1/
         ‚îî‚îÄ‚îÄ üìÇ start/
'''

Open the 'start' folder in VS Code.



3. Update Database Credentials
Navigate to:

'''
storefront3/settings.py
'''

Update the 'DATABASES' section with your local MySQL password:

'''python
'PASSWORD': 'your_mysql_password',
'''



4. Install Dependencies
Open the terminal in VS Code and run:

'''bash
pipenv install
'''

This installs all required Python packages from 'Pipfile'.



5. Activate the Virtual Environment
'''bash
pipenv shell
'''

Then, configure VS Code to use this Python interpreter:
- Run 'which python' (Linux/Mac) or 'where python' (Windows) inside the shell.
- Copy the path and open the Command Palette (‚áß‚åòP / Ctrl+Shift+P).
- Search: 'Python: Select Interpreter'
- Choose 'Enter interpreter path', paste the path, and replace 'activate' with 'python' at the end.


6. Run Migrations
'''bash
python manage.py migrate
'''

> Creates all database tables based on models.



7. Populate the Database (New Approach!)
We‚Äôll seed data using a custom management command rather than a raw '.sql' import.

üìÅ File Structure:
'''
store/
‚îî‚îÄ‚îÄ management/
    ‚îî‚îÄ‚îÄ commands/
        ‚îî‚îÄ‚îÄ seed_db.py  ‚Üê custom command
        ‚îî‚îÄ‚îÄ seed.sql    ‚Üê SQL data file
'''



üìå 'seed_db.py' Implementation

from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os

class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)


üìå Run the command:
'''bash
python manage.py seed_db
'''

‚úÖ ‚ÄúPopulating the database...‚Äù ‚Äì your data is now seeded.



8. Create a Superuser
'''bash
python manage.py createsuperuser
'''
Fill in:
- Username: 'admin'
- Email: 'admin@example.com'
- Password: 'yourpassword'



9. Run the Server
'''bash
python manage.py runserver
'''

Visit:
- [http://localhost:8000/](http://localhost:8000/) ‚Üí Blank homepage
- [http://localhost:8000/store/collections](http://localhost:8000/store/collections) ‚Üí Confirm seeded collections
- [http://localhost:8000/store/products](http://localhost:8000/store/products) ‚Üí Should show 1000 products with pagination



10. Login to Admin Panel
Go to:
'''
http://localhost:8000/admin
'''

Login with the credentials created in step 8.



üìä Summary Flow Diagram:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Project Setup Flow (Storefront 3)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Create DB             ‚îÇ storefront3          ‚îÇ
‚îÇ Download project      ‚îÇ Code ‚Üí Section 1     ‚îÇ
‚îÇ Update DB settings    ‚îÇ settings.py          ‚îÇ
‚îÇ pipenv install        ‚îÇ Install dependencies ‚îÇ
‚îÇ pipenv shell          ‚îÇ Activate env         ‚îÇ
‚îÇ Interpreter setup     ‚îÇ Use env Python       ‚îÇ
‚îÇ migrate               ‚îÇ Create tables        ‚îÇ
‚îÇ seed_db               ‚îÇ Populate DB          ‚îÇ
‚îÇ createsuperuser       ‚îÇ Create admin user    ‚îÇ
‚îÇ runserver             ‚îÇ Launch server        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


üí° Troubleshooting Tip
If you face any errors during setup:
- ‚úÖ Check forums: [forum.codewithmosh.com](https://forum.codewithmosh.com)
- ‚úÖ Use Google or Stack Overflow






Codes and other notes in this discussion: 

storefront3\store\management\commands\seed_db.py:

from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)



Then in the terminal:
python manage.py seed_db



















Uploading Files:
----------------
In this section, we're going to talk about uploading files. So together, we'll build a RESTful API that client apps can call for uploading images. It's going to be a lot of fun, so let's jump in and get started.

Managing Media Files:
---------------------




üìå Managing Media Files in Django
To support file uploads (e.g. images), Django must know where to store user-uploaded files and how to serve them in development. These files are commonly referred to as media files, and they must be configured separately from static files.



üìå 1. Creating the 'media/' Directory
‚úî In the root of your project, create a folder named:
'''
media/
'''

‚úî This is where Django will save user-uploaded content.  
‚úî Although you could name it something like 'uploads', 'media/' is standard and widely used in Django documentation.




üìå 2. Configuring 'settings.py'

Open your 'settings.py' and add the following:

'''python
import os

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
'''

# üîç Explanation:
| Setting       | Purpose                                                                 |
|---------------|-------------------------------------------------------------------------|
| 'MEDIA_URL'   | Public-facing URL path where media files will be served ('/media/').   |
| 'MEDIA_ROOT'  | Absolute filesystem path to the folder where uploaded files are stored. |

‚úî 'BASE_DIR' is already defined in 'settings.py', pointing to the root project directory.





üìå 3. Testing the Setup (Optional)
‚úî Place any image (e.g. 'dog.jpg') into the 'media/' directory.  
‚úî This simulates a file that might have been uploaded by a user.





üìå 4. Updating 'urls.py' to Serve Media

‚úî In development, Django must be explicitly told to serve media files via a URL route.

In 'storefront/urls.py':

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


üîç Explanation:
- 'static()' connects the '/media/' URL endpoint to the actual 'MEDIA_ROOT' on the disk.
- Only executes in development ('DEBUG = True'), not in production.

> ‚ö†Ô∏è In production, you should serve media files using a dedicated web server (e.g. NGINX) instead.





üìå 5. Verifying Your Setup
‚úî Run your development server:
'''bash
python manage.py runserver
'''

‚úî Visit this URL in your browser:
'''
http://localhost:8000/media/dog.jpg
'''

‚úÖ If the image loads, Django is correctly serving files from the 'media/' folder.






Codes and other notes in this discussion: 

settings.py:

MEDIA_URL = '/media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')



urls.py:
from django.conf import settings 
from django.conf.urls.static import static


urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


A better way to write this code: 

if settings.DEBUG:
	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)






üìå Key Takeaways
‚úî Media files are user-uploaded content and must be handled separately from static assets.  
‚úî Define 'MEDIA_URL' and 'MEDIA_ROOT' in 'settings.py'.  
‚úî Use 'static()' in 'urls.py' only in development (guarded by 'if settings.DEBUG').  
‚úî In production, serve media files using a web server‚Äînot Django.  
‚úî Placing files in 'media/' and verifying via browser confirms proper configuration.

























Adding Images to Products: 
--------------------------
üìå Adding Images to Products in Django
Each product can now have zero or more images, which requires creating a new model and establishing a one-to-many relationship between 'Product' and 'ProductImage'.



üìå 1. Defining the 'ProductImage' Model
‚úî Add this new class right after the existing 'Product' model in 'store/models.py', since they are closely related.

class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])





üìå 2. Explanation of Fields
‚û§ 'product = models.ForeignKey(...)'
- Relation: One-to-many ‚Äî each product can have multiple images.
- on_delete=models.CASCADE': If a product is deleted, its images are deleted too.
- related_name='images'': Enables reverse lookup using 'product.images.all()'.

‚û§ 'image = models.ImageField(...)'
- Purpose: Stores image files associated with products.
- upload_to='store/images'': Images are stored under 'MEDIA_ROOT/store/images/'.
- validators=[validate_file_size]': Optional custom validator to restrict max file size.

‚úî Note: Use 'ImageField' for image validation and dimension support. Use 'FileField' only for generic files (e.g., PDFs, DOCs).





üìå 3. Why Store Image Files in the Filesystem
‚úî Do NOT store images in the database.  
‚úî Images are stored in the filesystem, and only their file paths are saved in the DB.

 ‚ú≥Ô∏è Advantages:
- Keeps the database lightweight.
- Improves query performance.
- Easier to serve files directly from disk (or a CDN in production).





üìå 4. Installing Pillow (Image Support Library)
pipenv install pillow

‚úî 'Pillow' is required for Django to process and validate image files.





üìå 5. Creating and Running Migrations
python manage.py makemigrations
python manage.py migrate

‚úî This will create the corresponding database table to store product image references.





üìå 6. Project Structure Reference
Media files will be stored in the following structure:

project_root/
‚îú‚îÄ‚îÄ media/               ‚Üê MEDIA_ROOT
‚îÇ   ‚îî‚îÄ‚îÄ store/
‚îÇ       ‚îî‚îÄ‚îÄ images/      ‚Üê Image upload folder
‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îî‚îÄ‚îÄ models.py        ‚Üê Product & ProductImage models





Codes and Other Notes in this discussion: 

store/models.py:
class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])
		
		
pipenv install pillow 

python manage.py makemigrations
python manage.py migrate 





üìå Key Takeaways
‚úî A ProductImage model adds image upload functionality with a clear one-to-many structure.  
‚úî ImageField ensures proper validation for image uploads.  
‚úî Uploaded files are saved under 'MEDIA_ROOT/store/images/', not in the database.  
‚úî Use 'related_name' for clean reverse lookups like 'product.images.all()'.  
‚úî Install Pillow to enable Django‚Äôs image handling features.



Next up: Building an API that enables clients to upload images tied to specific products. Let me know if you'd like to bundle this and the next section into a printable PDF cheat sheet üßæüìÅ.
















Building an API to Upload Images: 
----------------------------------



üìå Uploading Images for Products in Django
To allow users to upload images for products, we implement a one-to-many relationship between 'Product' and a new model 'ProductImage', and expose it through a nested API endpoint.



üìå 1. Defining the Image Upload Endpoint
‚úî The endpoint is designed as:  
'''
/products/<product_id>/images/
'''
‚úî Follows a nested resource structure, where each product can have multiple images.

‚úî Django REST Framework requires three core components:
- Serializer
- ViewSet
- Router





üìå 2. Creating the Serializer
‚úî In 'store/serializers.py', define 'ProductImageSerializer'.

class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, validated_data)

    class Meta:
        model = ProductImage
        fields = ['id', 'image']


‚úî Why product ID isn't included in 'fields':
- It is already present in the URL ('product_pk'), so no need to duplicate it in the form body or JSON.

‚úî 'create()' method uses the 'product_id' from 'context' to associate the image.





üìå 3. Creating the ViewSet
‚úî In 'store/views.py', define 'ProductImageViewSet'.


class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}

    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])


‚úî 'product_pk' is automatically extracted from the URL using 'kwargs'.
‚úî 'get_queryset()' filters only images for the specified product.





üìå 4. Configuring the Nested Router
‚úî In 'store/urls.py', use 'NestedDefaultRouter' to register the image sub-resource.

'''python
router = routers.DefaultRouter()
router.register('products', views.ProductViewSet, basename='products')

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')
products_router.register('images', views.ProductImageViewSet, basename='product-images')
'''

‚úî 'lookup='product'' creates a route like '/products/<product_pk>/images/'.





üìå 5. Handling Form Uploads
‚úî When posting an image using a form or JSON, you don‚Äôt include the 'product_id'‚Äîit‚Äôs derived from the route.

‚úî If you see the error:
'''
Column 'product_id' cannot be null
'''
‚û° It means the 'product_id' wasn‚Äôt manually injected, which is why we override 'create()' and use 'context'.





üìå 6. Testing the API
- Upload images at '/products/1/images/'.
- Files are stored in:
  '''
  media/store/images/
  '''
- Django automatically appends suffixes to filenames if duplicates are uploaded (e.g., 'dog_xxx.jpg').





üìå 7. Key Takeaways
‚úî Use a nested router to expose image upload routes per product.  
‚úî Do not include 'product_id' in the form‚Äîit is inferred from the URL.  
‚úî Override 'create()' in the serializer to inject 'product_id'.  
‚úî Use 'get_serializer_context()' to pass the context into the serializer.  
‚úî Uploaded files are saved to the file system, not the database.  
‚úî This design keeps the API clean, secure, and scalable.






Codes and Other Notes in this Discussion: 

/products/1/images/1


serializers.py:
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)

    class Meta:
        model = ProductImage
        fields = ['id', 'image']

		


views.py:
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}

    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])




urls.py:

router = routers.DefaultRouter()
router.register('products', views.ProductViewSet, basename='products')


products_router = routers.NestedDefaultRouter(
    router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet,
                         basename='product-reviews')
products_router.register(
    'images', views.ProductImageViewSet, basename='product-images')






üìå 8. Summary
| Component                    | Purpose                                                                      |
|------------------------------|------------------------------------------------------------------------------|
| 'ProductImageSerializer'     | Validates and saves uploaded image. Uses 'context' to retrieve 'product_id'. |
| 'ProductImageViewSet'        | Filters images by 'product_pk' and injects it into serializer context.       |
| 'products_router.register()' | Sets up the nested route '/products/<product_pk>/images/'.                   |



















Returning Images from the API:
------------------------------


üìå Returning Images with Products via the API

After implementing the product image upload feature, we want to ensure that product images are included in the product list API response. This avoids requiring the client to make multiple requests to fetch images for each product, improving efficiency and performance.



üìå 1. Extending the Product Serializer

üìÑ File: 'store/serializers.py'

‚úî Modify the 'ProductSerializer' to include an 'images' field:

class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ['id', 'image']


‚úî Move 'ProductImageSerializer' above 'ProductSerializer' in the file to avoid reference issues.
‚úî Then add the nested field to 'ProductSerializer':

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = [
            'id', 'title', 'description', 'slug', 'inventory',
            'unit_price', 'price_with_tax', 'collection', 'images'
        ]

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)


üîç Explanation:
- 'many=True': Because a product can have multiple images.
- 'read_only=True': Prevents images from being submitted during product creation.
- 'ProductImageSerializer': Used to serialize the nested list of images for each product.





üìå 2. Eager Loading Images to Avoid Duplicate Queries
‚úî Without optimization, Django performs a separate query to fetch images for each product, leading to duplicate queries and inefficient performance.
‚úî To prevent this, update the 'ProductViewSet' to use eager loading via 'prefetch_related()':

üìÑ File: 'store/views.py'

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}


üîç Explanation:
- 'prefetch_related('images')': Preloads all product images in a single query.
- Prevents N+1 query problem, reducing the number of queries from one per product to just two.





üìå 3. Testing in Browser
‚úî Navigate to '/store/products/'.  
‚úî Each product now includes an 'images' key, which is a list of associated image objects:

"images": [
    {
        "id": 1,
        "image": "http://localhost:8000/media/store/images/dog.jpg"
    }
]


‚úî Clicking the image URL should display the uploaded image.
‚úî Confirm performance using Django Debug Toolbar:  
- Before optimization: ~14 queries  
- After adding 'prefetch_related('images')': reduced to ~6 queries






Codes and Other Notes in this Discussion: 


serializer.py:
class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
		
		
		
views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)




üìå Key Takeaways
‚úî To include related media in list responses, use nested serializers.  
‚úî Set 'many=True' and 'read_only=True' when returning related lists that aren't modified directly.  
‚úî Always use 'prefetch_related()' in the view to optimize query performance.  
‚úî Including images in the product list response avoids excessive API calls by the client.  
‚úî This approach keeps the API lean and responsive under load.














Validating Uploading Files:
---------------------------


üìå Validating Uploaded Files in Django
Django provides some built-in mechanisms for validating uploaded content. However, certain validations‚Äîsuch as file size checks‚Äîrequire custom logic. This note outlines how image and file validation works, including how to implement custom validators for uploads.



üìå 1. Default Validation via 'ImageField'
‚úî In 'ProductImage' model, the 'image' field is defined using 'models.ImageField'.  
‚úî This field automatically validates that the uploaded file is a valid image format (e.g. JPEG, PNG).  
‚úî Internally, Django uses the Pillow library to perform this check.

üìå Therefore, we must install Pillow:
pipenv install pillow


‚úî If a user uploads a non-image file (like '.pdf'), Django will raise an error automatically.





üìå 2. Validating File Size (Custom Validator)
Django does not validate the size of an uploaded file by default. To implement this, create a custom validator.

üìÑ File: 'store/validators.py'
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 500

    if file.size > max_size_kb * 1024:
        raise ValidationError(f'Files cannot be larger than {max_size_kb}KB!')


üìå This validator:
- Limits uploaded files to 500 KB
- Raises a 'ValidationError' with a descriptive message





üìå 3. Applying the Validator to 'ImageField'

In 'store/models.py':

from .validators import validate_file_size

class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])


‚úî The 'validators' argument accepts a list of one or more validator functions.




üìå 4. Testing the File Size Validator

To test:
- Upload an image larger than 500 KB via '/products/<id>/images/'
- Django will raise:
Files cannot be larger than 500KB!


‚úî ‚úÖ This confirms the custom size validator works as expected.





üìå 5. Validating File Extensions (For 'FileField')
‚úî When using 'FileField' (for generic uploads like PDFs or docs), Django does not check file types.  
‚úî To restrict allowed extensions (e.g. '.pdf' only), use 'FileExtensionValidator'.

üß™ Temporary demo ‚Äî change 'ImageField ‚Üí FileField' in 'models.py':

from django.core.validators import FileExtensionValidator

file = models.FileField(
    upload_to='store/files',
    validators=[FileExtensionValidator(allowed_extensions=['pdf'])]
)


‚úî This restricts uploads to only files with '.pdf' extension.
‚úî If a '.jpg' file is uploaded, error:
File extension ‚Äújpg‚Äù is not allowed. Allowed extensions are: pdf.


‚ö†Ô∏è You do not need this with 'ImageField' since it validates file type automatically using Pillow.




üìå 6. Final Cleanup
‚úî After testing 'FileField' + 'FileExtensionValidator', switch back:

- Replace 'FileField' with 'ImageField'
- Restore the custom file size validator

image = models.ImageField(
    upload_to='store/images',
    validators=[validate_file_size])





Codes and Other Notes in this discussion: 

validators.py:
from django.core.exceptions import ValidationError


def validate_file_size(file):
    max_size_kb = 500

    if file.size > max_size_kb * 1024:
        raise ValidationError(f'Files cannot be larger than {max_size_kb}KB!')




models.py:
class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])
		
		
		
For files --> from django.core.validators import FileExtensionValidator		

validators = [FileExtensionValidator(allowed_extensions=['pdf'])






üìå Key Takeaways
‚úî 'ImageField' automatically validates uploaded images using Pillow  
‚úî Create a custom validator to limit file size  
‚úî Use 'FileExtensionValidator' to restrict file type for FileField uploads  
‚úî Apply validators using the 'validators=[...]' argument  
‚úî Raising 'ValidationError' ensures clean feedback for invalid uploads


















Setting Up the Client App:
--------------------------


üìå Setting Up the Client App for File Uploads
In this lesson, we set up a simple front-end client to test file uploads to our Django API. The client is a basic JavaScript application, but no prior knowledge of JavaScript is required to follow this setup.



üìå 1. Locate the Client App Folder
‚úî Inside the provided course zip file, under:
Section 2 ‚Üí Uploading Files ‚Üí client-app/

‚úî This folder contains the complete source code of a lightweight client built for demo and testing purposes.
‚úî Purpose: Help full-stack developers understand how file uploads work from both the front-end and back-end.




üìå 2. Open the Project in VS Code
‚úî Launch a new instance of Visual Studio Code.
‚úî Drag and drop the 'client-app' folder into the new window to open it as a project workspace.





üìå 3. Install Node.js (if not already installed)
‚úî This project runs on Node.js, a JavaScript runtime environment.

‚úî If Node.js is not installed:
- Visit [https://nodejs.org](https://nodejs.org)
- Download and install the latest LTS version

‚úî You can verify installation using the terminal:
node -v


üìå Example:
v17.x.x




üìå 4. Install Project Dependencies
‚úî In the terminal (within the 'client-app' folder), run:
npm install

‚úî This will install all required packages from 'package.json'.
‚úî You may see warnings during installation ‚Äî they are harmless and can be ignored for now.




üìå 5. Start the Development Server

‚úî Run the app locally using:
npm start

‚úî This will spin up a development server on 'localhost:8001'.
‚úî Open your browser and navigate to:
http://localhost:8001






üìå 6. Confirm the Interface Loads
‚úî You‚Äôll see a simple web page with an input field for uploading images.
‚úî Note: The upload feature doesn‚Äôt work yet ‚Äî there‚Äôs a cross-origin issue that will be addressed in the next lesson.



üìå Key Takeaways
‚úî A minimal JavaScript client project is provided to simulate file uploads to the Django API.  
‚úî Node.js is required to run the app ‚Äî install it from nodejs.org if not already installed.  
‚úî Use 'npm install' to install dependencies and 'npm start' to launch the app.  
‚úî The app runs at 'http://localhost:8001' and provides a basic upload interface.  
‚úî Current functionality is limited ‚Äî we‚Äôll fix connectivity with the Django server in the next lesson.






















Enabling CORS:
--------------
üìå Enabling CORS in Django for File Uploads
When a frontend application (hosted on a different port or domain) attempts to make requests to a Django API, it triggers browser-enforced Cross-Origin Resource Sharing (CORS) restrictions. This step outlines how to configure Django to safely accept such requests, especially for file uploads.




üìå1. Understanding the Problem

‚û§ Scenario:
- Client app is served at: 'http://localhost:8001'
- Django API runs at: 'http://localhost:8000'

Even though both run on the same machine, they are considered different origins due to port mismatch.

‚û§ Result:
The browser blocks requests from the client to the API, showing:
Could not reach the server.





üìå 2. What Is CORS?
CORS (Cross-Origin Resource Sharing) is a browser security mechanism that:
- Prevents unauthorized cross-origin requests
- Ensures APIs only accept requests from approved sources

In our case, we must tell Django to explicitly allow requests from 'localhost:8001'.





üìå 3. Installing Required Library
Use the official package: ['django-cors-headers'](https://pypi.org/project/django-cors-headers/)
pipenv install django-cors-headers




üìå 4.Configuration in 'settings.py'

‚û§ a) Add to Installed Apps:

INSTALLED_APPS = [
    # Django built-ins
    'django.contrib.admin',
    ...

    # Third-party apps
    'corsheaders',

    # Local apps
    'store',
    ...
]


‚û§ b) Add Middleware (must be near the top):
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    ...
]

üîç *CORS middleware must appear before 'CommonMiddleware' to ensure proper processing.*


‚û§ c) Define Allowed Origins:
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]


‚úî This allows requests from both domain variants.




üìå 5. Testing the Setup

‚û§ Initial Behavior:
- Uploading a file from client app: Fails with CORS error

‚û§ After Enabling CORS:
- Upload succeeds
- Backend returns an image URL
- Upload progress is visible via the progress bar




üìå 6. Using Chrome DevTools to Inspect Requests

‚úî Go to Developer Tools ‚Üí Network Tab ‚Üí Throttling ‚Üí Slow 3G  
‚úî Upload a file to watch request flow in slow motion

üîç Request Breakdown:
1. OPTIONS request  
   - Used for preflight check
   - Server responds with headers:
     '''
     Access-Control-Allow-Origin: http://localhost:8001
     '''
2. POST request  
   - File upload is executed upon CORS approval

‚úî After successful upload, Chrome shows both requests sequentially.





üìå 7. Restoring Default Network Mode

‚úî Don‚Äôt forget to disable throttling after testing:
- DevTools ‚Üí Network tab ‚Üí Throttling ‚Üí No throttling




Codes and Other Notes in this discussion: 

django cors headers --> https://pypi.org/project/django-cors-headers/


in settings.py:

CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]





üìå Key Takeaways
‚úî CORS prevents clients from different origins from accessing APIs by default.  
‚úî Use 'django-cors-headers' to allow trusted frontend domains to send requests.  
‚úî Register the middleware early in the list.  
‚úî Use 'CORS_ALLOWED_ORIGINS' to explicitly whitelist client domains.  
‚úî Preflight 'OPTIONS' requests are automatically handled by the middleware.  
‚úî Use browser dev tools to confirm CORS headers and troubleshoot file uploads.



























Managing Images in the Admin:
-----------------------------
üìå Managing Product Images in the Django Admin Interface
This section covers the full implementation of managing and previewing product images inside the Django admin using inline editing and thumbnail previews.




üìå 1. Displaying Product Images Inline

‚û§ Context:
By default, the Product admin page doesn't show associated images.  
We want to manage images just like we do with tags‚Äîusing inlines.

‚û§ Refresher: Admin Layers
| Admin Class Location | Responsibility                                                              |
|----------------------|-----------------------------------------------------------------------------|
| 'store/admin.py'     | Reusable logic specific to the store app (e.g. 'ProductAdmin')              |
| 'core/admin.py'      | Project-specific logic that extends 'ProductAdmin' via 'CustomProductAdmin' |




üìå 2. Defining an Inline for ProductImage

üìÑ store/admin.py:
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''


‚úî 'thumbnail()' renders the image as an HTML tag  
‚úî 'readonly_fields' registers it in the UI  
‚úî 'format_html()' is used to safely inject HTML  




üìå 3. Registering the Inline in Both Admin Classes

üìÑ In 'store/admin.py' ‚Üí ProductAdmin:

@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    ...
    inlines = [ProductImageInline]



üìÑ In 'core/admin.py' ‚Üí CustomProductAdmin

class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]

‚úî Django combines reusable logic from the 'store' app with project-specific enhancements in 'core'.





üìå 4. Styling the Image as a Thumbnail

‚û§ Define a CSS class:
üìÅ 'store/static/store/styles.css'

'''css
.thumbnail {
  width: 100px;
  height: 100px;
  object-fit: cover;
}
'''

‚úî 'width' & 'height': Forces a square frame  
‚úî 'object-fit: cover': Prevents image distortion





üìå 5. Loading the CSS in Admin via Media Class

üìÑ Inside ProductAdmin:
class ProductAdmin(admin.ModelAdmin):
    ...

    class Media:
        css = {
            'all': ['store/styles.css']
        }


‚úî This loads 'styles.css' on all product admin views  
‚úî ''all'' is a CSS media type (applies to screen, print, etc.)





üìå 6. Namespacing Static Files to Avoid Conflicts

‚úî By default, Django collects all static files from installed apps  
‚úî If two apps have a file named 'styles.css', one could overwrite the other

üìÅ Organize like this:

store/
‚îî‚îÄ‚îÄ static/
    ‚îî‚îÄ‚îÄ store/
        ‚îî‚îÄ‚îÄ styles.css


‚úî Update the 'Media' class to use: ''store/styles.css''






Codes and Other Notes in this Discussion: 


core/admin.py:

class TagInline(GenericTabularInline):
    autocomplete_fields = ['tag']
    model = TaggedItem


class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]


admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)




store/admin.py:
from django.utils.html import format_html, urlencode

class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''


@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    autocomplete_fields = ['collection']
    prepopulated_fields = {
        'slug': ['title']
    }
    actions = ['clear_inventory']
    inlines = [ProductImageInline]
    list_display = ['title', 'unit_price',
                    'inventory_status', 'collection_title']
    list_editable = ['unit_price']
    list_filter = ['collection', 'last_update', InventoryFilter]
    list_per_page = 10
    list_select_related = ['collection']
    search_fields = ['title']

    def collection_title(self, product):
        return product.collection.title

    @admin.display(ordering='inventory')
    def inventory_status(self, product):
        if product.inventory < 10:
            return 'Low'
        return 'OK'

    @admin.action(description='Clear inventory')
    def clear_inventory(self, request, queryset):
        updated_count = queryset.update(inventory=0)
        self.message_user(
            request,
            f'{updated_count} products were successfully updated.',
            messages.ERROR
        )

    class Media:
        css = {
            'all': ['store/styles.css']
        }
		


store\static\store\styles.css:
		
.thumbnail {
  width: 100px;
  height: 100px;
  object-fit: cover;
}




üìå Key Takeaways

‚úî Define a 'TabularInline' for displaying related 'ProductImage' entries.  
‚úî Render thumbnails via a method using 'format_html()' and 'instance.image.url'.  
‚úî Apply custom CSS to style images as thumbnails.  
‚úî Use 'Media' class to load static assets in the admin.  
‚úî Namespace static files inside 'static/store/' to avoid conflicts across apps.















Sending Emails:
---------------
In this section, we'll be talking about sending emails from your Django applications. 



Setting up a Fake SMTP Server:
------------------------------
üìß Setting Up a Fake SMTP Server for Email Testing
In order to simulate email sending in a development environment, we need a local SMTP server. Instead of using a real (often paid) SMTP provider during development, we'll set up a fake SMTP server using SMTP4DEV, a powerful testing tool.



üìå 1. What Is SMTP?
- SMTP stands for *Simple Mail Transfer Protocol*.
- It is a protocol used to send and receive emails.
- Real SMTP servers (e.g., Gmail, SendGrid) are used in production, and usually require authentication and sometimes cost money.





üìå 2. Why Use a Fake SMTP Server in Development?
‚úî Avoids sending real emails  
‚úî Lets developers preview emails sent by the application  
‚úî Offers an admin panel to visualize email content




üìå 3. Introducing SMTP4DEV

GitHub link: [https://github.com/rnwood/smtp4dev](https://github.com/rnwood/smtp4dev)
SMTP4DEV is a fake SMTP server designed for developers. It captures sent emails and displays them in a web-based interface.




üìå 4. Installation Options

You can install SMTP4DEV in one of two ways:

‚û§ Option 1: Using .NET Core (v3.1+)
dotnet tool install Rnwood.Smtp4dev --global
smtp4dev

‚úî Recommended for systems that already use .NET SDK.



‚û§ Option 2: Using Docker (Preferred)
Docker is a container platform used to run applications in isolated environments.

üìå If Docker is not installed:
- Visit [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
- Download and install Docker Desktop for your OS

üìå Then run the following command:
docker run --rm -it -p 3000:80 -p 25:25 rnwood/smtp4dev


‚úî This pulls the SMTP4DEV Docker image from Docker Hub and exposes:
- Port 25 for sending emails
- Port 3000 for the browser-based admin panel





üìå 5. Confirming It Works

‚û§ Access the Admin Panel
- Open your browser and navigate to:
  '''
  http://localhost:3000
  '''

- This panel functions like a mock email inbox.
- Any emails sent by your Django app during development will appear here.



üìå Visual Overview:
[Django App] --(send email)--> [SMTP4DEV @ localhost:25]
                             ‚Ü≥ View messages at http://localhost:3000


‚úî Acts like an inbox (Outlook/Webmail)  
‚úî Helps visualize subject, recipients, headers, HTML content, and attachments



Codes and Other Notes in this discussion:

smtp4dev --> https://github.com/rnwood/smtp4dev



üìå Key Takeaways
‚úî SMTP4DEV helps you test email functionality without sending real emails  
‚úî You can view and debug email content in a browser-friendly admin panel  
‚úî Installation is quick using Docker or .NET CLI  
‚úî This setup is only for local development ‚Äî production uses real SMTP providers



Once set up, you‚Äôre ready to configure your Django project to use this SMTP server. That‚Äôs what we‚Äôll cover next. Let me know if you want a Docker-free setup or help integrating this with Django's 'EMAIL_BACKEND'. üìÆüöÄ

















Configuring the Email Backend: 
------------------------------


üì© Configuring the Email Backend in Django
Django provides multiple email backends for different environments and use cases. This setup explains how to configure Django to send emails via an SMTP server, specifically using a fake SMTP server like smtp4dev in a development environment.



üìå 1. What is an Email Backend?

An email backend in Django is a component responsible for handling the actual sending of emails. Django supports various backends for different scenarios:

| Backend Type | Description |
|--------------|-------------|
| SMTP         | Default backend. Sends emails via an SMTP server. |
| Console      | Prints emails to the terminal instead of sending them (used for local dev/testing). |
| File         | Writes emails to files in a designated directory. |
| LocMem       | Stores emails in memory (typically for testing). |
| Dummy        | Discards all email actions (used for disabling email entirely). |

üìå Reference: ''django.core.mail.backends.smtp.EmailBackend'' is Django‚Äôs default backend.





üìå 2. Configuring the SMTP Backend in 'settings.py'

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'             # Address of the SMTP server
EMAIL_HOST_USER = ''                 # Not required for fake SMTP
EMAIL_HOST_PASSWORD = ''            # Not required for fake SMTP
EMAIL_PORT = 2525                   # Default SMTP is 25; smtp4dev uses 2525
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'


‚úÖ Even though the SMTP backend is default, specifying it makes the configuration explicit.  
‚úÖ 'localhost' refers to where our SMTP server (e.g., smtp4dev) is hosted.  
‚úÖ 'EMAIL_PORT = 2525' because smtp4dev maps port 2525 for incoming email requests.





üìå 3. Avoid Hardcoding Credentials in Production

For real SMTP services (SendGrid, Mailgun, etc.):
- You will need to supply valid 'EMAIL_HOST_USER' and 'EMAIL_HOST_PASSWORD'.
- Avoid hardcoding passwords in 'settings.py'.

‚ö†Ô∏è Best Practice:
Use environment variables to securely store credentials:

import os

EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')

You can load these using '.env' files and libraries like 'python-decouple' or 'django-environ'.




‚úÖ Final Sample Snippet for Development

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_PORT = 2525
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'






Codes and Other Notes in this discussion: 

Backends: 
SMTP(Default)
Console
File
Locmem
Dummy


settings.py:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525   #by default smtp servers runs on port 25
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'





üìå Key Takeaways
‚úî Django provides several email backends; SMTP is the default.  
‚úî Use 'smtp4dev' during development for safe and local email testing.  
‚úî Set 'EMAIL_BACKEND', 'EMAIL_HOST', and 'EMAIL_PORT' to connect to your SMTP server.  
‚úî In real applications, use environment variables to protect credentials.  
‚úî You can switch to the console backend for quick debugging:
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'


























Sending Emails:
---------------
üìß Sending Emails in Django
With the email backend and SMTP server (like smtp4dev) configured, Django can now send emails using its built-in utilities. This note covers how to send emails to users and site admins with support for plain text and HTML content, and how to handle common errors safely.



üìå 1. Django‚Äôs Built-in Email Utilities

Import these tools from 'django.core.mail':

from django.core.mail import send_mail, mail_admins, BadHeaderError


Available Functions:

| Function          | Purpose                                   |
|-------------------|-------------------------------------------|
| 'send_mail()'     | Sends a single email                      |
| 'send_mass_mail()'| Sends multiple emails over one connection |
| 'mail_admins()'   | Sends email to site admins (from settings)|
| 'mail_managers()' | Sends email to site managers              |

‚ö†Ô∏è 'send_mail()' opens a new connection per email;  
'send_mass_mail()' reuses a single connection ‚Äî better for bulk sending.





üìå 2. Sending a Basic Email:

Example: 'playground/views.py'

def say_hello(request):
    try:
        send_mail(
            subject='subject',
            message='message',
            from_email='info@moshbuy.com',        # overrides DEFAULT_FROM_EMAIL
            recipient_list=['bob@moshbuy.com']
        )
    except BadHeaderError:
        pass  # should ideally return an error response
    return render(request, 'hello.html', {'name': 'Mosh'})


üîç Notes:
- 'BadHeaderError' is raised if malicious users inject headers (e.g., spoofing).
- Always catch and handle this exception securely.





üìå 3. Verifying in smtp4dev (Port 3000)

After triggering this view (e.g., visiting '/playground/hello'), smtp4dev will display the sent email:
- View subject, recipient, and body
- Confirm delivery without actually sending to external servers





üìå 4. Sending Email to Site Admins

Django can email site admins using 'mail_admins()'.

def say_hello(request):
    try:
        mail_admins(
            subject='subject',
            message='message',
            html_message='<strong>message</strong>'
        )
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})


üß© Configuration in 'settings.py'

ADMINS = [
    ('Mosh', 'admin@moshbuy.com')
]

'mail_admins()' ignores the 'User' model ‚Äî it relies solely on the 'ADMINS' setting.





üìå 5. Plain Text vs HTML Emails

- 'message' ‚Üí plain text content (suitable for all mail clients)
- 'html_message' ‚Üí optional HTML version of the email

üîç Why Send Both?
Some clients (e.g., screen readers or legacy devices) may only support plain text. Including both ensures maximum compatibility.

üí° smtp4dev Insight:
In the "Parts" tab of the email preview:
- You‚Äôll see both 'text/plain' and 'text/html' versions.
- Clients will render the preferred format based on support.






Codes and Other Notes in this Discussion: 

playground/views.py:

from django.core.mail import send_mail, mail_admins, BadHeaderError 

def say_hello(request):
	try:
		send_mail('subject', 'message', 'info@moshbuy.com', ['bob@moshbuy.com'])
	except BadHeaderError:
		pass
	return render(request, 'hello.html', {'name': 'Mosh'})
	
	
#to mail_admins
def say_hello(request):
	try:
		mail_admins('subject', 'message', html_message='message')
	except BadHeaderError:
		pass
	return render(request, 'hello.html', {'name': 'Mosh'})
	
in settings.py:
ADMINS = [
    ('Mosh', 'admin@moshbuy.com')
]
	
	
	
	
	
‚úÖ Summary

| Task                        | Description                                                  |
|-----------------------------|--------------------------------------------------------------|
| 'send_mail()'               | Sends a user-facing email                                    |
| 'mail_admins()'             | Sends site-wide alerts to configured admins                  |
| 'BadHeaderError'            | Protects against header injection attacks                    |
| 'html_message'              | Sends a formatted HTML version along with plain text         |
| 'ADMINS' in settings        | Registers recipients for admin-level notifications           |


















Attaching Files:
----------------


üìé Attaching Files in Django Emails
By default, Django provides utility functions like 'send_mail()' and 'mail_admins()' for basic email functionality. However, if you want finer control over email content‚Äîsuch as adding attachments, CC/BCC support, or setting specific headers‚Äîyou should use the 'EmailMessage' class directly.



üìå 1. Why Use 'EmailMessage'?
Internally, helper functions like 'send_mail()' use 'EmailMessage' behind the scenes. But by constructing an 'EmailMessage' yourself, you unlock additional features like:
- File attachments
- Multiple recipients
- CC/BCC support
- Inline image support (advanced use cases)



üìå 2. Attaching a File to an Email
‚úîÔ∏è Step-by-Step Setup
üß± File Structure (Relative to Project Root):

playground/
‚îî‚îÄ‚îÄ static/
    ‚îî‚îÄ‚îÄ images/
        ‚îî‚îÄ‚îÄ dog.jpg


You can drag-and-drop your image into this folder to simulate attaching a file.



üßæ Sample Implementation
üìÑ File: 'playground/views.py':
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render

def say_hello(request):
    try:
        message = EmailMessage(
            subject='subject',
            body='message',
            from_email='from@moshbuy.com',
            to=['bob@moshbuy.com']
        )
        message.attach_file('playground/static/images/dog.jpg')
        message.send()
    except BadHeaderError:
        pass  # In production, log and return proper error response

    return render(request, 'hello.html', {'name': 'Mosh'})





üìå 3. Explanation of Key Elements

| Parameter          | Description                                          |
|--------------------|------------------------------------------------------|
| 'subject'          | Email subject line                                   |
| 'body'             | Body of the message (can be plain text or HTML)     |
| 'from_email'       | Sender‚Äôs email address                               |
| 'to'               | List of recipient email addresses                    |
| 'attach_file(path)'| Attaches the file from the given path                |

‚ö†Ô∏è The file path is relative to the project root.



‚úÖ Result

After triggering the view (e.g., reloading '/playground/hello/'), smtp4dev will show:
- An email with the subject line and body message
- A file attachment: 'dog.jpg'
- You can preview and download the attached file in the admin UI





Codes and Other Notes in this discussion: 

from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render


def say_hello(request):
    try:
       message = EmailMessage('subject', 'message', 'from@moshbuy.com', ['bob@moshbuy.com']
       message.attach_file('playground/static/images/dog.jpg')
	   message.send()
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})
	
	
		

üìå Key Takeaways

‚úî Use 'EmailMessage' when you need more control than 'send_mail()' provides  
‚úî Attach files using '.attach_file(path)' with correct file path  
‚úî Always wrap 'send()' in a 'try-except' block to catch 'BadHeaderError'  
‚úî Use smtp4dev to test your email setup without sending real emails  
‚úî Useful for order receipts, invoices, downloadable reports, or any file delivery use case

	
	
	
	
	
	
	
	
	
	
Sending Templated Emails:
-------------------------	
üì© Sending Templated Emails in Django
Hardcoding email messages directly in your views can quickly become unmanageable‚Äîespecially when emails grow in length or need to support dynamic content. Instead, we can use the 'django-templated-mail' library to manage email messages through reusable templates.



üìå 1. Install 'django-templated-mail'

pipenv install django-templated-mail

This package provides the 'BaseEmailMessage' class‚Äîan extension of Django‚Äôs built-in 'EmailMessage'‚Äîwith support for rendering subject, plain text, and HTML bodies via Django templates.



üìå 2. Create a Templated Email:
üìÅ File: 'playground/templates/emails/hello.html'

{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}


üîç Explanation:
- '{% block subject %}' ‚Üí Defines the email subject
- '{% block html_body %}' ‚Üí Contains HTML-formatted message content
- '{{ name }}' ‚Üí Dynamically rendered using a context dictionary

‚úî You may also define a '{% block text_body %}' for plain-text clients (optional).

> ‚ö†Ô∏è To avoid formatting issues in VS Code when editing block templates, use Auto Save and avoid manual saving (which may reformat blocks poorly).



üìå 3. Using 'BaseEmailMessage' in Views

üìÑ File: 'playground/views.py':
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage
from django.core.mail import BadHeaderError

def say_hello(request):
    try:
        message = BaseEmailMessage(
            template_name='emails/hello.html',
            context={'name': 'Mosh'}
        )
        message.send(['john@moshbuy.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})


üîç Key Points:
| Parameter        | Purpose                                               |
|------------------|--------------------------------------------------------|
| 'template_name'  | Relative path to the email template                    |
| 'context'        | Dictionary of variables to be rendered in the template |
| '.send(to=[])'   | Required list of recipient emails                      |

‚úî 'BaseEmailMessage.send()' expects the 'to' parameter to be passed explicitly.



‚úÖ Final Output (via smtp4dev):

When triggered:
- The recipient receives an email with the subject:  
  _"This is a long subject"_
- The body renders:
  '''html
  <h1>Hello</h1>
  My name is Mosh
  '''

‚úî You can preview both HTML and plain text sections in the 'Parts' tab of smtp4dev.





Codes and Other Notes in this Discussion: 	
		
pipenv install django-templated-mail	

playground\templates\emails\hello.html:
{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}


views.py:	
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage


def say_hello(request):
    try:
       message = BaseEmailMessage(
           template_name='emails/hello.html',
           context={'name': 'Mosh'}
       )
       message.send(['john@moshbuy.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})
	
	
	
	
	
üìå Key Takeaways
‚úî Use 'django-templated-mail' to cleanly separate email content from Python logic.  
‚úî Email content is stored and rendered from template files.  
‚úî Templates support plain text and HTML blocks‚Äîalong with dynamic variables.  
‚úî Use 'BaseEmailMessage' with 'template_name' and 'context' to generate and send the email.  
‚úî Always namespace your templates (e.g., 'emails/hello.html') to avoid collisions.




















Running Background Tasks:
-------------------------

In this section, we'll be talking about running background tasks in Django applications. 


Introduction to Celery:
-----------------------
üìå Introduction to Celery ‚Äî Running Background Tasks in Django

Modern web applications often deal with resource-intensive tasks like:
- Sending emails
- Processing uploaded files (images, videos)
- Generating reports
- Running machine learning models
- Importing/exporting large data sets

These operations are typically slow and CPU-heavy, and should not block the request-response cycle of the main application. For a responsive and scalable system, such tasks should be offloaded to the background.



üîÑ Real-World Scenario
Let‚Äôs say a user uploads a video to your app.  
‚ùå If the backend processes the video in the same request cycle, the user experiences long wait times.  
‚úÖ Instead, we send the video to a background worker, and respond immediately:  

‚ÄúWe‚Äôre processing your video. You‚Äôll be notified when it‚Äôs ready.‚Äù




üß† Why Offload Background Tasks?

| Problem                         | Background Solution                     |
|---------------------------------|-----------------------------------------|
| Long-running tasks block server | Offload work to background worker       |
| Risk of request timeouts        | Reduce load on main process             |
| Poor user experience            | Immediate response improves UX          |
| Inflexible scaling              | Easily add workers to process more jobs |



üöÄ Meet Celery
Celery is a popular Python framework for executing asynchronous tasks and scheduling periodic jobs.  
Website: [https://docs.celeryq.dev](https://docs.celeryq.dev)


üåü Key Benefits:
- Offloads long-running tasks from the Django app
- Manages distributed task queues
- Supports scheduling (e.g., run every Monday 9 AM)
- Scales easily with multiple worker processes
- Is fault-tolerant: if a task fails, the Django app isn‚Äôt impacted



‚öôÔ∏è How Celery Works (Conceptual Flow):
[Django App] ‚îÄ‚îÄ‚ñ∂ [Task Queue] ‚óÄ‚îÄ‚îÄ‚ñ∂ [Celery Workers]
       ‚îÇ                               ‚ñ≤
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Immediate Response ‚îÇ


1. App pushes a task to the queue (e.g., send email).
2. Celery worker picks up the task.
3. Worker processes the task and marks it complete.
4. Django remains responsive to other users.



üïí Bonus: Task Scheduling
Celery can run periodic (cron-like) jobs:
- Run cleanup every day at midnight
- Rebuild cache every 6 hours
- Send weekly reports

This is done using Celery Beat (a scheduler that kicks off tasks based on a defined interval).





Codes and Other Notes in this Discussion: 

Processing images and videos
Generating reports 
Sending emails
Running machine learning models 





üìå Key Takeaways:
‚úî Celery enables running tasks asynchronously, outside the main Django process  
‚úî Great for heavy, blocking, or scheduled tasks  
‚úî Frees up Django to continue handling user requests instantly  
‚úî Makes your app more responsive, scalable, and robust



