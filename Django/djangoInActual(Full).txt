

The course is concentrated on teaching you to build production-grade backends.


Prerequisites:
--------------
For starters, you need to know Python. You need to know the basics of Python, as well as object-oriented programming concepts such as classes, inheritance, polymorphism, and so on. You should also know the basics of relational databases, so you should be familiar with concepts such as tables, columns, primary and foreign keys, relationships, and so on.


Here we're talking about using Python and Django to build and deploy the back-end for an e-commerce application (say like Amazon)





What is Django?
---------------
Django is a free and open source framework for building web applications with Python. 
It's not the only web framework for Python, but it's the most popular one. Because it helps us build a website in less time with fewer lines of code. That's why a lot of companies like YouTube, Instagram, Spotify, and Dropbox use Django in their tech stack.

Django is what we call a batteries included framework, which means It comes with a lot of features out of the box, so we don't have to code them from scratch.

The Feature includes: 
admin interface(admin interface for the database for managing our data), which is a huge time saver.
It also has an object relational mapper or ORM that abstracts the database so we can query or persist data without writing a lot of SQL code. 
It also comes with an authentication package for identifying users. It also has a package for caching data and much, much more. 

So, since Django offers all these amazing features, we can focus on our application and its requirements. We don't have to reinvent the wheel and code all these features from scratch. 

If ever you come up with Django is a piece of crap because it's old and bloated with so many features. Well, saying a framework is better than Django because it's faster is kind of like saying a Ferrari is better than a truck, because it's faster. What if you want to move something? You're not going to use your Ferrari for that, right? So a wise software engineer doesn't pick up a framework merely based on its performance. There are so many other things you need to take into account like the maturity of the framework, how stable it is from one version to another, its learning curve(difficulty), the size of the community and so on.


Django has been around for a long time and it has a huge community. So there are tons of Django packages built by the community that you can reuse in your applications. Also, If you get stuck, there's always someone out there to help you. 


Now, Regarding Django features. yes, Django comes with a lot of features, but you don't have to use or even learn all of them, because all these features are optional.





How the Web Works?
------------------
So, Django is a framework for building web applications with python.

Now, let's talk about some of the fundamental concepts you need to understand to build web applications. 
Let's say we're going to build an online store and publish it at 'dancooper.com'. Now this website is going to have two parts or two applications. A frontend and a backend. The frontend is the part that is loaded inside a web browser on a client machine. It's the part that the user sees and interacts with(also referred as UI). The backend is the part that runs on a web server and is responsible for data processing, validating business rules, and so on. 

Now let's imagine that Alice wants to visit our website. So she points her browser to 'dancooper.com'. This address is also called a URL, which is short for Uniform Resource Locator. It's basically a way to locate a resource on our internet. A resource can be a webpage, an image, a video, a PDF, and so on. So Alice types 'dancoop.com' in her browser and presses enter. At this moment, her browser sends a request to the web server that hosts our website and says, "hey, Alice wants to see the homepage". So,  the web server should take this request, process it, and return a response back to the client. This data exchange is defined by a protocol called HTTP, which is short for Hypertext Transfer Protocol. It defines how clients and servers can communicate. So this is the big picture. As Alice navigates our website, for each page, her browser sends an HTTP request to the server and receives an HTTP response. 


Front End (client) <----------> Back End (Server)


Client --- Request ----> Server

Client <-- Response ---- Server

The Response can be html, or can be only the data that is needed to build the webpage

Now, as part of building the backend for this website, we need to decide how we're going to respond to clients. One option is to generate the requested page on the server and return it to the client. We can use HTML for that. HTML is short for hypertext markup language. It's a simple language for representing web pages and their content. Every web page we have seen on our internet is built using HTML. So, one option is to generate the page on the server and return an HTML document to the client. The other option is to return only the data needed on the requested page and have the client generate the page. So instead of putting a complete page or a complete HTML document in an HTTP response, we only return the data like the list of products. 
Now, what is the difference? Well, if we push this responsibility to the client, we can free up the server so it can serve more clients. Our application will be more scalable. That's why over the past few years, this approach has become more trendy and is now considered the industry best practice. These days, we have tools like React, Angular, and Vue for generating web pages on the client. These are all client-side tools that are used by front-end developers. In contrast, we have server-side tools for building backends. Django falls in this category, so you should not compare Django with, let's say, React. You may compare Django with other server-side frameworks like ASP.NET Core, which is used by C# developers, Express, used by JavaScript developers, and so on. 

So,  if we push the responsibility of generating web pages to the client, the server essentially becomes a gateway to the data. On the server, we can provide endpoints that the client can talk to to get or save various pieces of data. For example, we can provide one endpoint to get the list of products and another endpoint to get the list of orders someone has placed. Now, all these endpoints together represent the interface that clients use to talk to the server. In technical terms, we say the server provides an API or an application programming interface to clients. This API is essentially like the buttons on a remote control. All these buttons together represent the interface or the API we use to interact with the TV.

So in this course, our focus will be on using Django to build an API for our online store. Client applications can use this API to get or save the data. How these clients are built is irrelevant here. We can use React, Angular, or even plain JavaScript. That falls under front-end development, which has nothing to do with Django. Once we build this API, if you know front-end development, you can always build a client app that talks to this API. 





Some of the concepts redefined below:
-------------------------------------
1. Gateway:
A server acting as an intermediary between a client (e.g., web browser or mobile app) and stored data. It processes requests, retrieves necessary information, and responds accordingly—functioning as a bridge between client and server.


2. Endpoint:
A designated URL or path on the server where clients interact with specific resources. Examples from an e-commerce platform:
- /products – Retrieve a product list
- /orders – Fetch order details
- /users – Access user information


3. API (Application Programming Interface):
A collection of endpoints that enable interaction with a server, akin to a remote control with buttons (endpoints) for different functionalities.


Real-World Example – Amazon:
- Gateway: The Amazon server facilitates data access when users browse products or place orders.
- Endpoints: Specific paths enable different actions:- /products – Fetch product details
- /orders – Retrieve order history
- /cart – Update cart items

- API: The full set of endpoints that allow client-server interactions for shopping, ordering, and account management.


RESTful APIs:

REST (Representational State Transfer):
An architectural style for networked applications based on these principles:
- Stateless: Each request contains all necessary information; the server does not retain client context.
- Client-Server: Separate entities interact over a network.
- Uniform Interface: Standardized HTTP methods (GET, POST, PUT, DELETE).
- Resource-Based: Everything is treated as a resource with unique identifiers (URLs).


RESTful API:
An API adhering to REST principles, enabling clients to interact with server resources via standard HTTP methods.
Example – Amazon API:

/products
	GET – Retrieve available products
	POST – Add a new product (admin use)

/orders
	GET – View order history
	POST – Place a new order

/users
	GET – Retrieve user details
	PUT – Update account information


Example Request and Response:

GET /products HTTP/1.1  
Host: api.amazon.com  

Response (JSON format):
[
  { "id": 1, "name": "Laptop", "price": 999.99 },
  { "id": 2, "name": "Smartphone", "price": 499.99 }
]



Process Flow:
Website Interaction Example – Amazon:
1. User Inputs URL: The browser sends a request (e.g., amazon.com).
2. DNS Lookup: Resolves domain to an IP address.
3. Browser Sends HTTP Request: Requests the homepage.
4. Server Processes Request: Retrieves necessary content.
5. Server Sends Response: Returns HTML, CSS, and JavaScript.
6. Browser Renders Page: Displays content and loads additional resources as needed.



API Request Flow:
1. Client Sends API Request: Example:GET /api/products HTTP/1.1  
Host: api.amazon.com  

- API Server Processes Request: Identifies endpoint, retrieves data.
- Server Responds with JSON: Sends structured data.
- Client Processes Response: Uses data for UI updates.


API Infrastructure:
API Server: Hosts the API, handling requests and managing data.
API Endpoints: Specific URLs facilitating interactions.
Example – Amazon API:
- API Server: Amazon's infrastructure manages client requests.
- Endpoints: Paths for various operations:- /api/products – Retrieve product data
- /api/orders – Fetch order details
- /api/users – Access user account information


An API Server is a backend system that processes incoming API requests from clients (such as web applications, mobile apps, or other services). It is responsible for:
- Handling Requests: Accepting client requests, processing them, and sending responses.
- Managing Data: Retrieving, modifying, or storing data in databases.
- Enforcing Security: Authentication, authorization, and data validation to ensure secure access.
- Ensuring Scalability: Handling multiple concurrent requests efficiently.
- Implementing Business Logic: Executing operations based on the requested action (e.g., fetching user details, processing transactions).


Example – Amazon API Server
Amazon’s API server manages e-commerce functionalities:
- API Request: A client application sends a request to api.amazon.com.
- API Server Processes: It verifies user authentication, retrieves requested products, and applies business rules.
- API Response: The server sends back the relevant data (e.g., a list of products in JSON format).







Setting Up the Development Environment:
---------------------------------------

install python 

check python version in the terminal/cmd prompt:  python --version


steps to create virtual environment: 

1. Navigate to your project directory: cd /path/to/your/project

Install virtualenv (if needed):
If you're using Python 3.3 or later, you already have the built-in venv module. But if you prefer virtualenv, install it with: pip install virtualenv

2. Create the virtual environment: python -m venv venv
	This creates a folder named venv containing the virtual environment.
	Replace venv with any name you prefer
3. Activate the virtual environment:
	On macOS/Linux: source venv/bin/activate
	On Windows (Command Prompt): venv\Scripts\activate
	On Windows (PowerShell): .\venv\Scripts\Activate.ps1
4. Install your dependencies: pip install -r requirements.txt
	Or install packages manually: pip install <package-name>
5. Deactivate the environment when done: deactivate

Also, install the python extension for visual studio code, because with this you get features such as intellisense, debugging, code navigation and so on. 



Difference between virtualenv and built-in venv:
------------------------------------------------
Both virtualenv and the built-in venv module are used to create isolated Python environments, but there are some key differences:

1. Availability:
	venv is built into Python (since version 3.3), so you don’t need to install anything extra.
	virtualenv is a separate package, meaning you have to install it manually with pip install virtualenv.

2. Feature Set:
	virtualenv supports more customization, including options to work with different Python versions.
	venv is simpler and lacks some of the extra features virtualenv offers, but is sufficient for most standard use cases.

3. Compatibility:
	virtualenv works with older Python versions (including Python 2), making it more versatile.
	venv is designed specifically for Python 3, so it won’t work with Python 2.

4. Speed:
	virtualenv is generally faster because it includes optimizations to speed up environment creation and activation.
	venv works well but might be a bit slower in comparison.

5. Package Management:
	virtualenv creates environments that come with pip automatically installed.
	venv might require you to install pip manually in some cases.

Which One Should You Use?
If you’re working with Python 3 and don’t need extra features, venv is simple and efficient. But if you need more flexibility, support for older versions, or extra options, virtualenv is a better choice.



pipenv and its comparison with venv:
------------------------------------
What is pipenv?

pipenv is a tool that combines package management (pip) and virtual environment management (venv) into one streamlined workflow. It simplifies dependency management by:
Automatically creating and managing a virtual environment.
Using a Pipfile (instead of requirements.txt) to track dependencies.
Handling dependency resolution better than pip.
Offering built-in security checks for installed packages.


Also, from the source - codewithmosh: 

pipenv is basically a dependency management tool for installing our application dependencies in virtual environments. This way, our application dependencies will not clash with other applications dependencies

Difference Between pipenv and venv
Feature	                     venv	                                        pipenv
Purpose	                     Creates isolated environments	                Manages dependencies and environments
Dependency File	             No built-in file (you use requirements.txt)	Uses Pipfile and Pipfile.lock
Package Installation	     Requires manual pip install commands	        Automatically installs dependencies when activating the environment
Dependency Management	     No automated dependency resolution	            Automatically resolves dependencies to avoid conflicts
Security	                 No built-in security checks	                Runs safety checks on dependencies


Which One Should You Prefer?
	Use venv if you just need a simple virtual environment without extra features.
	Use pipenv if you want better dependency management, automatic virtual environment handling, and a cleaner project structure.

If you work on larger projects or need strict dependency resolution, pipenv is great. But if you prefer simplicity and direct control, venv is a solid choice.


Setting up pipenv:
Unlike venv, pipenv combines virtual environment and package management.

Step 1: Install pipenv
First, install pipenv using:
pip install pipenv

Step 2: Create and Activate a Virtual Environment
Navigate to your project folder and run:
pipenv install
This will: ✅ Create a virtual environment automatically ✅ Generate a Pipfile for managing dependencies

Step 3: Install Dependencies
Instead of using pip, install packages like this:
pipenv install requests

Step 4: Activate the Virtual Environment
To enter the virtual environment, use:
pipenv shell

Step 5: Deactivate the Virtual Environment
Exit the environment using:
exit








Creating Your First Django Project: 
-----------------------------------

cd Desktop
mkdir storefront
cd storefront
pipenv install django 

This will create a Virtual environment and then install Django in that environment 

How Does the Virtual Environment Look?
Pipenv stores virtual environments outside the project directory to keep things clean. You won’t see a direct venv folder inside your project. Instead, it places the environment in a location managed by your system.

To find the virtual environment's path, run:
pipenv --venv

It will output something like:
/home/user/.local/share/virtualenvs/project-name-abc123/


Activates the Virtual Environment:
When you run 'pipenv shell', it opens a new shell session inside that environment, meaning all installed packages (like Django) are available.

Adjusts Environment Variables:
pipenv shell modifies your terminal’s settings so that Python and pip use the virtual environment’s isolated environment rather than the system Python.

Allows Access to Django & Other Packages:
Once inside the shell, you can check if Django is installed:
python -m django --version

You can also start a Django project:
django-admin startproject myproject


How Is This Different from Regular venv?
With venv, you manually activate the environment using:
source myenv/bin/activate

Whereas with pipenv, pipenv shell handles activation automatically and ensures dependencies are properly managed with Pipfile.



In addition to that pipenv will create two files in the storefront directory 'Pipfile' and 'Pipfile.lock'

Pipfile:
Acts as a replacement for the traditional requirements.txt file.
Stores all declared dependencies for your project.
Helps organize package dependencies into two categories:
	[packages] → Regular dependencies (e.g., requests, numpy).
	[dev-packages] → Development dependencies (e.g., testing tools like pytest).

Example Pipfile:

[packages]
requests = "*"
flask = "^2.0"

[dev-packages]
pytest = "^7.0"


Pipfile.lock:
Locks the exact versions of installed dependencies.
Ensures consistent environments across different setups.
Stores checksum hashes to verify package integrity.

Example snippet from Pipfile.lock:

json
{
    "default": {
        "requests": {
            "version": "2.27.1",
            "hashes": [
                "sha256:abc123..."
            ]
        }
    }
}

Whenever you install or update packages, pipenv updates the Pipfile.lock, keeping dependencies consistent across different machines.

Why Are They Useful?
✅ Pipfile makes dependency management cleaner 
✅ Pipfile.lock ensures reproducibility, avoiding conflicts 
✅ It prevents unexpected version mismatches when sharing projects



Now, as we discussed, back to the terminal window inside the storefront directory, we need to activate this particular virtual environment where pipenv created. So we'll use the Python interpreter inside this virtual environment, not the one that is installed globally on your machine. To do that, we're going to run 'pipenv shell'
 


django-admin startproject my_proj   (or) 
django-admin startproject my_proj . (tells django to use current directory as project Directory)
cd my_proj

Note: 

The django-admin utility command is a powerful tool that comes with Django, helping developers manage Django projects efficiently. It provides various commands for tasks like creating new projects, running the development server, managing database migrations, and interacting with Django apps.

manage.py --> This is a wrapper around Django-admin

So, Going forward, inside our project, we'll using 'manage.py' instead of 'django-admin'. The reason for this that 'manage.py' takes the settings of this project into account.

For eg., one of command that django-admin has is 'runserver'

But if we do so, django-admin runserver --> we get an error saying 'Requested setting DEBUG but settings are not configured'. Because at this point, Django admin doesn't know about the settings of our project. Instead of Django admin, we're going to run 'Python manage.py', which you can see the same commands that Django admin provides. 

So, you can run the application by, 
python manage.py runserver 9000 (optionally, we can supply the port number, by default it will take port 8000) 

Here at this point you won't get error as when you do django-admin, because 'manage.py' knows about the settings of our project



What is a Wrapper?
A wrapper is essentially a layer that simplifies or enhances functionality. In programming, wrappers are often used to make commands more user-friendly or project-specific. manage.py wraps django-admin to ensure Django commands work within your specific project.


Difference Between manage.py and django-admin:
Feature	         manage.py	                                 django-admin
Scope	         Project-specific	                         Global (works outside a project)
Purpose	         Helps manage a Django 
                 project with correct settings	             General Django utility tool
Configuration	 Uses the project's settings.py file	     Doesn't automatically use a project's settings
Usage	         Run commands from inside a Django project	 Works globally for creating Django projects or general tasks


When to Use Each?
✅ Use django-admin when working outside a project, like creating a new one:
django-admin startproject myproject


✅ Use manage.py when working inside a Django project, since it ensures the correct settings are applied:
python manage.py runserver
python manage.py migrate





Using the Integrated Terminal in VSCode:
----------------------------------------
ctrl + ~
to select the interpreter: ctrl + Shift + p --> Python: Select Interpreter --> 

you can the select the interpreter you want. or if you have been using the pipenv, you can choose the python related to that pipenv

To do that:
pipenv --venv    --> generates the path
select 'Enter the interpreter path'   --> path + /bin/python


Also, in the storefront directory, you'll have extra directory '.vscode', there we have '{..}settings.json' file, where python interpreter path is defined
{
	"python.pythonPath" : "/users/moshfeghhamedani/............

}



quick note: 
Sometimes, when running the 'runserver' command, you might get a syntax error saying invalid syntax. This happens every now and then when VS Code fails to activate the virtual environment for this project. To solve this problem, all you have to do is open a new terminal window



Creating Your First App:
-----------------------
So, every Django project is essentially a collection of various apps, each providing certain functionality. Just like the apps on your mobile phone, each app provides a certain functionality, right? Django projects are also exactly the same.

In the settings.py of projects core folder:
Every Django project by default includes these default apps, together we can add our own custom apps.

INSTALLED_APPS = [
    "django.contrib.admin",   # Admin interface
    "django.contrib.auth",    # Authentication system
    "django.contrib.contenttypes",  # Content type framework
    "django.contrib.sessions", # Session management
    "django.contrib.messages", # Messaging framework
    "django.contrib.staticfiles", # Static file handling

    # Custom apps
    "blog",  # Example of a user-created app
    "store", # Another user-defined app
]

INSTALLED_APPS is an important setting in Django's settings.py file that defines the list of applications that Django should recognize and use in a project. It determines which Django apps are active and available for use.

It is a list of strings, where each string represents a Django app.
Includes both Django’s built-in apps and custom apps created for the project.
Controls which apps Django loads into the project for database models, middleware, signals, and other features.


Built-in Apps Explained:

Django comes with several built-in apps, each serving a specific purpose:

django.contrib.admin = Provides the Django Admin interface to manage models.
django.contrib.auth = Manages user authentication, groups, and permissions.
django.contrib.contenttypes = Enables generic relationships between models.
django.contrib.sessions = Handles session management for user data storage. (Admin app is dependent on the sessions app, don't try to delete it) 
django.contrib.messages = Enables messaging framework (for sending notifications in templates). (is used for displaying one time notifications to the user)
django.contrib.staticfiles = Manages static files like CSS, JavaScript, and images.

Why is INSTALLED_APPS Important?
✅ Determines which apps are active in the project 
✅ Ensures database models are registered 
✅ Allows Django to load configurations for each app 
✅ Helps define third-party apps (e.g., django-rest-framework, django-debug-toolbar)


To create a new app: 
-------------------
python manage.py startapp app_name

Note : Once you created a new app, you have to register the app in the 'INSTALLED_APPS' in the project settings folder

for example:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]










Structure of Django project and APP:
------------------------------------
When you create a Django project using django-admin startproject myproject, it generates a directory inside the project folder with the same name (myproject). This inner directory is the core of the application, containing essential configurations for Django.

Project Structure Overview

After running:
django-admin startproject myproject

Your directory will look like this:

myproject/       ← Project root
│
├── manage.py    ← Command-line utility for project management
├── myproject/   ← Inner directory (Django project settings & configurations)
│   ├── __init__.py   ← Marks this directory as a Python package
│   ├── settings.py   ← Project settings & configurations
│   ├── urls.py       ← URL routing for the project
│   ├── asgi.py       ← ASGI configuration (for async applications)
│   ├── wsgi.py       ← WSGI configuration (for deployment)


Detailed Explanation of Each File:

🔹 manage.py:
A command-line tool to interact with the project.
Used to run the development server, create apps, handle migrations, etc.
Example usage:
python manage.py runserver


🔹 __init__.py
An empty file marking the directory as a Python package.
Enables Django to treat myproject/ as a module.


🔹 settings.py
Most important file—contains all Django configurations.
Defines:
	Installed apps (INSTALLED_APPS)
	Middleware (MIDDLEWARE)
	Database settings (DATABASES)
	Static files, templates, security options, and more.
Example:
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "myapp",  # Custom app
]


🔹 urls.py
Defines URL routing for the project.
Maps URLs to views using the urlpatterns list.
Example:
from django.urls import path
from myapp import views

urlpatterns = [
    path("home/", views.home, name="home"),
]


🔹 asgi.py
Configuration for Django’s ASGI server (for handling async requests).
Used in production setups requiring real-time capabilities (WebSockets, async APIs).


🔹 wsgi.py
Configuration for Django’s WSGI server (for traditional deployments).
Used when hosting Django on platforms like Apache or Gunicorn.


Summary
✅ Outer myproject/ → Contains manage.py (entry point for commands). 
✅ Inner myproject/ → Holds Django settings, URLs, WSGI/ASGI configs. 
✅ settings.py → The heart of the project, controlling configurations. 
✅ urls.py → Defines how URLs map to views. 
✅ manage.py → Used for running and managing the project.



App structure:
--------------
command: 
python manage.py startapp myapp

Django generates a directory (myapp/) containing several files that define the structure of your app. This folder helps organize everything related to your app, including models, views, templates, and more.

Django App Folder Structure:

myapp/            ← App directory
│
├── __init__.py   ← Marks this folder as a Python package
├── admin.py      ← Configuration for the Django admin panel
├── apps.py       ← Configuration for the app within Django settings
├── models.py     ← Defines database models
├── views.py      ← Handles request processing & response logic
├── tests.py      ← Contains test cases for the app
├── urls.py       ← Manages routing within the app (must be created manually)
├── migrations/   ← Tracks database changes for models
│   ├── __init__.py  
│   ├── 0001_initial.py  ← Auto-generated migration files



🔍 Explanation of Each File
🔹 __init__.py
Marks myapp/ as a Python package.
Enables Django to treat it as a module.


🔹 admin.py
Used to register models so they appear in Django’s admin interface.
Example:

from django.contrib import admin
from .models import Post

admin.site.register(Post)


🔹 apps.py
Defines app configurations.
This is where we configure this app. Here the name is misleading. I don't know why Django developers decided to call this module 'apps', it would be better if it was called 'config'
Example:
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "myapp"
	
	
🔹 models.py
Defines database models using Django’s ORM.
Models module is where we define the model classes for this app. We use model classes to pull out data from the database and present to the user.
Example:
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
	
	
🔹 views.py
Handles business logic and returns responses.
Again, the name is misleading. This is not the view that you think, if you havecome from a front-end development background. So, What they mean here is essentially a request handler. It's not a view which has a template or HTML in other frameworks. 
Example:
from django.http import HttpResponse

def home(request):
    return HttpResponse("Welcome to MyApp!")


🔹 urls.py (Must be manually created)
Manages routing for the app.

Example:
from django.urls import path
from . import views

urlpatterns = [
    path("", views.home, name="home"),
]


🔹 tests.py
Contains unit tests for the app.

Example:
from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_math(self):
        self.assertEqual(2 + 2, 4)


🔹 migrations/
Tracks database schema changes.

Auto-generated files when running:
python manage.py makemigrations
python manage.py migrate


📌 Summary
✅ models.py → Defines the database 
✅ views.py → Handles requests 
✅ urls.py → Manages routing 
✅ admin.py → Registers models for Django admin 
✅ apps.py → Configures the app 
✅ migrations/ → Manages database changes 
✅ tests.py → Helps in testing


Every time you create an app, you need to register it in the INSTALLED_APPS of project's 'setting.py' module

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'playground'
]


views.py and urls.py:
--------------------
HTTP is a request response protocol. So, every data exchange involves a request and a response. Every app has 'views.py' and this is where we define our views or view functions. A view function is a function that takes a request and returns a response. So more accurately, it's a request handler. In some frameworks, it's called an action. In Django, it's called a view. But I don't agree with this name because from an architectural point of view, a view is often associated with something that the user sees. But that part in Django is called a template. 

Now in this function, we can do anything we want. In a real-world scenario we can pull data from a database, we can transform data, we can send emails and so on. For now, let's just return a simple response.

apps --> view.py:

from django.http import HttpResponse

def say_hello(request):
	return HttpResponse('Hello World')


Now we need to map this view to url, so when we get a request at that url, this function will be called.


let's say whenever we send a request to 'playground/hello', our view function should be called and return 'Hello World' to the user.

apps --> urls.py:	
	
from django.urls import path
from . import views

#URLConf
urlpatterns = [
    path('hello/', views.say_hello)
 ]	
	

Note: we have 'urlpatterns' variable(all in lower case), which is an array of url pattern objects, we use path() function to create a url patter object

The parameters of path function --> (route: str, view: (*args: Any, **kwargs: Any) -> HttpResponse, kwargs: Dict[str, Any] = ...) -> URLPattern

Now, what we have here is URLConf module, which basically means URL Configuration. So, every app can have its own URL Configuration. But now we need to import this URL Configuration into the main URL Configuration for this project

	
projects --> urls.py:

use the include function from django.urls

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
   path('admin/', admin.site.urls),
   path('playground/', include('playground.urls'))
  ]

So, if the user sends the request to 'playground/hello', Django knows that all requests that start with playground should be handled by the playground app. So it's going to chop off the first part of this URL 'playground/' and Pass the rest 'hello' to the URL configuration module in the playground app. 










Using Templates:
----------------
So, I told you that views in Django are not really views. They're more like request handlers or actions. What we often call a view in other frameworks is called a template in Django.

Add templates folder in any app and then html file inside (say templates/hello.html)

Then in views.py:

from django.shortcuts import render

def say_hello(request):
	return render(request, 'hello.html') 
	

Note: render returns a HttpResponse object

we can also dynamically render the content, we just need to add another parameter which provides the context 
return render(request, 'hello.html', {'name': 'Mosh'})  --> now you have name parameter in the html content. For more details learn jinja template engine or django template engine








Django Debug toolbar:
---------------------


1. launch.json
2. select Django

understand Run and Debug in Visual Studio code 

to run the application without debugging --> ctrl + F5





Using Django Debug Toolbar:
---------------------------

There is another way to debug django applications using a powerful tool called Django Debug Toolbar.

The official documentation: 
https://django-debug-toolbar.readthedocs.io/en/latest/

Follow the instruction in the Installation page:


Note: 
The Django Debug Toolbar should appears only when we return proper HTML document.

i.e. in proper format --> starts from <html></html>










Building a Data Model: 
---------------------

Introduction to Data Modeling: 
------------------------------
Understanding Data Entities in a Django-Based E-Commerce Application:
The foundation of any Django project begins with identifying the pieces of data we need to store. In an e-commerce application, we must first define essential entities and their relationships.

Primary Entities:
1. Product – Represents an item available for purchase, with attributes like:
	title (name of the product)
	description (details about the product)
	price (cost of the product)
	inventory (stock availability)

2. Collection (or Category) – Groups products into different categories like shoes, beauty products, or fruits, with attributes like:
	title (name of the collection/category)



Defining Relationships:

One-to-Many Relationship:
Each product belongs to one and only one collection
A collection can have multiple products

Optional Relationship (Featured Product):
A collection can have zero or one featured product
This helps highlight a product in that collection

Additionally, every entity inherently has an id attribute, which Django automatically generates.



Below is a simple entity-relationship diagram illustrating these relationships:

[Collection] 1 ---- * [Product]
      |
      | (0 or 1)  
      v  
 [Featured Product]



Your Turn!
Take a moment to identify five more essential entities in an e-commerce application, considering attributes and relationships. Keep it simple—no need to create an overly detailed diagram!






Building an E-commerce Data Model:
----------------------------------

Data Modeling for an E-Commerce Application in Django:
When designing an e-commerce application, we must define key entities, attributes, and relationships between them. The structure should always align with the requirements of the application rather than arbitrary decisions. Below are the primary entities and relationships required for an efficient e-commerce system.

Entities and Their Attributes:
1. Product
	title (name of the product)
	description (details about the product)
	price (cost of the product)
	inventory (available stock)

2. Collection (or Category) (Optional: Depending on whether products belong to multiple collections)
	title (name of the category)
	Relationships:
		A product belongs to one collection and a collection can contain multiple products (One-to-Many).
		Alternatively, a product can belong to multiple collections and a collection contains multiple products (Many-to-Many).

3. Shopping Cart:
	created_at (timestamp of cart creation for cleanup purposes)
	Relationships:
		A cart can contain multiple products, and a product might be in multiple carts (Many-to-Many).

4. Cart Item (Association Class for Cart-Product Relationship):
	quantity (number of instances of the product in the cart)
	Relationships:
		A cart item belongs to one cart, while a cart can contain multiple items (One-to-Many).
		A cart item represents one product, while a product might appear in multiple cart items (One-to-Many).

5. Customer (Optional, since carts can be anonymous):
	name
	email
	Relationships:
		A customer can place multiple orders, but each order belongs to one customer (One-to-Many).

6. Order:
	placed_at (timestamp of order placement)
	Relationships:
		A customer can place multiple orders (One-to-Many).
		An order contains multiple products, and a product can appear in multiple orders (Many-to-Many).

7. Order Item (Association Class for Order-Product Relationship)
	quantity (number of instances of the product in the order)
	Relationships:
		An order item belongs to one order, while an order contains multiple order items (One-to-Many).
		Each order item represents one product, while a product might appear in multiple order items (One-to-Many).

8. Tag (Additional classification for products)
	title (tag name)
	Relationships:
		A product can have multiple tags, and a tag might be referenced by multiple products (Many-to-Many).



Entity-Relationship Diagram:

[Product] * ---- * [Cart]  
             |  
             | (Tracks product quantity) cartitem 
             V	  
[Product] 1 ---- * [CartItem]      [CartItem] * ---- 1 [Cart]



[Customer] 1 ---- * [Order]  



[Product] *  ----  *[Order]  
              |  
              | (Tracks Order quantity) cartitem 
              V	  
[Product] 1 ---- * [OrderItem]      [OrderItem] * ---- 1 [Order]



[Product] * ---- * [Tag]  


This refined explanation provides a clear structure for understanding Django data models in an e-commerce application.


What is an Association Class?
An association class is a special type of class that represents a relationship between two entities and contains attributes specific to that relationship.


Does an Association Class Only Come in Many-to-Many Relationships?
No, but it’s most commonly seen in many-to-many relationships because many-to-many relationships often require additional information beyond just linking two entities.
However, an association class can exist in other types of relationships too if the relationship itself has attributes that need to be stored.


Why Do Many-to-Many Relationships Need an Association Class?
A simple many-to-many relationship between two entities (e.g., Products and Tags) can usually be represented with a linking table.

But what if the relationship itself has attributes? That’s when we need an association class.

Example: Shopping Cart Scenario

Consider the relationship between Carts and Products:
	A Cart can contain multiple Products.
	A Product might be in multiple Carts.
	This is a many-to-many relationship.

Now, we need an attribute specific to this relationship — 'Quantity' (how many units of a product are inside a cart).

How Do We Solve This?
1. Instead of linking Cart directly to Product, we introduce a CartItem entity.
2. CartItem represents the relationship and contains the extra attribute quantity.
3. Now, instead of a single many-to-many link, we have two one-to-many relationships:
	A Cart can have multiple CartItems, but each CartItem belongs to one Cart.
	A Product can be referenced by multiple CartItems, but each CartItem points to a single Product.


Alternative Cases Where Association Classes Exist in Non-Many-to-Many Relationships:
While association classes are most common in many-to-many relationships, they can also appear in one-to-many or one-to-one relationships when the connection itself has attributes.

Example: Employment Records

Imagine a Company and its Employees:
	A Company employs multiple Employees (One-to-Many).
	Each Employee works for one Company.
	However, we may want to store an attribute about the relationship, such as hire_date.

Instead of just linking Company and Employee directly, we might introduce an EmploymentRecord association class, which holds:
	The company_id
	The employee_id
	The hire_date

This is an example of an association class appearing in a one-to-many relationship.

Key Takeaways:
✅ Association classes are required when a relationship needs extra attributes. 
✅ Most commonly used in many-to-many relationships, but can also exist in one-to-many or one-to-one cases. 
✅ Turns a many-to-many relationship into two one-to-many relationships for better data organization. 
✅ Provides flexibility when extra details must be stored in a connection.


Real world Examples of Association classes: 
-------------------------------------------
Association classes are widely used in various real-world scenarios where relationships between entities require additional attributes. Here are a few examples:

1. University Course Enrollment
Entities:
	Student (name, ID, email)
	Course (title, description, credits)
	Enrollment (Association Class)
		grade (the student's grade in the course)
		enrollment_date (when the student registered)

👉 A student can enroll in multiple courses, and a course can have multiple students. However, the enrollment itself needs attributes like grade and enrollment date, making Enrollment an association class.


2. Employee Job Assignment
Entities:
	Employee (name, ID, department)
	Project (name, budget, deadline)
	Assignment (Association Class)
		role (position in the project, e.g., Developer, Manager)
		hours_worked (amount of time contributed)

👉 An employee can work on multiple projects, and a project can have multiple employees, but the role and hours worked are specific to the relationship, so we introduce Assignment as an association class.


3. Online Shopping Order System
Entities:
	Customer (name, email)
	Product (title, price)
	OrderItem (Association Class)
		quantity (number of units purchased)
		discount_applied (any discount used for this item)

👉 A customer can place multiple orders, and an order can contain multiple products. However, the quantity and discount are tied to individual order-product pairs, making OrderItem an association class.


4. Movie Ticket Booking
Entities:
	Viewer (name, email)
	Movie (title, genre, runtime)
	Ticket (Association Class)
		seat_number (specific seat booked)
		price_paid (cost of ticket)

👉 A viewer can book multiple movies, and a movie can have multiple viewers. Since each ticket must track seat number and price paid, Ticket acts as an association class.


Key Takeaway:
✅ Association classes appear when relationships between entities have attributes that must be stored. 
✅ They commonly occur in many-to-many relationships, but can also exist in other types when needed.









Organizing Models in Apps:
--------------------------
Structuring a Django Project with Multiple Apps:
In Django, a project consists of one or more apps, each providing a specific functionality—similar to the apps on a phone. Each app has its own data model and serves a distinct purpose in the project.

Approaches to Organizing Django Apps:

1. Monolithic Design (Single App):
One approach is to create a single app called store and include all entities—such as Product, Collection, Customer, Shopping Cart, and Orders—within it.
✅ Advantages:
	Can be bundled and distributed via pip for reuse.
	Eliminates redundant development across multiple projects.

❌ Disadvantages:
	Becomes bloated with too many models and views.
	Hard to maintain and reuse effectively.
	Leads to a monolith—difficult to scale and update.


2. Fine-Grained App Separation (Too Many Small Apps):
An alternative is breaking down the project into several small apps:
	Products App (Manages products, collections, and tags)
	Customers App (Manages customer data)
	Shopping Cart App (Handles cart operations)
	Orders App (Manages order processing)

❌ Disadvantages:
	Creates tight coupling between apps.
	Apps depend on each other in a specific order (Products → Shopping Cart → Orders).
	Any update in Products App might break Shopping Cart and Orders Apps, requiring simultaneous updates.


3. Optimal Middle Ground (Balanced Separation)
Instead of separating highly interdependent apps, bundle related functionalities while keeping optional ones separate.
	Store App (Includes products, collections, cart, and orders)
	Tags App (Handles tagging functionality separately)

This approach ensures that:
✅ Store functionality is self-contained (Products, Cart, and Orders work together).
✅ Tags are independent (Tagging might apply to products, blog posts, videos, etc.).
✅ Apps can be reused independently without breaking dependencies.


Guiding Principles for Django App Design:
1. Avoid a Monolithic Structure – Too many features in one app make it hard to maintain.
2. Minimize Tight Coupling – Apps should not depend too much on each other.
3. Ensure High Cohesion – Each app should focus on one piece of functionality while including everything needed for that functionality.


Creating the Apps in Django:
To set up the Store and Tags apps, run:

python manage.py startapp store  
python manage.py startapp tags  


Then, register these apps in Django’s settings:

INSTALLED_APPS = [
    'store',
    'tags',
    ...
]
With this structure, each app is modular, reusable, and maintainable, making future development smoother.



Some real-time examples where middle ground is involved: 
--------------------------------------------------------
In the context of Django apps, finding the middle ground means designing a structure that balances maintainability, modularity, and low coupling. Here are real-world Django app examples where this principle is applied:

1. E-Commerce App Structure:
Imagine you're building an e-commerce platform.
	Monolithic Approach: All functionalities—products, shopping cart, orders, and payments—are in a single store app, making it hard to maintain.
	Overly Fragmented Approach: Each feature (products, cart, orders, payments) is a separate app, leading to complex interdependencies.

✅ Middle Ground:
A store app (manages products, collections, cart, orders).
A separate tags app (manages tagging functionality for products).
A payments app (handles transactions, keeping financial logic separate).

👉 This ensures reuse, modularity, and maintainability while keeping key functionalities together.



2. Content Management System (CMS) with Blog and Comments:
A CMS typically has features like articles, comments, categories, and tags.
	Monolithic Approach: One giant app manages everything, making customization difficult.
	Overly Fragmented Approach: Each feature (articles, comments, categories, tags) is a separate app, increasing dependencies.

✅ Middle Ground:
A blog app (manages articles, categories).
A comments app (handles commenting, so it can be reused for different types of content).
A tags app (optional tagging system that can work for articles, images, and other content).

👉 This makes the system modular yet cohesive.



3. Social Media Platform (Users, Posts, Messaging):
A social media platform contains user profiles, posts, likes, messaging, and notifications.
Monolithic Approach: Everything is lumped into a single app, reducing scalability.
Overly Fragmented Approach: Individual apps for users, posts, likes, messaging, notifications create complex dependencies.

✅ Middle Ground:
A users app (manages authentication, profiles).
A posts app (handles user-generated content).
A messaging app (for direct user communication).
A notifications app (alerts for likes, comments, messages).

👉 This allows independent development of messaging while keeping posts and notifications closely related.



Guidelines for Finding the Middle Ground in Django Apps
📌 Keep related functionalities bundled together to avoid excessive dependencies. 📌 Separate features only when they are reusable across different projects (e.g., tags, payments, notifications). 📌 Ensure apps are self-contained, meaning they work independently without forcing unnecessary installations.








Creating Models:
----------------
django field types: https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field types, Field Options
you can check for what field type and field option we need to mention for a particular field 

models.py:

from django.db import models

class Product(models.Model):
	title = models.charField(max_length=255) #varchar(255)
	description = models.TextField() 
	price = models.DecimalField(max_digits=6, decimal_places=2) # floatfield has round issues, so for monetary values always use decimal field  #9999.99
	inventory = models.IntegerField()
	last_update = models.DateTimeField(auto_now=True)
	
Now when we finished writing models for each entities, we need to migrate, then you will see that we can generate our database tables based on the definition of this model. So then we're going to have a table called 'product' and in that table we're going to have a column called 'title' and the type of that column is going to be varchar of 255. 


class Customer(models.Model):
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)


Now you might be curious why don't we have an ID field in any of these classes. Because as I said earlier, Django creates it for us automatically. So every entity or every model class is going to have an ID field which is going to be a primary key. But what if we don't want to have an ID field? What if in this product class, we need a field called SKU and this is going to be our primary key. 

So, if we want some random field to be a primary key instead of one generated by django itself,
sku = models.CharField(max_length=10, primary_key=True)

With this Django is not going to create an ID field and make it the primary key. 'sku' is going to be our primary key. 







Choice Fields:  
--------------
Sometimes we need to limit the list of values that can be stored in a field. For that you can use the 'choices' parameter 


https://docs.djangoproject.com/en/5.1/ref/models/fields/ --> Field Options --> Choices


MEMBERSHIP_CHOICES = [
		('B', 'Bronze'), 
		('S', 'Silver'), 
		('G', 'Gold'),
	]
Here in the tuple, the first value is the actual value that we're storing in the database. And the second value is a human readable name
This human readable name will be used in the admin interface.

class Customer(models.Model):
	MEMBERSHIP_BRONZE = 'B'
	MEMBERSHIP_SILVER = 'S'
	MEMBERSHIP_GOLD = 'G'
	
	MEMBERSHIP_CHOICES = [
		(MEMBERSHIP_BRONZE, 'Bronze'), 
		(MEMBERSHIP_SILVER, 'Silver'), 
		(MEMBERSHIP_GOLD, 'Gold'),
	]
	first_name = models.CharField(max_length=255)
	last_name = models.CharField(max_length=255)
	email = models.EmailField(unique=True)
	phone = models.CharField(max_length=255)
	birth_date = models.DateField(null=True)
	membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
	

Tomorrow if we have decided to change the value 'B' to something else. Then there are two places, we have to modify(in default, in MEMBERSHIP_CHOICES). So the best practice is to define these values separately, like MEMBERSHIP_BRONZE, MEMBERSHIP_GOLD, MEMBERSHIP_SILVER
 

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)










Defining one-to-one Relationships:
---------------------------------
Assume that every customer should have one address, and each address should belong to one customer. So, here we have one-to-one relationship between customers and addresses.

As you probably know, a database relationship has two ends, a parent and a child. The parent should exist before we can store the child. Here in this case, customer is obviously the parent. So, we need to define cutomer model first and then address model and then we can create relationship between these two in the child model. 


class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.OnetoOneField(Customer, on_delete=models.CASCADE, primary_key=True)




The argument 'on_delete' specifies the delete behavior. What should happen when we delete a customer or a parent field. So, if we put 'on_delete' to 'models.CASCADE', when we delete a customer the associated address will also be deleted. 
This is called the cascade behavior. Alternatively if this field accepts null values we can use set null(models.SET_NULL). So, when we delete a customer or the parent record, the child record(or the address in this case) is not going to get deleted. It's going to stay in the database and the customer field or the customer column is going to get set to null. Alternatively, we can use 'models.SET_DEFAULT;. So this field will be set to its default value. And one other option we have is models.PROTECT. And with this, we can prevent the deletion. So, if there is a child associated with this parent, we cannot delete that parent, we have to delete the child first.

Now, which value we use really depends on the requirements. There is no one size fits all. In this case, I believe we should use cascade. Because if we delete a customer, the associated address should also be deleted.

Now there is one more argument we need to set is 'primary_key=True'. If we don't set this, Django will create another field here called ID. So, every address is going to have an ID. And that means we're going to end up with a one-to-many relationship between customers and addresses, because we can have many addresses with the same customer. But if we make the customer field as a primary key, we can only have one address for each customer, because primary keys don't allow duplicate values, right? 
So this is how we can implement a one-to-one relationship between two models. Now, you might be wondering if we should define the reverse relationship in the customer class. In other words, do we have to go to the customer class and add a new field called 'address' for the reverse relationship. No, we don't have to do that because Django will automatically creates this for us. 










Defining a one-to-many Relationship:
-----------------------------------

Now let's assume that a customer can have multiple addresses. So we want to change this one-to-one relationship to one-to-many relationship. How can we do this? Really easy. First we need to change the type of the field to foreign key. So we're telling Django that customer is a foreign key in the address table. Okay? Next we need to remove field option 'primary_key=true'. Because we want to have multiple addresses for the same customer. So, we want to allow duplicate values in the customer column. This is how we can define a one-to-many relationship between two models. 

class Address(models.Model):
    street = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    customer = models.ForeignKey(
        Customer, on_delete=models.CASCADE)


Other examples as follows:
Collection - Product
Customer - Order
Order - Item
Cart - Item


class Collection(models.Model):
    title = models.CharField(max_length=255)
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)

class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)
	
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()


	
	
	





Defining Many-to-Many Relationships:
-----------------------------------

Let's talk about many-to-many relationships. So, I'm going to introduce a new class called Promotion and define a many-to-many relationship between promotions and products. So, a product can have different promotions and a promotion can be applied to different products.

class Promotion(models.Model):
    description = models.CharField(max_length=255)
    discount = models.FloatField()


Now we can define the relationship in either of these classes. And As I said earlier, Django will automatically create the reverse relationship. 
Now in this particular case, it makes more sense to define the relationship in the product class, because we might have a product that we need to show to the user and at the same time, we want to show all the promotions applied to that product.
	
class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

Now with this implementation, Django is going to create the reverse relationship in the Promotion class. which means, in the Promotion class, we're going to have a field called 'Product_set' that returns all the products that a particular promotion is applied to, if you don't like the name You can always change it. 
So, in our product class, we can supply a keyword argument related_name='products'. Django will use this name as the name of the field in the promotion class. So instead of 'product_set' we're gonna have a 'products'. 

Just remember, if you change the default convention in Django, it's best to change it consistently everywhere, otherwise in some classes you're going to have a field 'products', and in some other classes you're going to have a field 'product_set', and this makes your code really ugly.










Resolving Circular Relationships:
--------------------------------

Handling Circular Dependencies and Reverse Relationship Errors in Django:
When designing models in Django, you may encounter situations where two models have multiple relationships with each other. While implementing these, it's crucial to avoid circular dependencies and handle reverse relationship conflicts properly.



Understanding Circular Dependencies:
A circular dependency occurs when two classes depend on each other at the same time, causing errors in model definition.

Example: Collection and Product Models
1. The Product model contains a field called collection, which is a ForeignKey to the Collection model.

2. Now, we need another relationship: A Collection can have a featured_product, which is a ForeignKey to the Product model.

👉 This introduces a circular dependency:
The Product model depends on Collection.
The Collection model now depends on Product at the same time.



How to Resolve Circular Dependencies:

Django allows referencing models using string literals, so instead of:
featured_product = models.ForeignKey(Product, on_delete=models.SET_NULL, null=True)

We use:
featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True)


✅ Why does this work?
Django will resolve the model reference later, avoiding an immediate dependency issue.


❌ Potential downside:
If the Product model is renamed, this string won’t update automatically, which can lead to errors.

🔹 Use this technique only when necessary.




Handling Reverse Relationship Name Conflicts:
Django automatically creates reverse relationships to allow querying from both sides of a foreign key.

Issue in Collection-Product Relationship:
	The Product model already has a collection field.
	The Collection model now adds featured_product, which also creates an implicit reverse relationship in Product.
	Since Django auto-generates reverse relationships, it causes a naming conflict.

Solution Options
✅ Option 1: Set related_name in featured_product to avoid conflicts:

featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True, related_name="featured_in_collections")

Now, instead of Django auto-generating collection again, we control the naming.



✅ Option 2: Use "+" to disable the reverse relationship:

featured_product = models.ForeignKey("Product", on_delete=models.SET_NULL, null=True, related_name="+")

This prevents Django from creating the reverse link, ensuring no conflicts.




Final Takeaways:
Circular dependencies occur when models depend on each other simultaneously.
Using string literals for model references ("Product") solves circular dependency issues but requires caution when renaming models.
Reverse relationship conflicts arise when Django tries to auto-generate conflicting names.
Setting related_name or using "+" prevents these conflicts.

With these solutions, your Django models remain clean and maintainable. 🚀


class Collection(models.Model):
    title = models.CharField(max_length=255)
    featured_product = models.ForeignKey(
        'Product', on_delete=models.SET_NULL, null=True, related_name='+')


class Product(models.Model):
    title = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=6, decimal_places=2)
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
    promotions = models.ManyToManyField(Promotion)











Generic Relationships:
----------------------

Understanding Generic Relationships in Django:
Generic relationships allow models to associate with multiple types of objects without creating dependencies on specific models. This approach makes apps more reusable across different projects.

Why Use Generic Relationships?
Consider a 'tags' app where we want to tag different types of items—products, videos, articles, etc.

✅ Challenge:
If we directly reference a specific model (Product), the tags app becomes tightly coupled with the store app.
This limits reuse, as the app won't work for other types of items (e.g., articles, videos).

✅ Solution:
Instead of linking a concrete model (Product), we use Django’s ContentType framework to allow tagging any object dynamically.
This makes the tags app independent and reusable across multiple projects.


INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',  #this one 
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app_name'
]




from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey

# Tag Model
# Represents the actual tag label.
class Tag(models.Model):
    label = models.CharField(max_length=255)

# TaggedItem Model
# Tracks what item is associated with a tag.
class TaggedItem(models.Model):
	# Using this class, we can find out what tag is applied to what object
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
	
	# Generic Relationship Fields
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)  # Identifies the model type (Product, Article, etc.)
	object_id = models.PositiveIntegerField()  # Stores the specific object's ID
    content_object = GenericForeignKey()
    confirmmmmm between these two
    content_object = GenericForeignKey('content_type', 'object_id')  # Retrieves the actual object



How Generic Relationships Work
✅ Instead of a direct ForeignKey, we use:
1. content_type → Links to the type of object (Product, Article, Video).
2. object_id → Stores the object's primary key.
3. content_object → Acts as a dynamic reference to fetch the actual object.

🔹 When querying a tagged item, we can retrieve the actual product/video/article dynamically instead of being restricted to a fixed model.



Limitations of Generic Relationships:
❌ Only works well if primary keys are integers.
	If a model uses UUIDs or other non-integer keys, this approach may not work.

❌ Less efficient in queries compared to direct ForeignKeys.
	Generic relationships rely on joining multiple tables, which can slow down performance in large datasets.

✅ Best used when flexibility outweighs performance concerns.



exercise:

I want you to create an app called likes for tracking the objects that a user likes. So in this app, we're going to have a model called LikedItem. And using an instance of this model, we can tell what user likes what object. So here we need a field called user, which is going to be a foreign key to the user class defined in the model django.contrib.auth.models. So auth is another app that is automatically installed in every Django project. And using this app, we can authenticate and authorize users. 


App: Likes

LikedItem
 -what user likes what object
 -user: ForeignKey to User(django.contrib.auth.models)


likes/model.py:

from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)  # User who liked the item
	
	# Generic Relationship Fields
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE) # Object type
    object_id = models.PositiveIntegerField()  # Object ID
    content_object = GenericForeignKey()
	confirmm between these two
	content_object = GenericForeignKey('content_type', 'object_id')  # Actual object reference


So, We have created a new app called likes. And in this app, we have a new model called LikedItem. Now here we have four fields. We have user, which is a foreign key to the User class defined in django.contrib.auth.models. Now here for on_delete, I've used cascade. so, if a user is deleted, we want all the objects that the user has liked to be deleted as well. Then we have three fields exactly like before, no changes. We have content_type for identifying the type of an object that the user likes, we have object_id for referencing that particular object, and content_object for reading an actual object. 


💡 How this works:
A user can like any type of content (Product, Video, Post) without the app knowing specific models in advance.
Completely decoupled, making the app reusable across multiple projects.









                                                                                                                   

Setting up the database:
------------------------

In this section, we'll use Django migrations to generate our database schema based off of the models we've built in the previous section. So we'll talk about making migrations, running them, reversing them in case we make mistakes. We'll also talk about populating our database. So by the end of the section, we'll have a production grade database that we can query in the next section.


Supported Database Engines:
---------------------------

Django supports multiple database management systems (DBMS), allowing flexibility in choosing a backend based on project needs.

Default Database: SQLite
	Preconfigured in Django by default.
	A lightweight database suitable for development and low-traffic websites.
	❌ Not recommended for serious production applications due to limited scalability.


Production-Ready Databases:
For larger applications, Django officially supports:
	PostgreSQL
	MySQL
	MariaDB
	Oracle
Additionally, third-party libraries exist for Microsoft SQL Server and other databases.


Commonly Used Databases in the Django Community:
PostgreSQL – Popular for complex queries, scalability, and advanced features.
MySQL – Widely used for web applications, offering high performance and ease of setup.


Choosing a Database for a Django Project:
If starting with basic development, stick with SQLite.
If building a serious project, switch to PostgreSQL or MySQL.
If using PostgreSQL, research its integration with Django independently.


Next Step: Creating Migrations
Once a database is selected, the next step in Django development is creating migrations, which helps manage database schema changes efficiently.










Creating Migrations:
-------------------

Migrations in Django help create and update database tables based on the models defined in your project. Instead of manually writing SQL commands, Django automates database management using migration files.

Why Use Migrations?
Automatically creates, updates, and manages tables.
Ensures database schema remains in sync with model changes.
Reduces manual work, preventing errors in database structure.

Generating Migrations:
To create migrations after defining or modifying models, run:

python manage.py makemigrations	

Django scans installed apps and generates migration files.
Each migration file has a sequence number and a descriptive name.

📌 Example: If we rename 'price' to 'unit_price' in the Product model, Django asks for confirmation and creates a rename field migration instead of recreating the table.




Renaming Migrations Carefully:
If renaming a migration file manually, update all references in other migration files.

📌 Example:
dependencies = [
    ('store', '0001_initial'),
]

If "0001_initial" is renamed to "first_migration", update it here as well.



Handling Missing Changes in Migrations:
If makemigrations doesn’t detect model changes, check the INSTALLED_APPS list in settings.py. Missing an app here means Django won’t track changes.



Adding New Fields and Default Values:
When adding a new field like slug, Django may ask:
❌ Error: "You're trying to add a non-nullable field 'slug' to 'Product' without a default."

✅ Solutions:
1. Set a default value in the model
slug = models.SlugField(default='-')

2. Make it nullable
slug = models.SlugField(null=True)

📝 Choosing the first option keeps the database clean, while the second allows flexibility.



Final Takeaways
✔ Migrations automate database updates in Django. ✔ makemigrations detects model changes and creates migration files. ✔ Rename migration files carefully to avoid broken dependencies. ✔ Adding non-nullable fields requires a default value or null=True.

Note: slug --> slug is when you go to the stack overflow and if you search for a question in the address bar you can see the id of the question and the actual question itself(https://stackoverflow.com/questions/4492979/error-git-is-not-recognized-as-an-internal-or-external-command), what you see there is called a slug.  Slug can only contain letters, numbers, underscores and hyphens. So, any other characters other than these is going to be replaced by any special character like hypens or even removed. Now the whole point of adding a slug here is to make it easier for search engines to find our content. So this is a search engine optimization technique. 
 
 
 
 
 
 
 
 


Running Migrations: 
-------------------

Migrations in Django convert model definitions into actual database structures. Once migrations are created, they must be executed to apply these changes to the database.

1. Running Migrations:
To apply migrations and create/update database tables, run:

python manage.py migrate

✅ This command:
Checks installed apps for pending migrations.
Executes each migration sequentially like commits in a version control system.
Creates the database schema for models.
📌 Example: After running migrate, tables are created for installed apps like auth, admin, and your custom apps (store, tags, etc.).



2. Locating the Database
After migration, a database file is generated.

✅ Default for Django:
SQLite (db.sqlite3) → Used for development & small projects.
PostgreSQL/MySQL → Recommended for larger applications.

🔹 Viewing the database in VS Code:
Install the SQLite extension or use DB Browser for SQLite (sqlitebrowser.org).
Open the Command Palette (Shift + Ctrl + P on Windows / Shift + Cmd + P on Mac).
Search for "SQLite: Open Database" and select db.sqlite3.
Expand the SQLite Explorer to view tables.




3. Understanding the Migrations Table:
Django tracks migration history in a special django_migrations table.

✅ Viewing Applied Migrations:

1. Open the sqlite Explorer panel in VS Code.
2. Locate the django_migrations table.
3. Right-click → Select "Show Table" to see:
	Migration names (e.g., 0001_initial)
	Date & time applied
	Total executed migrations

💡 If no new migrations exist, running migrate again does nothing—since all migrations have been applied.




4. Viewing SQL Statements Using sqlmigrate
To preview the SQL commands Django will execute:

python manage.py sqlmigrate app_name migration_number

📌 Example:
python manage.py sqlmigrate store 0003

✅ Output: Displays raw SQL code for the specified migration, which differs based on database backend (SQLite, MySQL, etc.).



Exercise:
Add a zip field to the Address model.
Run makemigrations.
Execute migrate.
Inspect the django_migrations table to verify changes.

Key Takeaways
✔ migrate applies pending migrations to the database. 
✔ SQLite is default in Django, but PostgreSQL/MySQL are preferred for large applications. 
✔ The django_migrations table tracks executed migrations. 
✔ sqlmigrate lets you preview SQL commands before execution.



 








Customizing Database Schema:
----------------------------
In Django, you may need more control over your database schema by customizing table names, adding indexes, or setting default ordering. This is done using the Meta class inside models.

django model metadata --> https://docs.djangoproject.com/en/5.1/ref/models/options/


1. Defining Metadata for a Django Model:
To customize database behavior, define an inner Meta class inside your model.

Example: Customer Model with Metadata

class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]

    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE
    )

    class Meta:
        db_table = 'store_customers'  # Custom table name
        indexes = [models.Index(fields=['last_name', 'first_name'])]  # Index for faster lookup
		
		
		
✅ Metadata Options:
db_table → Renames the database table from default (store_customer) to 'store_customers'.
indexes → Creates an index on last_name and first_name to improve query performance.

💡 Indexing helps speed up queries when filtering or sorting large datasets.



2. Creating and Running Migrations
After adding metadata changes, generate migrations:

python manage.py makemigrations

This creates a new migration file that updates the database schema.

📌 Important Consideration: 
❌ Avoid mixing multiple types of operations in a single migration (e.g., renaming a table + adding an index). 
✅ Instead, make changes incrementally—create separate migrations for each modification.


🔹 Applying migrations:

python manage.py migrate

After running the migration, the table name changes to store_customers, and indexes are applied.




3. Checking the Updated Database Schema

To inspect the changes:
Open SQLite Explorer in VS Code.
Refresh the database.
Check that the table name is updated and indexes are applied.

📌 Observations:
The table name change may cause inconsistencies if other tables still use singular naming conventions.
Sticking to Django default table naming (lowercase_singular) maintains consistency.


Key Takeaways
✔ The Meta class customizes model behavior in Django. 
✔ Use db_table to rename tables (though default naming is usually preferable). 
✔ Indexes improve query performance for frequently used fields. 
✔ Migrations must be structured carefully—avoid combining unrelated changes.

🚀 Next Step: Learning how to undo migrations if changes need to be reverted.










Reverting Migrations:
---------------------

Reverting Migrations in Django:
Sometimes, we need to undo a migration due to mistakes or changes in project requirements. Django allows two approaches for reverting migrations:

1. Selectively Undoing a Migration
If you want to undo only part of the migration (e.g., keep the index but remove the custom table name), follow these steps:

✅ Steps:
1. Modify the model by removing or adjusting the unwanted changes.
2. Run:
	python manage.py makemigrations
	(This creates a new migration to revert the changes).
3. Apply it using:
python manage.py migrate
This ensures only selected changes are undone while keeping the rest intact.




2. Fully Reverting the Last Migration
If the entire migration must be removed, follow these steps:

✅ Steps:

1. Identify the last migration number.
	Open the migrations folder (store/migrations/ in this example).
	Find the last migration (e.g., 0004_customization).
2. Downgrade to the previous migration (migration 0003 in this example):
python manage.py migrate store 0003
(This removes the last migration from the database).

✅ Verification:
Check the database → The unwanted migration is removed.
Inspect the django_migrations table → The last migration entry should be gone.




3. Removing the Migration File and Code Changes
Even though the migration is removed from the database, the migration file still exists. 

To fully revert:
1. Delete the migration file manually (store/migrations/0004_customization.py).
2. Undo the code changes in the related model (e.g., remove the Meta class in Customer).
3. Prevent reapplying the migration by ensuring no code references remain.

🚀 Best Practice: Use Git for version control, so reverting changes becomes easier.




4. Using Git for Reverting Code Changes
Instead of manually removing changes, use Git commands:

✅ Steps:
1. Open the terminal and check Git history:
git log --oneline
(Find the last commit that introduced the migration).

2. Reset the branch to undo that commit:
git reset --hard HEAD~1
(Moves Git history one step back, removing all related changes).

✅ Verification:
The migration file is gone.
The model definition is restored to its previous state.


Exercise:
Try the following steps to practice reverting migrations:
1. Rename the first_name field in the Customer model to given_name.
2. Create a migration (makemigrations + migrate).
3. Revert the migration using the techniques discussed above.

Key Takeaways:
✔ Use makemigrations selectively if you only want partial changes reverted. 
✔ Use migrate <app> <previous_migration> to fully undo a migration. 
✔ Remove the migration file and associated model changes to prevent reapplying. 
✔ Using Git simplifies reverting code changes without manual deletion.










Installing MySQL:
-----------------
Connecting to MySQL:
--------------------

Setting Up and Using MySQL in Django:
When working on a Django project, switching from the default SQLite database to MySQL can provide better scalability and performance. Below is a step-by-step guide for installing MySQL, connecting to it, and integrating it with Django.


1. Installing MySQL
✅ Steps:

1. Go to MySQL Community Downloads.
2. Select MySQL Community Server and choose your operating system.
3. Download and install MySQL.
4. During installation, set:
	A root password for MySQL.
	Strong password encryption for secure access.
5. Confirm installation:
mysql -u root -p
(If this command runs successfully, MySQL is installed properly).

📝 If you encounter errors, Google them or check forums like StackOverflow for solutions.



2. Choosing a GUI Tool for MySQL:
✅ Popular Database Management Tools:
	MySQL Workbench (Free and official from MySQL).
	TablePlus (Lightweight, supports multiple databases).
	DataGrip (Best tool but requires a paid license).


E.g.
Setting Up MySQL Connection in DataGrip:
1. Open DataGrip and create a new project.
2. Click "+" → New Data Source → Select MySQL.
3. Enter connection details:
	Host: localhost
	Port: 3306
	User: root
	Password: (Set during installation)
4. Fix missing driver error → Download required drivers.
5. Set Time Zone → UTC.
6. Test Connection → Ensure successful authentication.




3. Creating a MySQL Database:
Before connecting Django to MySQL, create the database manually:

CREATE DATABASE storefront;
✅ This step ensures Django has a database to work with.





4. Installing MySQL Client for Django:
Django requires a package to communicate with MySQL. Install it using:

pip install mysqlclient

📝 Troubleshooting:
If installation fails, ensure MySQL is correctly installed.
If mysql command not found, add MySQL to your system PATH.

✅ Verify MySQL installation:
mysql -u root -p





5. Configuring MySQL in Django Settings:
Modify the DATABASES setting in settings.py:

python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # Change from SQLite to MySQL
        'NAME': 'storefront',  # Database name created earlier
        'USER': 'root',
        'PASSWORD': 'your_password',  # Replace with your MySQL password
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
🚀 Note: This setup is fine for development, but in production, avoid storing passwords directly in the settings file. Use environment variables instead.




6. Applying Migrations in MySQL
Once MySQL is integrated, run migrations to create database tables:

python manage.py migrate

✅ Check database updates in DataGrip:
Refresh the connection.
Look for storefront database with all Django-generated tables.




7. Troubleshooting Common Issues
🚨 Potential Errors & Fixes:
MySQL command not found → Add MySQL to PATH.
Access denied → Ensure correct password.
Missing drivers in DataGrip → Download required drivers.
Server returns invalid time zone → Set timezone to UTC.

✅ Best Practice: Be patient and determined when fixing installation issues.



Key Takeaways:
✔ Install MySQL and set up authentication. 
✔ Use GUI tools like MySQL Workbench, TablePlus, or DataGrip for easier database management. 
✔ Create a database manually before connecting it to Django. 
✔ Update settings.py to use MySQL instead of SQLite. 
✔ Run migrate to generate tables in MySQL.

🚀 Now your Django project is successfully connected to MySQL!











Running Custom SQL:
-------------------
Running Custom SQL in Django Migrations:
Sometimes, we need full control over how our database schema is modified. Django allows executing custom SQL queries within migrations, which is useful for tasks like: ✔ Creating stored procedures, views, or functions ✔ Modifying tables manually ✔ Performing data transformations


To do that: 
1. Creating an Empty Migration:
Instead of letting Django generate migrations, create an empty migration to manually define SQL commands:

python manage.py makemigrations store --empty

✅ This creates a migration file in the store/migrations/ folder without any predefined operations.




2. Writing Custom SQL in the Migration File:
Open the newly generated migration file and modify it using Django’s RunSQL class:

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('store', '003_add_slug_to_product'),
    ]
    
    operations = [
        migrations.RunSQL(
            '''INSERT INTO store_collection (title) VALUES('collection1')''',
            '''DELETE FROM store_collection WHERE title='collection1' '''
        )
    ]

✅ Explanation:
The first SQL command inserts a record into store_collection.
The second SQL command removes that record, allowing reversal of the migration.

🚀 Best Practice: Always provide a downward migration SQL statement, otherwise reverting the migration won't be possible.




3. Applying the Migration:
Run the migration to execute custom SQL in the database:

python manage.py migrate

🔹 Verifying the change:
	Open DataGrip or any MySQL GUI tool.
	Navigate to the store_collection table.
	The new record (collection1) should be inserted.




4. Reverting the Migration
To undo this migration and remove collection1, downgrade the database to the previous migration:

python manage.py migrate store 003

✅ Verification:
Refresh the store_collection table → The inserted record should be deleted.
The django_migrations table should no longer list the latest migration.

Key Takeaways: 
✔ Use empty migrations for manual SQL execution. 
✔ Always provide a downward SQL statement (DELETE for insertions, etc.). 
✔ Check the migration table (django_migrations) to verify changes. 
✔ Revert changes using python manage.py migrate <app> <previous_migration>.

🚀 Now you have full control over database modifications with Django migrations!	
	
	
	
	
	

Generating Dummy Data --> mockaroo.com









Django ORM:
-----------

In this section, you will learn how to query and manipulate data using Django ORM or Object Relational Mapper. We'll start off this section by a quick overview of Django ORM and the problem it solves. Then we'll spend the rest of the section on various ways to query and manipulate data. We'll cover filtering, sorting, grouping data, and much, much more. So by the end of this section, you'll be able to confidently pull out the data from the relational database or also store it in a the relational database.

Django ORM:
Understanding Django ORM (Object-Relational Mapper):

Django ORM (Object-Relational Mapper) simplifies database interactions by mapping relational database records to Python objects. Instead of manually writing SQL queries, ORM allows us to manipulate data using Python code, which is converted into SQL at runtime.



1. The Problem ORMs Solve
In traditional databases:
	Data is stored as rows in tables.
	Querying data requires SQL commands.
	Developers must manually map rows to objects in their application.

✅ Before ORMs:
Developers had to write SQL, retrieve data, and convert rows into objects manually.
This process was time-consuming and repetitive.

✅ With ORMs:
The ORM automates the mapping between rows and objects.
Eliminates the need for manual SQL queries in many cases.
Allows coding directly in Python, while ORM translates it into SQL.


💡 Example: Instead of writing
SELECT * FROM products WHERE price > 100;

In Django ORM, we can simply write:
Product.objects.filter(price__gt=100)


This reduces complexity and speeds up development.





2. Do We Still Need SQL?
❌ ORMs are not always perfect
For complex queries, ORM may generate inefficient SQL.
In such cases, it's better to write optimized SQL manually.


✅ Best Approach:

Use ORM for most queries.
Switch to raw SQL when performance optimization is necessary.

🔹 Example of ORM helping in Django migrations:
ORM automatically creates database tables during migration without manual SQL.
ORM manages relationships and indexes efficiently.




3. ORM in Django Models
All model classes in Django inherit from models.Model, gaining ORM capabilities automatically.

📌 Example:
class Product(models.Model):
    title = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=10, decimal_places=2)
		
✅ This model allows querying without SQL, such as:
Product.objects.all()  # Fetch all products
Product.objects.filter(price__lt=50)  # Get products with price < 50





4. Addressing ORM Criticism
Some developers prefer manual SQL, believing ORMs are slow. However, ORM reduces repetitive coding, making projects easier to maintain.

✅ Best Practice: 
✔ Use ORM where appropriate. 
✔ Optimize only when performance issues arise. 
✔ Avoid premature optimization—focus on development speed first.



Key Takeaways:
✔ Django ORM automates database interactions, reducing manual SQL work. 
✔ Simplifies querying using Python instead of SQL commands. 
✔ Manual SQL is needed for complex optimizations. 
✔ Avoid over-engineering—use the right tool based on project needs.

🚀 Next: Using ORM for database queries in Django.







Resetting the Database:
-----------------------

resetting the everything 










Managers and Querysets:
-----------------------

Understanding Managers and QuerySets in Django ORM:
Django ORM (Object-Relational Mapper) provides an efficient way to interact with the database without writing raw SQL queries. Two key components of ORM are Managers and QuerySets, which help in querying and updating data.


1. Managers in Django Models
Every Django model automatically gets an attribute called objects, which provides access to the Manager.

✅ What is a Manager?
A Manager is an interface to the database.
Acts as a remote control with methods to query or modify database records.
Every model has a default Manager (objects), but custom Managers can be defined.

📌 Example:
from store.models import Product  

# Default Manager
Product.objects.all()  # Retrieves all records
Product.objects.filter(price__gt=50)  # Filters products with price > 50

🚀 The Manager provides methods such as:
all() → Fetches all records.
get() → Retrieves a single object.
filter() → Filters data based on conditions.
count() → Returns the number of records (does NOT return a QuerySet).




2. What is a QuerySet?
A QuerySet represents a query that has not yet been executed.
Django delays evaluation of QuerySets (they are lazy).


🔹 When is a QuerySet evaluated?
1. Iteration → Looping through results:

for product in Product.objects.all():
    print(product)

2. Conversion to list (list(QuerySet)) → Forces execution.
3. Accessing specific elements (QuerySet[0], QuerySet[:5]).

✅ Why are QuerySets lazy?

Allows building complex queries efficiently without fetching unnecessary data.

Example:
products = Product.objects.filter(price__gt=50).order_by('title')
🚀 This query will not execute until we iterate over it.





3. Debugging SQL Queries in Django
Django Debug Toolbar helps inspect SQL queries generated by ORM.

📌 Example Output:

SELECT id, title, price FROM store_product WHERE price > 50 ORDER BY title;
✅ Helps optimize queries for performance improvements.





4. When NOT to Use QuerySets
Some methods return direct results instead of QuerySets, for example:
Product.objects.count()  # Returns an integer, not a QuerySet

✅ This avoids unnecessary query chaining.




Key Takeaways:
✔ Managers provide methods for querying/updating database records. 
✔ QuerySets are lazy and only execute when needed. 
✔ Efficient QuerySet chaining builds optimized queries before execution. 
✔ Use Django Debug Toolbar for SQL inspection.

🚀 Next Step: Learning how to retrieve objects in Django ORM!











Retrieving objects:
-------------------

Django provides multiple ways to retrieve objects from the database using its Object-Relational Mapper (ORM). Below are the key methods for querying data efficiently.


1. Retrieving All Objects (all()):
The all() method retrieves all records from a table.

📌 Example:

from store.models import Product

products = Product.objects.all()  # Returns a QuerySet of all products

✅ Returns a QuerySet, which is evaluated only when iterated over.




2. Retrieving a Single Object (get())
The get() method fetches a single object based on a lookup parameter.

📌 Example:
product = Product.objects.get(id=1)  # Fetches product with ID 1

🚀 Using pk Instead of id:
pk refers to the primary key field, whether it's id, code, or any other identifier.

Equivalent to:
product = Product.objects.get(pk=1)

✅ Returns a single object (not a QuerySet). 
❌ Throws an exception if the object does not exist.





3. Handling Errors in get() Method
If no matching object is found, Django raises DoesNotExist exception.

✅ Using Try-Except Block:
from django.core.exceptions import ObjectDoesNotExist

try:
    product = Product.objects.get(pk=0)  # Product with ID 0 (not found)
except ObjectDoesNotExist:
    product = None  # Handle error gracefully

🚀 Best Practice: 
Organize Django imports together for cleaner code. Like, 
from django.shortcuts import render
from django.core.exceptions import ObjectDoesNotExist

These two lines should goes together





4. Better Alternative: Using filter().first()
To avoid exceptions, use .filter().first() instead of get().

📌 Example:
product = Product.objects.filter(pk=0).first()  # Returns None if not found

✅ Does not throw an exception if no product exists. ✅ Returns the first matching object or None.




5. Checking If an Object Exists (exists())
Sometimes, we just need to verify whether a record exists without retrieving it.

📌 Example:
exists = Product.objects.filter(pk=0).exists()  # Returns True or False

✅ Returns a Boolean value (True or False) instead of an object.




Key Takeaways:
✔ all() → Retrieves all objects (returns a QuerySet). 
✔ get() → Retrieves one object, throws exception if not found. 
✔ Try-except block handles missing objects in get(). 
✔ Use filter().first() instead of get() to avoid errors. 
✔ exists() checks if a record exists without fetching the actual object.

🚀 Next Lesson: Detailed Filtering in Django ORM!







Filtering Objects:
------------------
Filtering Objects in Django ORM:
Django ORM provides powerful filtering capabilities using the filter() method. This allows querying based on conditions such as numeric comparisons, string searches, date filtering, and null checks.

1. Filtering by Numeric Values
📌 Find products with price exactly $20:
queryset = Product.objects.filter(unit_price=20)



📌 Find products priced higher than $20:
queryset = Product.objects.filter(unit_price__gt=20)

🚀 Explanation:
Logical operators (>, <) cannot be used directly in filter().

Use lookup types:
__gt → Greater than
__gte → Greater than or equal to
__lt → Less than
__lte → Less than or equal to




📌 Find products within a price range ($20 to $30):
queryset = Product.objects.filter(unit_price__range=(20, 30))
✅ Uses the range lookup type, which requires a tuple (min_value, max_value).







2. Filtering Across Relationships
Django allows filtering based on related models.

Syntax: 
relationship + __field or attributes of the particular relationship  (example: collection__id, only if you put double underscore, you would navigate to the relationship


📌 Find products in collection ID 1:
queryset = Product.objects.filter(collection__id=1)

📌 Find products in collections greater than ID 1:
queryset = Product.objects.filter(collection__id__gt=1)


📌 Find products belonging to multiple collections:
queryset = Product.objects.filter(collection__id__range=(1, 2, 3))

🚀 Explanation:
collection__id represents the foreign key to the Collection model.
filter() can navigate relationships using double underscores (__).






3. Filtering Strings (Case-Sensitive and Insensitive)

📌 Find products with “coffee” in their title (case-sensitive):
queryset = Product.objects.filter(title__contains='coffee')
🚨 Issue: This lookup is case-sensitive, meaning "coffee" and "Coffee" are treated differently.


📌 Case-insensitive search:
queryset = Product.objects.filter(title__icontains='coffee')
✅ Using icontains ensures case insensitivity.


🔹 Other useful string lookup types:
startswith → Matches only if a string starts with a given value.
endswith → Matches only if a string ends with a given value.
istartswith, iendswith → Case-insensitive versions.





4. Filtering Dates
📌 Find products updated in 2021:
queryset = Product.objects.filter(last_update__year=2021)
✅ Allows extracting specific components like year, month, day, hour, etc.


📌 Filtering by exact date values (rarely used):
queryset = Product.objects.filter(last_update='2021-05-10')




5. Checking for Null Values
📌 Find products without a description:
queryset = Product.objects.filter(description__isnull=True)
✅ Returns objects where description is NULL in the database.

📌 Find products with a description:
queryset = Product.objects.filter(description__isnull=False)




Key Takeaways
✔ Use filter() with lookup types (__gt, __contains, etc.) for complex queries. 
✔ Filter related models using double underscores (collection__id). 
✔ Use case-insensitive lookups (icontains, istartswith). 
✔ Extract date components (year, month). 
✔ Check for null values (isnull=True).

🚀 Next Lesson: More advanced querying techniques!




Using collection__id vs. collection_id:
----------------------------------------
collection_id: This is the actual database column automatically created by Django for a ForeignKey field. ✅ Example:

queryset = Product.objects.filter(collection_id=1)
  
This works because collection_id is a direct reference to the column in the database.



collection__id: This follows Django’s ORM lookup syntax, allowing navigation through relationships. ✅ Example:

queryset = Product.objects.filter(collection__id=1)  

Here, collection is the ForeignKey field in Product, and we are accessing the id attribute of the related Collection model.



🚀 Key Difference: Both work, but:
collection_id is more direct (avoids ORM navigation).
collection__id is used when filtering based on related model attributes.

💡 Example with Other Attributes in Related Models:

queryset = Product.objects.filter(collection__title="Summer Collection")
Here, collection__title accesses the title field of the related Collection model.



Understanding collection_id vs. collection__id in Django ORM:
-------------------------------------------------------------
When dealing with ForeignKey relationships in Django models, Django provides two ways to reference related objects in queries:

1. collection_id → Directly refers to the ForeignKey column in the database.
2. collection__id → Uses ORM relationship traversal, accessing the actual id field of the related model.

Example Scenario
Let’s say we have a Product model with a ForeignKey relationship to a Collection model:

class Collection(models.Model):
    title = models.CharField(max_length=255)

class Product(models.Model):
    title = models.CharField(max_length=255)
    collection = models.ForeignKey(Collection, on_delete=models.CASCADE)

🚀 Django automatically creates a database column called collection_id in the Product table to store the relationship.



Using collection_id (Direct Reference to the Database Column):
When filtering directly in the Product table:

Product.objects.filter(collection_id=1)

✅ This queries the database column directly, avoiding ORM relationship traversal. ✅ Efficient and faster since it doesn’t check the Collection model.

📌 Equivalent SQL Query:
SELECT * FROM product WHERE collection_id = 1;

✔ Django treats collection_id as a normal integer field since it exists directly in the database.



Using collection__id (Navigating Relationships with ORM):
Alternatively, you can use collection__id:

Product.objects.filter(collection__id=1)

✅ This tells Django ORM:
Navigate the collection relationship (go to the Collection model).
Check the id field within the Collection model.

📌 Equivalent SQL Query:
SELECT * FROM product 
JOIN collection ON product.collection_id = collection.id
WHERE collection.id = 1;

✔ This performs an INNER JOIN between the Product and Collection tables.




Key Difference
Query Syntax	     How It Works	                                     Performance
collection_id=1	     Direct lookup on the database column (faster)	     ✅ More efficient
collection__id=1	 Navigates ORM relationships & joins related table	 ❌ Can be slower




When to Use Each?
✔ Use collection_id when filtering using the ForeignKey column directly. 
✔ Use collection__id when filtering based on attributes inside the related model.

💡 Example of filtering by related model attributes:
Product.objects.filter(collection__title="Summer Collection")
✅ This navigates the relationship to filter based on the title field inside the Collection model.

Final Summary
✔ collection_id → Fast, direct lookup in the database. 
✔ collection__id → Navigates ORM relationships, useful when filtering by related model fields.




Some more examples:

# Customers with .com accounts
querset = Customer.objects.filter(email__icontains='.com')

# Collections that don’t have a featured product
queryset = Collection.objects.filter(featured_product__isnull=True)

# Products with low inventory (less than 10)
queryset = Product.objects.filter(inventory__lt=10)

# Orders placed by customer with id = 1
queryset = Order.objects.filter(customer__id=1)

# Order items for products in collection 3
queryset = OrderItem.objects.filter(product__collection__id=3)














Complex Lookups Using Q Objects:
--------------------------------

Django ORM provides Q objects to build complex queries involving multiple conditions. This is useful when applying AND, OR, and NOT filters dynamically.

1. Filtering with Multiple Conditions Using filter()
The simplest way to filter using multiple conditions is by passing multiple keyword arguments:

📌 Find products with inventory < 10 AND unit price < 20:
queryset = Product.objects.filter(inventory__lt=10, unit_price__lt=20)
✅ Generates a SQL query with the AND operator:

SELECT * FROM product WHERE inventory < 10 AND unit_price < 20;


Alternatively, you can chain filter calls:
queryset = Product.objects.filter(inventory__lt=10).filter(unit_price__lt=20)
✅ Returns the same result but makes filtering more readable.




2. Using Q Objects for Complex Lookups
Q objects allow logical combinations (AND, OR, NOT) using bitwise operators.

📌 Importing Q Objects:
from django.db.models import Q


3. Using the OR (|) Operator
📌 Find products where inventory < 10 OR unit price < 20:
queryset = Product.objects.filter(Q(inventory__lt=10) | Q(unit_price__lt=20))

✅ Generates a SQL query with the OR operator:
SELECT * FROM product WHERE inventory < 10 OR unit_price < 20;
🚀 Q objects must be enclosed in parentheses for the OR operation to work correctly.



4. Using the AND (&) Operator
📌 Find products where inventory < 10 AND unit price < 20:

queryset = Product.objects.filter(Q(inventory__lt=10) & Q(unit_price__lt=20))
✅ Works like passing multiple conditions in filter(), but is more verbose.



5. Using the NOT (~) Operator
📌 Find products where inventory < 10 AND unit price is NOT less than 20:

queryset = Product.objects.filter(Q(inventory__lt=10) & ~Q(unit_price__lt=20))
✅ This negates the second condition, ensuring unit price is NOT less than 20.




Key Takeaways
✔ Use filter() directly for simple AND conditions. 
✔ Use Q objects (Q(condition1) | Q(condition2)) for OR conditions. 
✔ Use ~Q(condition) to negate a condition. 
✔ Use parentheses to ensure correct precedence in Q objects.

🚀 Next Lesson: Using F objects to reference fields dynamically!











 


Referencing Fields using F Objects:
-----------------------------------

When filtering data in Django ORM, sometimes we need to compare a field against another field in the same model instead of a static value. This is where F objects come into play.

1. The Problem: Direct Field Comparison Causes Errors

📌 Incorrect way to filter:
queryset = Product.objects.filter(inventory = unit_price)  # ❌ Causes error
✅ Issue: Django expects a value, but unit_price is a field, not a variable.


🚨 Another incorrect attempt:

queryset = Product.objects.filter(inventory = 'unit_price')  # ❌ Doesn't work
✅ Issue: This compares inventory (a number) with a string "unit_price", which is invalid.




2. Solution: Using F Objects
📌 Import the F class:

from django.db.models import F


📌 Correct way to compare fields:
queryset = Product.objects.filter(inventory = F('unit_price'))

✅ Explanation:
F('unit_price') references the unit_price field dynamically.
Django converts this to SQL where the database compares two columns.

📌 Generated SQL Query:
SELECT * FROM product WHERE inventory = unit_price;





3. Comparing Fields Across Related Models
We can also reference fields from related models using ForeignKey relationships.
📌 Compare inventory with collection_id:
queryset = Product.objects.filter(inventory = F('collection__id'))

✅ Explanation:
collection__id navigates the ForeignKey relationship and retrieves the id of the related Collection object.

📌 Generated SQL Query:
SELECT * FROM product 
JOIN collection ON product.collection_id = collection.id
WHERE inventory = collection.id;


Key Takeaways:
✔ Use F('field_name') to reference fields dynamically in queries. 
✔ Avoid using variables or strings for field comparisons. 
✔ Can reference fields in related models using double underscores (collection__id). 
✔ Django automatically translates F objects into SQL queries.

🚀 Next Lesson: Sorting Query Results!











Sorting:
--------

Django ORM allows sorting query results using the order_by() method. You can sort by one or multiple fields and control the sorting direction.

1. Basic Sorting with order_by()
📌 Sort products by title in ascending order:
queryset = Product.objects.order_by('title')
✅ Default sorting order is ascending (A → Z).

📌 Sort products by title in descending order:
queryset = Product.objects.order_by('-title')
✅ Adding a negative sign (-) reverses the order (Z → A).




2. Sorting by Multiple Fields
📌 Sort by unit price (ascending), then by title (descending):
queryset = Product.objects.order_by('unit_price', '-title')
✅ First, products are sorted by price (lowest → highest). ✅ If multiple products have the same price, they are sorted by title (Z → A).




3. Reversing the Sorting Order (reverse())
📌 Reverse the sorting direction of a query set:
queryset = Product.objects.order_by('unit_price', '-title').reverse()
✅ Final order:
Unit price → descending (highest → lowest).
Title → ascending (A → Z).

📌 Example SQL Query Generated:
SELECT * FROM product ORDER BY unit_price DESC, title ASC;
🚀 Useful when dynamically adjusting sorting without modifying field names.




4. Sorting After Filtering
You can sort results after applying a filter.
📌 Filter products in collection ID 1, then sort by unit price:
queryset = Product.objects.filter(collection__id=1).order_by('unit_price')
✅ Filters products first, then applies sorting.



5. Selecting the First Object After Sorting
📌 Retrieve the cheapest product:
product = Product.objects.order_by('unit_price')[0]
✅ Extracts the first object after sorting by unit price. ❌ Warning: If no records exist, this may cause an error.


📌 Better Alternative: Using earliest() and latest() ✅ These methods sort and return the first object directly.



📌 Get the cheapest product using earliest():
product = Product.objects.earliest('unit_price')
✅ Automatically sorts by unit_price and returns the first result.

📌 Get the most expensive product using latest():
product = Product.objects.latest('unit_price')
✅ Sorts by unit_price in descending order and returns the first product.




Key Takeaways
✔ Use order_by() to sort by fields (ascending or descending). 
✔ Use multiple fields to refine sorting (e.g., unit_price, -title). 
✔ Use reverse() to dynamically flip sorting direction. 
✔ Apply order_by() after filtering for precise results. 
✔ Use earliest() and latest() instead of manually accessing queryset[0].

🚀 Next Lesson: Limiting Query Results!












Limiting Results:
-----------------

Our product table has a thousand products. Now quite often, we don't want to show all these products to the user in one list. We want to show pages of products. So let's say our page size is five and we want to show the products on the first page. To do that, we use Python's array slicing syntax.

queryset = Product.objects.all()[:5]  # 0, 1, 2, 3, 4

sql statement:
select * from store.product limit 5



Now to get the products on the second page, we can start from five and finish before 10. 

queryset = Product.objects.all()[5:10]  # 5, 6, 7, 8, 9

sql statement:
select * from store.product limit 5 offset 5

Note: 
LIMIT 5 → Fetch only 5 records.
OFFSET 5 → Skip the first 5 records and start fetching from the 6th record onward.

Use Case: This is useful for pagination, where you need to display results in batches (e.g., pages of search results).
Page 1 → LIMIT 5 OFFSET 0 (fetch first 5 records).
Page 2 → LIMIT 5 OFFSET 5 (fetch next 5 records).
Page 3 → LIMIT 5 OFFSET 10 (fetch next 5 records), and so on.








Selecting Fields to Query:
--------------------------


By default, when querying objects in Django ORM, all fields are retrieved from the database. However, if you only need a subset of fields (to optimize performance), you can use values() and values_list().

1. Using values() for Specific Fields
📌 Query only id and title from the Product table:
queryset = Product.objects.values('id', 'title')

✅ Result: Instead of returning full model instances, it returns a list of dictionaries:

[
    {'id': 1, 'title': 'Product A'},
    {'id': 2, 'title': 'Product B'},
]

📌 Generated SQL Query:
SELECT store_product.id, store_product.title FROM store_product;

🚀 Useful when you don't need all fields, reducing database load.





2. Querying Related Fields
You can also retrieve fields from related models using double underscore (__) notation.

📌 Get the product ID, title, and its collection title:
queryset = Product.objects.values('id', 'title', 'collection__title')

✅ Result:
[
    {'id': 1, 'title': 'Product A', 'collection__title': 'Summer Collection'},
    {'id': 2, 'title': 'Product B', 'collection__title': 'Winter Collection'},
]


📌 Generated SQL Query:
SELECT store_product.id, store_product.title, store_collection.title 
FROM store_product 
INNER JOIN store_collection ON store_product.collection_id = store_collection.id;

🚀 Automatically performs an INNER JOIN to fetch related fields.





3. Using values_list() for Tuples Instead of Dictionaries
📌 Retrieve data as tuples instead of dictionaries:
queryset = Product.objects.values_list('id', 'title', 'collection__title')


✅ Result:
[
    (1, 'Product A', 'Summer Collection'),
    (2, 'Product B', 'Winter Collection'),
]
🚀 Useful when you don’t need key-value mapping (faster processing).





4. Finding Ordered Products Using Subqueries
Not all products have been ordered—we need to identify products present in the OrderItem table.

📌 Step 1: Extract Product IDs from OrderItem table
queryset = OrderItem.objects.values('product_id')

🚀 Why product_id instead of product__id?
Django automatically creates the product_id field for ForeignKey relationships at runtime.
You don’t need to explicitly define product_id in models, Django handles it internally.


📌 Step 2: Remove duplicates using .distinct()
queryset = OrderItem.objects.values('product_id').distinct()
✅ Ensures we don't get duplicate products from multiple orders.

📌 Step 3: Filter products using the extracted product IDs
queryset = Product.objects.filter(id__in=OrderItem.objects.values('product_id').distinct())
✅ Finds all products that exist in the OrderItem table.

📌 Final Step: Sort by Title
queryset = Product.objects.filter(id__in=OrderItem.objects.values('product_id').distinct()).order_by('title')
🚀 Returns ordered products sorted by title.



Key Takeaways
✔ Use values() to return dictionaries (for key-value mapping). 
✔ Use values_list() to return tuples (faster processing). 
✔ Use product_id for ForeignKey filtering (product__id works too). 
✔ Use distinct() to remove duplicate results. 
✔ Use the IN lookup (id__in) to filter records efficiently.

🚀 Next Lesson: Advanced Querying Techniques!








Deferring Fields: 
-----------------

When querying objects, Django ORM retrieves all fields from the database by default. However, sometimes we only need specific fields for optimization. Django provides two methods for controlling this:
1. only() → Load only selected fields.
2. defer() → Delay loading of certain fields until needed.



1. Using only() to Optimize Queries
📌 Retrieve only id and title from the Product table:
queryset = Product.objects.only('id', 'title')

✅ Instead of querying all fields, it fetches only the specified ones. ✅ Returns full Product instances, unlike values(), which returns dictionaries.

📌 Generated SQL Query:
SELECT store_product.id, store_product.title FROM store_product;

🚨 Potential Issue:
If we later access a field not included in only(), Django will send a separate query for each missing field, leading to many unnecessary queries.

Example: If we display product.unit_price in a template after using only('id', 'title'), Django will issue one query per product to fetch unit_price, causing performance issues.




2. How Excess Queries Can Occur with only()
📌 Example:
queryset = Product.objects.only('id', 'title')
Later, in a template, we try to display product.unit_price:
html:
{{ product.unit_price }}

🚀 What Happens:
Main Query: Fetches only id and title.

sql
SELECT store_product.id, store_product.title FROM store_product;
Extra Queries (One Per Product):

sql
SELECT store_product.id, store_product.unit_price FROM store_product WHERE store_product.id = 1 LIMIT 21;
SELECT store_product.id, store_product.unit_price FROM store_product WHERE store_product.id = 2 LIMIT 21;
...
(1000+ queries if 1000 products exist)
❌ This can drastically slow down performance.

🛑 Solution: Avoid only() if you will need other fields later.





3. Using defer() to Delay Loading Fields
📌 Exclude description from initial query:
queryset = Product.objects.defer('description')

✅ The description field will not be loaded unless explicitly accessed. ✅ Better performance compared to only(), because fewer queries are sent.

🚨 Potential Issue:
If you later iterate over products and access description, Django will issue separate queries for each product, leading to performance issues similar to only().

📌 Example Scenario:
queryset = Product.objects.defer('description')

for product in queryset:
    print(product.description)  # ❌ This triggers extra queries



Key Takeaways
✔ Use only() to load specific fields but avoid accessing missing fields later. 
✔ Be cautious with defer()—it delays loading but may cause excessive queries if the deferred field is later accessed. 
✔ If optimizing queries, always check Django Debug Toolbar to analyze query performance.

🚀 Next Lesson: Further ORM optimization techniques!












Selecting Related Objects:
--------------------------

<li>{{ product.title }} - {{ product.collection.title }}</li>

Sometimes we need to preload a bunch of objects together. For example, while fetching all the products, we also want to render the collection of each product next to its title (say product.collection.title). But when you do it normally, you would get the same problem as before. Our application will be hanging because Django is sending a thousands of extra queries Queries to the database to read the collection of all the related products. Because when we ask for products, Django is only going to query the product table. It's not going to query the related tables unless we specifically instructed to do so. So here we want to preload the products with our collection. 




To do that we can use the select_related()(before we call the 'all' method, we can call select_related and specify the field that we want to preload). 
Here say the field is 'collection'
Now our products loaded instantly. 

queryset = Product.objects.select_related('collection').all()

SQL:
SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER_JOIN store_collection ON (store_product.collection_id = store_collection.id)

Here we're selecting all the fields from the product table followed by the three fields from the collection table and then we have a join between product and collection table. So, when we use the select related method, Django creates a join between our tables. 




Now, we can also span relationships. So, let's say collection has another field that we want to preload as part of the query. So, we can add double underscores there and then type the name of that other field. 

queryset = Product.objects.select_related('collection__someOtherField').all()




Okay so, this is 'select_related'. Now. We have another method called 'prefetch_related'. We use select_related when the other end of the relationship has one instance (a product has one collection). But we use prefetch related when the other end of the relationship has many objects (a product may have many promotions). you can check product class real quick, where each product has one collection, but it can have many promotions. So to preload the promotions, we use the 'prefetch_related' method. 

class Product(models.Model):
    title = models.CharField(max_length=255)
	slug = models.SlugField()
    description = models.TextField()
    inventory = models.IntegerField()
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(Collection, on_delete=models.PROTECT)
	promotions = models.ManyToManyField(Promotion)

#select_related(1) --> other end of the relationship has one instance (product - collection)
#prefetch_related(N) when other end of the relationship has many objects (product - promotion)

#prefetch_related
queryset = Product.objects.prefetch_related('promotions').all()

SQL:
select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price from store_product

select (store_product_promotions.product_id) as _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount
from store_promotion inner join store_product_promotions on (store_promotion.id = store_product_promotions.promotion_id) where store_product_promotions.product_id in (1,2,3,4,5,6,7,8,9,10...)

Here's the first query to read the columns from the product table. Now, after that, we have another query to read the promotions of the products. So, you're reading three columns from the promotion table, and we have a join between promotion and product. So, essentially, we have two result sets. The first set includes the products. The second set includes promotions. Django reads these sets and then populates our objects in memory. 



Now, we can also combine these two methods. So let's say we want to load all the products with their promotions and collection. So after the call to 'prefetch_related', we can call the 'select_related' to load the collection of each product. 

queryset = Product.objects.prefetch_related('promotions').select_related('collection').all()


SQL: 

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, store_collection.id, store_collection.title, store_collection.featured_product_id FROM store_product INNER JOIN store_collection ON (store_product.collection_id = store_collection.id)

SELECT (store_product_promotions.product_id) AS _prefetch_related_val_product_id, store_promotion.id, store_promotion.description, store_promotion.discount FROM store_promotion INNER JOIN store_product_promotions ON (store_promotion.id = store_product_promotions.promotion_id) WHERE store_product_promotions.product_id IN(2,3,12........)

we have two queries. The first query is to read the products and their collection. So, there we have a join between product and collection. And the second query is to read the promotions of all these products.






Note on what is 'store_product_promotions':
-------------------------------------------
store_product_promotions is a junction table (also known as a many-to-many relationship table) that Django automatically creates when a Many-to-Many relationship exists between two models.



Why Does Django Create store_product_promotions?

In your Django model:
class Product(models.Model):
    title = models.CharField(max_length=255)
    promotions = models.ManyToManyField(Promotion)

The ManyToManyField between Product and Promotion means each product can have multiple promotions, and each promotion can apply to multiple products.
Since relational databases do not support direct Many-to-Many relationships, Django automatically creates an intermediate table (store_product_promotions) to link Product and Promotion.



What Does store_product_promotions Contain?
It consists of two ForeignKey columns:
product_id → Links to the store_product table.
promotion_id → Links to the store_promotion table.


📌 Structure of store_product_promotions:
product_id	promotion_id
1	            2
1	  			3
2				1
3				2
4				1




How Django Prefetches Related Objects?
📌 SQL Query Explanation:

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price 
FROM store_product;
✅ First, fetches all products.

SELECT store_product_promotions.product_id AS _prefetch_related_val_product_id, 
       store_promotion.id, store_promotion.description, store_promotion.discount
FROM store_promotion 
INNER JOIN store_product_promotions ON store_promotion.id = store_product_promotions.promotion_id 
WHERE store_product_promotions.product_id IN (1,2,3,4,5,6,7,8,9,10...);
✅ Then, fetches all related promotions, linking them via store_product_promotions. 
✅ This avoids extra queries per product, optimizing database performance.


🚀 In Summary: ✔ store_product_promotions is a junction table that Django creates for Many-to-Many relationships. ✔ Used to link Product and Promotion efficiently in queries. ✔ Prefetching loads related objects in batches, improving performance compared to individual queries.





Exercise: 
---------
I want you to write a query to get the last five orders with their customer and items, including the product reference in each order item. 

First we want to get a list of orders. So, we should start with the order class. Then we go to Objects. Now we want to preload these orders with their customer. So, this is where we call select related to preload the customer field. Now we don't want to show all the orders, we want to show the last five orders. Hence, we need to sort them by 'placed_at' in descending order. So that latest orders come first. And then we use array slicing syntax to pick the top five orders. 
 
queryset = Order.objects.select_related('customer').order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

So, we have a single query to read the orders along with their customers. So, we are selecting all the columns from the order table, followed by all the columns from the customer table. And we have a join operation between order and customer tables. Great. So let's move on to the next step.



Now we should preload the items of these orders. So, here we can call prefetch_related because each order can have many items. Now, to know the name of the field we're going to query, you have a quick look at our Order class. 


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    product = models.ForeignKey(Product, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField()
    unit_price = models.DecimalField(max_digits=6, decimal_places=2)


So, each order has three fields 'placed_at', 'payment status' and 'customer'. But we don't have a field called 'items', but when you look at the OrderItem class, there we have 'order' field, which is a foreign key to Order. So, Django is going to create the reverse relationship for us. And the relationship name as you know, would be 'orderitem_set'. This is the convention that Django uses to create the reverse relationship. If you don't like this name, you can always set it using the 'related_name' argument. 


queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set').order_by('-placed_at')[:5]

SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

Nothing much, we have one extra query to load the order items. So, we're loading the order items for the Orders in this list. 


So, everything is fine so far Now the last step is to load the products referenced in each order item. So, over where we are prefetching the order item, we can span the relationship by adding two underscores, and then we can type the name of the target field, which is 'product'. 

queryset = Order.objects.select_related('customer').prefetch_related('orderitem_set__product')order_by('-placed_at')[:5]


SQL:
SELECT store_order.id, store_order.placed_at, store_order.payment_status, store_order.customer_id, store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership FROM store_order INNER JOIN store_customer ON (store_order.customer_id = store_customer.id) ORDER BY store_order.placed_at DESC LIMIT 5

SELECT store_orderitem.id, store_orderitem.order_id, store_orderitem.product_id, store_orderitem.quantity, store_orderitem.unit_price FROM store_orderitem WHERE store_orderitem.order_id IN (408,513,711,2,248)

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product WHERE store_product.id IN (166, 780, 976, 505, 219)

Now we have one more extra query to read the products referenced in the order items. So, we are reading all the columns from the product table where the product id is in the list(166, 780, 976, 505, 219). And this list is the list of order items we have queried so far. 

So this is how I want you to write code. Write a little bit of code, test your code, make sure everything works before doing a big step. 
With this technique, we can prevent a lot of crazy issues down the road.











Aggregating Objects:
--------------------

Sometimes you want to compute summaries like max or average price of our products. This is where we use the 'aggregate' method.

So, let's say we want to count our products. Here we create a count object and specify the field we want to use for counting. If we use ID, we can count the total number of products because every product has an ID, right?. But if we use a different column, let's say 'description', and assume that description can be NULL, this will count the number of products that have a description, okay? 

So the proper way to count the total number of records to use the ID or the primary key field. Now the aggregate method doesn't return a query set because once we calculate a summary value, it doesn't really make sense to do anything extra with it. We're not gonna add filters or sort data and so on. 


from django.db.models.aggregates import Count, Max, Min, Avg, Sum

result = Product.objects.aggregage(Count('id')) #returns a dictionary

	
while rendering in the UI part: {id__count : 1000}


The reason for the name 'id__count' is because we use the 'id' column for counting objects. 

We can also change the name of this key if we want to, by passing the keyword arguments
result = Product.objects.aggregage(count = Count('id')) 

#in UI --> {'count': 1000}


Now we can also calculate multiple summaries. So, in addition to the total number of products, We can also calculate the minimum price of our products. 

result = Product.objects.aggregage(count = Count('id'), min_price=Min('unit_price'))

#in UI --> {'count': 1000, 'min_price': Decimal('1.06')} 

Since aggregate is one of the methods of querysets, we can also apply it wherever we have a query set. 
So, we can filter our products and pull out the products in our given collection(say collection 1). And then calculate these summaries over that data set.

result = Product.objects.filter(collection__id=1).aggregate(count=Count('id'))


Aggregate Exercises:

#How many orders do we have?
result = Order.objects.aggregate(count=Count('id'))

#How many units of product 1 have we sold?
result = OrderItem.objects.filter(product__id=1).aggregate(units_sold=Sum('quantity'))

#How many orders has customer 1 placed?
result = Order.objects.filter(customer__id=1).aggregate(count=Count('id'))

#What is the min, max and avg price of products in collection 1? 
result = Product.objects.filter(collection__id=3).aggregate(min_price=Min('unit_price'), avg_price=Avg('unit_price'), max_price=Max('unit_price'))	










Annotating Objects:
-------------------

Django ORM provides the annotate() method to add custom attributes to query results dynamically. These attributes are not actual database fields but are computed at runtime.


we cannot go and simply add the value 'True' directly, we would get an error saying QuerySet.annotate() received non-expressions	. 
This error tells us that we cannot pass a Boolean value. We need to pass an expression object. So, in Django, we have this 'Expression' class, which is the base class for all all types of expressions. Derivatives of this class are 'Value', for representing simple values, like a number, a boolean, a string. We have 'F', which you have seen before. Using the F class, we can reference a field in the same or another table, right? So an F object is essentially an expression object. We also have 'Func' for calling database functions. So, all these database engines have a bunch of functions for manipulating data. To call those functions, We use a 'Func' object. We also have Aggregate, which is the Base class for all Aggregate classes. So those aggregate classes you learn about, like Count,sum, max, min.  All these classes derived from the aggregate class.

Expression 
	Value
	F
	Func
	Aggregate



1. Basic Annotation with Value()
To add a static field to query results, use Value():

📌 Add a field is_new with a constant value True:
from django.db.models import Value

queryset = Customer.objects.annotate(is_new=Value(True))
✅ Result: Adds a column called is_new to every customer with value True.

📌 Generated SQL Query:
SELECT id, first_name, last_name, TRUE AS is_new FROM store_customer;
🚀 Note: The boolean True is stored as 1 in the database.


❌ Error if we use a raw Boolean:
queryset = Customer.objects.annotate(is_new=True)  # ❌ Causes an error
Django requires expressions, not raw values—hence the need for Value(True).




2. Referencing Existing Fields Using F()
To reference another field in the model, use F().

📌 Add a field new_id, duplicating the existing id field:
from django.db.models import F

queryset = Customer.objects.annotate(new_id=F('id'))
✅ Result: new_id is identical to id.

📌 Generated SQL Query:
SELECT id, first_name, last_name, id AS new_id FROM store_customer;

📌 Perform a Calculation on id:
queryset = Customer.objects.annotate(new_id=F('id') + 1)
✅ Result: new_id = id + 1.

📌 Generated SQL Query:
SELECT id, first_name, last_name, id + 1 AS new_id FROM store_customer;

🚀 Use Case:
F() allows dynamic field computations without needing to fetch data into Python memory.




3. Other Expression Classes in Django
Django provides other expression types for more advanced annotations:

Value() → Wraps static values.
F() → References existing fields.
Func() → Calls database functions.
Aggregate() → Performs aggregations (Count(), Sum(), etc.).



Key Takeaways
✔ Use annotate() to add computed fields to queries. ✔ Use Value() for static values. ✔ Use F() to reference existing model fields dynamically. ✔ Perform computations directly in the query (F('field') + 1). ✔ Avoid passing raw values—always wrap them in expression objects.

🚀 Next Lesson: Using Func() for database functions in annotations!















Calling Database Functions: 
---------------------------

Alright, now let's see how we can call a database function. So,from the same module, we're need to import the Func class. Now we're going to give our customers a new field called 'full_name'. And this is where we're going to call the CONCAT function of a database engine. So, pretty much all database engines have this function for concatenating strings. So, we have to create a 'Func' object and give it a bunch of arguments. Just remember that can we reference fields using the F objects. Next we need to give a keyword argument that specifies the target function. So, we set function to 'CONCAT'. We also need to add a space in between and we cannot simply pass a white space. We need to pass an expression object. So, we need to wrap this inside a value object.

from django.db.models import Value, F, Func

queryset = Customer.objects.annotate(full_name = Func(('first_name'), Value(' '), F('last_name'), function = 'CONCAT')
 #Here concat is the concat function database engine

SQL: SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership CONCAT(store_customer.first_name, '', store_customer.last_name) AS full_name FROM store_customer



Great. Now, there is also a shorthand to achieve the same result. we're going to import the CONCAT class from Django. Remember to add a white space, we need to wrap it inside a 'Value' object otherwise Django thinks this is a column in our table. 


from django.db.models.functions import Concat

queryset = Customer.objects.annotate(full_name = Concat('first_name', Value(' '), 'last_name'))



Now, if you're curious about Django database functions, just Google 'Django database functions' 
https://docs.djangoproject.com/en/5.1/ref/models/database-functions/

On this page. You can see various functions in different categories. For example, we have a bunch of functions for working with dates, we have mathematical functions. We have functions for manipulating text and so on. These functions are common across all database engines, but different database engines have their own unique functions. So, to call those functions you have to go back and use a 'Func' object.













Grouping Data:
--------------

Now let's say we want to see the number of orders each customer has placed. So we're going to annotate our customers with a new field called 'orders_count'. For that we are going to use the count class.


from django.db.models import Value, F, Funct, Count


Now if you look at Customer and Order class


class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)


class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)



When you look at the order class, we have customer field, which is a foreign key. And with this implementation, Django is going to create the reverse relationship for us. So, in the customer class, we're gonna have a field called 'order_set'(the singular name of the target class followed by '_set' and this all should in lowercase). 
Now, for some reason that is known to Django developers, we cannot use the same, to count the number of orders for each customer, which means  

if you use,
queryset = Customer.objects.annotate(orders_count=Count('order_set'))

we get an exception saying "cannot resolve keyword order_set into field. Our choices are address, birth_date, email, first_name, id, last_name, membership, order, phone." 



So, the name of the field that we should use for counting is 'order'. Why? Honestly, I don't know. So back to our code, let's change it to 'order'. 

queryset = Customer.objects.annotate(orders_count=Count('order'))

SQL:
SELECT store_customer.id, store_customer.first_name, store_customer.last_name, store_customer.email, store_customer.phone, store_customer.birth_date, store_customer.membership, COUNT(store_order.id) AS orders_count FROM store_customer LEFT OUTER JOIN store_order ON (store_customer.id =  store_order.customer_id) GROUP BY store_customer.id ORDER BY NULL

So in the SQL,  we are selecting all the fields from the customer table, and we're also counting the number of orders. Now look, we have a left join between customers and orders, because not every customer has an order. And finally we have, a group by clause for grouping the number of orders for each customer.



🚀 Reason:
order_set is only available for direct queries on Customer objects, but not in ORM aggregation methods like annotate().
Instead of order_set, Django ORM refers to the related model name (order) when counting instances.

📌 Correct Query:
queryset = Customer.objects.annotate(orders_count=Count('order'))

✅ This ensures orders_count is calculated properly.













Working with Expression Wrappers:
---------------------------------




So, let's quickly recap what you have learned so far. We talked about the Expression class, which is the base class for all types of expressions. Derivatives of this class are 'Value' for representing simple values like a boolean, a number, a string. We have 'F' for referencing fields, 'Func' for calling database functions, 'Aggregate', which is the base class for all aggregate classes like count, sum, and so on. Now in this lesson, we're going to talk about another derivative of the Expression class called ExpressionWrapper. We use this class when building complex expressions. 

Expression 
	Value
	F
	Func
	Aggregate
	ExpressionWrapper



Let's do an example and check an error: 
queryset = Product.objects.annotate(discounted_price=F('unit_price') * 0.8)


So, here's an example. Let's say we're going to annotate our products and give them a new field called discounted_price. So here we're going to get the unit price and multiply it by 0.8. 

Now, if we run it, we're going to get an exception. So we get this error saying "FieldError: Expression contains mixed types: DecimalField, FloatField. you must set output_field." Here because we have mixed decimal field, which is our unit price field, with a float field, which is our 0.8 number. Now the error is saying that we must set the output field. 


So, to solve this problem, first we need to import the ExpressionWrapper class from the same module. Then we should wrap the expression inside an ExpressionWrapper object, and that's where we specify the type of the output field. As the second argument to the constructor of the ExpressionWrapper class, we specify the output field. So, we need to decide what is the type of the output field. For monetary values, we should always use a decimal field, because float fields have rounding issues and are not very accurate. 

from django.db.models import Value, F, ExpressionWrapper

dicounted_price = ExpressionWrapper(F('unit_price') * 0.8, output_field = DecimalField())
queryset = Product.objects.annotate(dicounted_price = discounted_price)


SQL: select store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id, (store_product.unit_price * 0.8e0) AS discounted_price FROM store_product


More exercises with ExpressionWrapper:

# customers and their last order ID
queryset = Customer.objects.annotate(last_order_id=Max('order__id'))

# collections and count of their products
queryset = Collection.objects.annotate(products_count=Count('product'))

# Customers with more than 5 orders
queryset = Customer.objects.annotate(orders_count=Count('order')).filter(orders_count__gt=5)



# Customers and the total amount they've spent
queryset = Customer.objects.annotate(total_spent=Sum(F('order__orderitem__unit_price') * F('order__orderitem__quantity')))

from django.db.models import Sum, F, ExpressionWrapper, DecimalField

total_spent = ExpressionWrapper(
    Sum(F('order__orderitem__unit_price') * F('order__orderitem__quantity')),
    output_field=DecimalField()
)

queryset = Customer.objects.annotate(total_spent=total_spent)




# Top 5 best-selling products and their total sales
queryset = Product.objects.annotate(total_sales=Sum(F('orderitem__unit_price') * F('orderitem__quantity'))).order_by('-total_sales')[:5]


total_sales = ExpressionWrapper(
    Sum(F('orderitem__unit_price') * F('orderitem__quantity')),
    output_field=DecimalField()
)

queryset = Product.objects.annotate(total_sales=total_sales).order_by('-total_sales')[:5]



🚀 Why Use ExpressionWrapper?
Ensures Django treats computed values correctly (e.g., decimal types).
Useful for complex calculations within annotations.












Querying Generic Relationships:
-------------------------------
Django’s content type framework allows models to relate dynamically to multiple models, making them more reusable. This is useful for tagging systems where a TaggedItem model can associate tags with different models (e.g., products, articles, blog posts).

1. Understanding Content Types and Generic Relationships:
Content Type Table:
Django maintains a table called django_content_type, which contains metadata about all models in the project.

📌 Example Entries in django_content_type:
id	app_label	model
1	admin	logentry
2	auth	user
11	store	product

✅ Each model has a unique content_type_id. 
✅ The Product model’s content type ID is 11, meaning Django refers to it internally with this ID.





2. Finding Tags for a Given Product

📌 Steps to Query Tags for a Product:
1. Find the content type ID for the Product model.
2. Use that ID to filter TaggedItem records where:
	content_type_id = Product’s content type ID
	object_id = Product’s ID

📌 Implementation:
from django.contrib.contenttypes.models import ContentType
from store.models import Product
from tags.models import TaggedItem

# Get the content type ID for the Product model
content_type = ContentType.objects.get_for_model(Product)

# Filter TaggedItem objects for a specific product
queryset = TaggedItem.objects.select_related('tag').filter(
    content_type=content_type,
    object_id=1  # Replace with dynamic product ID
)


🚀 Why Not Hardcode content_type_id = 11?
The ID may differ in production versus development databases.
get_for_model(Product) dynamically retrieves the correct ID.



📌 SQL Query Generated:
SELECT django_content_type.id, django_content_type.app_label, django_content_type.model
FROM django_content_type
WHERE (django_content_type.app_label = 'store' AND django_content_type.model = 'product')
LIMIT 21;

✅ Finds the content type ID for the Product model.





3. Optimizing the Query with select_related()
Since TaggedItem refers to Tag, we need to preload the tag field to avoid extra queries.

📌 Optimized Query Using select_related()

queryset = TaggedItem.objects.select_related('tag').filter(
    content_type=content_type,
    object_id=1
)

🚀 Ensures only ONE query is sent, instead of separate queries for each tag lookup.


📌 SQL Query Generated:
SELECT tags_taggeditem.id, tags_taggeditem.tag_id, tags_taggeditem.content_type_id, tags_taggeditem.object_id,
       tags_tag.id, tags_tag.label
FROM tags_taggeditem
INNER JOIN tags_tag ON (tags_taggeditem.tag_id = tags_tag.id)
WHERE (tags_taggeditem.content_type_id = 11 AND tags_taggeditem.object_id = 1);

✅ Uses INNER JOIN to fetch tag labels in a single query.




Key Takeaways
✔ Use Django’s content type framework to decouple models dynamically. 
✔ Use get_for_model(Product) instead of hardcoded IDs to ensure correct lookup. 
✔ Use select_related('tag') to optimize queries when fetching related objects. 
✔ Format long ORM queries using \ for better readability.

🚀 Next Lesson: Creating a custom manager to simplify generic relationships in Django ORM.














Custom Managers:
================

Django allows us to create custom managers to extend the functionality of model queries. This improves code reusability and ensures cleaner, more efficient queries.

1. The Problem: Querying Generic Relationships Manually

Previously, to find tags for a given product, we had to:
1. Retrieve the content type ID for the Product model.
2. Query the TaggedItem table using this ID.
3. Use select_related('tag') to optimize queries.

🚀 This approach worked but was repetitive—every time we needed tags, we had to write the same logic manually.




2. Solution: Creating a Custom Manager for TaggedItem
A custom manager allows us to: ✔ Encapsulate the query logic in a reusable method. ✔ Call TaggedItem.objects.get_tags_for(product) instead of writing complex queries manually.


Step 1: Creating a Custom Manager
📌 Define a new manager in tags/models.py:

from django.db import models
from django.contrib.contenttypes.models import ContentType

class TaggedItemManager(models.Manager):
    def get_tags_for(self, obj_type, obj_id):
        content_type = ContentType.objects.get_for_model(obj_type)

        return TaggedItem.objects \
            .select_related('tag') \
            .filter(
                content_type=content_type,
                object_id=obj_id
            )



So, this class 'TaggedItemManager' is inheriting from the 'Manager' class in the 'models' module. So, the 'models.Manager' class is the base class for all Managers.

✅ What This Manager Does:
Retrieves the content type ID for the given model (obj_type).
Queries TaggedItem.objects filtering by content type & object ID.
Uses select_related('tag') to optimize queries and fetch tags efficiently.


Step 2: Assigning the Custom Manager to the Model
📌 Use the custom manager in TaggedItem:

class TaggedItem(models.Model):
    objects = TaggedItemManager()  # Assign the custom manager

    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()

✅ This replaces Django's default manager with TaggedItemManager.

Now, instead of manually querying for tags, we can simply call:
TaggedItem.objects.get_tags_for(Product, 1)  # Fetch tags for Product ID 1
🚀 Cleaner and more reusable!





3. Query Execution Behind the Scenes
📌 Generated SQL Query:
SELECT tags_taggeditem.id, tags_taggeditem.tag_id, tags_taggeditem.content_type_id, tags_taggeditem.object_id,
       tags_tag.id, tags_tag.label
FROM tags_taggeditem
INNER JOIN tags_tag ON tags_taggeditem.tag_id = tags_tag.id
WHERE tags_taggeditem.content_type_id = 11 AND tags_taggeditem.object_id = 1;

✅ Uses INNER JOIN for efficient retrieval of related tags. ✅ Ensures optimized querying for better database performance.



Key Takeaways
✔ Custom managers improve code maintainability by centralizing query logic. 
✔ get_tags_for() makes querying tags simple and removes repetitive code. 
✔ Assign TaggedItemManager() to TaggedItem.objects to use the custom method. 
✔ Optimized queries using select_related('tag') reduce extra database hits.

🚀 Next Step: Implementing further custom managers for different query optimizations!















Understanding QuerySet:
-----------------------

Let's talk about the caching mechanism built into query sets.

queryset = Product.objects.all()

list(queryset)

queryset[0]

Now, you know that when we convert the queryset into a list, Django is going to evaluate the query set and that's when it's going to go to the database to get the result. Now, this is an expensive operation because reading data from the disk is always slower than reading it from the memory. So, when Django evaluates this query and gets the data from the database and it's going to store it somewhere in memory called the query set cache. So, the second time we convert the query set in to a list(say again list(queryset)), Django is not going to evaluate thhe query again. 
It's not going to go to the database. It's going to read the result from the query set cache. Now the same thing happens if you access an individual element from this query set. Again, Django is going to read this object from the query set cache. Now one thing you need to know about caching is that caching happens only if you evaluate the entire query set first. In contrast, if you accessed an individual element first(say queryset[0]), then converting our queryset into a list. you would end up with two queries to the database. 



SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product LIMIT 1

SELECT store_product.id, store_product.title, store_product.slug, store_product.description, store_product.unit_price, store_product.inventory, store_product.last_update, store_product.collection_id FROM store_product


We have two queries now, with the first query, we are reading the first product in the product table. And with the second query we're reading all our products. So keep this in mind. Even though caching is a great optimization technique, if you don't structure your code properly, Caching is gonna cost us. So this is all about caching. Next we're going to talk about creating objects.











Creating Objects:
-----------------

collection = Collection()
collection.title = 'Video Games'
collection.featured_product = Product(pk=1) or Product(id=1) #when you use pk, you don't have to remember what is the primary key name
collection.featured_product_id = 1 


Either way, the product should exists before we can create this collection. In other words, we cannot create this collection and this product(product 1) at the same time. And this is how the relational databases work, the parent record should exists before we create child record. 

 or 
 
collection = Collection(title='Video Games') --> this approach won't give IntelliSense
collection.save()


Hence dot operator (.) gives you the intellisense, but the keyword argument doesn't
Also in future if you have changed the field name, it will get reflected with the dot operator, but not with the keyword argument


collection = Collection.objects.create(name = 'a', featured_product_id = 1) # it will the call the save method automatically 

But again, intellisense doesn't work here and would not get updated if we have changed the field name 













Updating Objects: 
-----------------
Updating objects in Django requires careful handling to avoid unintended data loss. There are two main approaches: 
✔ Updating an instance directly (recommended for selective updates). 
✔ Using the update() method (useful for bulk updates, but requires caution).


1. Directly Updating an Instance
🚀 Best practice: Retrieve the object from the database before modifying fields.

📌 Steps to update a collection:
collection = Collection.objects.get(pk=11)  # Fetch collection from DB
collection.title = 'Games'  # Modify title
collection.featured_product = None  # Modify featured product
collection.save()  # Save changes

✅ Ensures all existing field values are preserved before updating.

📌 Generated SQL Query:
UPDATE store_collection 
SET title = 'Games', featured_product_id = NULL 
WHERE id = 11;


🛑 Potential Issue: If we only want to update particular field instead of everything (say only the 'featured_product'):

collection = Collection(pk=11)  # Creates an empty instance, missing database values!
collection.featured_product = None  
collection.save()  # ❌ Data loss (title overwritten to empty string!)

🚨 Why?
Django will set the Unset fields (like title) to some default to empty values and this causes data loss. 

Here's the reason. This collection object that we have in memory, by default, its 'title' is set to an empty string. So even if we don't explicitly update this field, Django is going to include it in our SQL statement. 
And this is where Django is different from some of the other ORMs you might have worked with. Some other ORMs out there have this feature called 'change tracking'. So, the SQL statement that is generated will be based on the fields that are updated. So, to properly update an object in Django applications, first we have to read it from the database. 


✅ Solution: Always use .get() to fetch the existing record first!

collection = Collection.objects.get(pk=11)  
collection.featured_product = None  
collection.save()  





2. Updating Fields Without Reading the Object (update())
Django’s update() method allows updating database records without fetching them first.

📌 Steps to update a specific field without loading the object:
Collection.objects.filter(pk=11).update(featured_product=None)

✅ Optimized: Avoids retrieving the object first. 

✅ Generated SQL Query:
UPDATE store_collection 
SET featured_product_id = NULL 
WHERE id = 11;

The update() method directly modifies database records without loading model instances into memory.

🚀 Use Case: ✔ Works well when updating only one or a few fields on multiple records. ✔ Should not be used if additional logic (e.g., validation, pre-save hooks) is needed.




3. When to Use Each Approach?
             	
.get() + save()	        
Best Use Case:
Selective updates, where maintaining existing field values is critical	

Avoid When:
Fetching unnecessary data for bulk updates


.update()
Best Use Case:	
Fast, direct updates to one or multiple fields
	
Avoid When:
When signals, hooks, or validation are needed



🚀 Rule of Thumb: 
✔ Use .get() + save() for individual object updates where all fields matter. 
✔ Use .update() for bulk field modifications where only certain fields need updating.

Key Takeaways
✔ Always use .get(pk=ID) before modifying fields to prevent unintended data loss. 
✔ Use update() to modify specific fields directly, avoiding unnecessary queries. 
✔ Avoid using Collection(pk=ID) for updates—it creates an empty instance, causing overwrites. 
✔ Choose the right method (save() vs. update()) based on need and efficiency.








Deleting Objects:
-----------------

We can delete a single object or multiple objects in a query set. 

To delete a single object: 
collection = Collection(pk=11)
collection.delete()


Now to delete multiple objects, first we need to get a query set:
Collection.objects.filter(id__gt=5).delete()



Exercise: 

Creating, Updating and Removing Objects

write code to 
create a shopping cart with an item 
Update the quantity of an item in a shopping cart 
Remove a shopping cart with its items. 


Solutions: 
cart = Cart()
cart.save()

item1 = CartItem()
item1.cart = cart
item1.product_id = 1
item1.quantity = 1
item1.save()

#Updating the quantity of an item
item1 = CartIem.objects.get(pk=1)
item1.quantity = 2
item1.save()

#Removing a cart 
cart = Cart(pk=1) 
cart.delete()
# Because we've enabled cascading in the relationship between 
# cart and its items, deleting a cart automatically causes 
# deletion of its items. So, we don't need to delete each item
# individually 












Transactions:
-------------

Transactions ensure atomicity, meaning multiple database operations succeed together or fail together. This prevents data inconsistency when inserting related records like orders and order items.

1. Why Use Transactions?
📌 Problem:
When creating an order, we first insert the order record and then its associated order items.
If saving an order item fails, the order gets inserted without its items—causing data inconsistency.

📌 Solution: ✔ Wrap all dependent operations inside a transaction using transaction.atomic(). ✔ If any operation fails, all changes get rolled back, preventing incomplete data.




2. Implementing Transactions in Django
Step 1: Import Transaction Module
from django.db import transaction

📌 Django’s transaction.atomic() ensures all database operations within it succeed together.

Step 2: Creating an Order and Order Item Safely
with transaction.atomic():  # Start a transaction
    order = Order(customer_id=1)  # Create an order
    order.save()  # Save the parent record first
    
    order_item = OrderItem(order=order, product_id=5, quantity=2, unit_price=50)  
    order_item.save()  # Save the child record

✅ If saving order_item fails, order won't be saved.

📌 Generated SQL Query (If Successful):
INSERT INTO store_order (customer_id) VALUES (1);
INSERT INTO store_order_item (order_id, product_id, quantity, unit_price) VALUES (1001, 5, 2, 50);

🚨 Preventing Data Loss:
If an exception occurs, all changes are rolled back, avoiding partial inserts.




3. Using transaction.atomic() as a Decorator:
Instead of wrapping operations manually, apply @transaction.atomic at the view level:
@transaction.atomic
def place_order(request):
    order = Order(customer_id=1)
    order.save()

    order_item = OrderItem(order=order, product_id=5, quantity=2, unit_price=50)
    order_item.save()
✅ Ensures atomicity across the entire view function.





4. Demonstrating Rollback on Failure
📌 Example: Trying to Save an Invalid Order Item
with transaction.atomic():
    order = Order(customer_id=1)
    order.save()

    order_item = OrderItem(order=order, product_id=-1, quantity=2, unit_price=50)  
    order_item.save()  # ❌ Error: Product ID -1 does not exist!


🚨 Integrity Error Occurs → Transaction Rolls Back
IntegrityError: FOREIGN KEY constraint failed
✅ Query rollback prevents the orphaned order from being saved.

📌 Verifying the Database:
SELECT * FROM store_order ORDER BY id DESC;  -- No new order is inserted




5. When to Use Transactions?
✔ Multiple related inserts (e.g., orders and items). 
✔ Bulk updates requiring consistency (e.g., updating product stock after purchase). 
✔ Preventing incomplete data on errors.



🚀 Key Takeaways 
✔ Use transaction.atomic()  as a context manager to ensure multiple operations succeed together or fail together. 
✔ If one operation fails, all changes are rolled back to maintain consistency. 
✔ Can be used as a decorator for entire views (@transaction.atomic). 
✔ Always test transactions by simulating failures (e.g., invalid foreign keys).













Executing Raw SQL Queries: 
--------------------------
Django ORM provides powerful query capabilities, but sometimes certain queries become overly complex using ORM filters and annotations. In such cases, you can execute raw SQL queries directly.

1. Using .raw() to Execute Raw SQL Queries
Django allows executing raw queries using the .raw() method.

📌 Example: Fetch all products using raw SQL
queryset = Product.objects.raw('SELECT * FROM store_product')

✅ Result: Django executes the query and maps the retrieved columns to model fields. 
✅ Returns a special raw query set, which does not support methods like .filter() or .annotate().

📌 Generated SQL Query:
SELECT * FROM store_product;

🚀 When to Use .raw()? 
✔ When Django ORM cannot efficiently generate complex queries. 
✔ When manually writing SQL is more readable or performs better than the django generated one. ✔ When optimizing database queries for speed.




2. Limiting Columns to Improve Performance
Instead of selecting all fields, specify only necessary columns:
queryset = Product.objects.raw('SELECT id, title FROM store_product')
✅ Django loads only id and title, while other fields remain deferred (not fetched unless needed).

📌 Generated SQL Query:
SELECT id, title FROM store_product;
🚀 Use Case: ✔ Reduces memory usage and speeds up queries by fetching only required fields.




3. Using connection.cursor() for Full SQL Control
Sometimes, raw queries do not map directly to Django models. In such cases, access the database directly using connection.cursor().

📌 Example: Executing arbitrary SQL queries
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SELECT COUNT(*) FROM store_product")
    result = cursor.fetchone()  # Fetch single result
✅ Allows executing SELECT, INSERT, UPDATE, DELETE, or any SQL operation. ✅ Using with ensures cursor closure, preventing memory leaks.

🚀 Advantages of Using connection.cursor() ✔ Provides full SQL control, bypassing Django models. ✔ Supports transaction handling and direct interactions with the database. ✔ Helps in executing complex queries that ORM cannot handle efficiently.




4. Using Stored Procedures in Django
Django supports calling stored procedures using .callproc().

📌 Example: Executing a stored procedure
cursor.callproc('get_customers', [1, 2])  # Calls stored procedure with parameters

✅ Encapsulates SQL logic inside stored procedures, making Python code cleaner. 
✅ Optimizes performance when complex queries are frequently used.

🚀 Best Practice: ✔ Store complex query logic inside stored procedures, instead of writing SQL statements inside Python scripts.



Key Takeaways
✔ Use .raw() for raw SQL queries, but only when ORM becomes inefficient. 
✔ Specify only required columns to improve query performance. 
✔ Use connection.cursor() for full database control (SELECT, INSERT, UPDATE, DELETE). 
✔ Prefer stored procedures for reusable SQL logic, avoiding hardcoded queries. 
✔ Always use the with statement with cursor to prevent memory leaks.


🚀 Next Lesson: Exploring Django’s admin interface!















The Admin Site:
---------------

Here in this section we're gonna talk about setting up the admin interface for managing our data. 
We'll talk about various ways to customize the admin interface, how to add computed columns, load related objects, add searching and filtering, implement custom actions, add data validations and more. 
So by the end of this section, we'll have a full fledged admin interface for managing our data


Setting Up the Admin Site:
---------------------------
Django provides a built-in admin interface that allows managing users, models, and permissions efficiently. Below is a step-by-step guide to setting it up.

1. Accessing the Admin Panel
The Django admin interface is available at:

http://localhost:8000/admin
On first access, it shows the login screen.




2. Creating a Superuser for Admin Access
To log into the admin panel, create a superuser using the following command in the terminal:

python manage.py createsuperuser
You will be prompted for:

Username → Example: admin
Email → Example: admin@example.com
Password → Example: 123123 (you may need to bypass security warnings by pressing Y)

✅ Once created, you can log in using these credentials.




3. Fixing Session Errors
If the session app is missing, Django’s admin login may fail.

📌 Solution: Ensure django.contrib.sessions is added in INSTALLED_APPS in settings.py:

INSTALLED_APPS = [
    'django.contrib.sessions',
    # other installed apps...
]
✅ After adding a new app, always run migrations to create necessary tables:


python manage.py migrate
🚀 This creates the django_session table for session storage.





4. Exploring the Admin Dashboard
Once logged in:
Manage users and groups stored in Django’s auth tables.
Superuser permissions grant full access.
User passwords are stored in encrypted format.

📌 View user records in the database:

SELECT * FROM auth_user;
✅ Displays admin user details, including login history and permissions.




5. Resetting Admin Password
If you forget your password, reset it using:

python manage.py changepassword admin
✅ Allows setting a new password for the admin user.




6. Customizing the Admin Interface
You can personalize the admin site header and title.

📌 Modify admin.py or add customization in urls.py:
from django.contrib import admin
admin.site.site_header = "Storefront Admin"  # Custom header
admin.site.index_title = "Admin Dashboard"  # Custom title

✅ Refresh the admin page to see updated branding.




Key Takeaways
✔ Use createsuperuser to set up admin credentials. ✔ Always run migrations after adding new apps. ✔ Check django_session table to verify session functionality. ✔ Use changepassword if admin credentials are lost. ✔ Customize the admin branding using site_header and index_title.

🚀 Next Lesson: Registering models in the Django admin panel!













Registering Models:
-------------------
Django's admin interface allows us to manage models from a graphical interface instead of running database commands manually. To make models accessible in the admin panel, we need to register them.



1. Registering Models in Django Admin
Each Django app has an admin.py module, where we configure which models appear in the admin panel.

📌 Steps to Register the Collection Model:
1. Open the store/admin.py file.
2. Import Django’s admin module and the models.
3. Register models using admin.site.register().

📌 Code Example:
from django.contrib import admin
from .models import Collection  # Import the model

admin.site.register(Collection)  # Register Collection in the admin panel

✅ Once registered, Django lists the model in the admin panel.

📌 After refreshing localhost:8000/admin, you'll see "Store" with "Collections" listed.





2. Changing Object Representation in Admin Panel
By default, Django displays object instances as "Collection object" in the admin panel. To improve readability, override the __str__ method in the model.

📌 Modify Collection Model (models.py):
class Collection(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Show collection title in admin panel

✅ Now, Django will display the collection name instead of "Collection object".






3. Sorting Objects in Admin Panel
By default, models are displayed unsorted in the admin panel. To sort collections alphabetically, define a Meta class inside the model.

📌 Modify Collection Model (models.py):
class Collection(models.Model):
    title = models.CharField(max_length=255)

	def __str__(self):
		return self.title
	
    class Meta:
        ordering = ['title']  # Sort collections alphabetically

✅ All collections in the admin panel will now be ordered alphabetically.





4. Registering the Product Model in Admin
Follow the same process to register products in the admin panel.

📌 Modify admin.py to include Product:
from django.contrib import admin
from .models import Collection, Product  # Import both models

admin.site.register(Product)  # Register Product


📌 Modify Product Model (models.py):
class Product(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Show product title instead of "Product object"

    class Meta:
        ordering = ['title']  # Sort products alphabetically

✅ Now, products will be listed in the admin panel and sorted by title.



Note:
Fixing Empty Collection Titles
- sometimes if a collection was mistakenly saved with an empty title, it will appear blank in the admin panel.
- We can delete such entries manually from the admin interface.



Key Takeaways
✔ Use admin.site.register(ModelName) to register models in Django admin. 
✔ Override __str__ in models to display meaningful names in the admin panel. 
✔ Use the Meta class inside models to define default ordering. 
✔ Register multiple models (Collection, Product, etc.) to manage them in the admin panel easily.

🚀 Next Lesson: Customizing the Django admin list page!











Customizing the List Page:
--------------------------
Customizing the Django Admin List Page
Django's admin interface allows customization for how models are displayed and managed. You can add columns, make fields editable, control pagination, and define sorting behavior.


1. Creating a Custom Admin Class
Instead of using default settings, create a custom admin class for each model.

📌 Example: Customizing the Product model in admin.py
from django.contrib import admin
from .models import Product, Customer

@admin.register(Product)  # Alternative to admin.site.register(Product, ProductAdmin)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price']  # Display fields in the list view
    list_editable = ['unit_price']  # Allow editing unit price directly in the list view
    list_per_page = 10  # Show 10 products per page
    ordering = ['title']  # Sort products alphabetically by title


So, we are saying that the 'ProductAdmin' class is the admin model for the 'Product' class.  

	
✅ Once registered, you can view and edit Product models in the admin panel.

📌 Generated SQL Query Example:
SELECT id, title, unit_price FROM store_product ORDER BY title LIMIT 10;

✅ Ensures products are displayed alphabetically and paginated.




2. Sorting and Pagination in the Admin Panel
✔ Sorting Columns
Click column headers to sort in ascending/descending order.
Default ordering can be set in ordering.

✔ Pagination
list_per_page=10 ensures only 10 records are shown per page.
Django automatically generates pagination controls at the bottom.

📌 Example SQL Query for Pagination:
SELECT * FROM store_product ORDER BY title LIMIT 10 OFFSET 10;

🚀 Optimizes performance by limiting database queries!





3. Creating a Custom Admin Class for Customer
Follow the same process to customize the Customer admin page.

📌 Example: Managing Customer records in admin.py
@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership']  # Show key fields
    list_editable = ['membership']  # Allow inline membership editing
    ordering = ['first_name', 'last_name']  # Default sorting order
    list_per_page = 10  # Show 10 customers per page

✅ Now, customers appear sorted, with membership editable inline.


📌 Generated SQL Query Example:
SELECT id, first_name, last_name, membership FROM store_customer ORDER BY first_name, last_name LIMIT 10;




4. Additional Customization Options
Django provides many ModelAdmin customization attributes. 
To explore more: 🔍 Search "Django ModelAdmin" documentation: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/

✔ Other useful options:
search_fields = ['title'] → Adds a search bar for filtering records.
list_filter = ['membership'] → Adds filter options for refining results.
actions = None → Disables batch actions (delete, update).




Key Takeaways
✔ Use @admin.register(Model) for cleaner admin registration. 
✔ Define list_display to show relevant fields in the admin table. 
✔ Use list_editable for inline editing of specific fields. 
✔ Set ordering to define the default sorting behavior. 
✔ Limit records per page using list_per_page for performance optimization. 
✔ Refer to Django’s ModelAdmin docs for advanced options.

🚀 Next Lesson: Adding computed columns in the Django admin panel!












Adding Computed Columns:
------------------------
Django allows adding computed columns to the admin list view. Instead of displaying raw field values, we can process the data dynamically and show user-friendly outputs.


1. Defining a Computed Column for Inventory Status:
We want to display an "Inventory Status" column that: 
✔ Shows "Low" if inventory is less than 10. 
✔ Shows "OK" otherwise.

📌 Modify admin.py to include a computed column:
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'unit_price', 'inventory_status']  # Show computed column

    @admin.display(ordering='inventory')  # Allow sorting by inventory
    def inventory_status(self, product):
        return 'Low' if product.inventory < 10 else 'OK'  # Compute inventory status dynamically

✅ Now, instead of showing raw inventory numbers, Django displays Low or OK.





2. Making Computed Columns Sortable
By default, Django does not know how to sort computed columns. To enable sorting, use the @admin.display(ordering='inventory') decorator.

📌 Sorting Implementation:
@admin.display(ordering='inventory')
def inventory_status(self, product):
    return 'Low' if product.inventory < 10 else 'OK'
	
	
🚀 Why This Works? 
✔ Links the computed column (inventory_status) to inventory so sorting behaves correctly. 
✔ Clicking the column header will sort in ascending or descending order.






3. Viewing Computed Column in Admin Panel

📌 Example Output in Django Admin:
Title	Unit Price	Inventory Status
Laptop	$999	    OK
Phone	$500	    Low
Tablet	$799	    OK

✅ Clickable column headers allow sorting by inventory count.




Key Takeaways
✔ Use computed columns in Django admin for better readability. 
✔ Override list_display to include custom methods. 
✔ Use @admin.display(ordering='inventory') to enable sorting on computed fields. 
✔ Computed columns dynamically process values, improving clarity for admins.











Selecting Related Objects:
--------------------------
Django’s admin interface allows displaying related objects in list views. Instead of performing separate queries for related objects, we can optimize data retrieval using select_related.

1. Displaying Related Objects in Admin
To show product collections in the admin panel: 📌 Modify list_display in admin.py

list_display = ['title', 'unit_price', 'inventory_status', 'collection']
✅ This adds a "Collection" column to the product list page. ✅ Django will automatically call __str__() from the Collection model to display its title.

📌 Collection Model with __str__() Method
class Collection(models.Model):
    title = models.CharField(max_length=255)

    def __str__(self):
        return self.title  # Ensure proper display in the admin panel
		
✅ Admin will show collection names instead of "Collection object".




2. Displaying Specific Fields from Related Models
If you want to display a specific field instead of the __str__() representation: 📌 Define a method inside the admin class

def collection_title(self, product):
    return product.collection.title  # Display collection title instead of full object
	
📌 Update list_display
list_display = ['title', 'unit_price', 'inventory_status', 'collection_title']

✅ Ensures that only the title field from Collection is displayed.




3. Reducing Extra Queries Using list_select_related
By default, Django queries related fields separately, increasing the query count. To optimize performance, use list_select_related.

📌 Enable eager loading for related fields
list_select_related = ['collection']

🚀 What This Does? 
✔ Reduces extra queries by fetching collection data along with products in a single query. 
✔ Prevents Django from sending one query per product, improving speed.

📌 Before Optimization (Multiple Queries)
SELECT * FROM store_product;
SELECT title FROM store_collection WHERE id = 1;
SELECT title FROM store_collection WHERE id = 2;

📌 After Optimization (Single Query)
SELECT store_product.id, store_product.title, store_product.unit_price, store_product.inventory, 
       store_collection.title 
FROM store_product 
INNER JOIN store_collection ON store_product.collection_id = store_collection.id;

✅ Efficiently loads related objects using INNER JOIN instead of separate queries.




4. Displaying Orders Along with Customers in Admin

📌 Define an admin class for orders
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'placed_at', 'customer']

✅ Displays order details along with customer names.

📌 Modify Customer model for proper display
class Customer(models.Model):
    first_name = models.CharField(max_length=255)
    last_name = models.CharField(max_length=255)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"  # Show full name in admin

✅ Ensures customers appear as "John Doe" instead of "Customer object".

📌 Set default ordering inside Customer model
class Meta:
    ordering = ['first_name', 'last_name']

✅ Sorts customers alphabetically by first and last name.

Key Takeaways
✔ Use list_display to show related fields in admin. 
✔ Define custom methods (collection_title) for displaying specific fields. 
✔ Use list_select_related to optimize queries and reduce database calls. 
✔ Override __str__() in models to customize object display in the admin panel. 
✔ Set default ordering in Meta class to keep lists sorted properly.












Overriding the Base QuerySet:
-----------------------------
Django’s admin interface allows customizing how models are retrieved for list views. By overriding the base queryset, we can add computed columns such as counting related objects.

1. Adding a Computed Column for Product Count
📌 Objective:
Show the number of products in each collection inside the admin panel.
Add sorting functionality to the column.

📌 Steps:
Create a custom admin class for Collection.
Define a computed column (products_count) for counting related products.
Override the queryset to annotate collections with their product count.





2. Implementing the Computed Column

Step 1: Register Collection with a Custom Admin Class

📌 Modify admin.py to create CollectionAdmin:
from django.contrib import admin
from django.db.models import Count
from .models import Collection

@admin.register(Collection)  # Register Collection with a custom admin class
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']  # Show title and product count

    @admin.display(ordering='products_count')  # Enable sorting on this column
    def products_count(self, collection):
        return collection.products_count  # Return computed field

✅ Now, the "Products Count" column appears in the admin panel. ✅ Sorting functionality is enabled using @admin.display(ordering='products_count').




3. Overriding the QuerySet to Annotate Data
By default, Collection does not have a products_count field. To compute this dynamically, override get_queryset():

📌 Modify CollectionAdmin to annotate product count:
def get_queryset(self, request):
    return super().get_queryset(request).annotate(
        products_count=Count('product')  # Count related products
    )

🚀 What This Does? ✔ Fetches all collections with the number of related products. ✔ Uses annotate() to attach a computed field (products_count). ✔ Ensures sorting works properly in the admin panel.

📌 Generated SQL Query:
SELECT store_collection.id, store_collection.title, COUNT(store_product.id) AS products_count
FROM store_collection
LEFT JOIN store_product ON store_collection.id = store_product.collection_id
GROUP BY store_collection.id;

✅ Uses LEFT JOIN to count products while ensuring collections with no products still appear.



4. Sorting the Computed Column
Without explicit sorting, Django doesn’t know how to sort products_count. 📌 Solution: Use @admin.display(ordering='products_count'):
@admin.display(ordering='products_count')
def products_count(self, collection):
    return collection.products_count
✅ This ensures sorting works properly in ascending and descending order.



The entire code looks like: 

@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['title', 'products_count']
	
	@admin.display(ordering='products_count')
	def products_count(self,collection):
		return collection.products_count
	
	
	def get_queryset(self, request):
	    return super().get_queryset(request).annotate(
		    products_count=Count('product')
		)


Key Takeaways
✔ Use get_queryset() to override the base queryset and annotate data. 
✔ Use Count() inside annotate() to compute related object counts dynamically. 
✔ Use @admin.display(ordering='field_name') to enable sorting on computed columns. 
✔ Register models with @admin.register(Model) for cleaner admin setup.


















Providing Links to Other Pages:
-------------------------------
Django allows adding hyperlinks inside the admin interface to navigate between pages. This is useful for linking related models—such as showing a collection's products inside the collection list view.

1. Adding Clickable Links in Django Admin
Instead of displaying just the number of products in a collection, we can convert it into a link that takes users to the product list filtered by that collection.

📌 Modify admin.py to include formatted HTML:
from django.utils.html import format_html
from django.urls import reverse

@admin.display(ordering='products_count')  # Enable sorting
def products_count(self, collection):
    url = reverse('admin:store_product_changelist')  # Generate product list URL dynamically  #Sytax is reverse('admin:app_model_page')
    return format_html('<a href="{}">{}</a>', url, collection.products_count)  # Create clickable link
	
✅ Now, clicking the product count redirects to the product list page. ✅ No hardcoding required—Django dynamically generates URLs.





2. Applying a Filter to Show Only Related Products
Clicking the link currently shows all products, but we need to filter products for that specific collection. To apply a filter, append a query string (?collection__id=1) to the URL.

📌 Modify admin.py to include filtering logic:
from django.utils.html import format_html, urlencode

def products_count(self, collection):
    url = (
        reverse('admin:store_product_changelist')  # Get product list URL
        + '?'  
        + urlencode({'collection__id': str(collection.id)})  # Append query parameters
    )
    return format_html('<a href="{}">{}</a>', url, collection.products_count)  # Format clickable link

✅ Now, the product list page will only show products in the selected collection.

📌 Example URL Generated:

/admin/store/product/?collection__id=1
🚀 This ensures clicking the collection’s product count links to the correct filtered list.





3. Creating Links for Customers to View Their Orders
As an exercise, you can implement a similar feature for customers. 📌 Example: Add an "Orders" column in the Customer admin panel:

@admin.display(ordering='orders_count')  # Enable sorting
def orders_count(self, customer):
    url = (
        reverse('admin:store_order_changelist')  # Get order list page URL
        + '?'  
        + urlencode({'customer__id': str(customer.id)})  # Filter by customer ID
    )
    return format_html('<a href="{}">{}</a>', url, customer.orders_count)  # Create clickable link

✅ Now clicking a customer’s order count shows only orders placed by that customer.



Key Takeaways
✔ Use format_html() to create clickable links inside Django admin. 
✔ Use reverse() to dynamically generate admin URLs, avoiding hardcoded paths. 
✔ Append query strings using urlencode() to filter lists based on selected items. 
✔ Enable sorting using @admin.display(ordering='field_name') to sort computed columns.















Adding Search to the List Page:
-------------------------------

Django’s admin interface allows adding a search bar to filter records based on specific fields. This improves user experience when managing large datasets.

1. Enabling Search in Django Admin
The search_fields attribute determines which fields can be searched.

📌 Modify admin.py for CustomerAdmin:
@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    search_fields = ['first_name', 'last_name']  # Enable search for these fields
    list_per_page = 10  # Show 10 records per page
	
✅ Now, the admin panel displays a search bar. ✅ Search results match records where first_name or last_name contains the query.




2. Improving Search Accuracy Using Lookup Types
By default, Django searches for partial matches anywhere within the field. To restrict searches to names starting with a query, use lookup types.

📌 Modify search_fields with startswith lookup:
search_fields = ['first_name__startswith', 'last_name__startswith']
✅ Now, searching "M" will return names starting with "M", but results are case-sensitive.

📌 Example SQL Query Generated:
SELECT * FROM store_customer WHERE first_name LIKE 'M%' OR last_name LIKE 'M%';
🚨 Issue: "m" (lowercase) does not match "M" (uppercase).





3. Making Searches Case-Insensitive
To ignore case differences, use istartswith instead:
📌 Modify search_fields to use case-insensitive lookup:
search_fields = ['first_name__istartswith', 'last_name__istartswith']

✅ Now, searching "m" will correctly match "M" as well.

📌 Generated SQL Query:
SELECT * FROM store_customer WHERE LOWER(first_name) LIKE LOWER('m%') 
OR LOWER(last_name) LIKE LOWER('m%');

🚀 Results are now case-insensitive, improving usability.



codes used in this lesson: 
search_fields = ['first_name', 'last_name']
search_fields = ['first_name__startswith', 'last_name__startswith']
search_fields = ['first_name__istartswith', 'last_name__istartswith']



Key Takeaways
✔ Use search_fields to enable search functionality in Django admin. 
✔ Use startswith for precise searches that match the beginning of fields. 
✔ Use istartswith to make searches case-insensitive for better accuracy. 
✔ Combine multiple fields in search_fields to allow searching across related attributes.


🚀 Next Lesson: Adding filters for refining admin list views!











Adding Filtering to the List Page:
----------------------------------
Django’s admin panel provides built-in filtering options to refine search results efficiently. You can filter using existing model fields or create custom filters based on specific conditions.

1. Adding Built-In Filters for Standard Fields
Django allows filtering using simple fields like collections and last update.

📌 Modify admin.py to include list_filter:
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_filter = ['collection', 'last_update']  # Enable filtering by collection and last update

✅ Now, the right panel in the admin interface shows filtering options. 
✅ Selecting a collection filters products belonging to that collection. 
✅ Filtering by last update allows selecting records from today, past 7 days, this month, etc.

📌 Example URL with filters applied:
/admin/store/product/?collection__id=3

🚀 Django automatically generates query strings for filtering!




2. Creating a Custom Filter for Inventory Levels
If built-in filtering is not sufficient, you can create custom filters.

📌 Example: Filter products based on inventory levels

Step 1: Create a Custom Filter Class
Define a new filter by extending admin.SimpleListFilter:

class InventoryFilter(admin.SimpleListFilter):
    title = 'Inventory'  # Title displayed in the admin panel
    parameter_name = 'inventory'  # Query parameter in URL

    def lookups(self, request, model_admin):
        return [
            ('<10', 'Low')  # Filter option: products with inventory < 10
        ]

    def queryset(self, request, queryset):
        if self.value() == '<10':  # If filter is applied
            return queryset.filter(inventory__lt=10)  # Filter products with low inventory

✅ Defines a filter that lets users view only "low inventory" products (<10).

Step 2: Add the Custom Filter to list_filter
📌 Modify ProductAdmin to include the new filter:

list_filter = ['collection', 'last_update', InventoryFilter]
🚀 Now, filtering by "Low Inventory" shows only products with inventory < 10.

📌 Example URL after applying the filter:
/admin/store/product/?inventory=<10

✅ Django applies query parameters automatically, filtering results dynamically.





Code References in this lesson:
list_filter = ['collection', 'last_update']


you can also create your own custom filter:

class InventoryFilter(admin.SimpleListFilter):
	title = 'inventory'
	parameter_name = 'inventory'
	
	def lookups(self, request, model_admin):
	    return[
		    ('<10', 'Low')
			]
			
	def queryset(self, request, querset):
		if self.value() == '10':
		    return queryset.filter(inventory__lt=10)
			
			
list_filter = ['collection', 'last_update', InventoryFilter]




Key Takeaways
✔ Use list_filter to enable filtering on standard fields. 
✔ Create custom filters using admin.SimpleListFilter for complex conditions. 
✔ Use lookups() to define filter options in the UI. 
✔ Use queryset() to apply filtering logic dynamically.













Creating Custom Actions:
------------------------

Django admin allows defining custom actions to perform bulk operations on selected objects. These actions appear in a dropdown list above the item list.

1. Defining a Custom Action:
let's say we want to define a custom action to clear the inventory of a bunch of products in one go. so we want set their inventory to zero.


📌 Step 1: Define a Method for the Custom Action
from django.contrib import admin

@admin.action(description='Clear inventory')  # Display name in the dropdown
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)  # Bulk update selected products
    self.message_user(
        request,
        f'{updated_count} products were successfully updated.',  # Success message
    )
	
✅ Now, selecting multiple products and executing this action sets their inventory to 0.




2. Registering the Custom Action
To make this action available in the admin panel, add it to the actions list.

📌 Modify ProductAdmin in admin.py
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    actions = ['clear_inventory']  # Register the custom action
	
✅ Now, "Clear Inventory" appears in the dropdown for bulk operations.




3. Displaying Messages to Users
Django allows showing status messages after executing an action.

📌 Using message_user()
self.message_user(
    request,
    f'{updated_count} products were successfully updated.',
    messages.ERROR  # Change message type (e.g., ERROR, SUCCESS, INFO)
)

✅ Messages appear at the top of the admin panel after the action runs. ✅ Different message types include ERROR, DEBUG, INFO, SUCCESS, WARNING.

📌 Example of an ERROR message:
from django.contrib import messages

self.message_user(
    request,
    f'{updated_count} products were successfully updated.',
    messages.ERROR
)
🚀 Use error messages when an action needs extra attention or failed execution.





Code in this lesson: 

from django.contrib import admin, messages

@admin.action(description='Clear inventory')
def clear_inventory(self, request, queryset):
    updated_count = queryset.update(inventory=0)
	self.message_user(
	    request,
		f'{updated_count} products were successfully updated.',
		messages.ERROR
		)


actions = ['clear_inventory']
	




Key Takeaways
✔ Use @admin.action(description='Action Name') to define custom actions. ✔ Bulk update selected objects using queryset.update(field=value). ✔ Register actions using actions = ['action_name'] in ModelAdmin. ✔ Use self.message_user() to display feedback messages after execution. ✔ Change message type (messages.ERROR, messages.SUCCESS, etc.) based on context.














Customizing Forms:
------------------

Django’s admin interface automatically generates forms for adding and updating models. However, customizing these forms allows better user experience and control over displayed fields.

1. Controlling Displayed Fields
By default, Django displays all model fields in the form. ✔ Use fields to explicitly define which fields should appear. ✔ Use exclude to remove unnecessary fields.

📌 Example: Display Only Specific Fields in Admin Form
class ProductAdmin(admin.ModelAdmin):
    fields = ['title', 'slug']  # Show only Title & Slug fields
	
✅ Now, only title and slug appear in the form.


📌 Example: Exclude Specific Fields
exclude = ['promotions']  # Hide the promotions field

✅ Removes promotions from the form while keeping others.




2. Making Fields Read-Only
Some fields should be displayed but not editable, like unique identifiers.

📌 Example: Display title but make it read-only
readonly_fields = ['title']

✅ Users see the title, but cannot modify it.





3. Auto-Populating Fields Using prepopulated_fields
Django can automatically generate values for fields based on other inputs.

📌 Example: Auto-generate slug based on title
prepopulated_fields = {
    'slug': ['title']  # Slug updates as the user types the title
}

✅ The slug field updates dynamically while typing the title. 
🚨 Note: Once edited manually, it will not auto-update again.





4. Using Autocomplete for Large Datasets
Some fields, like foreign keys, should be searchable instead of dropdowns, especially when they reference hundreds or thousands of records.

📌 Example: Convert collection field to autocomplete
autocomplete_fields = ['collection']

🚨 Error Handling: Django requires the related model to define search_fields. ✔ Fix by adding search_fields in CollectionAdmin:
class CollectionAdmin(admin.ModelAdmin):
    search_fields = ['title']  # Enable search functionality in autocomplete fields
	
✅ Now, users can search for collections instead of scrolling through a long dropdown list.

📌 Query Sent When Searching for a Collection:
SELECT * FROM store_collection WHERE title LIKE '%query%'

🚀 Optimizes performance by reducing page load time.





5. Understanding Missing Fields
✔ Some fields (e.g., placed_at) may not appear in the form. 
✔ Django automatically excludes fields with auto_now_add=True.

📌 Example: placed_at field does not appear because it auto-populates on creation.
class Order(models.Model):
    placed_at = models.DateTimeField(auto_now_add=True)  # Automatically set on creation
	
✅ Solution: Remove auto_now_add=True to allow manual date selection.(but it is not recommended, since we have used 'auto_now_add' for reason)



code used in this lesson:
fields = ['title', 'slug']

exclude --> opposite of fields

exclude = ['promotions']

read_only = []


prepopulated_fields = {
   'slug': ['title']   
}

autocomplete_fields = ['collection']



ModelAdmin Options: 
So, these are few ways to customize the form, But again if you want to find all the options available to you, just search for 'Django modeladmin' 
https://docs.djangoproject.com/en/5.2/ref/contrib/admin/
--> ModelAdmin Options  --> on this page you can find all possible ways to customize the list and forms 



Key Takeaways
✔ Use fields to explicitly control which fields appear in forms. 
✔ Use exclude to hide unnecessary fields. 
✔ Use readonly_fields for fields that should be displayed but not editable. 
✔ Use prepopulated_fields to auto-fill fields dynamically. 
✔ Use autocomplete_fields for foreign key relationships with large datasets. 
✔ Missing fields are often due to auto_now_add=True—remove to make them visible.















Adding Data Validation:
-----------------------
Django automatically provides basic validation for model fields, ensuring required fields are filled and correct data types are used. However, custom validation rules can further refine input handling.

1. Understanding Built-In Validation
By default: 
✔ Required fields must be filled (unless explicitly set as nullable). 
✔ Number fields (e.g., DecimalField) enforce numerical input. 
✔ Django prevents invalid data types automatically.

📌 Example: If a user submits a form without filling out required fields, Django displays validation errors.





2. Making Fields Optional in the Admin Interface
✔ null=True → Allows database storage of NULL values. 
✔ blank=True → Allows the field to be empty in forms.

📌 Modify models.py to allow an optional description field:
description = models.TextField(null=True, blank=True)

✅ This ensures the description field can be left empty in both the database and admin forms.
🚨 Important: null=True applies only to the database, but does not make the field optional in forms. To allow empty forms, you must also set blank=True.





3. Enforcing Minimum Values Using Validators
Numeric fields allow invalid values, such as 0 or negative numbers. To prevent this, use Django’s built-in validators.

📌 Example: Ensure unit_price is at least 1.00
from django.core.validators import MinValueValidator

unit_price = models.DecimalField(
    max_digits=6,
    decimal_places=2,
    validators=[MinValueValidator(1)]  # Restricts values to 1 or higher
)

✅ Now, submitting a value below 1.00 triggers a validation error.

📌 Default error message shown:
Ensure this value is greater than or equal to 1.


🚀 Other Validators: 
✔ MaxValueValidator(100) → Ensures value does not exceed 100. 
✔ MinLengthValidator(5) → Ensures text has at least 5 characters. 
✔ RegexValidator(r'^\d+$') → Restricts input to numeric characters only.

🔍 Explore all validators: Django Validators




4. Making Fields Optional (Example: Promotions)
Fields like promotions should not be required.

📌 Modify models.py to make promotions optional:
promotions = models.ManyToManyField(Promotion, blank=True)

✅ Now, promotions can be left empty while adding products in the admin panel.



Codes in this lesson:
in the model class -->

description = models.TextField(null=True)

we do still get after the above statement, to make this field optional in the admin interface 

description = models.TextField(null=True, blank=True)     

from django.core.validators import MinValueValidator

unit_price = models.DecimalField(
    max_digits=6,
	decimal_places=2,
	validators=[MinValueValidator(1)]
	)


In this module 'django.core.validators', we have bunch of built-in validators. If you want to see all of them, just google 'Django Validators'

https://docs.djangoproject.com/en/5.2/ref/validators/

On this page, you can see all these built-in validators  



Key Takeaways
✔ Use null=True for database flexibility, but also set blank=True for forms. ✔ Use MinValueValidator to enforce minimum values on numeric fields. ✔ Apply validators=[...] inside model fields to restrict user inputs. ✔ Make fields optional using blank=True in ManyToMany relationships. ✔ Check Django’s built-in validators for additional validation options.


















Editing Children Using Inlines:
-------------------------------
Django allows managing related objects (children) directly from the parent model form using inlines in the admin interface. This is useful when handling Order Items inside Order Admin.

1. Creating an Inline for Order Items
To manage order items inside the order form, create an inline admin class.

📌 Define OrderItemInline in admin.py:
from django.contrib import admin
from .models import OrderItem

class OrderItemInline(admin.TabularInline):  # Display items in table format
    model = OrderItem
    extra = 0  # Remove default empty rows
    min_num = 1  # Require at least 1 item per order
    max_num = 10  # Limit maximum items per order
	
✅ Allows editing order items directly inside the order form.




2. Register the Inline in OrderAdmin
Once the inline is created, register it inside OrderAdmin.

📌 Modify OrderAdmin to include the inline class:
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    autocomplete_fields = ['customer']  # Convert customer selection to autocomplete
    inlines = [OrderItemInline]  # Include order item inline in order form
    list_display = ['id', 'placed_at', 'customer']
	
✅ Now, order items appear inside the order form in the Django admin panel.




3. Tabular vs. Stacked Inlines
Django provides two inline display styles: 
✔ TabularInline → Displays children as table rows (recommended for structured data like order items). 
✔ StackedInline → Displays children as separate forms (useful when each child has many fields).

📌 Example: Switching to StackedInline
class OrderItemInline(admin.StackedInline):
    model = OrderItem
	
✅ Changes display style to stacked forms instead of a table.




4. Improving User Experience with Autocomplete Fields

Large dropdown lists can be slow and difficult to navigate. 

📌 Convert product selection to autocomplete inside inline:
class OrderItemInline(admin.TabularInline):
    model = OrderItem
    autocomplete_fields = ['product']  # Allow searching for products instead of dropdown

✅ Enhances selection speed and usability, especially for large datasets.




codes in this lesson:
class OrderItemInline(admin.TabularInline):   or StackedInline
	model = models.OrderItem
	extra = 0
	min_num = 1
	max_ num = 10
	

@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
	autocomplete_fields = ['customer']
	inlines = [OrderItemInline]
	list_display = ['id', 'placed_at', 'customer']
 




Key Takeaways:
✔ Use TabularInline for structured data (recommended for order items). 
✔ Use StackedInline for detailed entry forms (better for complex child models). 
✔ Remove extra empty rows using extra = 0 to keep forms clean. 
✔ Set autocomplete_fields = ['product'] for better UX in dropdown fields. 
✔ Register inlines inside OrderAdmin using inlines = [OrderItemInline].






















Using Generic Relations:
------------------------
Generic relationships allow models to associate dynamically with multiple other models, making them highly reusable. In this case, we are managing tags for products inside the admin interface.

1. Registering the Tag Model in Admin
To manage tags via the Django admin panel, register the Tag model.

📌 Modify tags/admin.py:
from django.contrib import admin
from .models import Tag

admin.site.register(Tag)  # Register the Tag model


✅ Now, "Tags" appears in the Django admin panel, allowing tag management.

📌 Modify Tag Model to Display Labels Properly
class Tag(models.Model):
    label = models.CharField(max_length=255)

    def __str__(self):
        return self.label  # Show tag label instead of "Tag object"
		
✅ Ensures tags appear with meaningful names in admin lists and dropdowns.




2. Using Inlines to Manage Tags in the Product Form
Instead of manually linking tags to products, we embed tag management directly within the product form using generic inlines.

📌 Define an Inline Class for TaggedItem in store/admin.py
from django.contrib.contenttypes.admin import GenericTabularInline
from .models import TaggedItem

class TagInline(GenericTabularInline):  # Creates a table-like interface for tags
    model = TaggedItem
    autocomplete_fields = ['tag']  # Enable autocomplete for tag selection

✅ Now, when adding or editing a product, tags can be modified directly in the same form.


🚀 Why Use GenericTabularInline? 
✔ Works for models with generic foreign keys, such as TaggedItem. 
✔ Displays related objects in a compact tabular format.


📌 Alternative: Use GenericStackedInline if a form layout is preferred.
class TagInline(GenericStackedInline):  # Uses stacked form layout
    model = TaggedItem
	
✅ Displays each tag as a separate form instead of a table.





3. Registering Inlines in ProductAdmin
To integrate TagInline into the product form, register it inside ProductAdmin.

📌 Modify ProductAdmin in store/admin.py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    inlines = [TagInline]  # Include tag management in the product form

✅ Now, while editing a product, users can assign tags directly from the product page.

🚀 Tags are directly editable within the product form!





4. Handling Autocomplete Errors
If autocomplete_fields = ['tag'] triggers an error, it’s because Django doesn’t know how to search for tags.

📌 Fix by Adding a Custom TagAdmin in tags/admin.py:
@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    search_fields = ['label']  # Enable searching by tag label
	
✅ Now, autocomplete works properly, allowing users to search for tags instead of using dropdowns.

📌 Example Query Sent When Searching for Tags:
SELECT * FROM tags_tag WHERE label LIKE '%search_term%'

🚀 Autocomplete dynamically retrieves matching tags, improving efficiency.




Codes used in this lesson:
tags/admin.py:
from django.contrib import admin
from .models import Tag

admin.site.register(Tag)



from django.contrib.contenttypes.admin import GenericTabularInline

class TagInLine(GenericTabularInline)
    autocomplete_fields = ['tag']
	model = TaggedItem
	
	
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
	inline=[TagInline]




Key Takeaways
✔ Register models (admin.site.register) to manage them in Django admin. 
✔ Use GenericTabularInline for compact inline editing of generic relationships. 
✔ Use autocomplete_fields = ['tag'] for efficient tag selection in large datasets. 
✔ Define search_fields = ['label'] inside TagAdmin to enable autocomplete functionality. 
✔ Use __str__() in models for better representation in admin lists.














Extending Pluggable Apps:
-------------------------

In a well-architected Django project, each app should be self-contained and independent, allowing easy reuse in different projects. This means avoiding direct dependencies between pluggable apps.

For example, in a store app, we originally had a dependency on the tags app, making them tightly coupled. To solve this, we decouple them by creating a separate customization app (store_custom), which handles custom integrations while keeping both original apps reusable.

1. Why Extend Pluggable Apps?
✔ Allows building apps independently without unnecessary dependencies. 
✔ Enables plug-and-play flexibility, so each app can be reused easily. 
✔ Keeps customizations separate while maintaining core functionality.

Before Decoupling
🚨 Problem: store/admin.py was importing TaggedItem from tags/models.py, making store depend on tags.

📌 Example Dependency:
from tags.models import TaggedItem  # ❌ Causes tight coupling!

🚀 Solution: Move customization logic into a separate app (store_custom).





2. Creating a Separate Customization App
A new store_custom app will manage cross-app integrations while keeping store and tags independent.

📌 Create a new Django app:
python manage.py startapp store_custom

✅ Now, instead of modifying store or tags, customization happens inside store_custom.





3. Moving Custom Admin Logic to store_custom/admin.py
In store_custom/admin.py, we import admin configurations from both store and tags:

📌 Modify store_custom/admin.py
from django.contrib import admin
from store.admin import ProductAdmin  # Import default ProductAdmin
from tags.models import TaggedItem  # Import TaggedItem (generic model)
from django.contrib.contenttypes.admin import GenericTabularInline

Step 1: Create a Custom Inline for Tags
Move the TagInline class into store_custom to handle tag management inside product forms:

class TagInline(GenericTabularInline):  # Generic inline for tags
    autocomplete_fields = ['tag']
    model = TaggedItem
	
✅ This ensures store no longer depends on tags.


Step 2: Extend ProductAdmin for Customization
Create a new ProductAdmin class (CustomProductAdmin), which extends the default ProductAdmin:

class CustomProductAdmin(ProductAdmin):  # Extend ProductAdmin from store
    inlines = [TagInline]  # Add inline functionality for tags

✅ Stores all customization logic in a separate class, keeping the original ProductAdmin intact.




4. Unregistering and Replacing Default Admin Configuration
Before registering the customized ProductAdmin, remove the original:

📌 Unregister default ProductAdmin and register CustomProductAdmin
admin.site.unregister(Product)  # Remove default registration
admin.site.register(Product, CustomProductAdmin)  # Register the custom implementation

✅ Now, the admin interface loads CustomProductAdmin instead of the default one.




5. Registering store_custom in INSTALLED_APPS
Finally, we register our customization app so Django recognizes it:

📌 Modify settings.py:
INSTALLED_APPS = [
    # Core pluggable apps
    'store',
    'tags',

    # Custom integration app
    'store_custom',
]

✅ Now, Django loads the customization app, ensuring pluggable apps remain independent.





6. Verifying the Setup
To test, remove store_custom from INSTALLED_APPS and refresh the admin panel:

🚀 Expected Result: 
✔ Without store_custom: The product admin panel does not include tags. 
✔ With store_custom: The product admin panel includes the tags section.




Codes in this lesson: 

create a new store_custom app
register it in INSTALLED_APPS

from django.contrib import admin
from store.admin import ProductAdmin
from tags.models import TaggedItem
from django.contrib.contenttypes.admin import GenericTabularInline

class TagInline(GenericTabularInline):
	autocomplete_fields = ['tag']
	model = TaggedItem
	
class CustomProductAdmin(ProductAdmin);
	inlines = [TagInLine]
	
	
admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)

	
	

Key Takeaways
✔ Pluggable apps should be independent and free from cross-dependencies. 
✔ Store customizations should be handled in a separate app (store_custom). 
✔ Move admin customizations into a separate CustomProductAdmin to override built-in behavior. 
✔ Unregister the default admin configuration (admin.site.unregister()) before replacing it. 
✔ Register custom integration apps (store_custom) in INSTALLED_APPS for modular flexibility.






What's next: 
In the next part, we'll talk about the advanced Django concepts such as building RESTful APIs, authentication and authorization, logging, caching, sending emails, deployment and more. So if you're serious about learning Django and want to become a backend developer, don't miss the next part. 

====================================================================================================================================================================


Part -2 (Django Rest Framework)
--------------------------------
In this part, we're gonna continue our journey and build a restful API for this application. So by the end of this course, we'll have a complete production grade backend for an imaginary online store. 


In the first part, we have covered so many things like Models, Migrations, Querysets, Views, URLCONF


Building RESTful APIs with Django REST Framework:
-------------------------------------------------

So in this section, we'll be talking about RESTful APIs, what they are, and how they work. Then we'll install Django REST Framework, which is the most popular framework for building web APIs with Django. Once we do that, then we'll talk about some of the fundamental concepts such as creating API views, creating serializers, serializing and deserializing models, and much, much more. So by the end of this section, we'll have a basic API for managing our products and collections.










What are RESTful APIs?
----------------------
In the first part of this course, we built an admin panel to manage our data. However, this interface is only meant for admins and is not accessible to client applications. To expose our data to web and mobile applications, we need an API (Application Programming Interface).

1. Understanding APIs
An API acts as an interface that client applications (such as a web app or mobile app) can use to fetch or modify data remotely.

📌 Think of an API like a remote control: 
✔ Each button provides specific functionality (e.g., fetching products, updating orders). 
✔ Client apps send requests to API endpoints to retrieve or modify data.

🚀 Example API Endpoints:
GET /products → Fetch a list of products.
POST /products → Create a new product.
PUT /products/{id} → Update a product.
DELETE /products/{id} → Remove a product.
GET /orders → Retrieve orders placed by customers.
POST /cart → Add items to a shopping cart.

✅ APIs allow client applications to interact with backend data seamlessly.




2. What Makes an API RESTful?
✔ REST (Representational State Transfer) is an architectural style that defines a set of rules for designing scalable, reliable, and maintainable APIs. 
✔ RESTful APIs follow these principles to ensure efficient communication between clients and servers.

📌 Origin of REST:
Introduced in 2000 as part of a PhD thesis.
Helps build systems that are fast, easy to understand, and scalable.

🚀 Why Follow REST Principles? 
✔ Improves performance and scalability. 
✔ Simplifies maintenance and evolves easily over time. 
✔ Ensures standardized communication between client and server.




3. Core Concepts of RESTful APIs
To build a RESTful API, we must understand three key concepts:

Resources → Entities like products, users, or orders. 
Resource Representations → JSON or XML format used to describe resources. 
HTTP Methods → Operations performed on resources (GET, POST, PUT, DELETE).

🚀 Next Lessons: We'll explore each of these concepts in detail to understand how they shape RESTful APIs!

Key Takeaways
✔ APIs allow client applications to interact with backend data via endpoints. 
✔ RESTful APIs follow structured rules for scalability and efficiency. 
✔ REST principles focus on resources, resource representations, and HTTP methods. 
✔ Following REST ensures fast, reliable, and maintainable APIs.

🚀 Next Lesson: Diving deeper into RESTful API concepts!












Resources:
----------
The first key concept in RESTful APIs is the idea of resources. A resource represents an entity within the application, such as products, collections, shopping carts, and more. These resources are accessible via URLs (Uniform Resource Locators), which serve as unique addresses on the web.

1. Accessing Resources with URLs:
In a RESTful API, each resource is exposed via a URL. 📌 Example URLs for Managing Products:

moshbuy.com/products     → Fetch all products
moshbuy.com/products/1   → Fetch product with ID 1
✅ Appending the resource ID to the URL allows access to specific objects.




2. Resources Can Contain Other Resources
Some resources may contain sub-resources. 
📌 Example: Accessing Reviews for a Product
moshbuy.com/products/1/reviews       → Get all reviews for product 1
moshbuy.com/products/1/reviews/5     → Get review with ID 5

✅ This structure ensures clarity and consistency in API endpoints.
🚨 Best Practice: Avoid deeply nested URLs beyond two levels, as they become complex and hard to manage.




3. Recognizing RESTful API Patterns
RESTful APIs follow a consistent URL structure, making them intuitive and easy to use. 
✔ Clear hierarchy of resources. 
✔ Logical organization of endpoints. 
✔ Simple resource access patterns.

🚀 Following these conventions ensures that APIs remain familiar, readable, and easy to work with.

Key Takeaways
✔ Resources are core entities like products, collections, and orders. (is like an object in our application, like product, collection, shopping cart, and so on.)
✔ URLs serve as resource locators, allowing easy access to data. 
✔ Sub-resources should be structured efficiently (e.g., product reviews). 
✔ Avoid deep nesting to maintain API simplicity.

🚀 Next Lesson: Exploring resource representations in RESTful APIs!













Resource Representations:
-------------------------
Once a resource is identified via a URL, the server returns that resource in a specific format. This representation allows client applications to interpret and process the data efficiently.

1. Types of Resource Representations
A server may return data in different formats, such as: 
✔ HTML → Used for displaying web pages. 
✔ XML (Extensible Markup Language) → Older format for structured data. ✔
 JSON (JavaScript Object Notation) → Modern, lightweight format replacing XML.

📌 Key Idea: The internal representation of a resource on the server is different from the format sent to the client.
On the server, resources exist as objects (e.g., Python instances).
When sending data to a client, it must be converted into a readable format like JSON or XML.




2. REST and Format Flexibility
📌 RESTful APIs do not enforce a specific format for resource representation. 
✔ The API may support multiple formats (JSON, XML, etc.). 
✔ The client should specify the desired format when requesting data.

🚀 Example: A client can request a product in JSON or XML, depending on its preference.




3. What is JSON?
📌 JSON (JavaScript Object Notation) is the most widely used format for RESTful APIs.

✔ Uses curly braces {} to define objects. 
✔ Stores data in key-value pairs. 
✔ Supports various data types, including strings, numbers, Booleans, arrays, and objects.

📌 Example: JSON Representation of a Product
json
{
    "name": "Laptop",
    "price": 999.99,
    "in_stock": true,
    "manufacturer": {
        "name": "TechCorp",
        "country": "USA"
    },
    "tags": ["electronics", "computers"]
}

🚀 JSON Data Breakdown: 
✔ Keys are always strings (e.g., "name", "price"). 
✔ Values can be different types:

String → "Laptop"
Number → 999.99
Boolean → true
Object → "manufacturer"
Array → "tags"

✅ Throughout this course, JSON will be the preferred format for exchanging data between clients and servers.

Key Takeaways
✔ Resource representations define how data is structured when sent to clients. 
✔ Common formats include HTML, XML, and JSON (JSON is the most widely used). 
✔ REST APIs allow multiple formats, with clients selecting their preferred representation. 
✔ JSON uses key-value pairs to structure data in a readable way.

🚀 Next Lesson: Exploring HTTP Methods for interacting with RESTful APIs!












HTTP Methods:
-------------
Understanding HTTP Methods in RESTful APIs:
In RESTful APIs, clients interact with endpoints to access or modify resources. Each endpoint may support different operations, and clients specify what they want to do using HTTP methods.

1. HTTP Methods for Resource Management
📌 Common HTTP methods used in RESTful APIs:
✔ GET → Retrieve a resource or collection of resources. 
✔ POST → Create a new resource. 
✔ PUT → Update an entire resource. 
✔ PATCH → Update part of a resource (a subset of properties). 
✔ DELETE → Remove a resource.




2. Practical Scenarios Using HTTP Methods

Creating a Product
📌 Client sends a POST request to create a new product:
Http:
POST /products

✔ Product details are included in the request body (JSON format). 
✔ Server reads the JSON object and stores it as a new product.

📌 Example JSON Data in Request Body:

json:
{
    "name": "Laptop",
    "price": 999.99,
    "in_stock": true
}


Updating a Product
📌 Updating ALL properties (PUT request):
Http:
PUT /products/1

✔ Request body contains complete product details. 
✔ Replaces all properties of product ID 1.


📌 Updating PART of a product (PATCH request):
Http:
PATCH /products/1

✔ Request body contains only the modified fields. 
✔ Useful for partial updates, e.g., changing only the price.

📌 Example JSON for Partial Update (PATCH):
json
{
    "price": 899.99
}


Deleting a Product
📌 Client sends a DELETE request to remove product ID 1:
http:
DELETE /products/1

✔ No request body needed—server deletes the specified product. 
✔ ID in the URL is enough to identify the resource to delete.




3. Key Takeaways
✔ GET retrieves data, POST creates data, PUT updates full data, PATCH updates partial data, and DELETE removes data. 
✔ Always include JSON data in the request body when creating or updating resources. 
✔ Use PUT for full updates, PATCH for partial updates. 
✔ For deletions, the resource ID in the URL is sufficient—no request body is needed.

🚀 Next Lesson: Installing Django REST Framework and building our first API!










Installing Django REST Framework:
---------------------------------
Django REST Framework (DRF) is a powerful extension of Django that simplifies the process of building RESTful APIs. It provides built-in tools for serializing data, handling authentication, and managing API views.

1. Installing Django REST Framework:
To install Django REST Framework, use pipenv in the terminal:

📌 Run the following command:
pipenv install djangorestframework

✅ DRF will now be installed in the project environment.

🚀 Alternative: If using a virtual environment directly, run:
pip install djangorestframework




2. Adding REST Framework to Installed Apps
Once installed, register Django REST Framework inside INSTALLED_APPS in settings.py.

📌 Modify settings.py:
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Add Django REST Framework
    'rest_framework',

    # Custom apps
    'store',
    'tags',
]

✅ Always place rest_framework right after Django’s built-in apps before any custom apps.




3. Verifying the Installation

📌 Check the installation by running:
python manage.py shell

Then, try importing REST Framework:
import rest_framework

✅ If no errors appear, DRF is installed correctly!

Key Takeaways
✔ Django REST Framework simplifies building RESTful APIs in Django. 
✔ Use pipenv install djangorestframework or pip install djangorestframework to install DRF. 
✔ Register rest_framework in INSTALLED_APPS inside settings.py. 
✔ Verify installation using Python shell (import rest_framework).

🚀 Next Lesson: Creating API views using Django REST Framework!











Creating API Views:
-------------------
In RESTful APIs, we define endpoints to expose data to client applications. Using Django REST Framework (DRF), we can create API views to retrieve, create, update, or delete data.

1. Creating a Basic API View
A view function processes HTTP requests and returns responses. 📌 Example: Defining product_list() to fetch all products

from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request):  # Handles GET requests for products
    return Response('ok')  # Temporary response
	
✅ Uses DRF’s api_view() decorator to handle API requests. 
✅ Returns an API response using Response().


📌 Defining URL Patterns
from django.urls import path
from . import views

urlpatterns = [
    path('products/', views.product_list),  # Maps `/store/products/` to product_list view
]

🚀 Now, visiting /store/products/ returns a response!


Note: If we apply '@api_view()' decorator to our view function, the request object that we receive will be an instance of the request class that comes with the rest framework. So, it will replace the request object in Django with the newer request object that comes with the rest framework, which is simpler and more powerful. 
So, I made two simple changes. First, I applied 'api_view()' decorator and second, I replaced Httpresponse with response. Now, With these two simple changes, if we hit the URL, we get a beautiful page which is called the Browsable API. This Browsable API makes it incredibly easy to test our API endpoints in the browser. 
But note that we only see this page if we hit our endpoints in the browser. If a client app, like a mobile app, hits our endpoints, it's not going to see the Browsable API. It's only going to see the data in the response.




2. Using Django REST Framework’s Request and Response Objects
Instead of Django’s HttpResponse, we use DRF’s Response class for API responses.

📌 Changes Made: 
✔ Applied @api_view() decorator to enable API functionality. 
✔ Replaced HttpResponse with DRF’s Response() class.

🚀 Why Use DRF’s Response? 
✔ Provides automatic JSON formatting. 
✔ Enables Browsable API, making endpoint testing easier.

📌 Example Response in Browsable API
json
{
    "message": "ok"
}

✅ If accessed from a mobile app, only JSON data is returned.





3. Creating an API View for Product Details
We can define a new endpoint to fetch individual product details.


📌 Define product_detail() view
@api_view()
def product_detail(request, id):  # Handles GET requests for a specific product
    return Response(id)  # Returns the ID for verification
	
✅ Receives an id parameter to identify products.


📌 Update urlpatterns to include product details

urls.py:
urlpatterns = [
    path('products/', views.product_list),  
    path('products/<int:id>/', views.product_detail),  # Uses integer URL converter
]

🚀 Visiting /store/products/1/ returns 1 in the response!





4. Restricting Product ID to Integers
To ensure product IDs are always integers, use a URL converter:

📌 Modify URL pattern
path('products/<int:id>/', views.product_detail),

✅ Now, non-numeric IDs (e.g., /store/products/A/) will trigger an error.



codes referred in this lesson:
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view()
def product_list(request): # replaces the request object that comes with django with the restframework request object 
    return Response('ok')

@api_view()
def product_detail(request, id):
	return Response(id)

#URLConf
urlpatterns = [
    path('products/', views.product_list),
	path('products/<int:id>/', views.product_detail),
]




Key Takeaways
✔ Use @api_view() to define API views in Django REST Framework. 
✔ Use Response() instead of Django’s HttpResponse to return API responses. 
✔ Define URL patterns for API endpoints using path(). 
✔ Use URL converters (<int:id>) to restrict parameters to integers. 
✔ Browsable API improves endpoint testing in browsers.

🚀 Next Lesson: Exploring serializers for formatting and structuring API data!














Creating Serializers: 
---------------------
In RESTful APIs, we need a way to convert model instances into JSON objects so that client applications can process the data. This is where serializers come into play.

1. What is a Serializer?
✔ A serializer converts a Django model instance into a Python dictionary. ✔ This dictionary is then converted into a JSON object for API responses. ✔ Why is serialization important?

API responses should be structured and readable.
Some fields may contain sensitive data that should not be exposed.
Provides an external representation of resources separate from internal models.

📌 Process Flow:
Model Instance → Python Dictionary → JSON Renderer → JSON Object




2. Defining a Serializer for the Product Model
To create a serializer, add a new file serializers.py in the store app.

📌 Modify serializers.py to define ProductSerializer:
from rest_framework import serializers

class ProductSerializer(serializers.Serializer):  # Define serializer class
    id = serializers.IntegerField()  # Product ID
    title = serializers.CharField(max_length=255)  # Product title
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)  # Product price
	
✅ Converts product objects into JSON-friendly dictionaries. ✅ Includes only selected fields (id, title, unit_price) to exclude sensitive data.

📌 Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99
}




3. Understanding Serializer Fields
✔ Similar to defining fields in a Django model but structured for external use. 
✔ Django REST Framework provides various field types such as:

IntegerField() → For numeric values.
CharField(max_length=255) → For text fields.
BooleanField() → For true/false values.
DecimalField(max_digits=6, decimal_places=2) → For currency values.

📌 Check the full list of serializer fields: 🔍 Django REST Framework - Serializer Fields
# apiguide --> serializer fields in django-rest-framework.org
https://www.django-rest-framework.org/api-guide/fields/




4. Key Differences Between Models and Serializers
✔ Models represent the internal data structure in the database. 
✔ Serializers define the external representation of data returned to clients.

🚀 Example: A product model may have an internal field called cost_price, but this field should not be exposed in the API response. Instead, the serializer only includes unit_price, title, and id.



Code References in this lesson:
JSONRenderer
render(dict)

serializer 
converts a model instance to a dictionary

model is the internal representation of a product. But what we return from our API is the external representation of a product. Sometimes you might have sensitive information here, we don't want to expose them to the outside world. 
That is why we need two separate representations of a product, an internal representation and an external representation.

model --> python dictionary(serializing helps us to convert model into dictionary) --> JSONRenderer(cls) render(dict) --> JSON Object

#serializers.py
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)     




Key Takeaways
✔ Serializers convert Django model instances into structured JSON data. 
	Serializers convert Django model instances into Python dictionaries first—not directly into JSON.
	📌 Process Flow: 
	1. Serializer → Converts a model instance into a Python dictionary. 
	2. JSON Renderer (render()) → Converts the dictionary into a JSON object for API responses.
✔ Defines an external representation of data separate from internal models. 
✔ Uses serializers.Serializer to specify fields for API responses. 
✔ Restricts API data exposure to relevant fields only (e.g., excluding sensitive details).

🚀 Next Lesson: Using serializers to return product data in API responses!





   












Serializing Objects:
--------------------
Serializers in Django REST Framework (DRF) allow model instances to be converted into Python dictionaries, which are then transformed into JSON responses for client applications.

1. Using Serializers to Convert Models into JSON
Instead of returning a simple "ok" response, we now return actual product data.

📌 Modify product_detail to fetch product details:
from rest_framework.decorators import api_view
from rest_framework.response import Response
from store.models import Product
from store.serializers import ProductSerializer

@api_view()
def product_detail(request, id):
    product = Product.objects.get(pk=id)  # Fetch product by ID
    serializer = ProductSerializer(product)  # Convert product to dictionary
    return Response(serializer.data)  # Return JSON response
	
✅ The serializer converts the model instance into a dictionary, which is automatically rendered into JSON.

📌 Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99
}

🚀 How JSON Rendering Works: 
✔ Django automatically applies a JSON renderer to convert dictionary data into JSON format. 
✔ No need to explicitly use JSONRenderer().render()—it happens under the hood!




2. Fixing Decimal Formatting in JSON Responses
By default, Django REST Framework converts decimal fields into strings. To disable this behavior:

📌 Modify settings.py

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False
}

✅ Now, decimal values appear as numbers instead of strings.

📌 Before Fix (Default Behavior)
json
{
    "unit_price": "999.99"
}

📌 After Fix
json
{
    "unit_price": 999.99
}




3. Handling Missing Products Gracefully
Instead of raising an exception when a product is not found, return a 404 status code.

📌 Using Exception Handling:
from rest_framework import status

try:
    product = Product.objects.get(pk=id)
except Product.DoesNotExist:
    return Response(status=status.HTTP_404_NOT_FOUND)

	
🚀 Better Approach: Use Django’s shortcut function get_object_or_404() to simplify error handling.

📌 Modify product_detail()
from django.shortcuts import get_object_or_404

@api_view()
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)  # Automatically raises a 404 response if not found
    serializer = ProductSerializer(product)
    return Response(serializer.data)

✅ Returns JSON response with error details instead of throwing an exception.

📌 Example JSON Response for Missing Product

json
{
    "detail": "Not found."
}




4. Serializing a List of Products
Instead of fetching a single product, we retrieve all products and return them as JSON.

📌 Modify product_list()
@api_view()
def product_list(request):
    queryset = Product.objects.all()  # Fetch all products
    serializer = ProductSerializer(queryset, many=True)  # Convert queryset to list of dictionaries
    return Response(serializer.data)

✅ Setting many=True tells the serializer to process multiple objects in a queryset.

📌 Example JSON Response
json
[
    {"id": 1, "title": "Laptop", "unit_price": 999.99},
    {"id": 2, "title": "Phone", "unit_price": 499.99},
    {"id": 3, "title": "Tablet", "unit_price": 299.99}
]
🚀 Django REST Framework automatically formats lists of objects into JSON arrays!



codes discussed in this lesson:

views.py:
import the respective model class from models.py
import the respective serializer class from from serializers.py

@api_view()
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	serializer = ProductSerializer(product)  #converts the model object into dictionary, we get our dictionary by 'serializer.data'
	return Response(serializer.data)  # under the hood -- at some point, Django is going to create a JSON render object and give this dictionary, the JSON 
	                                       renderer will convert that dictionary to a JSON object and that JSON Object will end up in the response
										   
										   										   
to avoid decimal to string in the response, in the settings.py
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
}	 


product doesnotexist:
from rest_framework import status

except Product.DoesNotExist:
	return Response(status=status.HTTP_404_NOT_FOUND) 


from django.shortcuts import get_object_or_404	
instead of try and except block --> use get_object_or_404:

product = get_object_or_404(Product, pk=id)


we can also pass queryset to the serializer:
@api_view()
def product_list(request):
	queryset = Product.objects.all()
	serializer = ProductSerializer(queryset, many=True)
	return(serializer.data)



Key Takeaways
✔ Use serializers to convert model instances into dictionaries for JSON responses. ✔ Fix decimal formatting with COERCE_DECIMAL_TO_STRING: False. ✔ Use get_object_or_404() to handle missing resources gracefully (returns a 404 response). ✔ Pass many=True to serialize multiple objects in a queryset. ✔ DRF automatically applies JSON rendering—no need for manual conversion.












creating custom serializer fields:
----------------------------------
When designing a RESTful API, the data we return does not have to match the internal structure of our models. The API represents an external interface, while models define the internal implementation, which may evolve over time. To keep the API stable, we must carefully control the exposure of fields and even add computed fields.

1. Why API Representation is Different from Data Models
✔ Our data models are implementation details—they can change without affecting the API. 
✔ The API should remain stable so existing clients continue to work properly. 
✔ We may hide certain fields from our API or add computed fields that don’t exist in our models.

📌 Example Analogy: A remote control’s internal technology may change, but the external buttons remain the same for users. Similarly, our API interface remains stable even if the underlying model changes.




2. Adding a Computed Field in the Serializer
We can add new fields to the serializer that don’t exist in the model.

📌 Modify ProductSerializer to include price_with_tax:
from decimal import Decimal
from rest_framework import serializers
from store.models import Product  # Import Product model

class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')  # Computed field

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)  # Apply 10% tax
		
✅ Uses SerializerMethodField() to define a custom method for computation. ✅ Tax calculation is handled separately from the model definition.

📌 Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "price_with_tax": 1099.99
}

🚀 Now, products automatically include tax calculations in API responses!




3. Fixing Decimal Multiplication Errors
🚨 Problem: Python automatically treats numbers like 1.1 as float, which can cause errors when multiplying with a DecimalField. 📌 Solution: Convert floating numbers into Decimal objects.

from decimal import Decimal

def calculate_tax(self, product: Product):
    return product.unit_price * Decimal(1.1)  # Converts 1.1 to Decimal before multiplication

✅ Ensures consistent calculations without type errors.




4. Renaming Fields in the API Response
Sometimes, we may want to rename fields in the API response without modifying the model.

📌 Example: Rename unit_price to price in the serializer
price = serializers.DecimalField(max_digits=6, decimal_places=2, source='unit_price')

🚀 What Happens Here? 
✔ The API returns "price" instead of "unit_price". 
✔ The serializer fetches data from "unit_price" but presents it as "price" externally.

📌 Updated JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "price": 999.99,
    "price_with_tax": 1099.99
}

✅ This ensures a stable API while keeping internal data models flexible!





Codes learned in this lesson:
API Model(Interface) != Data Model(Implementation)


from decimal import Decimal

class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
	
	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)


if you want rename the field in the serializer class which is different from the model:
price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')




Key Takeaways
✔ API models (external representation) are different from data models (internal implementation). 
✔ Use SerializerMethodField() to define computed fields like price_with_tax. 
✔ Always convert floating numbers to Decimal before performing calculations. 
✔ Use source='field_name' to rename fields in API responses without changing the model. 
✔ Keeping a stable API prevents breaking changes for existing clients.















serializing Relationships:
--------------------------
When returning a product in a RESTful API, we may need to include its related collection. Django REST Framework (DRF) provides multiple ways to serialize relationships, depending on the desired level of detail.

1. Four Ways to Serialize Relationships
✔ Primary Key → Include only the related object’s ID. 
✔ String Representation → Convert the related object into a string (e.g., collection title). 
✔ Nested Object → Include all details of the related object inside the response. 
✔ Hyperlink → Provide a URL to retrieve details of the related object.

📌 Example JSON Responses for Each Approach
json
// Primary Key Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": 3  // Only the collection ID
}

// String Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": "Electronics"  // Collection title as a string
}

// Nested Object Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": {
        "id": 3,
        "title": "Electronics"
    }
}

// Hyperlink Representation
{
    "id": 1,
    "title": "Laptop",
    "collection": "http://api.example.com/collections/3/"  // Link to collection details
}

🚀 Choosing the Best Approach depends on the level of detail required in API responses.




2. Primary Key Representation
✔ Returns only the ID of the related object. 
✔ Efficient, but requires additional requests to fetch full details.

📌 Modify ProductSerializer to include collection as a primary key
collection = serializers.PrimaryKeyRelatedField(
    queryset=Collection.objects.all()
)

🚀 Use Case: Lightweight response where only IDs are needed.





3. String Representation
✔ Converts the related object into a string representation. 
✔ Typically returns the value from the __str__() method of the related model.

📌 Modify ProductSerializer to return the collection title
collection = serializers.StringRelatedField()

🚀 Use Case: Readable response without requiring extra API calls.
🚨 Performance Warning: By default, Django lazily loads related objects, causing extra database queries. 
✔ Fix using select_related() in views:

📌 Optimize queries in views.py
@api_view(['GET', 'POST'])
def product_list(request):
    queryset = Product.objects.select_related('collection').all()
    serializer = ProductSerializer(queryset, many=True)
    return Response(serializer.data)
	
✅ Now, collections are loaded efficiently with products in a single query.




4. Nested Object Representation
✔ Includes full details of the related object inside the response. 
✔ Allows retrieving related data without additional API calls.

📌 Step 1: Define a separate serializer for collections
class CollectionSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
	
📌 Step 2: Modify ProductSerializer to use CollectionSerializer
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
    collection = CollectionSerializer()  # Includes full collection details

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
		
🚀 Use Case: API responses that require full details in one request.




5. Hyperlinked Representation
✔ Provides a URL to view related object details instead of embedding the object. 
✔ Makes the API more RESTful by following resource linking principles.

📌 Modify ProductSerializer to return collection as a hyperlink
collection = serializers.HyperlinkedRelatedField(
    queryset=Collection.objects.all(),
    view_name='collection-detail'
)

📌 Step 2: Define the URL pattern for collection details
python
urlpatterns = [
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail')
]

📌 Step 3: Create the corresponding view function
@api_view()
def collection_detail(request, pk):
    return Response('ok')  # Later, return serialized collection data
	
🚀 Use Case: When clients need URLs to retrieve detailed data separately.

🚨 Fixing URL Resolution Errors: DRF expects the lookup field to be named pk, so update the parameter name in views:
def collection_detail(request, pk):  # Use 'pk' instead of 'id'

📌 Ensure the serializer knows the request context
serializer = ProductSerializer(queryset, many=True, context={'request': request})

✅ Now, collection fields return hyperlinks instead of objects.




Codes learned in this lesson:

1. Primary key
2. String
3. Nested object
4. Hyperlink


way 1 -->
in the serializer class:
collection = serializers.PrimaryKeyRelatedField(
	queryset = Collection.objects.all()
)

way 2 -->
collection = serializers.StringRelatedField()   --> remember to use select_related/prefetch_related if necessary or else you'll end with more queries

@api_view(['GET', 'POST'])
def product_list(request):
	queryset = Product.objects.select_related('collection').all()
	serializer = ProductSerializer(queryset, many=True)
	return Response(serializer.data)



way 3 --> as a nested object

#define the respective serializer of the nested object
class CollectionSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length = 255)


#in ProductSerializer class:
class ProductSerializer(serializers.Serializer):
	id = serializers.IntegerField()
	title = serializers.CharField(max_length=255)
	unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')
	collection = CollectionSerializer()
	
	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)



way 4 --> hyperlink to an endpoint for viewing that object 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

urls.py:
path('collections/<int:pk>/', views.collection_detail, name='collection-detail')

views.py:
@api_view
def collection_detail(request, pk):
    return Response('ok')


in ProductSerializer class:
serializer = ProductSerializer(queryset, many=True, context={'request': request}) 



Key Takeaways
✔ Use PrimaryKeyRelatedField for lightweight responses with IDs. 
✔ Use StringRelatedField for readable responses, but optimize queries with select_related(). 
✔ Use Nested Objects for detailed responses without requiring extra API calls. 
✔ Use HyperlinkedRelatedField for fully RESTful responses with navigable resource links. 
✔ Ensure the request context is passed to serializers when using hyperlinks.













Model Serializers:  
------------------
In previous lessons, we manually defined each field in the serializer, even though they were already present in the Django model. This led to redundancy, requiring us to update both the model and serializer separately whenever changes were made.

🚀 Solution: Model Serializers eliminate this duplication by automatically pulling field definitions from the model.

1. What is a Model Serializer?
✔ Model Serializers automatically retrieve fields and validation rules from Django models. ✔ Reduces duplication and makes updates easier. ✔ Provides a cleaner approach for maintaining consistency.

📌 Standard Serializer (Manual Field Definition)
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    unit_price = serializers.DecimalField(max_digits=6, decimal_places=2)
	
🚨 Problem: Repeating field definitions in both the model and serializer.




2. Implementing a Model Serializer
Instead of defining fields manually, inherit from ModelSerializer.

📌 Modify ProductSerializer to use ModelSerializer:
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product  # Link serializer to model
        fields = ['id', 'title', 'unit_price', 'collection']  # Explicitly select fields
		
✅ Django REST Framework now automatically handles field definitions. ✅ If validation rules change in the model, the serializer updates automatically.

📌 Example JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3  // Uses primary key by default
}




3. Handling Related Fields
By default, ModelSerializer uses primary key representation for related fields. To change this behavior, override the related field.

📌 Option 1: Convert Related Field to Hyperlink
collection = serializers.HyperlinkedRelatedField(
    queryset=Collection.objects.all(),
    view_name='collection-detail'
)

✅ Returns a URL instead of an ID.


📌 Option 2: Nest the Related Object
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title']

class ProductSerializer(serializers.ModelSerializer):
    collection = CollectionSerializer()  # Include full object
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']
		
✅ Returns full collection details inside the product response.

📌 Example JSON Response for Nested Object:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": {
        "id": 3,
        "title": "Electronics"
    }
}




4. Adding Custom Fields (Computed Fields)
Model Serializers allow defining additional fields not present in the model.

📌 Example: Adding price_with_tax
class ProductSerializer(serializers.ModelSerializer):
    price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'price_with_tax', 'collection']

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)  # Add 10% tax

✅ Now, price_with_tax is dynamically computed and included in responses.

📌 Updated JSON Response:
json
{
    "id": 1,
    "title": "Laptop",
    "unit_price": 999.99,
    "price_with_tax": 1099.99,
    "collection": 3
}




5. Avoiding Bad Practices (fields = '__all__')
🚨 Do NOT use fields = '__all__' in Model Serializers. ✔ Automatically exposing ALL fields in the model creates security risks. ✔ New fields may unintentionally leak sensitive information.

📌 Bad Practice (Avoid This)
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'  # ❌ Exposes all fields automatically
		
✅ Instead, always explicitly specify fields:
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price', 'collection']
		
🚀 Keeps control over the API output and prevents unwanted exposure.



codes learned in this lesson:
(two places, in model and serializer, so a better way)

class ProductSerializer(serializer.ModelSerializer):
	class Meta:
		model = Product
		fields = ['id', 'title', 'unit_price', 'collection', 'price_with_tax']
	
	price_with_tax = serializers.SerializerMethodField(method_name='calculate_tax')

	def calculate_tax(self, product: Product):
		return product.unit_price * Decimal(1.1)
		
		

By default ModelSerializers use primary key related fields, if you don't want it. you can override it easily

example, in the same class above, define 

collection = serializers.HyperlinkedRelatedField(
	queryset=Collection.objects.all(),
	view_name='collection-detail'
)

also for custom serializers you can override it. 
    fields = ['id', 'title', 'price', 'collection']

price = serializers.DecimalField(max_digits=6, decimal_places=2, source = 'unit_price')



Key Takeaways
✔ Model Serializers automatically map fields from models, reducing redundancy. 
✔ Explicitly define fields to avoid exposing sensitive data. 
✔ Customize related fields using HyperlinkedRelatedField, StringRelatedField, or nested serializers. 
✔ Use SerializerMethodField() to add computed fields (e.g., price_with_tax). 
✔ NEVER use fields = '__all__'—always explicitly list fields.










Deserializing Objects:
-----------------------
Deserialization is the reverse of serialization—it occurs when the server receives data from the client in an API request and needs to convert it into a Django model instance for storage in the database.

🚀 Use Case: 
✔ A client sends a POST request to the /products/ endpoint. 
✔ The request body contains product data in JSON format. 
✔ The server reads and deserializes the JSON data into a Django model instance.

1. Enabling POST Requests in the API View
📌 Modify the @api_view decorator By default, API views only support GET requests. To allow POST requests, we need to explicitly define supported HTTP methods:

@api_view(['GET', 'POST'])  # Supports both GET and POST requests
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)  # ✅ Returns serialized product data

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # ✅ Begins deserialization process
        return Response('ok')  # Placeholder response for now
		
🚀 Key Changes: ✔ Added 'POST' to @api_view(['GET', 'POST']). ✔ Used request.data to capture incoming JSON data for deserialization.




2. Understanding Deserialization Process
📌 Steps in Deserialization: 
1️. Client sends JSON data in the request body. 
2️. DRF converts JSON into a Python dictionary (request.data). 
3. Serializer processes this dictionary to create a Django model instance. 
4. Data validation ensures correctness before storing in the database.

📌 Example Incoming JSON Data (from client)
json
{
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3
}

📌 Using the Serializer for Deserialization
serializer = ProductSerializer(data=request.data)  # ✅ Converts JSON into Python dictionary

✔ Setting data=request.data tells the serializer to process incoming data instead of serializing an existing object.

🚀 Under the Hood: 
✔ The serializer automatically maps JSON fields to model fields. 
✔ It performs validation checks before creating a model instance. 
✔ The processed data becomes available in serializer.validated_data.




3. Validating Data Before Accessing validated_data
🚨 Before we access serializer.validated_data, we must validate the data! 
✔ This ensures incoming data matches the expected format and rules. 
✔ Validation prevents incorrect or malicious input from being stored in the database.

📌 Validation will be handled in the next lesson. For now, we simply return "ok" in the response while preparing to implement data validation.




4. Testing API Requests in Browsable API
🚀 Benefits of the Browsable API: 
✔ Shows a box for sending content when POST requests are enabled. 
✔ Allows testing API endpoints without needing external tools like Postman. 
✔ Displays JSON formatting automatically when selecting "POST" requests.

📌 Example of Browsable API Request Box:
POST /products/
{
    "title": "Laptop",
    "unit_price": 999.99,
    "collection": 3
}
🚀 When submitted, Django REST Framework processes the request!




codes learned in this lesson:

@api_view(['GET', 'POST'])
def product_list(request):
	if request.method == 'GET':
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)
	elif request.method == 'POST':
		serializer = ProductSerializer(data=request.data)  
		   #the deserialized data will be available at serializer.validated_data, but before that we need to  validate the data
		



Key Takeaways
✔ Deserialization converts incoming JSON data into Python objects for database storage. 
✔ Enable POST requests using @api_view(['GET', 'POST']) in API views. 
✔ Set data=request.data inside the serializer to process incoming data. 
✔ Browsable API makes it easier to test API requests without external tools. 
✔ Validation must occur before accessing serializer.validated_data to ensure data integrity.

🚀 Next Lesson: Implementing data validation in Django REST Framework!










Data Validation:
----------------
Data validation is a critical step when processing incoming API requests. Before accessing validated_data, Django REST Framework (DRF) must verify that the submitted data meets the model’s constraints. Otherwise, an exception will be raised.

1. Why Validation is Necessary
✔ Prevents malformed or incorrect data from being stored in the database. 
✔ Ensures API clients adhere to expected data structure. 
✔ Protects against missing required fields, incorrect data types, or logic errors.

🚀 Example: Client sends an incomplete product object
json
POST /products/
{}

🚨 Without validation, the database could receive invalid data, leading to errors!




2. Implementing Basic Validation in API Views

📌 Modify the product_list API view
from rest_framework import status

@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Begin deserialization

        if serializer.is_valid():  # ✅ Validate incoming data
            return Response('ok')
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)  # Return errors
			
✅ Validates the submitted data using serializer.is_valid(). 
✅ Returns validation errors if the input is incorrect.

📌 Example Response for Invalid Input
json
{
    "title": ["This field is required."],
    "unit_price": ["This field is required."],
    "collection": ["This field is required."]
}

🚀 HTTP 400 (Bad Request) ensures clients know their request is invalid.




3. A Cleaner Approach with raise_exception=True
Instead of manually handling validation errors, we can simplify this logic by enabling automatic error handling.

📌 Modify the API view
serializer.is_valid(raise_exception=True)  # ✅ Automatically raises error response

🚀 This removes the need for an explicit if-else block and reduces boilerplate code.

📌 Updated Code
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Begin deserialization
        serializer.is_valid(raise_exception=True)  # ✅ Validation + automatic error handling
        return Response('ok')
		
✅ If the request is invalid, DRF automatically returns a 400 Bad Request error response. ✅ Less code, same result!

📌 Example Response
json
{
    "title": ["This field is required."],
    "unit_price": ["This field is required."],
    "collection": ["This field is required."]
}




4. Understanding validated_data
After successful validation, DRF provides a cleaned dictionary containing valid data.

📌 Example: Printing validated_data
print(serializer.validated_data)

🚀 Example Output in Terminal
OrderedDict([
    ('title', 'Laptop'),
    ('unit_price', Decimal('999.99')),
    ('collection', <Collection: Electronics>)
])

✅ DRF automatically converts collection from an ID into a model instance.
🚀 This cleaned data is now ready for saving into the database.




5. Validating Objects at a Higher Level
By default, validation rules are derived from model field constraints. 
However, sometimes, we need to compare multiple fields together.

📌 Example: User Registration ✔ A user submits a form with password and confirm_password. ✔ We need to ensure both fields match before processing the request.

📌 Modify ProductSerializer to include custom validation

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['title', 'unit_price', 'collection']

    def validate(self, data):  # ✅ Overriding the validate method of ModelSerializer
        if data['password'] != data['confirm_password']:
            raise serializers.ValidationError('Passwords do not match')
        return data  # Return validated data if correct

✅ If passwords do not match, an error is returned before saving.

📌 Example Response for Invalid Input
json
{
    "non_field_errors": ["Passwords do not match"]
}
🚀 Useful for validation logic that involves multiple fields together.




codes learned in this discussion:
from rest_framework import status

if serializer.is_valid():
    serializer.validated_data
	return Response('ok')
else:
	return Reponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


or by cleaner way
serializer.is_valid(raise_exception=True)  ---> we don't need if else block
serializer.validated_data   --> ordereddict


validated data : OrderedDict([('title', 'a'), ('unit_price', Decimal('1.00')), ('collection', <Collection: collection1>)]) 

by default, validation rules comes from the definition of model fields. So, if we need anything extra, we need to override the validate method in our serializer


So, in our product serializer class:
def validate(self, data): # this is defined in our ModelSerializer class, and we are overriding it here
	if data['password'] != data['confirm_password']:
		return serializers.ValidationError('Passwords do not match')
	return data




Key Takeaways
✔ Always validate data before accessing validated_data to prevent errors. 
✔ Use serializer.is_valid(raise_exception=True) for cleaner error handling. 
✔ DRF automatically converts foreign key IDs to model instances in validated_data. 
✔ Override validate(self, data) for object-level validation (e.g., comparing passwords). 
✔ HTTP 400 ensures that clients know when their request fails validation.

🚀 Next Lesson: Saving validated data into the database!














Saving Objects:
---------------
When processing incoming data from clients, we need to deserialize and store the data in the database. Django REST Framework (DRF) simplifies this process with the save() method, which creates or updates objects automatically based on the serializer state.

1. How the save() Method Works
✔ save() automatically creates or updates a model instance. 
✔ Uses data from validated_data (but we don’t need to access it directly). 
✔ Calls either create() or update(), depending on whether the serializer has an instance.

📌 Example: Saving a Product After Validation
serializer.is_valid(raise_exception=True)  # ✅ Validate incoming data
serializer.save()  # ✅ Automatically creates or updates product

🚀 We don’t need to touch validated_data—DRF handles everything internally!




2. Creating a New Product
✔ Clients send a POST request with JSON data to /products/. 
✔ The serializer validates the data and creates a new product.

📌 Modify the API View to Handle POST Requests
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = ProductSerializer(data=request.data)  # Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # Validate data
        serializer.save()  # ✅ Save product to the database
        return Response(serializer.data, status=status.HTTP_201_CREATED)  # ✅ Return the created product

✅ Returns the created product instead of just "ok", following RESTful conventions.

📌 Example Request (Client sends POST request)
json
{
    "title": "Laptop",
    "slug": "laptop",
    "unit_price": 999.99,
    "collection": 1,
    "inventory": 50
}

📌 Example Response (Product created successfully)
json
{
    "id": 4,
    "title": "Laptop",
    "slug": "laptop",
    "unit_price": 999.99,
    "inventory": 50,
    "collection": 1
}

🚀 DRF automatically assigns the product an id and stores it in the database.




3. Overriding create() for Custom Object Creation
Sometimes, we need to modify object creation behavior, such as adding computed fields.

📌 Example: Overriding create() in the Serializer
class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['title', 'slug', 'unit_price', 'inventory', 'collection']

    def create(self, validated_data):  # ✅ Override default creation behavior
        product = Product(**validated_data)  # Create product using validated data
        product.special_field = "Custom Value"  # ✅ Set extra fields
        product.save()
        return product
		
🚀 This ensures custom logic is applied before saving the product.




4. Updating a Product (PUT Requests)
✔ Clients send a PUT request to update a product (e.g., /products/2/). 
✔ The serializer identifies an existing product and updates its attributes.

📌 Modify the API View to Handle PUT Requests
@api_view(['GET', 'PUT'])
def product_detail(request, id):
    product = Product.objects.get(pk=id)  # ✅ Retrieve product by ID

    if request.method == 'GET':  
        serializer = ProductSerializer(product)
        return Response(serializer.data)  # ✅ Return product details

    elif request.method == 'PUT':  
        serializer = ProductSerializer(product, data=request.data)  # ✅ Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # ✅ Validate data
        serializer.save()  # ✅ Update the product in the database
        return Response(serializer.data, status=status.HTTP_200_OK)  # ✅ Return updated product
		
🚀 If PUT is used, update() is triggered instead of create().

📌 Example Request (PUT /products/2/)
json
{
    "title": "Laptop+",
    "slug": "laptop-updated",
    "unit_price": 899.99,
    "inventory": 45,
    "collection": 1
}

📌 Example Response (Product updated successfully)
json
{
    "id": 2,
    "title": "Laptop+",
    "slug": "laptop-updated",
    "unit_price": 899.99,
    "inventory": 45,
    "collection": 1
}
✅ The title and price are updated, and the response includes the modified product.




5. Overriding update() for Custom Update Behavior
✔ If extra processing is needed while updating, override update() in the serializer. ✔ update() receives:
instance → The product being updated.
validated_data → The incoming validated data.

📌 Example: Overriding update() of ModelSerializer

in the ProductSerializer:
def update(self, instance, validated_data):  # ✅ Customize update behavior
    instance.unit_price = validated_data.get('unit_price', instance.unit_price)  # ✅ Modify specific attributes
    instance.inventory = validated_data.get('inventory', instance.inventory)  
    instance.save()
    return instance
	
🚀 Ensures product attributes are correctly updated without modifying other fields.




6. When to Use PUT vs. PATCH
✔ PUT updates all fields, requiring the complete object. 
✔ PATCH updates only the provided fields, ignoring the rest.

📌 Example API View for Both PUT and PATCH
@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
    product = Product.objects.get(pk=id)

    if request.method == 'GET':  
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    elif request.method in ['PUT', 'PATCH']:  
        serializer = ProductSerializer(product, data=request.data, partial=request.method == 'PATCH')  
        serializer.is_valid(raise_exception=True)  
        serializer.save()
        return Response(serializer.data, status=status.HTTP_200_OK)
		
🚀 Setting partial=True ensures PATCH updates only provided fields.




codes in this lesson:

our Model serializer has save method ( used for creating or updating)

posting a product object like this:
{
	"title" : "a",
	"slug" : "a",
	"unit_price" : 1,
	"collection" : 1,
	"inventory" : 1
}

right after validating the data
serializer.save() and we don't need serializer.validated_data after this


Now there are situations where we want to override how a product is created

in serializer class:

def create(self, validated_data):
	product = Product(**validated_data)
	product.other = 1
	product.save()
	return product
	
we can override the update method:

def update(self, instance, validated_data):
	instance.unit_price = validated_data.get('unit_price')
	instance.save()
	return instance


The save method will call one of the above methods depending on the state of the serializer.

For updating:
@api_view(['GET', 'PUT', 'PATCH'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)





Key Takeaways
✔ Use save() to automatically create or update objects. 
✔ DRF calls create() when saving new objects, and update() when modifying existing ones. 
✔ Use validated_data inside create() and update() to apply custom logic. 
✔ Always return the created or updated object in API responses. 
✔ Enable both PUT and PATCH depending on whether full updates or partial updates are needed. 
✔ Use HTTP 201 (CREATED) for newly created objects and HTTP 200 (OK) for updates.

🚀 Next Lesson: Deleting objects from the database!











Deleting Objects:
-----------------
Deleting objects from the database is a critical operation in RESTful APIs. Proper handling ensures that deletions are safe, meaningful, and aligned with API conventions.

1. Implementing the DELETE Operation
✔ The delete operation is implemented in the product_detail() function, as it applies to a specific product. 
✔ Adding DELETE to the view allows clients to remove products via API requests.

📌 Modify the API View to Handle DELETE Requests
@api_view(['GET', 'PUT', 'DELETE'])
def product_detail(request, id):
    product = get_object_or_404(Product, pk=id)  # Fetch product by ID

    if request.method == 'GET':
        serializer = ProductSerializer(product)
        return Response(serializer.data)  # ✅ Return product details

    elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    elif request.method == 'DELETE':
        if product.orderitems.count() > 0:  # ✅ Prevent deletion if product is linked to orders
            return Response(
                {'error': 'Product cannot be deleted because it is associated with an order item.'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        product.delete()  # ✅ Remove the product from the database
        return Response(status=status.HTTP_204_NO_CONTENT)  # ✅ Return empty response with 204 status

🚀 Now, DELETE requests remove products while preventing unintended deletions.




2. Testing Deletions Using Browsable API
✔ Once DELETE is added to the view, the browsable API automatically shows a delete button. 
✔ Clicking DELETE sends a request to remove the product.

📌 Example Request (DELETE /products/1/)
DELETE /products/1/

📌 Expected API Response
json
{
    "error": "Product cannot be deleted because it is associated with an order item."
}

🚀 Ensures users get proper feedback when attempting deletions.




3. Handling Foreign Key Constraints
🚨 Problem: Some products cannot be deleted because they are linked to order items. 
✔ Django enforces this protection using Foreign Key relationships. 
✔ If an attempt is made to delete a product that belongs to an order, an exception is raised.

📌 Fix: Check for Order Items Before Deletion
if product.orderitems.count() > 0:  
    return Response(
        {'error': 'Product cannot be deleted because it is associated with an order item.'},
        status=status.HTTP_405_METHOD_NOT_ALLOWED
    )
🚀 This prevents application crashes and provides meaningful error responses.




4. Choosing the Correct HTTP Status Code
✔ 204 No Content → Standard RESTful convention for successful deletions. 
✔ 405 Method Not Allowed → Used when deletion is restricted due to dependencies. 
✔ Use httpstatuses.com to find correct status codes.

📌 Example Response When Deletion is Blocked

json
{
    "error": "Product cannot be deleted because it is associated with an order item."
}

🚀 Provides clarity to API consumers, ensuring safe request handling.




5. Renaming Foreign Key Related Attributes
✔ Django defaults to orderitem_set for reverse relationships. ✔ Renaming to orderitems makes the API more intuitive.

📌 Modify models.py
class OrderItem(models.Model):
    product = models.ForeignKey(Product, on_delete=models.PROTECT, related_name='orderitems')  # ✅ Use a clearer related name
	
📌 Update product_detail() View
if product.orderitems.count() > 0:  # ✅ Updated related name

🚀 Now, accessing order items is more readable and intuitive.



codes learned in this lesson:
@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])
def product_detail(request, id):
	product = Product.objects.get(pk=id)
	if request.method == 'GET':		
		serializer = ProductSerializer(product)  
		return Response(serializer.data)  
	elif request.method == 'PUT':
        serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
	elif request.method == 'DELETE':
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)


httpstatus.com --> on this page, you can see all the standard HTTP status code. 





Key Takeaways
✔ Use DELETE in the product_detail() view to remove specific products. 
✔ Prevent deletion if the product is linked to existing orders (orderitems.count() > 0). 
✔ Return 204 No Content for successful deletions, and 405 Method Not Allowed when deletion is restricted. 
✔ Check HTTP status codes on httpstatuses.com for best practices. 
✔ Rename default Django reverse relationship attributes (orderitem_set → orderitems).










Exercise: Building the Collections API
--------------------------------------
This section focuses on implementing API endpoints for managing collections. 
These endpoints allow us to: 
✔ Retrieve all collections and include the number of products in each collection. 
✔ Create new collections via API requests. 
✔ Perform CRUD operations (Get, Update, Delete) on individual collections.

1. Implementing collection_list() for Managing Multiple Collections
✔ Handles GET requests to return all collections. 
✔ Handles POST requests to create a new collection. 
✔ Uses annotate(products_count=Count('products')) to include the number of products in each collection.

📌 Modify the API View
@api_view(['GET', 'POST'])
def collection_list(request):
    if request.method == 'GET':  
        queryset = Collection.objects.annotate(products_count=Count('products')).all()
        serializer = CollectionSerializer(queryset, many=True)  
        return Response(serializer.data)  # ✅ Return serialized data

    elif request.method == 'POST':  
        serializer = CollectionSerializer(data=request.data)  # ✅ Deserialize incoming data
        serializer.is_valid(raise_exception=True)  # ✅ Validate request data
        serializer.save()  # ✅ Save new collection to the database
        return Response(serializer.data, status=status.HTTP_201_CREATED)  # ✅ Return created collection

🚀 Now, clients can retrieve and create collections via API requests.

📌 Example API Response (GET /collections/)
json
[
    {"id": 1, "title": "Electronics", "products_count": 10},
    {"id": 2, "title": "Clothing", "products_count": 5}
]

✅ Includes product count inside each collection object.

📌 Example Request (POST /collections/)
json
{
    "title": "Furniture"
}

📌 Example Response (POST /collections/)
json
{
    "id": 3,
    "title": "Furniture",
    "products_count": 0
}

🚀 New collections are created successfully!




2. Implementing collection_detail() for Managing Individual Collections
✔ Handles GET requests → Fetch details of a single collection. 
✔ Handles PUT requests → Update an existing collection. 
✔ Handles DELETE requests → Remove a collection if no products are linked. 
✔ Uses get_object_or_404() to return a 404 error if the collection does not exist.

📌 Modify the API View
@api_view(['GET', 'PUT', 'DELETE'])
def collection_detail(request, pk):
    collection = get_object_or_404(
        Collection.objects.annotate(products_count=Count('products')), pk=pk)

    if request.method == 'GET':  
        serializer = CollectionSerializer(collection)  
        return Response(serializer.data)  # ✅ Return collection details

    elif request.method == 'PUT':  
        serializer = CollectionSerializer(collection, data=request.data)  
        serializer.is_valid(raise_exception=True)  
        serializer.save()  
        return Response(serializer.data)  # ✅ Return updated collection

    elif request.method == 'DELETE':
        if collection.products.count() > 0:  # ✅ Prevent deletion if collection has products
            return Response(
                {'error': 'Collection cannot be deleted because it includes one or more products.'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        collection.delete()  # ✅ Remove collection
        return Response(status=status.HTTP_204_NO_CONTENT)  # ✅ Return empty response
		
🚀 Clients can now retrieve, update, and delete individual collections via API.

📌 Example Request (GET /collections/1/)
json
GET /collections/1/

📌 Example Response (GET /collections/1/)
json
{
    "id": 1,
    "title": "Electronics",
    "products_count": 10
}
🚀 Returns full details, including product count.

📌 Example Request (DELETE /collections/1/)
json
DELETE /collections/1/

🚀 Prevents deletion if products are linked and returns error.

📌 Example Response (DELETE /collections/1/)
json
{
    "error": "Collection cannot be deleted because it includes one or more products."
}

🚀 Ensures safe deletion by preventing accidental removals.




3. Updating URL Routing (urls.py)
✔ Register collection endpoints in the URL configuration. 
✔ Define routes for both list and detail views.

📌 Modify urls.py
# URLConf
urlpatterns = [
    path('products/', views.product_list),
    path('products/<int:id>/', views.product_detail),
    path('collections/', views.collection_list),
    path('collections/<int:pk>/', views.collection_detail, name='collection-detail'),
]
🚀 Ensures proper API routing for collections.




4. Modifying Collection Model to Improve Related Names (models.py)
✔ Use related_name='products' to rename the default reverse relationship in Django.

📌 Modify models.py
class Product(models.Model):
    title = models.CharField(max_length=255)
    slug = models.SlugField()
    description = models.TextField(null=True, blank=True)
    unit_price = models.DecimalField(
        max_digits=6, decimal_places=2, validators=[MinValueValidator(1)])
    inventory = models.IntegerField(validators=[MinValueValidator(0)])
    last_update = models.DateTimeField(auto_now=True)
    collection = models.ForeignKey(
        Collection, on_delete=models.PROTECT, related_name='products')  # ✅ Custom related name
		
🚀 Now, accessing collection products is more intuitive (collection.products).




5. Updating Admin Module for Improved Product Count (admin.py)
✔ Modify get_queryset() to reflect the updated field name (products instead of product_set).

📌 Modify admin.py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    autocomplete_fields = ['featured_product']
    list_display = ['title', 'products_count']
    search_fields = ['title']

    @admin.display(ordering='products_count')
    def products_count(self, collection):
        url = (
            reverse('admin:store_product_changelist')
            + '?'
            + urlencode({'collection__id': str(collection.id)}))
        return format_html('<a href="{}">{} Products</a>', url, collection.products_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(products_count=Count('products'))  # ✅ Updated field name
		
🚀 Ensures that collection product counts appear correctly in the admin panel.


Note on get_queryset():
The get_queryset() method in this context is specifically for the Django admin interface. It modifies the default queryset used by the Django admin panel when displaying the Collection model.

🚀 Purpose of get_queryset() in CollectionAdmin 
✔ Annotates collections with the number of products → Adds a products_count field dynamically using Count('products'). 
✔ Ensures product count appears in the admin interface → Used in the list_display column for better visibility. 
✔ Optimizes queries → Instead of running a separate query for each collection's product count, it fetches them efficiently in a single query.

📌 Comparison: Django ORM vs. Admin Interface Usage
In Django ORM (Views, API, Templates) → Used for querying database objects within views or API endpoints.
In Django Admin (CollectionAdmin) → Used inside the admin panel to modify how data is fetched/displayed.

🚀 In Action (Admin Panel)
The product count appears in the admin list page (list_display = ['title', 'products_count']).
The custom method products_count() uses this annotation to generate clickable product links.

📌 If this method was missing, the admin panel would require separate queries for each collection’s product count, reducing efficiency!





Key Takeaways
✔ collection_list() handles retrieving all collections and creating new ones. 
✔ collection_detail() manages individual collections (GET, PUT, DELETE). 
✔ Collections are annotated using Count('products') to include product counts. 
✔ Prevent collection deletion if products are linked, ensuring data integrity. 
✔ Define proper URL routes (/collections/ for all collections, /collections/{id}/ for a specific collection). 
✔ Use related_name='products' for a more intuitive reverse relationship. 
✔ Update the admin panel to reflect correct product counts.

🚀 Next Lesson: Exploring advanced API concepts in Django REST Framework!












Advanced API Concepts:
----------------------

In this section, we'll be talking about advanced API concepts that help us build APIs faster with less code. We'll be talking about Class-based views, Generic views, Viewsets, Routers, as well as Searching, Filtering and Pagination. So by the end of this section, our products endpoint will be in a much better shape and our code, as you will see, will be cleaner and more concise. 


Class-based Views:
------------------
Django REST Framework (DRF) supports class-based views (CBVs), which make the code cleaner, more reusable, and maintainable compared to function-based views. Instead of using multiple if statements, CBVs automatically dispatch requests to the appropriate method (GET, POST, PUT, DELETE).

1. Benefits of Class-Based Views
✔ Cleaner Code → No need for multiple if conditions within a single function. 
✔ Reusability → Allows inheritance and customization. 
✔ Object-Oriented Features → Uses standard Python class structures. 
✔ Built-in Methods → Provides better API structure with built-in support.

📌 Function-Based vs. Class-Based View Example 

🚨 Function-Based View (before conversion)
@api_view(['GET', 'POST'])
def product_list(request):
    if request.method == 'GET':  
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)  

    elif request.method == 'POST':  
        serializer = ProductSerializer(data=request.data)  
        serializer.is_valid(raise_exception=True)  
        serializer.save()  
        return Response(serializer.data, status=status.HTTP_201_CREATED)
		
🚀 Class-Based View (after conversion)
from rest_framework.views import APIView

class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

✅ Cleaner, more structured, and reusable!

📌 Updating urls.py to use Class-Based View
path('products/', views.ProductList.as_view()),  # ✅ Converts class into a function-based view internally

🚀 as_view() method converts the class into a Django view function.




2. Implementing a Class-Based View for Individual Products
✔ **Handles GET, PUT, and DELETE requests for a single product. 
✔ Uses get_object_or_404() to fetch the product and return a 404 if not found.

📌 Modify the View Class (ProductDetail)
class ProductDetail(APIView):
    def get(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product)
        return Response(serializer.data)

    def put(self, request, id):
        product = get_object_or_404(Product, pk=id)
        serializer = ProductSerializer(product, data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    def delete(self, request, id):
        product = get_object_or_404(Product, pk=id)
        if product.orderitems.count() > 0:
            return Response(
                {'error': 'Product cannot be deleted'},
                status=status.HTTP_405_METHOD_NOT_ALLOWED
            )
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

🚀 Requests automatically dispatch to the correct method (get(), put(), or delete()).

📌 Update urls.py to use Class-Based View
path('products/<int:id>/', views.ProductDetail.as_view()),  # ✅ Converts class into a function-based view

🚀 Now, requests to /products/{id}/ are correctly handled by the corresponding method in ProductDetail.




3. Fixing Unexpected Keyword Argument ID Error
🚨 Issue: Missing id in method parameters. 
✔ Solution: Each method (get, put, delete) must explicitly include id as a parameter.

📌 Example Fix
class ProductDetail(APIView):
    def get(self, request, id):  # ✅ Include ID parameter
🚀 Without this fix, Django will not recognize id in the request URL.




4. Key Differences Between Function-Based and Class-Based Views
✔ Function-Based Views (FBVs)
Simple and easy to understand.
Good for small applications with fewer endpoints.
Requires nested if conditions to handle multiple request types (GET, POST, PUT, DELETE).

✔ Class-Based Views (CBVs)
More structured and reusable.
Uses separate methods (get(), post(), put(), delete()) to cleanly handle request types.
Easier to extend and customize with inheritance.

📌 Choosing the Right Approach 
✔ Use FBVs for simple API views. 
✔ Use CBVs for complex, reusable views with multiple request types.

🚀 Now that our API is structured using class-based views, we can further refine it using Django's built-in generic views!




Codes learned in this lesson:
Django provides more features over class based views

from rest_framework.views import APIView

class ProductList(APIView):
	def get(self, request):
		queryset = Product.objects.select_related('collection').all()
		serializer = ProductSerializer(	
					queryset, many=True, context={'request': request})
		return Response(serializer.data)

	def post(self, request):
		serializer = ProductSerializer(data=request.data) 
        serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data, status=status.HTTP_201_CREATED)
						
in urls.py:
path('products/', views.ProductList.as_view()),  # at the end of day, there is a function under the hood that gets called. 
						
class productDetail(APIView):
	def get(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product)
		return Response(serializer.data)
		
	def put(self, request, id):
		product = get_object_or_404(Product, pk=id)
		serializer = ProductSerializer(product, data=request.data)
		serializer.is_valid(raise_exception=True)
		serializer.save()
		return Response(serializer.data) 
		
	def delete(self, request, id):
		product = get_object_or_404(Product, pk=id)
		if product.orderitem_set.count() > 0:
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		product.delete()
		return Response(status=status.HTTP_204_NO_CONTENT)

in urls.py:
path('products/<int:id>/', views.ProductDetail.as_view()),




Key Takeaways
✔ Class-Based Views improve code structure, reusability, and maintainability. ✔ Requests automatically dispatch to methods (get(), post(), put(), delete()) without nested if statements. ✔ Use APIView as a base class for defining class-based views in Django REST Framework. ✔ Fix Unexpected Keyword Argument ID error by explicitly adding id as a parameter in each method. ✔ Class-Based Views are ideal for complex applications requiring multiple request types. ✔ Use as_view() in urls.py to register CBVs as Django views.

🚀 Next Lesson: Leveraging Django’s Generic API Views for even more streamlined development!



		
		
		
		
		
		

Mixins:
-------
Mixins are reusable components that encapsulate common patterns used in API views. They help reduce duplication and improve code maintainability.

🚀 Why Use Mixins? 
✔ Avoid Repetitive Code → Eliminates redundant logic across multiple views. 
✔ Encapsulation → Groups common behaviors into reusable classes. 
✔ Scalability → Simplifies adding new API endpoints. 
✔ Easy Customization → Extend and override methods when needed.

1. Identifying Repetitive Code Patterns
✔ When listing products (ProductList) and collections (CollectionList), both views follow the same structure: 
   - Create a queryset (database query). 
   - Create a serializer to transform data. 
   - Return serialized data in a response.
   
So, the main differences, when you compare across the models are:
1. how they are creating a queryset
2. the serializers they are using
   

✔ Similarly, when creating products or collections, both views: 
   - Instantiate a serializer with request data. 
   - Validate the data. 
   - Save the model instance. 
   - Return the serialized object in the response.


🚀 This duplication suggests that mixins can help streamline the implementation!




2. Understanding Django REST Framework’s Built-in Mixins
Django REST Framework provides generic mixins to handle common API operations.

📌 Available Mixins (API Guide → Generic Views)
ListModelMixin → Handles listing objects.
CreateModelMixin → Handles resource creation.
RetrieveModelMixin → Handles fetching a single resource (detail view).
UpdateModelMixin → Handles full or partial updates (PUT, PATCH).
DestroyModelMixin → Handles deletion (DELETE).




3. Exploring Built-in Mixins in DRF
✔ ListModelMixin → Encapsulates the logic for listing models.

📌 Implementation
class ListModelMixin:
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())  # ✅ Retrieve queryset

        page = self.paginate_queryset(queryset)  
        if page is not None:
            serializer = self.get_serializer(page, many=True)  # ✅ Serialize paginated data
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)  # ✅ Serialize data
        return Response(serializer.data)

🚀 DRF handles filtering, pagination, serialization, and response formation—everything in one method!

✔ CreateModelMixin → Encapsulates logic for creating a resource.

📌 Implementation
class CreateModelMixin:
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)  # ✅ Deserialize request data
        serializer.is_valid(raise_exception=True)  # ✅ Validate data
        self.perform_create(serializer)  # ✅ Save the instance
        headers = self.get_success_headers(serializer.data)  
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()  # ✅ Saves the model instance

    def get_success_headers(self, data):
        try:
            return {'Location': str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}
			
🚀 Handles validation, serialization, saving, and response formation effortlessly.




4. Applying Mixins to Our Class-Based Views

📌 Refactor ProductList to use Mixins
from rest_framework.mixins import ListModelMixin, CreateModelMixin
from rest_framework.generics import GenericAPIView

class ProductList(ListModelMixin, CreateModelMixin, GenericAPIView):
    queryset = Product.objects.select_related('collection').all()  # ✅ Define default queryset
    serializer_class = ProductSerializer  # ✅ Define serializer class

🚀 Now, ProductList automatically supports both GET and POST, removing redundant code!

📌 Refactor ProductDetail
from rest_framework.mixins import RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin

class ProductDetail(RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin, GenericAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
	
🚀 Now, ProductDetail automatically supports GET, PUT, and DELETE without additional methods!

📌 Update urls.py
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ✅ Handles list and creation
    path('products/<int:id>/', views.ProductDetail.as_view()),  # ✅ Handles retrieve, update, delete
]

🚀 Now our API views are fully optimized and scalable!




5. How Mixins Improve Code Structure
🚀 Before (Manual Code Handling)
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

🚀 After (Using Mixins)
class ProductList(ListModelMixin, CreateModelMixin, GenericAPIView):
    queryset = Product.objects.select_related('collection').all()
    serializer_class = ProductSerializer
	
✅ Less code, same functionality!




codes referred in this discussion:
from rest_framework.mixins import ListModelMixin, CreateModelMixin

class ListModelMixin:
    """
    List a queryset.
    """
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class CreateModelMixin:
    """
    Create a model instance.
    """
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return {'Location': str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}



django rest framework --> https://www.django-rest-framework.org/ --> API Guide --> Generic views --> 




Key Takeaways
✔ Mixins remove redundant code and streamline API views. 
✔ ListModelMixin encapsulates logic for retrieving lists of objects. 
✔ CreateModelMixin handles resource creation, including validation and saving. 
✔ Other mixins (RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin) handle object retrieval, updates, and deletion. 
✔ Refactoring views with mixins makes APIs scalable and maintainable. 
✔ Use GenericAPIView to combine mixins and customize behavior when needed.












Generic Views:
--------------
Now, most of the time, we are not going to use these mixins directly. Instead, we're going to use concrete classes that combine one or more mixins. We call these classes generic views. 

Generic views simplify API development by combining mixins to provide reusable, structured functionalities. They reduce boilerplate code and make API views more scalable.

🚀 Why Use Generic Views?
✔ Less Boilerplate Code → Eliminates repetitive logic across views. 
✔ Encapsulation → Groups related behaviors into concrete classes. 
✔ Scalability → Makes adding new API endpoints easier. 
✔ Customization → Easily override methods when needed.




1. Identifying Common Patterns in API Views
✔ When listing products (ProductList) and collections (CollectionList), both views perform similar operations:
Define a queryset (fetch database records).
Assign a serializer for data transformation.
Return serialized data in the API response.

So, the main differences across models are: 
 - How they create a queryset. 
 - The serializer classes they use.

✔ Similarly, when creating products or collections, the views:
 - Instantiate a serializer with request data.
 - Validate the data.
 - Save the model instance.
 - Return the serialized object in the API response.

🚀 This repetition indicates generic views can streamline the implementation!




2 .Understanding Django REST Framework’s Generic Views
Django REST Framework provides built-in generic views that combine one or more mixins to handle API actions.

📌 Built-in Generic Views 
✔ ListCreateAPIView → Handles listing and creation. 
✔ ListAPIView → Handles only listing (GET). 
✔ RetrieveAPIView → Handles retrieving single resources (GET). 
✔ RetrieveUpdateAPIView, RetrieveDestroyAPIView, RetrieveUpdateDestroyAPIView → Supports update, delete, and retrieve.




3. Exploring Built-in Generic Views in DRF
✔ ListCreateAPIView → Encapsulates logic for listing and creating objects.

📌 Implementation
from rest_framework.generics import ListCreateAPIView

class ListCreateAPIView(mixins.ListModelMixin,
                        mixins.CreateModelMixin,
                        GenericAPIView):
    """
    Concrete view for listing a queryset or creating a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)

🚀 DRF automatically handles listing (GET) and creation (POST), removing redundant code!

✔ GenericAPIView → The base class for all generic views. It provides key methods to override: 
📌 get_queryset() → Defines the queryset. 
📌 get_serializer_class() → Specifies the serializer. 
📌 get_serializer_context() → Provides request data in serializer context.




4. Applying Generic Views in Our API

📌 Refactor ProductList to use Generic Views
from rest_framework.generics import ListCreateAPIView

class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related('collection').all()  # ✅ Define queryset
    serializer_class = ProductSerializer  # ✅ Assign serializer class

	def get_serializer_context(self):
		return {'request': self.request}
		
🚀 Now, ProductList supports both GET and POST without needing separate methods!

📌 Refactor CollectionList
class CollectionList(ListCreateAPIView):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer
	
✔ Now, collections can be listed or created using the same optimized view.




5. Handling Read-Only Fields in Serializers
🚀 Problem: products_count should not be included when creating/updating a collection. 🚀 Solution: Mark the field as read-only in the serializer.

📌 Implementation
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title', 'products_count']

    products_count = serializers.IntegerField(read_only=True)
	
✔ Prevents products_count from appearing in POST requests, avoiding unnecessary validation errors.




6. How Generic Views Improve Code Structure

🚀 Before (Manual API Logic)
class ProductList(APIView):
    def get(self, request):
        queryset = Product.objects.select_related('collection').all()
        serializer = ProductSerializer(queryset, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = ProductSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

🚀 After (Using Generic Views)
class ProductList(ListCreateAPIView):
    queryset = Product.objects.select_related('collection').all()
    serializer_class = ProductSerializer
	
✅ Less code, same functionality!

📌 Updating urls.py
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ✅ Handles list and creation
    path('collections/', views.CollectionList.as_view()),  # ✅ Handles list and creation
]

🚀 Our API views are now optimized and scalable!




Codes referred in this discussion:

from rest_framework.generics import ListCreateAPIView

class ListCreateAPIView(mixins.ListModelMixin,
                        mixins.CreateModelMixin,
                        GenericAPIView):
    """
    Concrete view for listing a queryset or creating a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)



class ProductList(ListCreateAPIView):
	def get_queryset(self):
		return Product.objects.select_related('collection').all()
		
	def get_serializer_class(self):
		return ProductSerializer
		
	def get_serializer_context(self):
		return {'request': self.request}



class ProductList(ListCreateAPIView):
	queryset = Product.objects.select_related('collection').all()
	serializer_class = ProductSerializer
		
	def get_serializer_context(self):
		return {'request': self.request}


For collection:
class CollectionList(ListCreateAPIView):
	queryset = Collection.objects.annotate(products_count=Count('products')).all()
	serializer_class = CollectionSerializer


make 'product_count' as read_only:
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Collection
        fields = ['id', 'title', 'products_count']

    products_count = serializers.IntegerField(read_only=True)




📌 Key Takeaways
✔ Generic views remove redundant code and streamline API development. 
✔ ListCreateAPIView handles both listing and creation efficiently. 
✔ RetrieveAPIView, UpdateAPIView, and DestroyAPIView encapsulate retrieval, updates, and deletion. 
✔ Using queryset and serializer class attributes simplifies API views. 
✔ Refactoring with generic views makes APIs more maintainable and scalable. 
✔ Use GenericAPIView when more customization is needed.











Customizing Generic Views:
--------------------------
Generic views provide powerful abstractions, but sometimes we need custom logic that they don’t directly support. This section explores how to customize Django REST Framework (DRF) generic views.

🚀 Why Customize Generic Views?
✔ Handle complex logic → Some functionalities (e.g., conditional deletion) are specific to your application. 
✔ Optimize code structure → Removing redundant view logic while keeping custom behavior intact. 
✔ Maintain DRY principles → Use built-in mixins while overriding only necessary parts.

1. Understanding RetrieveUpdateDestroyAPIView
We use RetrieveUpdateDestroyAPIView when we need GET (retrieve), PUT (update), and DELETE (remove) operations in a view.

📌 Built-in Class Structure
class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,
                                   mixins.UpdateModelMixin,
                                   mixins.DestroyModelMixin,
                                   GenericAPIView):
    """
    Concrete view for retrieving, updating or deleting a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
✔ Provides default implementations for GET, PUT, PATCH, and DELETE. ✔ We can override specific methods if needed.




2. Customizing ProductDetail View
The ProductDetail view provides retrieving, updating, and deleting products.

📌 Implementation
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
🚀 Why override delete()? 
✔ DestroyModelMixin doesn’t understand business rules. 
✔ Our app needs to check if a product is linked to an order before deletion. 
✔ Returns an error if deletion isn’t allowed.




3. Handling URL Parameter Naming (pk vs. id)
By default, DRF expects the URL parameter pk, but our URL pattern uses id.

📌 Incorrect URL pattern
path('products/<int:id>/', views.ProductDetail.as_view()),

🚀 Fix: Change id to pk OR use lookup_field in the view.

📌 Using lookup_field
class ProductDetail(RetrieveUpdateDestroyAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    lookup_field = 'id'  # Overrides default 'pk'
	
✔ Now DRF correctly identifies the URL parameter.

🚀 Best Practice: Stick to Django’s convention (pk) for consistency.




4. Testing Deletion Errors
Possible Errors When Deleting a Product
📌 Error: Unexpected keyword argument pk in delete() 
✔ Cause: The method expected id, but URLs use pk. 
✔ Fix: Rename id to pk inside delete().

📌 Error: Product cannot be deleted because it is associated with an order item. 
✔ Cause: Business rule prevents deleting a product linked to an order. 
✔ Fix: Validate relationships before deletion.




5. Customizing CollectionDetail View
Like ProductDetail, the CollectionDetail view also requires a custom delete method.

📌 Implementation
class CollectionDetail(RetrieveUpdateDestroyAPIView):
    queryset = Collection.objects.annotate(products_count=Count('products'))
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
		
🚀 What’s Different? 
✔ Prevents collections containing products from being deleted. 
✔ Uses annotate(products_count=Count('products')) to count related products efficiently.

6. Updating urls.py for Generic Views
We need to register our optimized views in the URLs.

📌 Updated URL Configuration
urlpatterns = [
    path('products/', views.ProductList.as_view()),  # ✅ Handles listing and creation
    path('products/<int:pk>/', views.ProductDetail.as_view()),  # ✅ Handles retrieve, update, delete
    path('collections/', views.CollectionList.as_view()),  # ✅ Handles listing and creation
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),  # ✅ Handles collection actions
]

🚀 Now our API follows a clean, scalable structure.




Codes discussed in this lesson:

class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin,
                                   mixins.UpdateModelMixin,
                                   mixins.DestroyModelMixin,
                                   GenericAPIView):
    """
    Concrete view for retrieving, updating or deleting a model instance.
    """
    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        return self.partial_update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)

class ProductDetail(RetrieveUpdateDestroyAPIView):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def delete(self, request, pk):
		product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

class CollectionDetail(RetrieveUpdateDestroyAPIView):
	queryset = Collection.objects.annotate(products_count=Count('products'))
	serializer_class = CollectionSerializer
	
	def delete(self, request, pk):
		collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

# URLConf
urlpatterns = [
    path('products/', views.ProductList.as_view()),
    path('products/<int:pk>/', views.ProductDetail.as_view()),
    path('collections/', views.CollectionList.as_view()),
    path('collections/<int:pk>/', views.CollectionDetail.as_view(), name='collection-detail'),
]




📌 Key Takeaways
✔ Generic views provide efficient API development but may need customization. 
✔ Override delete() when business rules require additional validation. 
✔ Use lookup_field to match URL parameter names (default is pk). 
✔ Collection deletion should prevent removing collections that contain products. 
✔ Stick to DRF conventions (pk) unless a strong reason exists to modify them.













class based views --> to avoid duplication(to combine multiple operations) --> mixins --> combined mixins with GenericView --> to avoid duplication(to combine multiple views) --> ViewSets

ViewSets:
---------
ViewSets combine multiple related views into a single class, reducing code duplication and improving maintainability.

🚀 Why Use ViewSets?
✔ Eliminates redundancy → Combines similar views into a single class. 
✔ Encapsulation → Groups all logic related to a resource (e.g., products). 
✔ Scalability → Makes API endpoints more manageable and structured. 
✔ Less boilerplate → No need for separate classes for listing, creating, updating, and deleting.

1. Identifying Code Duplication in API Views
📌 Current Issue: 
✔ We have two separate views for ProductList (listing & creating) and ProductDetail (retrieving, updating, deleting). 
✔ Both views share similar querysets and the same serializer_class.

📌 Solution: ✔ Use ViewSets to merge related views into a single class.

🚀 What Changes? 
✔ No need for ProductList and ProductDetail as separate classes. 
✔ ProductViewSet will handle listing, creating, updating, and deleting in one class.




2. Understanding ViewSet Structure
📌 Import ViewSets
from rest_framework.viewsets import ModelViewSet

📌 Implementation of ModelViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, pk):  # ✅ Note: `destroy()` is used in `ModelViewSet`, not `delete()`
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
🚀 How does this improve our code? 
✔ Combines listing, creating, retrieving, updating, and deleting into one class. 
✔ Overrides destroy() to add business logic (prevent deletion of linked products). 
✔ Uses queryset & serializer_class attributes, reducing redundant method definitions.




3. Refactoring Collection Views Using ViewSets
📌 Implementation
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):  # ✅ Custom delete logic for collections
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'},
                            status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT
		
🚀 What changed?
✔ Merged CollectionList & CollectionDetail into CollectionViewSet.
✔ Prevent deletion of collections with associated products.




4. Read-Only ViewSets (ReadOnlyModelViewSet)
Sometimes, we only need to retrieve data without allowing creation, updates, or deletions.

📌 Using ReadOnlyModelViewSet
from rest_framework.viewsets import ReadOnlyModelViewSet

class ReadOnlyCollectionViewSet(ReadOnlyModelViewSet):
    queryset = Collection.objects.all()
    serializer_class = CollectionSerializer
	
🚀 Effect: 
✔ API only supports GET operations (list and retrieve). 
✔ No POST, PUT, or DELETE—ideal for read-only endpoints.

5. Updating urls.py for ViewSets
Since ViewSets don’t work with regular path() routes, we will use routers to register them dynamically.

📌 Basic URL Mapping
urlpatterns = [
    path('products/', views.ProductViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('products/<int:pk>/', views.ProductViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'})),
    path('collections/', views.CollectionViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('collections/<int:pk>/', views.CollectionViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
]


🚀 What changed? 
✔ We replaced ProductList and ProductDetail with ProductViewSet. 
✔ We replaced CollectionList and CollectionDetail with CollectionViewSet.

🚀 Next Step: Using routers for automatic route management (covered in the next lesson).


Codes in this lesson:
Using a view set, we can combine the logic for multiple related views inside a single class. 

from rest_framework.viewsets import ModelViewSet

class ProductViewSet(ModelViewSet):
	queryset = Product.objects.all()
	serializer_class = ProductSerializer
	
	def get_serializer_context(self):
		return {'request' : self.request}
	
	def destroy(self, request, pk):      #note modelViewSet has destroy method not delete method
		if OrderItem.objects.filter(product_id=kwargs['pk']).count > 0   (changing the logic, since self. fetching product already)
			return Response({'error': 'Product cannot be deleted'},status=status.HTTP_405_METHOD_NOT_ALLOWED)
		return super().destroy(request, *args, **kwargs)


class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(
        products_count=Count('products')).all()
    serializer_class = CollectionSerializer

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


Go through ReadOnlyModelViewSet and other viewsets




📌 Key Takeaways
✔ ViewSets merge multiple related views into a single class, improving code structure. 
✔ ModelViewSet provides full CRUD functionality (list, create, retrieve, update, delete). 
✔ ReadOnlyModelViewSet restricts endpoints to only GET operations. 
✔ Customizing destroy() in ViewSets lets us enforce business rules before deletion. 
✔ Routers will help us automate URL handling (covered in the next lesson).











Routers:
--------
Routers automatically generate URL patterns for ViewSets, eliminating the need for manually defining each route.

🚀 Why Use Routers?
✔ Simplifies URL management → No need to manually define path() for ViewSets. 
✔ Ensures consistency → Standardized routes for API resources. 
✔ Handles ViewSets dynamically → Registers all view logic within a single router. 
✔ Supports additional features → Default Router provides API navigation and JSON formatting.

1️. Understanding Router Mechanism in DRF

📌 Manually Defining ViewSet URLs (Before Using Routers)
urlpatterns = [
    path('products/', views.ProductViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('products/<int:pk>/', views.ProductViewSet.as_view({'get': 'retrieve', 'put': 'update', 'delete': 'destroy'})),
    path('collections/', views.CollectionViewSet.as_view({'get': 'list', 'post': 'create'})),
    path('collections/<int:pk>/', views.CollectionViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
]

🚀 Problem: 
✔ Manually specifying routes is redundant and requires updates for every new ViewSet. 
✔ Solution: Use Routers to automate URL generation.




2. Using SimpleRouter to Register ViewSets
📌 Import and Register ViewSets

from rest_framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)  # ✅ Registers ProductViewSet
router.register('collections', views.CollectionViewSet)  # ✅ Registers CollectionViewSet

# URL configuration
urlpatterns = router.urls  # ✅ Automatically generates routes for ViewSets

🚀 Effect: 
✔ Eliminates the need for manual URL definitions. 
✔ Maps ViewSets automatically to routes.

📌 Generated URL Patterns (router.urls)

[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk>[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk>[^/.]+)/$' [name='collection-detail']>]
 
🚀 What changed? 
✔ product-list → Handles listing (GET) and creation (POST). 
✔ product-detail → Handles retrieving (GET), updating (PUT), and deleting (DELETE). 
✔ collection-list & collection-detail work similarly.




3. Handling Additional URL Patterns
If our project includes custom routes, we use include() to merge router-generated URLs with additional patterns.

📌 Example: Including Router URLs With Custom Paths
from django.urls import path, include

urlpatterns = [
    path('', include(router.urls)),  # ✅ Registers all ViewSet URLs
    path('custom-path/', views.CustomView.as_view()),  # ✅ Additional custom routes
]

🚀 Effect: ✔ Allows merging router-generated URLs with manually defined patterns.




4. Using DefaultRouter for Additional Features

📌 Replacing SimpleRouter with DefaultRouter
from rest_framework.routers import DefaultRouter

router = DefaultRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

urlpatterns = router.urls

🚀 What extra features does DefaultRouter provide? 
✔ API Root Navigation → Visiting /store/ shows a page listing all available endpoints. 
✔ JSON Browsing Support → Appending .json to an endpoint returns JSON-formatted data.

📌 Example: JSON Output
GET /store/products.json  
# Returns all products in JSON format

🚀 When to Use DefaultRouter? 
✔ Use DefaultRouter if you want API navigation and JSON formatting. 
✔ Use SimpleRouter if you prefer a clean, minimal API without extra endpoints.




5. Fixing Issues With destroy() Instead of delete()
📌 Problem: Delete Button Appearing on the Wrong View 
✔ Cause: When converting ProductDetail to ProductViewSet, the delete() method was not replaced with destroy().

📌 Fix: Override destroy() Instead of delete()
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def destroy(self, request, *args, **kwargs):  # ✅ Correct method for ViewSets
        if OrderItem.objects.filter(product_id=pk).count() > 0:
            return Response({'error': 'Product cannot be deleted'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        return super().destroy(request, *args, **kwargs)
		
🚀 Effect: 
✔ Ensures delete functionality only appears on individual product pages. 
✔ Prevents unnecessary database queries by using get_object() from DestroyModelMixin.

📜 Code References Used
from rest-framework.routers import SimpleRouter

router = SimpleRouter()
router.register('products', views.ProductViewSet)
router.register('collections', views.CollectionViewSet)

Now the urls will be available at --> router.urls


when you print router.urls: 
[<URLPattern '^products/$' [name='product-list']>,
 <URLPattern '^products/(?P<pk[^/.]+)/$' [name='product-detail']>,
 <URLPattern '^collections/$' [name='collection-list']>,
 <URLPattern '^collections/(?P<pk[^/.]+)/$' [name='collection-detail']>]


so, 
#URLCONF
urlpatterns = router.urls

if you have other urls

urlpatterns = [
 path('', include(router.urls)),
]


from rest-framework.routers import DefaultRouter


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
	
    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):  
        if OrderItem.objects.filter(product_id=pk).count() > 0:
            return Response({'error': 'Product cannot be deleted'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        return super().destroy(request, *args, **kwargs)




📌 Key Takeaways
✔ Routers simplify URL handling by automatically registering ViewSet endpoints. 
✔ SimpleRouter generates standard API routes for ViewSets. 
✔ DefaultRouter adds API root navigation and JSON formatting. 
✔ Use include(router.urls) if additional custom paths are needed. 
✔ Always override destroy() instead of delete() in ViewSets. 
✔ Routers eliminate the need for manual URL definitions, making API maintenance easier.











Building the Reviews API:
-------------------------
We are introducing reviews in our API, allowing products to have associated customer feedback. ✔ Each product can have multiple reviews. ✔ We need to implement nested resources for managing product reviews.

🚀 Steps to Build the Reviews API
1. Define the Model
✔ Create a model class to represent reviews. 
✔ Generate a migration for database schema changes. 
✔ Apply the migration to update the database.

📌 Implementation (models.py)
from django.db import models

class Review(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='reviews')  # ✅ Link to Product
    name = models.CharField(max_length=255)  # ✅ Name of the reviewer
    description = models.TextField()  # ✅ Review content (unlimited length)
    date = models.DateField(auto_now_add=True)  # ✅ Timestamp when review was created
	
🚀 Key Features: 
✔ Foreign Key (product) → Links reviews to products. 
✔ Cascade delete (on_delete=models.CASCADE) → If a product is deleted, its reviews are also removed. 
✔ Related Name (reviews) → Allows access via product.reviews. 
✔ Auto timestamp (auto_now_add=True) → Automatically sets review date on creation.




2. Generate & Apply Migrations
✔ Step 1: Create a migration file for the model changes.
python manage.py makemigrations

✔ Step 2: Apply the migration to update the database schema.
python manage.py migrate

🚀 Best Practice:
✔ Always run migrations after modifying models to prevent accumulating untracked changes.




3. Create the Serializer
✔ Transform Review objects into JSON format for API responses. 
✔ Define fields that should be exposed to clients.

📌 Implementation (serializers.py)

from rest_framework import serializers
from .models import Review

class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description', 'product']  # ✅ Fields exposed in API response

🚀 Key Features: 
✔ Uses ModelSerializer for automatic field mapping. 
✔ Includes ID, date, name, description, and product attributes.




4. Create the ViewSet
✔ Use ModelViewSet → Combines listing, creating, updating, and deleting reviews into a single class.

📌 Implementation (views.py)
from rest_framework.viewsets import ModelViewSet
from .models import Review
from .serializers import ReviewSerializer

class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()  # ✅ Retrieve all reviews
    serializer_class = ReviewSerializer  # ✅ Serialize review objects
	
🚀 Why use ModelViewSet? 
✔ Eliminates redundant code → Handles CRUD operations in one class. 
✔ Provides flexibility → Can override methods if custom logic is needed.




5. Register the Route
✔ Use nested routers → Reviews belong to specific products, requiring URLs like /products/{id}/reviews/.

📌 Basic Router Registration (urls.py)
from rest_framework.routers import SimpleRouter
from .views import ReviewViewSet

router = SimpleRouter()
router.register('reviews', ReviewViewSet)  # ✅ Register review endpoints

urlpatterns = router.urls  # ✅ Auto-generates URL patterns for reviews

🚀 Next Step: ✔ Implement nested routers to integrate reviews within product endpoints (covered in the next lesson).

📜 Code References Used

Building the Model:
create a model model class
create a migration
apply a migration

models.py:
class Review(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='reviews')
    name = models.CharField(max_length=255)
    description = models.TextField()
    date = models.DateField(auto_now_add=True)


Building the API:
create a serializer
create a view
register a route

serializers.py:
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']


📌 Key Takeaways
✔ Reviews are nested resources inside products. 
✔ Foreign key with on_delete=models.CASCADE ensures dependent deletion. 
✔ Serializers convert model instances into JSON for API responses. 
✔ ViewSets simplify API logic by combining multiple operations in one class. 
✔ Using routers eliminates manual route definitions. 
✔ Next step: Implementing nested routers for /products/{id}/reviews/.










Nested Routers:
---------------
When working with nested resources (e.g., reviews belonging to products), we use nested routers to maintain structured, hierarchical API endpoints.

🚀 Why Use Nested Routers?
✔ Organized API Structure → Keeps child resources under their parent. 
✔ Automatic Route Management → Generates routes dynamically using routers. 
✔ Efficient Lookups → Fetch child resources based on parent relationships (/products/{id}/reviews). 
✔ Reduces Manual URL Configuration → No need to manually define nested paths.

1. Desired URL Structure
📌 Example: Domains & NameServers in a Nested Router (GitHub Reference)

/domains/                  <- Domains list
/domains/{pk}/             <- Retrieve specific domain
/domains/{domain_pk}/nameservers/  <- List name servers for a specific domain
/domains/{domain_pk}/nameservers/{pk}  <- Retrieve a specific name server for a domain

🚀 We apply this logic for Products and Reviews: 
✔ /products/ → Lists all products. 
✔ /products/{pk}/ → Retrieves a specific product. 
✔ /products/{product_pk}/reviews/ → Lists reviews only for a specific product. 
✔ /products/{product_pk}/reviews/{pk}/ → Retrieves a specific review of a product.




2. Installing & Importing drf-nested-routers
📌 Install Nested Routers
pipenv install drf-nested-routers

📌 Import Required Classes (urls.py)
from rest_framework_nested import routers




3. Configuring Nested Routers for Products & Reviews
📌 Step 1: Create the Parent Router
router = routers.SimpleRouter()
router.register(r'products', ProductViewSet)  # ✅ Registers product endpoints

📌 Step 2: Create the Nested Router
products_router = routers.NestedSimpleRouter(router, r'products', lookup='product')
products_router.register(r'reviews', ReviewViewSet, basename='product-reviews')  # ✅ Registers review endpoints inside products

🚀 How It Works: 
✔ Parent Prefix (products) → Defines products/ as the base. 
✔ Lookup Parameter (product) → Creates {product_pk} in nested routes. 
✔ Child Prefix (reviews) → Maps /products/{product_pk}/reviews/ to ReviewViewSet. 
✔ Basename (product-reviews) → Generates URL patterns like product-reviews-list & product-reviews-detail.

📌 Step 3: Include Routers in URL Patterns
urlpatterns = [
    path('', include(router.urls)),          # ✅ Registers top-level product routes
    path('', include(products_router.urls)), # ✅ Registers nested review routes inside products
]

or 

urlpatterns = router.urls + products_router.urls

🚀 Result: 
✔ /products/ → Lists all products. 
✔ /products/{product_pk}/reviews/ → Lists reviews for a specific product. 
✔ /products/{product_pk}/reviews/{pk}/ → Retrieves, updates, or deletes a review inside a product.




4. Fixing Review Creation Without product_id in Request
🚀 Problem: 
✔ When posting a review, we shouldn't pass product_id in the request body. 
✔ Instead, we should extract it from the URL.

📌 Step 1: Modify ReviewSerializer to Remove product_id
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']
		
🚀 Effect: 
✔ API no longer requires product_id in the request body. 
✔ Now, we must fetch product_id from the URL within ReviewViewSet.

📌 Step 2: Pass product_id in Serializer Context (views.py)
class ReviewViewSet(ModelViewSet):
    serializer_class = ReviewSerializer

    def get_queryset(self):
        return Review.objects.filter(product_id=self.kwargs['product_pk'])  # ✅ Filters reviews based on product_pk

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}  # ✅ Pass product ID from URL to serializer
		
🚀 Effect: 
✔ product_pk is extracted from the nested URL and passed to the serializer. 
✔ Ensures only reviews for a specific product are displayed.

📌 Step 3: Override create() Method in ReviewSerializer
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']

    def create(self, validated_data):
        product_id = self.context['product_id']  # ✅ Retrieve product ID from context
        return Review.objects.create(product_id=product_id, **validated_data)  # ✅ Create review with extracted product ID
		
🚀 Effect: 
✔ product_id is automatically assigned when creating a review. 
✔ Removes the need for manually specifying product_id in request payload.





5. Fixing Review Visibility Issue
🚀 Problem: 
✔ All reviews were shown, regardless of product ID in the URL. 
✔ Reviews must be filtered based on the specific product in the request.

📌 Fix: Override get_queryset() in ReviewViewSet
class ReviewViewSet(ModelViewSet):
    serializer_class = ReviewSerializer

    def get_queryset(self):
        return Review.objects.filter(product_id=self.kwargs['product_pk'])  # ✅ Ensures only reviews of the requested product are shown
		
🚀 Effect: 
✔ /products/2/reviews/ only displays reviews for product 2. 
✔ Prevents showing reviews from other products incorrectly.




📜 Code References Used
nested routers --> https://github.com/alanjds/drf-nested-routers

The desired URL signatures are:
/domains/ <- Domains list
/domains/{pk}/ <- One domain, from {pk}
/domains/{domain_pk}/nameservers/ <- Nameservers of domain from {domain_pk}
/domains/{domain_pk}/nameservers/{pk} <- Specific nameserver from {pk}, of domain from {domain_pk}

How to do it (example):
# urls.py
from rest_framework_nested import routers
from views import DomainViewSet, NameserverViewSet
(...)

router = routers.SimpleRouter()
router.register(r'domains', DomainViewSet)

domains_router = routers.NestedSimpleRouter(router, r'domains', lookup='domain')
domains_router.register(r'nameservers', NameserverViewSet, basename='domain-nameservers')
# 'basename' is optional. Needed only if the same viewset is registered more than once
# Official DRF docs on this option: http://www.django-rest-framework.org/api-guide/routers/

urlpatterns = [
    path(r'', include(router.urls)),
    path(r'', include(domains_router.urls)),
]



pipenv install drf-nested-routers

from rest_framework_nested import routers




Note: In the view class, we have access to URL parameters, eg. we can read the product_id from the URL and using a context object, we can pass it to the serializer. So, Remember that we use a context object to provide additional data  to the serializer. 
So, if you want pass anything from the request(from the user) in viewset to the serializer, we use context 

class ReviewViewSet(ModelViewSet):
	serializer_class = ReviewSerializer
	
	def get_queryset(self):
		return Review.objects.filter(product_id=self.kwargs['product_pk'])
	
	def get_serializer_context(self):
		return{'product_id': self.kwargs['product_pk']}

class ReviewSerializer(serializer.ModelSerializer):
	class Meta:
		model = Review
		fields = ['id', 
		
	def create(self, validated_data):
	    product_id = self.context['product_id']
		return Review.objects.create(product_id=product_id, **validated_data) 





📌 Key Takeaways
✔ Nested routers organize API endpoints hierarchically (/products/{id}/reviews/). 
✔ drf-nested-routers automates nested route management. 
✔ Parent-child relationships are reflected in generated URL patterns. 
✔ Extract product_id from URL instead of requiring it in request payload. 
✔ Modify get_queryset() to ensure reviews are filtered by the parent product. 










Quick QnA session:
------------------
Here's a quick note to clarify where resource creation, updating, and deletion happens in Django REST Framework (DRF):

📌 What happens in the Serializer?
The create() method inside ReviewSerializer handles object creation based on validated data.
This method does not handle updates or deletions—it only creates a new review instance.
The validated_data dictionary contains fields passed in the request.
The product_id is extracted from self.context, ensuring the review is associated with the correct product.




🚀 Where are updates and deletions handled? 
✔ Updates (PUT, PATCH) → Handled in the ViewSet, specifically via update() (from UpdateModelMixin). 
✔ Deletions (DELETE) → Managed in the ViewSet, via destroy() (from DestroyModelMixin). 
✔ The ViewSet interacts with the queryset, retrieving objects and performing updates/deletes.

📌 Summary: 
✔ Creation happens inside the create() method in the serializer. 
✔ Updates & deletions are performed inside the ViewSet (not the serializer).
✔ Serializers primarily validate and format data for API requests and responses.



Is this common in django, don't we have viewset for create, update and delete. Or creation happens in serializers and rest of the operations like update, delete, get happens in the viewset. clarify me

Great question! Here's a clear breakdown of how create, update, and delete operations work in Django REST Framework (DRF):

🚀 Where Do CRUD Operations Happen in Django REST Framework?
✔ Creation (POST) → Usually handled inside the serializer (create() method). 
✔ Update (PUT, PATCH) → Handled inside the ViewSet, using built-in mixins. 
✔ Delete (DELETE) → Managed inside the ViewSet, using destroy(). 
✔ Retrieve (GET) → Handled inside the ViewSet, using retrieve() or list().


1. Why Does Creation Happen in the Serializer?
📌 When a POST request is sent, DRF calls the create() method of the serializer. 
✔ Serializers validate data before saving it. 
✔ They define how a model instance is created with validated_data. 
✔ If extra logic is needed (like assigning a foreign key from context), we override create().

📌 Example: create() inside a serializer
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'date', 'name', 'description']

    def create(self, validated_data):
        product_id = self.context['product_id']  # ✅ Extract from context
        return Review.objects.create(product_id=product_id, **validated_data)  # ✅ Create the review instance
		
🚀 Effect: 
✔ create() automatically saves a new instance using validated data. 
✔ Used when creating new records instead of handling it inside ViewSet.


2. Where Do Update and Delete Happen?
Unlike create(), updates and deletions are handled inside the ViewSet because: 
✔ Updating requires fetching an existing record first. 
✔ Deletion should ensure conditions before removing an object.

📌 Example: Overriding destroy() inside ViewSet
class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def destroy(self, request, pk):  # ✅ Override delete logic
        review = get_object_or_404(Review, pk=pk)
        review.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
🚀 Effect: 
✔ destroy() first fetches the object, applies any business rules, then deletes it. 
✔ Update (PUT, PATCH) works similarly but modifies the existing object instead.

📌 Example: Overriding update() inside ViewSet
class ReviewViewSet(ModelViewSet):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def update(self, request, pk):  # ✅ Handles update logic
        review = get_object_or_404(Review, pk=pk)
        serializer = ReviewSerializer(review, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()  # ✅ Update the review instance
        return Response(serializer.data)
		
🚀 Effect: 
✔ Ensures the existing review is fetched, validated, and updated correctly. 
✔ Calls serializer.save() to commit changes to the database.



3. Summary: Where CRUD Operations Happen?
✔ Create (POST) → Inside the serializer (create()). 
✔ Update (PUT, PATCH) → Inside the ViewSet (update()). 
✔ Delete (DELETE) → Inside the ViewSet (destroy()). 
✔ Retrieve (GET) → Inside the ViewSet (retrieve() or list()).


🚀 Why this structure?
✔ Serializers focus on data validation & transformation. 
✔ ViewSets focus on managing requests and database operations.












Filtering:
----------
Currently, the /products/ endpoint returns all products in the database. However, we need filtering functionality, such as filtering products by collection using query parameters (collection_id).

Example: 📌 /store/products?collection_id=1 → Returns products only in collection 1.

🚀 Steps to Implement Filtering in ViewSet
1. Override get_queryset() Instead of Using queryset
Since filtering depends on user input (collection_id), we cannot set a static queryset. Instead, we override get_queryset() to dynamically filter products.

📌 Implementation (views.py)
class ProductViewSet(ModelViewSet):
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        queryset = Product.objects.all()  # ✅ Start with all products
        collection_id = self.request.query_params.get('collection_id')  # ✅ Retrieve query parameter
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)  # ✅ Apply filter dynamically
        return queryset  # ✅ Return filtered queryset
		
🚀 Effect: 
✔ Retrieves collection_id from the query parameters. 
✔ Filters products dynamically based on user input (GET request). 
✔ If no filter is applied, returns all products.




2. Explicitly Set basename in Router
🚀 Problem: 
✔ Django REST Framework automatically determines the basename from the queryset attribute. 
✔ Since we overrode get_queryset(), DRF cannot infer the base name automatically. 
✔ This leads to an error during API loading.

📌 Solution: Define basename explicitly in urls.py
router.register('products', views.ProductViewSet, basename='products')  # ✅ Explicitly set base name

🚀 Effect: 
✔ Fixes API error where DRF cannot determine basename automatically. 
✔ Generates proper URL names (e.g., products-list, products-detail).




3. Handling Query Parameter Errors
🚀 Problem: 
✔ If collection_id is not present in query parameters, the API throws a multi-value dictionary key error. 
✔ This happens when trying to access a non-existent key using bracket notation (self.request.query_params['collection_id']).

📌 Solution: Use .get() Instead of []
collection_id = self.request.query_params.get('collection_id')  # ✅ Returns None if key doesn’t exist
🚀 Effect: 
✔ .get('collection_id') → Returns None if the key doesn’t exist, avoiding dictionary key errors. 
✔ Prevents unnecessary crashes when no filtering is applied.




4. Testing the Implementation
✔ Visit /store/products/ → Returns all products. 
✔ Visit /store/products?collection_id=1 → Returns filtered products only in collection 1. 
✔ Remove collection_id → API defaults back to returning all products.




📜 Code References Used
127.0.0.1:8000/store/products?collection_id=1

in the ProductViewSet:
overriding the get_queryset function:
def get_queryset(self):
	queryset= Product.objects.all()
	collection_id = self.request.query_params.get('collection_id')
	if collection_id is not None:
		queryset = queryset.filter(collection_id=collection_id)
	
	return queryset  


also remember to add basename to the respective router since we overridden the get_queryset, django will unable to set the basename

in urls.py --> router.register('products', views.ProductViewSet, basename='products')




📌 Key Takeaways
✔ Filter products dynamically using query parameters (collection_id). 
✔ Override get_queryset() to apply filters based on user requests. 
✔ Use .get() instead of brackets ([]) to avoid missing key errors. 
✔ Explicitly set basename in urls.py to prevent DRF errors. 
✔ Next steps: Implement more advanced filtering techniques using Django Filters!





Explanation of 2nd point (setting the basename, since queryset is overrode by get_queryset()):
---------------------------------------------------------------------------------------------
🚀 What is basename in Django REST Framework?
✔ basename is used internally by DRF to generate the names of URL patterns. 
✔ These names are essential when referring to named routes in Django. 
✔ Typically, DRF automatically determines the basename from the queryset inside a ViewSet.


Example URL names DRF generates: 
📌 products-list → Handles /products/ (GET request for listing products). 
📌 products-detail → Handles /products/{pk}/ (GET request for a single product).


🚀 Why Does basename Become a Problem?
When you register a ViewSet using a router, DRF automatically assigns a basename. 
✔ Normally, it uses the model name from the queryset to generate URLs (products-list, products-detail). 
✔ BUT when we override get_queryset(), DRF can no longer infer the base name automatically.


🚀 Effect: 
✔ DRF throws an error during API loading because it doesn't know the basename. 
✔ Your API fails to work properly without explicitly defining it.


🚀 Solution: Explicitly Define basename in Router
✔ Since DRF cannot determine it on its own, we must manually set it when registering the ViewSet.


📌 Fix this by explicitly defining basename in urls.py:
router.register('products', views.ProductViewSet, basename='products')
🚀 Effect: 
✔ Prevents errors when DRF cannot infer basename. 
✔ Generates correct URL patterns (products-list, products-detail). ✔ Your API works smoothly without confusion.


🚀 Summary (Why basename Matters)
✔ When you override get_queryset(), DRF loses automatic basename detection. 
✔ Explicitly setting basename fixes errors and allows DRF to generate correct URL names. 
✔ This ensures proper route handling (products-list, products-detail).




How it detects the basename from the queryset initially.

Great question! Django REST Framework (DRF) detects the basename automatically using the queryset attribute in a ViewSet. Let me explain step by step.

🚀 How DRF Determines basename Automatically
✔ When you register a ViewSet using router.register(), DRF tries to infer the basename from the ViewSet's queryset. 
✔ The default detection method follows this logic:

📌 Step 1: Check if queryset exists in the ViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ✅ Defined queryset
    serializer_class = ProductSerializer
	
✔ Since queryset is defined, DRF extracts the model name (Product) automatically. 
✔ The model name is converted to lowercase and pluralized, resulting in: ✅ basename = "product" (or "products", depending on the router).


📌 Step 2: Generates URL names using basename 
✔ DRF then appends standard suffixes (-list, -detail) to create URL pattern names: 
✅ products-list → Handles /products/ (GET request for listing). 
✅ products-detail → Handles /products/{pk}/ (GET request for retrieving a single object).


🚀 What Happens If queryset Is Missing?
✔ If you override get_queryset() instead of defining queryset as an attribute, DRF cannot infer the model name anymore.

📌 Example of Overriding get_queryset()
class ProductViewSet(ModelViewSet):
    serializer_class = ProductSerializer
    
    def get_queryset(self):
        queryset = Product.objects.all()
        collection_id = self.request.query_params.get('collection_id')
        if collection_id is not None:
            queryset = queryset.filter(collection_id=collection_id)
        return queryset
		
		
🚀 Problem: 
✔ DRF no longer has a direct queryset attribute to extract the model name. 
✔ As a result, basename detection fails, leading to an error.


📌 Solution: Explicitly Set basename
router.register('products', views.ProductViewSet, basename='products')
🚀 Effect: 
✔ Manually assigns the correct basename, ensuring DRF generates proper URL names (products-list, products-detail). 
✔ Prevents API errors caused by missing automatic detection.


🚀 Summary (How DRF Detects basename)
✔ If queryset is defined, DRF automatically extracts the model name (Product → "products"). 
✔ If queryset is missing or overridden, DRF cannot infer the basename—so we must set it manually. 
✔ Basename helps DRF generate named routes (products-list, products-detail) for linking views.












Generic Filtering:
------------------
Filtering helps refine API responses based on specific criteria. While basic filtering works for a single field, generic filtering allows filtering across multiple fields effortlessly using Django Filter, eliminating manually coded filters.

🚀 Why Use Django Filter?
✔ Simplifies filtering logic → No need for manual query manipulation. 
✔ Supports multiple fields → Filter data by any attributes dynamically. 
✔ Allows range filtering → Query data greater or less than a value (e.g., unit price filtering). 
✔ Enhances API usability → Browsable API UI shows interactive filtering options.



1. Installing and Configuring Django Filter
📌 Step 1: Install Django Filter Library
pipenv install django-filter

📌 Step 2: Add Django Filter to Installed Apps (settings.py)
INSTALLED_APPS = [
    ...
    'django_filters',  # ✅ Important: Use `django_filters`, not `django-filter`
]

📌 Step 3: Import DjangoFilterBackend in ViewSet (views.py)
from django_filters.rest_framework import DjangoFilterBackend




2. Implementing Basic Filtering in ViewSet
Instead of manually filtering within get_queryset(), we assign filter backends to DjangoFilterBackend.

📌 Basic Filtering (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ✅ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]  # ✅ Enable Django Filter
    filterset_fields = ['collection_id']  # ✅ Allow filtering by `collection_id`
	
🚀 Effect: 
✔ Enables filtering by collection_id using query parameters. 
✔ /store/products?collection_id=1 → Returns products only in collection 1.

📌 Browsable API Enhancement: 
✔ Adds "Filters" UI Button, allowing users to select filtering criteria interactively.




3. Implementing Advanced Filtering Using a Custom FilterSet
🚀 Problem: 
✔ Basic filtering only supports exact matches (collection_id=1). 
✔ Need range-based filtering for numeric fields (e.g., unit price).

📌 Solution: Create a Custom FilterSet (filters.py)
from django_filters.rest_framework import FilterSet
from .models import Product

class ProductFilter(FilterSet):
    class Meta:
        model = Product
        fields = {
            'collection_id': ['exact'],  # ✅ Filter by exact collection ID
            'unit_price': ['gt', 'lt']   # ✅ Allow filtering by unit price range
        }
		
🚀 Effect: 
✔ Users can filter products greater or less than a specific price. 
✔ /store/products?unit_price__gt=10 → Returns products greater than $10. 
✔ /store/products?unit_price__lt=20 → Returns products less than $20.

📌 Step 2: Integrate ProductFilter in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter  # ✅ Apply the custom filter class

🚀 Effect: 
✔ Encapsulates filtering logic inside ProductFilter. 
✔ Supports range queries (unit_price__gt, unit_price__lt).




4. Testing Advanced Filtering in Browser API
📌 Apply Filters for Collection and Price Range 
✔ All products: /store/products/ 
✔ Filter by collection ID: /store/products?collection_id=1 
✔ Filter by unit price greater than $10: /store/products?unit_price__gt=10 
✔ Filter by unit price less than $20: /store/products?unit_price__lt=20 
✔ Filter products between $10 - $20: /store/products?unit_price__gt=10&unit_price__lt=20

📌 Browsable API Enhancements 
✔ Interactive "Filters" button allows users to select conditions. 
✔ Query parameters automatically update based on UI selections.




📜 Code References Used
pipenv install django-filter

add it in the list of installed apps, remember while adding, it is 'django_filters'

from django_filters.rest_framework import DjangoFilterBackend


in ProductViewSet -->

filter_backends = [DjangoFilterBackend]
filterset_fields = ['collection_id']

and bring back the queryset to 
queryset = Product.objects.all()

read doc django-filters -->  https://django-filter.readthedocs.io/en/stable/


filters.py:
from django_filters.rest_framework import FilterSet
from .models import Product

class ProductFilter(FilterSet):
  class Meta:
    model = Product
    fields = {
      'collection_id': ['exact'],
      'unit_price': ['gt', 'lt']
    }


views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ProductFilter

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)





📌 Key Takeaways
✔ Django Filter automates filtering logic, eliminating manual query manipulations. 
✔ Use DjangoFilterBackend to enable generic filtering in ViewSets. 
✔ Encapsulate filtering logic inside a FilterSet for advanced queries. 
✔ Filtering by numeric ranges (gt, lt) allows more flexibility. 
✔ Browsable API provides an interactive UI for filtering queries. 
✔ Next steps: Implementing search functionality!















Searching:
----------
Searching allows users to find products by title or description dynamically. Unlike filtering, which works with specific field values, searching is designed for text-based queries.

🚀 Why Use Searching?
✔ Find products easily → Users can search by keywords instead of exact field values. 
✔ Supports multiple fields → Search across title, description, and related fields. 
✔ Case-insensitive → Queries match text regardless of letter casing. 
✔ Browsable API Enhancement → Adds a search bar for interactive search functionality.


1. Adding Search Functionality in ViewSet
📌 Step 1: Import SearchFilter in Views (views.py)
from rest_framework.filters import SearchFilter

📌 Step 2: Enable Search Filtering in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ✅ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter]  # ✅ Add SearchFilter to filter backends
    search_fields = ['title', 'description']  # ✅ Allow searching in `title` & `description`
	
🚀 Effect: 
✔ Enables search queries via query parameters. 
✔ /store/products/?search=coffee → Returns products containing "coffee" in title or description.

📌 Browsable API Enhancement: ✔ Adds interactive search box in the browsable API UI. ✔ Users can type a keyword, and results automatically filter without needing exact matches.




2. Searching Across Related Fields
🚀 Problem: 
✔ Searching works only on direct fields (title, description). 
✔ What if we need to search within related fields, like collection__title?

📌 Solution: Reference Related Fields in search_fields
search_fields = ['title', 'description', 'collection__title']  # ✅ Enables searching within related model fields

🚀 Effect: 
✔ Users can now search products by their collection name (collection__title). 
✔ /store/products/?search=Summer Collection → Returns all products belonging to "Summer Collection".




3. Multi-Keyword Search
✔ Users can search using multiple keywords separated by spaces or commas.

📌 Example Queries: 
✔ /store/products/?search=coffee → Finds all products containing "coffee". 
✔ /store/products/?search=coffee 10 ounce → Finds products containing both "coffee" and "10 ounce". 
✔ /store/products/?search=coffee, 10 ounce → Works similarly, separating words with a comma.

🚀 Effect: ✔ Flexible search options make it easier for users to refine results.




4. Testing the Implementation in Browser API
📌 Step 1: Visit /store/products/ 
	✔ Displays all products initially.
📌 Step 2: Try Searching 
	✔ Enter "coffee" → Returns products where "coffee" appears in title or description. 
	✔ Enter "10 ounce" → Filters products matching "10 ounce". 
	✔ Enter "coffee 10 ounce" → Returns products containing both words.
📌 Step 3: Search Across Related Fields 
	✔ Enter "Summer Collection" → Finds products linked to that collection title.
📌 Step 4: Ensure Case-Insensitive Matching 
	✔ Try searching "COFFEE" → Results should match even though uppercase is used.




5. Extending Search With Sorting & Pagination
🚀 Enhancement: ✔ Combine searching, sorting, and pagination for better user experience.

📌 Final ProductViewSet Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']
	
🚀 Effect: ✔ Users can search, sort, and paginate results dynamically.




Codes referenced in this lesson:
from rest_framework.filters import SearchFilter

in ProductViewSet -->

filter_backends = [DjangoFilterBackend, SearchFilter]
search_fields = ['title', 'description'] also we can reference fields in related classes 'collection__title'


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)




📌 Key Takeaways
✔ Searching allows text-based queries on title & description. 
✔ Supports searching within related fields (collection__title). 
✔ Case-insensitive matching ensures better search usability. 
✔ Multi-keyword search enables refined filtering. 
✔ Browsable API provides interactive search functionality. 
✔ Combining search with ordering & pagination improves user experience. 
✔ Next steps: Implementing sorting functionality!










Sorting:
--------
Sorting allows users to organize API results dynamically based on specific fields, such as unit price or last update.

🚀 Why Use Sorting?
✔ Improves data readability → Users can easily rank products by price or recent updates. 
✔ Supports ascending & descending order → Prefix fields with - for descending sort. 
✔ Allows multi-field sorting → Sort by multiple attributes simultaneously. 
✔ Browsable API Enhancement → Adds interactive sorting options to the UI.


1. Adding Sorting Functionality in ViewSet
📌 Step 1: Import OrderingFilter in Views (views.py)
from rest_framework.filters import OrderingFilter

📌 Step 2: Enable Ordering Filter in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ✅ Retrieve all products
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]  # ✅ Add OrderingFilter
    ordering_fields = ['unit_price', 'last_update']  # ✅ Enable sorting by unit price & last update
	
🚀 Effect: 
✔ Sorting can now be performed dynamically via query parameters. 
✔ /store/products/?ordering=unit_price → Returns products sorted by unit price (ascending). 
✔ /store/products/?ordering=-unit_price → Returns products sorted by unit price (descending).

📌 Browsable API Enhancement: 
✔ Adds an interactive sorting option to the browsable API UI. 
✔ Users can select sorting criteria easily without needing query parameters.




2. Sorting by Multiple Fields
🚀 Problem: 
✔ Single-field sorting works, but what if we want to sort by multiple attributes? 
✔ Example: Sort by unit price in descending order, then by last update in ascending order.

📌 Solution: Pass Multiple Fields in ordering Parameter(in the url)
/store/products/?ordering=-unit_price,last_update

🚀 Effect: ✔ First, sorts products by unit price in descending order. ✔ Then, sorts products by last update in ascending order.




3. Testing Sorting in Browser API
📌 Step 1: Visit /store/products/ ✔ Displays all products initially.

📌 Step 2: Sort Using Query Parameters 
✔ /store/products/?ordering=unit_price → Products sorted from cheapest to most expensive. 
✔ /store/products/?ordering=-unit_price → Products sorted from most expensive to cheapest.

📌 Step 3: 
Multi-field Sorting ✔ /store/products/?ordering=-unit_price,last_update → Sorts by unit price in descending order, then last update in ascending order.




4. Extending Sorting With Searching & Pagination
🚀 Enhancement: ✔ Combine sorting, searching, and pagination for improved API usability.

📌 Final ProductViewSet Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']
    pagination_class = DefaultPagination
	
🚀 Effect: ✔ Users can search, sort, and paginate results dynamically.




Codes learned in this lesson:
from rest_framework.filters import SearchFilter, OrderingFilter

filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
ordering_fields = ['unit_price', 'last_update']

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

Multiple field sorting:
127.0.0.1:8000/store/products/?ordering=-unit_price,last_update







📌 Key Takeaways
✔ Sorting allows dynamic organization of API results. 
✔ Prefix fields with '-' for descending order (ordering=-unit_price). 
✔ Supports multi-field sorting (ordering=-unit_price,last_update). 
✔ Browsable API provides interactive sorting functionality. 
✔ Combining search, sorting & pagination enhances user experience. 
✔ Next steps: Implementing pagination functionality!















Pagination:
-----------
Pagination allows users to retrieve API results in smaller, manageable chunks instead of loading all data at once.

🚀 Why Use Pagination?
✔ Improves API performance → Loads a limited number of records per request. 
✔ Enhances user experience → Users navigate pages instead of handling large data sets. 
✔ Supports multiple pagination styles → Page-based (page=1,2) or offset-based (limit=10, offset=10). 
✔ Browsable API Enhancement → Displays pagination controls for easier navigation.

1. Adding Pagination Using Page Numbers
📌 Step 1: Import PageNumberPagination in Views (views.py)
from rest_framework.pagination import PageNumberPagination

📌 Step 2: Assign Pagination Class in ViewSet (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()  # ✅ Retrieve all products
    serializer_class = ProductSerializer
    pagination_class = PageNumberPagination  # ✅ Enable page-based pagination
	
🚀 Effect: 
✔ Products will be paginated, displaying a limited number per request. 
✔ API results now return page links (next, previous). 
✔ Users navigate pages using query parameters (page=1, page=2).




2. Configuring Page Size in Settings
📌 Step 1: Set Global Pagination Settings (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10  # ✅ Limits results per page to 10
}

🚀 Effect: 
✔ Ensures pagination is applied to all API endpoints. 
✔ Automatically sets default page size to 10 records per page.

📌 Browsable API Enhancement: ✔ API results now return metadata:
json
{
    "count": 50,
    "next": "/store/products/?page=2",
    "previous": null,
    "results": [ ... list of products ... ]
}
✔ count → Total products. 
✔ next → Link to next page. 
✔ previous → Link to previous page. 
✔ results → Products for the current page.




3. Using Limit-Offset Pagination
🚀 Alternative Pagination Style: ✔ Instead of page numbers, use limit-offset pagination (limit=10, offset=10).

📌 Step 1: Change Pagination Type in Settings (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 10
}

🚀 Effect: 
✔ API now supports limit-based navigation: ✔ /store/products/?limit=10&offset=10 → Returns next 10 records after skipping 10.

📌 Browsable API Adjustment: 
✔ Query parameters change from page=1 to limit=10, offset=10. 
✔ Provides better flexibility for paginating large datasets.




4. Setting Pagination Per View Instead of Globally
🚀 Problem: 
✔ Global pagination affects all API endpoints. 
✔ Need pagination only for specific views (ProductViewSet).

📌 Solution: Define Pagination Only in ProductViewSet
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    pagination_class = PageNumberPagination  # ✅ Pagination applied only to this view
	
🚀 Effect: 
✔ Pagination applies only to the product endpoint (/store/products). 
✔ Other endpoints (e.g., /store/collections) remain unpaginated.




5. Fixing Pagination Warning When Removing Global Settings
🚀 Problem: 
✔ Removing 'PAGE_SIZE' from settings.py causes a warning: ❌ "You have specified a default PAGE_SIZE setting without also specifying a DEFAULT_PAGINATION_CLASS"

📌 Solution: Use a Custom Pagination Class
📌 Step 1: Create a Custom Pagination Class (pagination.py)
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
    page_size = 10  # ✅ Define page size inside the class

	
📌 Step 2: Use Custom Pagination in ViewSet (views.py)
from store.pagination import DefaultPagination

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    pagination_class = DefaultPagination  # ✅ Use custom pagination class
	
🚀 Effect: 
✔ Fixes pagination warning by defining page size inside a custom class. 
✔ Prevents unnecessary global pagination settings in settings.py.




6. Testing Pagination in Browser API
📌 Step 1: Visit /store/products/ ✔ Displays first page of products.
📌 Step 2: Navigate to Next Page ✔ Click "Next" → Loads page 2 (/store/products/?page=2).
📌 Step 3: Test Offset-Based Pagination ✔ /store/products/?limit=10&offset=10 → Loads next 10 records.
📌 Step 4: Check API Response Structure ✔ Includes pagination metadata (count, next, previous, results).





Codes learned in this lesson:
from rest_framework.pagination import PageNumberPagination

in the ProductViewSet class:
pagination_class = PageNumberPagination


To specify the pagesize:
in the settings.py -->
REST_FRAMEWORK = {
     'COERCE_DECIMAL_TO_STRING' : False
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.pagination.PageNumberPagination',  #pagination applied to all endpoints
	 'DEFAULT_PAGINATION_CLASS' : 'rest_framework.LimitOffsetPagination',  #if you want limit and offset type pagination instead of page number
	 'PAGE_SIZE': 10
}	 

Now with this, we don't need to specify the pagination class per view or per view set. So, back to our views module, we can delete the line 'pagination_class = PageNumberPagination'


to surpass the error: 'you have specified a default PAGE_SIZE pagination rest_framework setting, without specifying also a DEFAULT_PAGINATION_CLASS':


setting the custom pagination class: 
pagination.py:
from rest_framework.pagination import PageNumberPagination

class DefaultPagination(PageNumberPagination):
	page_size = 10
	
	
and now you can remove the PAGE_SIZE in the settings.py
and in the ProductViewSet --> pagination_class = DefaultPagination


views.py/ProductViewSet:
from store.pagination import DefaultPagination

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)






📌 Key Takeaways
✔ Pagination ensures API results load in smaller, manageable chunks. 
✔ Page-based (page=1,2) and limit-offset (limit=10, offset=10) pagination styles available. 
✔ Browsable API provides pagination controls for easy navigation. 
✔ Global pagination affects all endpoints; use pagination_class for specific views. 
✔ Custom pagination class prevents unnecessary global settings. ✔ Next steps: Building a Shopping Cart API!











Designing and Implementing a Shopping Cart API:
-----------------------------------------------
In this section, we're going to put everything together and build a shopping cart API from A to Z. This is a fantastic opportunity for you to practice everything you have learned so far. So, let's jump in and get started.



Designing the API:
------------------
🚀 Designing a Shopping Cart API in Django REST Framework**
A shopping cart API allows users to add items, update quantities, remove items, and retrieve cart details without requiring authentication.

🚀 Operations Supported in the API:
✔ Create a cart → Generate a new cart for storing items.  
✔ Add items to a cart → Specify products and quantities.  
✔ Update item quantity → Modify existing cart items.  
✔ Remove items from a cart → Delete items individually.  
✔ Get cart details → Retrieve cart contents and metadata.  
✔ Delete the entire cart → Remove all items from a cart.  



1. Endpoints Required for Shopping Cart API**  

📌 Cart Management Endpoints  :

| Action          | HTTP Method     | Endpoint           | Request Body     | Response |
|-----------------|-----------------|------------------- |------------------|-------------|
| Create Cart     |  POST           |  /carts/           |  {}              |  cart       |
| Get Cart        |  GET            |  /carts/{id}/      |  {}              |  cart       |
| Delete Cart     |  DELETE         |  /carts/{id}/      |  {}              |  {}         |


📌 Cart Item Management Endpoints  

| Action          | HTTP Method     | Endpoint                | Request Body          | Response |
|-----------------|-----------------|-------------------------|-----------------------|----------|
| Add Item        |  POST           | /carts/{id}/items/      |  { product_id, qty }  |  item    |
| Update Item     |  PATCH          | /carts/{id}/items/{id}/ |  { qty }              | { qty }  |
| Delete Item     |  DELETE         | /carts/{id}/items/{id}/ |  {}                   |  {}      |


🚀 How It Works:  
✔ Creating a cart: generates a cart ID stored on the client side.  
✔ Adding items to a cart: requires specifying `product_id` and `quantity`.  
✔ Updating a cart item supports only `PATCH`, since we modify quantity instead of replacing the item.  





2. ViewSet Classes for Implementation:

🚀 CartViewSet: Handles cart-related operations 
✔ /carts/ → Create a cart  
✔ /carts/{id}/ → Retrieve or delete a cart  

🚀 CartItemViewSet: Handles cart item-related operations  
✔ /carts/{id}/items/ → Add an item to a cart  
✔ /carts/{id}/items/{id}/ → Update or delete a cart item  


Class Definitions:
class CartViewSet(ModelViewSet):
    queryset = Cart.objects.all()
    serializer_class = CartSerializer

class CartItemViewSet(ModelViewSet):
    queryset = CartItem.objects.all()
    serializer_class = CartItemSerializer


🚀 Effect:
✔ Encapsulates all shopping cart logic within two ViewSets.  
✔ Creates a structured and reusable API design.  




3. Next Steps: Revisiting Data Models:  
✔ Before implementing these endpoints, we need to refine our cart and cart item models to support the API structure.  
✔ Define relationships between carts, items, and products.  
✔ Ensure each cart has a unique identifier for anonymous tracking.  

🚀 Next Topic: Revisiting the data model to structure cart relationships effectively.  



📌 Key Takeaways
✔ Designed a structured API for shopping cart operations. 
✔ POST, GET, DELETE methods handle cart creation, retrieval, and removal.  
✔ Cart items are managed via `/carts/{id}/items/`.  
✔ PATCH request updates quantity instead of replacing items. 
✔ Two ViewSets (`CartViewSet`, `CartItemViewSet`) simplify API logic.  
✔ Next steps: Refining the cart data model! 













Revisiting the Data Model:
--------------------------
Before implementing the API, we need to refine our data model to ensure security, efficiency, and proper structure.

🚀 Why Modify the Cart Model?
✔ Prevent unauthorized access → Using predictable cart IDs (e.g., /carts/1) allows hackers to guess and manipulate carts. 
✔ Improve security → A GUID (Globally Unique Identifier) makes it extremely hard to guess cart IDs. 
✔ Optimize database relationships → Ensure cart-item uniqueness and improve query efficiency.

1. Changing the Primary Key to a UUID
📌 Problem: 
✔ Django automatically assigns an integer primary key (cart_id = 1, 2, 3...). 
✔ Hackers can easily guess cart IDs and modify carts they don’t own.

📌 Solution: Use a GUID Instead of an Integer ✔ GUIDs are randomly generated 32-character strings, making guessing cart IDs nearly impossible.

📌 Implementation (models.py)
from uuid import uuid4
from django.db import models

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)  # ✅ Assigns a random UUID as the primary key
    created_at = models.DateTimeField(auto_now_add=True)  # ✅ Tracks cart creation time
	
	
🚀 Effect: 
✔ /store/carts/{guid}/ → More secure, preventing easy cart manipulation. 
✔ Each cart gets a random unique identifier, instead of an easily guessable number.

📌 Important: 
✔ Do NOT call uuid4() directly → Doing so will hardcode a GUID in the migration file, making all carts use the same ID. 
✔ Pass uuid4 as a reference → This ensures Django dynamically generates a new GUID for each cart.




2. Checking Migration for UUID Change
📌 Step 1: Create Migration
python manage.py makemigrations

📌 Step 2: Verify Migration File 
✔ Ensure the migration does NOT contain a hardcoded GUID. 
✔ Expected result:
default=uuid4  # ✅ Reference, not a hardcoded GUID

📌 Step 3: Apply Migration
python manage.py migrate

🚀 Effect: 
✔ The cart table now uses UUIDs instead of integers. 
✔ Cart IDs are more secure and harder to guess.




3. Addressing Performance Considerations
📌 Problem: GUIDs require more storage space than integers. 
✔ Integer keys: Use 8 bytes (BIGINT). 
✔ GUIDs: Use 32 bytes, three times larger than an integer.

📌 Assessing the Impact: 
✔ If cart_items table has 1 million records, extra GUID storage is only 22MB. 
✔ Since shopping carts are temporary, data is eventually moved to orders, reducing long-term database size. 
✔ Regular cleanup (e.g., delete carts older than 3 months) prevents excessive growth.

🚀 Conclusion: 
✔ GUIDs offer better security, and storage increase is negligible. 
✔ Using UUIDs for temporary data is reasonable, but orders can still use integer keys for efficiency.




4. Applying Unique Constraints in Cart Items
📌 Problem: 
✔ A customer might add the same product multiple times, creating duplicate cart items. 
✔ Instead of multiple records, quantity should be updated when the same product is added again.

📌 Solution: Enforce a Unique Constraint for cart + product Combination 
✔ Ensures each cart contains a product only once.

📌 Implementation (models.py)
class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')  # ✅ Establish cart-item relationship
    product = models.ForeignKey(Product, on_delete=models.CASCADE)  # ✅ Reference the product
    quantity = models.PositiveSmallIntegerField(validators=[MinValueValidator(1)])  # ✅ Ensure valid quantity

    class Meta:
        unique_together = [['cart', 'product']]  # ✅ Prevent duplicate items in the same cart
		
🚀 Effect: ✔ A single record per product exists for each cart. ✔ Adding the same product updates quantity, instead of creating duplicates.




5. Running Migration for Cart Item Constraints
📌 Step 1: Create Migration for Unique Constraint
python manage.py makemigrations

📌 Step 2: Apply Migration
python manage.py migrate

🚀 Effect: 
✔ cart_items table prevents duplicate products in a cart. 
✔ Customers cannot add the same product multiple times—quantity updates instead.




6. Verifying Database Changes
📌 Check Database Schema for Updates 
✔ cart table now uses a UUID (char(32)) instead of an integer. 
✔ cart_items table has a unique constraint on (cart_id, product_id). 
✔ cart_items are linked to carts via related_name='items' for easier queries.




Codes learned in this lesson:
models.py(initially):
class Cart(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)


class CartItem(models.Model):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField()


127.0.0.1:8000/store/carts/1

models.py:
from uuid import uuid4

class Cart(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid4)
    created_at = models.DateTimeField(auto_now_add=True)

class CartItem(models.Model):
    cart = models.ForeignKey(
        Cart, on_delete=models.CASCADE, related_name='items')
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.PositiveSmallIntegerField(
        validators=[MinValueValidator(1)]
    )

    class Meta:
        unique_together = [['cart', 'product']]





📌 Key Takeaways
✔ Replaced integer cart IDs with UUIDs for enhanced security. 
✔ Ensured cart items store only one instance of each product using a unique constraint. 
✔ Verified storage impact of using UUIDs—minimal increase, negligible concern. 
✔ Regular cleanup of abandoned carts prevents excess database growth. 
✔ Next steps: Implementing API endpoints for shopping cart operations.


Explanation of 'unique_together':
--------------------------------
The unique_together constraint is applied to both cart and product, rather than just product, because the uniqueness of a product should be enforced within the context of a specific cart—not globally across all carts. Let me break it down step by step.

🚀 Why Include cart in unique_together?
✔ If only product were unique, a product could appear only once across all carts, which doesn't make sense. 
✔ A product should be allowed in multiple carts, but within each cart, it should appear only once. 
✔ Using unique_together=['cart', 'product'] ensures that each cart can contain a product only once, preventing duplicates within a specific cart.

🚀 How unique_together Works in Cart Items
📌 Example Scenario Without unique_together ❌ If a customer adds Product A twice to the same cart: ✔ Two separate records would be created:

Cart ID | Product ID | Quantity
--------|-----------|---------
1       | 101       | 2
1       | 101       | 3

🚀 Problem: ✔ Multiple rows exist for the same product in the same cart, which is redundant.

📌 Example Scenario With unique_together=['cart', 'product']
✔ When a customer adds Product A again, instead of creating a new row, the quantity increases in the existing row:

Cart ID | Product ID | Quantity
--------|-----------|---------
1       | 101       | 5  ✅ Updated Quantity

🚀 Effect: ✔ Ensures only one entry per product per cart, improving efficiency.


🚀 When Would unique_together=['product'] Make Sense?
✔ If you wanted to enforce product uniqueness across all carts (which isn't useful in a shopping cart scenario). 
✔ Use case: A product catalog where each product must have a unique SKU or name, regardless of carts.

🚀 Conclusion: ✔ We need both cart and product in the constraint to enforce uniqueness within the scope of each cart, not globally across all carts.















Creating a Cart:
----------------
Creating a cart involves defining a serializer, a view, and a route to handle API requests effectively.

🚀 Steps to Implement Creating a Cart
✔ Step 1: Define the serializer → Converts cart model data into JSON. 
✔ Step 2: Create the view → Handles incoming requests to create a cart. 
✔ Step 3: Register the route → Maps the view to an API endpoint (/carts/).

1. Building the Cart Serializer
📌 Purpose: 
✔ Converts Cart model into JSON format for API responses. 
✔ Exposes only the cart ID (no unnecessary server-side metadata).

📌 Implementation (serializers.py)

class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)  # ✅ Ensures ID is generated server-side  # as it is read only, we don't need it to be present in the UI
    class Meta:
        model = Cart
        fields = ['id']  # ✅ Only return the cart ID in API response
			
🚀 Effect: 
✔ The API automatically generates a cart ID, ensuring security using UUIDs instead of integers. 
✔ Clients only receive the cart ID, reducing unnecessary data exposure.




2. Creating the Cart ViewSet
📌 Problem: 
✔ ModelViewSet supports all operations (list, retrieve, create, update, delete). 
✔ A cart does not need list (GET /carts/) or update (PATCH /carts/{id}/). (as it applies only for cart items, a cart is simply a cart)
✔ Only create (POST), retrieve (GET /carts/{id}), and delete (DELETE /carts/{id}) are needed.

📌 Solution: Use a Custom ViewSet Without Unnecessary Operations ✔ Extend GenericViewSet instead of ModelViewSet. ✔ Include only mixins needed (CreateModelMixin).

📌 Implementation (views.py)
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import GenericViewSet

class CartViewSet(CreateModelMixin, GenericViewSet):
    queryset = Cart.objects.all()
    serializer_class = CartSerializer

🚀 Effect: 
✔ The API only supports creating a cart (POST /carts/). 
✔ No list or update operations, ensuring carts remain private.




3. Registering the Route for Cart Creation
📌 Purpose:
✔ Maps /carts/ endpoint to CartViewSet, allowing clients to send requests.

📌 Implementation (urls.py)
router.register('carts', views.CartViewSet)  # ✅ Register `/carts/` endpoint

🚀 Effect: ✔ Clients can POST to /carts/ to create a new cart.




4. Testing Cart Creation in API
📌 Step 1: Visit API Root (/store/) 
✔ /carts/ is now registered as an available endpoint.
	
📌 Step 2: Send POST Request to /carts/ 
✔ Request Body: {} (Empty object, since cart ID is auto-generated). 
✔ Expected Response:
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013"
}

🚀 Effect: 
✔ The API creates a cart and returns its unique ID. 
✔ Clients can store this cart ID for future operations (adding items, retrieving the cart, etc.).


📌 Step 3: Prevent Sending ID in Request Body 
✔ If the request accidentally includes ID (null), API should ignore it. 
✔ Solution: Mark ID as read_only in the serializer.

📌 Fix (serializers.py)
id = serializers.UUIDField(read_only=True)  # ✅ Ensures ID is read-only
🚀 Effect: ✔ API generates the cart ID automatically, preventing clients from modifying it.



codes learned in this lesson:

Building an API:
Serializer
View
Route

serializer.py:
class CartSerializer(serializers.ModelSerializer):
	id = serializers.UUIDField(read_only=True)
    class Meta:
        model = Cart
        fields = ['id']

views.py:
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import ModelViewSet, GenericViewSet

class CartViewSet(CreateModelMixin, GenericViewSet):
	queryset = Cart.objects.all()
	serializer_class = CartSerializer


urls.py:
router.register('carts', views.CartViewSet)




📌 Key Takeaways
✔ Implemented cart creation using a serializer, a custom viewset, and a registered route. 
✔ Avoided unnecessary operations (list, update) by using GenericViewSet with CreateModelMixin. 
✔ Ensured security using UUIDs instead of easily guessable integer IDs. 
✔ Prevented clients from modifying cart IDs using read_only=True in the serializer. 
✔ Next steps: Implementing retrieval (GET /carts/{id}/) for accessing cart details.











Getting a Cart:
---------------
Retrieving a cart involves returning all cart items, each with its product details and total price calculations.

🚀 Steps to Implement Getting a Cart
✔ Step 1: Modify the serializer to include cart items and total price. 
✔ Step 2: Extend the viewset to support retrieving (GET /carts/{id}/). 
✔ Step 3: Optimize queries using eager loading (prefetch_related).

1. Updating the Cart Serializer to Include Items
📌 Problem: ✔ Currently, retrieving a cart (GET /carts/{id}/) does not return items. ✔ We must include cart items and their respective product details in the response.

📌 Solution: Modify CartSerializer to Include Items
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)  # ✅ Secure unique ID
    items = CartItemSerializer(many=True, read_only=True)  # ✅ Include all cart items
    total_price = serializers.SerializerMethodField()  # ✅ Calculate total cart price

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])  # ✅ Sum of item totals

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']
		
🚀 Effect: 
✔ API now returns cart items in the response. 
✔ Total cart price is dynamically calculated.

📌 Expected API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        }
    ],
    "total_price": 17.98
}

🚀 Effect: ✔ Includes all cart items with product details and total price calculations.




2. Improving Product Representation Using a Separate Serializer
📌 Problem: 
✔ Including entire product details might expose unnecessary fields. 
✔ Future updates in ProductSerializer might introduce unwanted data in carts.

📌 Solution: Use a Separate Simplified Product Serializer
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']  # ✅ Restrict fields to essential ones

🚀 Effect: 
✔ Returns only relevant product details (ID, title, price). 
✔ Prevents future serializer changes from affecting cart responses.

📌 Modify CartItemSerializer to Use SimpleProductSerializer
class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()  # ✅ Restrict product fields in cart response
    total_price = serializers.SerializerMethodField()  # ✅ Calculate total item price

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price  # ✅ Quantity * Unit Price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']
🚀 Effect: ✔ API returns only necessary product details in cart items.




3. Adding Retrieve Functionality in CartViewSet
📌 Problem: 
✔ CartViewSet only supports POST (CreateModelMixin). 
✔ We need to extend it to support GET /carts/{id}/ for retrieval.

📌 Solution: Include RetrieveModelMixin in CartViewSet
from rest_framework.mixins import RetrieveModelMixin, CreateModelMixin, DestroyModelMixin

class CartViewSet(CreateModelMixin, RetrieveModelMixin, DestroyModelMixin, GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()  # ✅ Optimize database queries
    serializer_class = CartSerializer
	
🚀 Effect: 
✔ API now supports retrieving a cart and its items (GET /carts/{id}/). 
✔ Queries are optimized using eager loading (prefetch_related).




4. Optimizing Database Queries Using prefetch_related
📌 Problem: ✔ Without optimization, Django makes multiple separate queries for each cart item. ✔ Example:
1 query to retrieve cart
1 query per cart item
1 query per product for each cart item

📌 Solution: Use prefetch_related in queryset
queryset = Cart.objects.prefetch_related('items__product').all()

🚀 Effect: 
✔ Retrieves all cart items and product details in fewer queries. 
✔ Reduces N+1 query problem, significantly improving performance.

📌 Comparison Before vs. After Optimization

Action	           Without Optimization	     With prefetch_related
Retrieve Cart	      1 query	                 1 query
Retrieve Items	      1 query per item	         1 query for all items
Retrieve Products	  1 query per product	     1 query for all products
Total Queries	      N+1 (High)	             3 (Optimized)

🚀 Performance Improvement: ✔ Queries drop from ~13 to ~7, improving API efficiency.




5. Testing Cart Retrieval in API
📌 Step 1: Manually Add Cart Items to Database ✔ Insert test products into cart item table.
📌 Step 2: Send GET Request to /carts/{id}/ ✔ Expected Response:

json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        }
    ],
    "total_price": 17.98
}

✔ Confirms items, products, and total prices are correctly retrieved.

📌 Step 3: Check Query Performance with Debug Toolbar ✔ Should show only 7 optimized queries instead of unnecessary multiple queries.



codes in this lesson:
serializers.py:
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class CartItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart_item: CartItem):
        return cart_item.quantity * cart_item.product.unit_price

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price']


class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True)
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']


views.py:
class CartViewSet(CreateModelMixin,
                  RetrieveModelMixin,
                  DestroyModelMixin,
                  GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()
    serializer_class = CartSerializer







📌 Key Takeaways
✔ Implemented retrieving a cart with all its items and product details. 
✔ Used a dedicated SimpleProductSerializer to return minimal product information. 
✔ Ensured total price calculations for each item and the entire cart. 
✔ Optimized queries using prefetch_related to improve performance. 
✔ Next steps: Implementing cart item operations (POST /carts/{id}/items/).









Quick QnA Session:
------------------

Q1: In the CartSerializer class: what is the many parameter means, to serialize all the items ? items = CartItemSerializer(many=True, read_only=True)
Great question! The many=True parameter in CartItemSerializer(many=True, read_only=True) is telling Django REST Framework (DRF) that this field contains multiple items instead of just a single one.

🚀 What Does many=True Mean?
✔ Normally, a ModelSerializer expects a single object to serialize. 
✔ If a field contains a list of objects (like multiple cart items in a shopping cart), we need to set many=True. 
✔ This ensures DRF properly serializes each item in the queryset as an individual JSON object inside an array.

📌 Example Without many=True:
items = CartItemSerializer(read_only=True)

🚀 Problem: 
❌ DRF expects only one item instead of a list. 
❌ Causes errors when trying to serialize multiple cart items.

📌 Example With many=True:
items = CartItemSerializer(many=True, read_only=True)

🚀 Effect: 
✔ Correctly serializes multiple items into an array format. 
✔ Ensures the response includes all cart items, not just one.

📌 Expected Behavior in API Response
When a cart contains multiple items, the many=True parameter ensures they are properly structured.

📌 API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [  
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        },
        {
            "id": 13,
            "product": {
                "id": 8,
                "title": "T-Shirt",
                "unit_price": 25.00
            },
            "quantity": 1,
            "total_price": 25.00
        }
    ],
    "total_price": 42.98
}

🚀 Effect: 
✔ Each cart item is serialized individually inside the items array. 
✔ Total price calculations can now be done easily across all cart items.

📌 Why Use read_only=True?
✔ Prevents clients from modifying cart items directly via the cart serializer. 
✔ Cart items must be managed separately via CartItemViewSet (adding/updating/deleting). 
✔ Ensures only the server can modify cart items—clients can only read them.

📌 Effectively, This Line Means: ✔ "items" contains multiple cart items (many=True). ✔ Clients can read them but cannot modify them directly (read_only=True).

🚀 Conclusion: 
✔ many=True ensures serialization of all cart items in a list. 
✔ read_only=True prevents modifications via CartSerializer.




Q2: In the CartItemSerializer, in the method signature get_total_price, 'cart_item' is an instance of CartItem, right?

Yes, exactly! In the get_total_price method, the parameter cart_item represents an instance of the CartItem model.

✔ How it Works:
DRF automatically passes the current instance of CartItem to the method when serializing data.
Since total_price is defined as serializers.SerializerMethodField(), it looks for a method named get_total_price in the serializer.
The method takes in the current 'cart item' instance and calculates the total price based on quantity * unit_price.

✔ Example in Execution: If there is a CartItem instance like this:
cart_item = CartItem(product=Product(unit_price=10.00), quantity=2)

When DRF calls get_total_price(cart_item), it will return:
cart_item.quantity * cart_item.product.unit_price  # ✅ 2 * 10.00 = 20.00

🚀 Effect: ✔ Ensures each cart item’s total price is correctly computed and included in the API response.




Q3:explanation of method 'get_total_price()' in the CartSerializer


🚀 Purpose of get_total_price
✔ Calculates the total price of all items in the shopping cart. 
✔ Multiplies the quantity of each item by its unit price. 
✔ Sums up all those individual totals to get the cart's total price.

🚀 Step-by-Step Breakdown
📌 Step 1: Get All Items in the Cart
cart.items.all()
✔ cart.items is the related name for the cart's items (related_name="items" in CartItem). 
✔ .all() retrieves all items belonging to this cart.

📌 Step 2: Loop Through Each Item and Calculate Price
[item.quantity * item.product.unit_price for item in cart.items.all()]
✔ Loops through each cart item using list comprehension. 
✔ item.quantity → Number of units for the product in the cart. 
✔ item.product.unit_price → Price of one unit of the product. 
✔ Multiplying quantity * unit_price gives the total price for each item.

📌 Example Calculation ✔ If the cart contains:
CartItem(product=Product(unit_price=10), quantity=2)  # ✅ Total = 2 * 10 = 20
CartItem(product=Product(unit_price=5), quantity=3)   # ✅ Total = 3 * 5 = 15

Then, the list comprehension will return:
[20, 15]  # ✅ List of individual item totals

📌 Step 3: Sum Up All Item Totals
sum([item.quantity * item.product.unit_price for item in cart.items.all()])

✔ Takes the list of item totals and adds them together using sum().

📌 Example Final Calculation
sum([20, 15])  # ✅ 20 + 15 = 35
🚀 Effect: ✔ The final total price for the cart is $35.


🚀 Example API Response
When retrieving a cart (GET /carts/{id}/), this method ensures the total price is dynamically calculated.

📌 API Response for /carts/{id}/
json
{
    "id": "1f7b36b4-4d58-43c8-89c0-78d2b4dca013",
    "items": [
        {
            "id": 12,
            "product": {
                "id": 5,
                "title": "Coffee Mug",
                "unit_price": 8.99
            },
            "quantity": 2,
            "total_price": 17.98
        },
        {
            "id": 13,
            "product": {
                "id": 8,
                "title": "T-Shirt",
                "unit_price": 25.00
            },
            "quantity": 1,
            "total_price": 25.00
        }
    ],
    "total_price": 42.98
}


🚀 Effect: 
✔ Each cart item has its own total price (quantity * unit_price). 
✔ The cart itself has a total price (sum of all item totals).

📌 Summary
✔ Retrieves all items in the cart (cart.items.all()). 
✔ Calculates total price for each item (quantity * unit_price). 
✔ Sums up all individual totals to get the final cart price. 
✔ Ensures cart price updates dynamically whenever items change.





Q4: what is the difference between cart time total price and cart's total price. Both places, we are calculating the total price. Also, in 'cart.items.all()', is it supposed to be 'cart.items.objects.all()'

Great questions! Let's break them down one by one.

🚀 Difference Between Cart Item Total Price & Cart's Total Price

✔ Cart Item Total Price (CartItemSerializer)
Calculates the total price for ONE specific item in the cart.
Formula: quantity * unit_price

Example:
def get_total_price(self, cart_item: CartItem):
    return cart_item.quantity * cart_item.product.unit_price
	
If a customer adds 2 coffee mugs priced at $8.99 each, the cart item total price is:
2 * 8.99 = 17.98  # ✅ Total price for this single cart item


✔ Cart's Total Price (CartSerializer)
Calculates the total price for the ENTIRE cart (sum of all cart items).
Formula: sum(quantity * unit_price for each cart item)

Example:
def get_total_price(self, cart):
    return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

If the cart contains:
2 coffee mugs ($8.99 each) → $17.98
1 T-shirt ($25.00 each) → $25.00
Total cart price = 17.98 + 25.00 = $42.98


🚀 Key Difference: 
✔ CartItemSerializer.get_total_price() → Calculates per-item total price. 
✔ CartSerializer.get_total_price() → Summarizes all item totals to compute cart price.



🚀 Understanding cart.items.all() vs. cart.items.objects.all()

✔ Correct Usage:
cart.items.all()
🚀 Why? 
✔ cart.items is a related manager that automatically handles database queries. 
✔ Since items is a related field (from related_name="items" in CartItem), it already behaves like a queryset. 
✔ Calling .all() retrieves all cart items without needing .objects.


❌ Incorrect Usage:
cart.items.objects.all()
🚀 Why is this incorrect? 
✔ cart.items is already a manager, not an individual model instance. 
✔ .objects.all() is used only for directly querying models, not related fields.

📌 Example Comparisons: 
✔ CartItem.objects.all() → ✅ Correct for retrieving all cart items from the database. 
✔ cart.items.all() → ✅ Correct for retrieving items related to a specific cart. 
✔ cart.items.objects.all() → ❌ Incorrect—items is already a manager, no need for .objects.

🚀 Summary
✔ Cart item total price → Price of one cart item (quantity * unit_price). 
✔ Cart's total price → Sum of all cart item prices (sum of all item totals). 
✔ Use cart.items.all(), not cart.items.objects.all() — items is already a manager.





Q5. 
✔ cart.items is already a manager, not an individual model instance. 
✔ .objects.all() is used only for directly querying models, not related fields. 
Explain these two lines. So objects.all() is used for direct instance of the particular model whereas .all() is used directly when related field is used right, which means foreign instance


Yes, you’ve got the right idea! Let me clarify it further to ensure full understanding.

🚀 Understanding objects.all() vs. cart.items.all()
✔ .objects.all() is used for querying the entire model table. ✔ .all() is used when accessing related fields via ForeignKey (or related_name).

📌 What Does objects.all() Do?
The .objects attribute exists in model classes and provides access to the database query manager.

📌 Example: Getting all records of CartItem
CartItem.objects.all()

🚀 Effect: 
✔ Retrieves all cart items in the entire database. 
✔ Used when querying the main model directly, not through a relationship.

📌 What Does cart.items.all() Do?
✔ cart.items is a manager object that automatically manages related records. 
✔ .all() retrieves only the cart items associated with this specific cart.

📌 Example: Getting cart items for a specific cart instance
cart = Cart.objects.get(id="some-cart-id")  # ✅ Get a specific cart
cart.items.all()  # ✅ Get all cart items related to THIS cart

🚀 Effect: 
✔ Retrieves only items linked to this specific cart, instead of querying the entire table.

🚀 Key Difference
Usage	                   What It Does	                            Example
.objects.all()	           Retrieves all records of a model	        CartItem.objects.all()
.all() (on FK)	           Retrieves related records for one item	cart.items.all() (cart’s items)


🚀 Final Takeaway: 
✔ Use .objects.all() when querying the full model table. 
✔ Use .all() on related fields when retrieving associated records via ForeignKey.














Deleting a Cart:
----------------
Deleting a cart allows users to remove an entire cart, clearing all its items.

🚀 Steps to Implement Cart Deletion
✔ Step 1: Add DestroyModelMixin to CartViewSet to enable DELETE requests. 
✔ Step 2: Mark items field as read_only in CartSerializer to prevent inclusion when creating a cart. 
✔ Step 3: Verify that deleting a cart removes all associated cart items.

1. Enabling Cart Deletion in ViewSet
📌 Problem: 
✔ Currently, CartViewSet does not support the DELETE method (DELETE /carts/{id}/). 
✔ The API needs to allow users to remove their cart entirely.

📌 Solution: Add DestroyModelMixin to CartViewSet
from rest_framework.mixins import DestroyModelMixin

class CartViewSet(CreateModelMixin,
                  RetrieveModelMixin,
                  DestroyModelMixin,  # ✅ Enable DELETE operations
                  GenericViewSet):
    queryset = Cart.objects.prefetch_related('items__product').all()
    serializer_class = CartSerializer
	
🚀 Effect: 
✔ The API now supports deleting a cart using DELETE /carts/{id}/. 
✔ When a cart is deleted, all associated cart items are automatically removed (on_delete=models.CASCADE).




2. Fixing Items Field in CartSerializer
📌 Problem: 
✔ When creating a cart (POST /carts/), the API unexpectedly includes the items field. 
✔ Since items should be added separately, this field must be read_only.

📌 Solution: Mark items Field as read_only=True in CartSerializer
class CartSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(read_only=True)
    items = CartItemSerializer(many=True, read_only=True)  # ✅ Ensure `items` can only be read, not modified
    total_price = serializers.SerializerMethodField()

    def get_total_price(self, cart):
        return sum([item.quantity * item.product.unit_price for item in cart.items.all()])

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_price']
		
🚀 Effect: 
✔ items field will no longer appear when creating a cart. 
✔ Clients cannot modify cart items directly—they must manage them via separate requests.




3. Testing Cart Deletion in API
📌 Step 1: Create a New Cart Using /carts/ 
✔ Expected Response:
json
{
    "id": "5f7b36b4-3d48-43b2-92b7-12a3d2e2e567",
    "items": [],
    "total_price": 0
}

🚀 Effect: ✔ The cart is created successfully.

📌 Step 2: Delete the Cart Using /carts/{id}/ 
✔ Send a DELETE request to /carts/5f7b36b4-3d48-43b2-92b7-12a3d2e2e567/. 
✔ Expected Response:
json
{}

✔ Now, refreshing /carts/{id}/ returns a 404 Not Found error. 🚀 Effect: ✔ The cart is deleted, and all associated items are removed automatically.




📌 Key Takeaways
✔ Enabled cart deletion using DestroyModelMixin in CartViewSet. 
✔ Marked items as read_only in CartSerializer to prevent modification during cart creation. 
✔ Deleting a cart also removes all associated cart items due to on_delete=models.CASCADE. 
✔ Next steps: Implementing retrieval of individual cart items (GET /carts/{id}/items/).














Getting Cart Items:
-------------------
Retrieving cart items allows users to view all items inside a specific shopping cart.

🚀 Steps to Implement Retrieving Cart Items
✔ Step 1: Define CartItemViewSet to handle retrieving cart items. 
✔ Step 2: Override get_queryset() to ensure only items from the requested cart are fetched. 
✔ Step 3: Register a nested router for cart items. 
✔ Step 4: Optimize queries using select_related to improve performance.

1. Creating CartItemViewSet for Cart Items
📌 Problem: 
✔ We need a separate viewset for handling cart items, apart from the main CartViewSet. 
✔ Cart items must be filtered to ensure only items from the requested cart are retrieved.

📌 Solution: Implement CartItemViewSet with Query Filtering
class CartItemViewSet(ModelViewSet):
    serializer_class = CartItemSerializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ✅ Optimize queries
				
🚀 Effect: 
✔ The API now supports retrieving cart items from a specific cart (GET /carts/{id}/items/). 
✔ cart_pk is extracted dynamically from the URL using self.kwargs['cart_pk']. 
✔ select_related('product') optimizes queries by reducing extra database lookups.




2. Registering Cart Items Route Using Nested Routers
📌 Problem: 
✔ Cart items are nested resources under carts (/carts/{id}/items/). 
✔ The API must structure URLs correctly to reflect this relationship.

📌 Solution: Use NestedDefaultRouter for Correct URL Structure

router.register('carts', views.CartViewSet)

carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')  # ✅ Sets `cart_pk` as a URL parameter
carts_router.register('items', views.CartItemViewSet, basename='cart-items')  # ✅ Registers cart items under `/carts/{id}/items/`

urlpatterns = router.urls + carts_router.urls

🚀 Effect: 
✔ /carts/{id}/items/ retrieves all items for a specific cart. 
✔ /carts/{id}/items/{item_id}/ retrieves a specific cart item. 
✔ Nested routing ensures a clean and intuitive API structure.

📌 Example API Requests 
✔ Retrieve all cart items: /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/ 
✔ Retrieve a specific cart item: /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/3/




3. Testing Cart Items Retrieval in API
📌 Step 1: Retrieve All Items in a Cart (GET /carts/{id}/items/) 
✔ Expected Response:
json
[
    {
        "id": 3,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 2,
        "total_price": 17.98
    },
    {
        "id": 4,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

🚀 Effect: 
✔ Returns only items from the specified cart. 
✔ Includes product details and total price calculations.

📌 Step 2: Retrieve a Specific Cart Item (GET /carts/{id}/items/{item_id}/) 
✔ Expected Response:
json
{
    "id": 3,
    "product": {
        "id": 5,
        "title": "Coffee Mug",
        "unit_price": 8.99
    },
    "quantity": 2,
    "total_price": 17.98
}
🚀 Effect: ✔ Retrieves only the requested cart item using its ID.

📌 Step 3: Handle Non-Existent Cart Items (GET /carts/{id}/items/30/) 
✔ Expected Response: 404 Not Found 🚀 Effect: ✔ Ensures non-existent items return correct error responses.




4. Optimizing SQL Queries Using select_related
📌 Problem: ✔ Without optimization, Django performs extra queries for each cart item’s product details.

📌 Solution: Use select_related in get_queryset()
def get_queryset(self):
    return CartItem.objects \
            .filter(cart_id=self.kwargs['cart_pk']) \
            .select_related('product')  # ✅ Optimize queries
			
🚀 Effect: 
✔ Reduces database queries from ~5 per request to ~2. 
✔ Ensures efficient retrieval of cart items without excessive lookups.

📌 Checking Queries via Debug Toolbar 
✔ Before Optimization: 5 queries 
✔ After Optimization: 2 queries (inner join between cart_items and products) 
✔ Performance Boost → Less database overhead, faster API responses.




Codes learned in this lesson:
items endpoint:
127.0.0.1:8000/store/carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items

particular item endpoint:
127.0.0.1:8000/store/carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/3

views.py:
class CartItemViewSet(ModelViewSet):
	serializer_class = CartItemSerializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')



urls.py:
router.register('carts', views.CartViewSet)
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart') #So, once we set this lookup='cart', we have a URL parameter called 'cart_pk'
                                                                           #That's how we we extracted this URL parameter in ViewSet as self.kwargs['cart_pk']
carts_router.register('items', views.CartItemViewSet, basename='cart-items')


# URLConf
urlpatterns = router.urls + products_router.urls + carts_router.urls




📌 Key Takeaways
✔ Implemented retrieving all cart items (GET /carts/{id}/items/). 
✔ Implemented retrieving a single cart item (GET /carts/{id}/items/{item_id}/). 
✔ Used NestedDefaultRouter to properly structure cart item URLs. 
✔ Optimized queries using select_related to minimize extra lookups. 
✔ Next steps: Implementing adding items to a cart (POST /carts/{id}/items/).






Quick QnA session:
------------------
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart') #So, once we set this lookup='cart', we have a URL parameter called 'cart_pk' 
                                                                           #That's how we we extracted this URL parameter in ViewSet as self.kwargs['cart_pk'] 

carts_router.register('items', views.CartItemViewSet, basename='cart-items') 

What does the lookup and basename parameter does. why it is used. where it appears and what is the outcome.



🚀 Understanding lookup in Nested Routers
✔ The lookup parameter defines the URL variable name used in views. ✔
 When registering a nested router, it ensures a dynamic path for retrieving child resources.

📌 Example Usage
carts_router = routers.NestedDefaultRouter(router, 'carts', lookup='cart')

🚀 Effect: 
✔ Defines 'cart' as the lookup parameter in URLs. 
✔ Creates a URL variable called cart_pk that can be accessed in views.

📌 How It Affects URLs 
✔ When a request is made to /carts/{id}/items/, the {id} value is mapped as cart_pk. 
✔ In the view, we retrieve it using:
cart_id = self.kwargs['cart_pk']

✔ Without lookup='cart', Django wouldn't generate the proper nested structure.



🚀 Understanding basename in Router Registration
✔ basename defines the name prefix for generated URL patterns. 
✔ Django uses basename to create named routes for referencing in reverse lookups.

📌 Example Usage
carts_router.register('items', views.CartItemViewSet, basename='cart-items')

🚀 Effect: 
✔ Assigns 'cart-items' as the prefix for generated named routes. 
✔ Ensures the API generates correctly named URLs for list and detail views.

📌 Resulting Named Routes 
✔ For listing cart items (GET /carts/{cart_pk}/items/):
cart-items-list

✔ For retrieving a specific cart item (GET /carts/{cart_pk}/items/{item_id}/):
cart-items-detail

✔ These names can be used in Django’s reverse URL resolution:
reverse('cart-items-detail', kwargs={'cart_pk': 'some-cart-id', 'pk': 3})

✔ Without basename, Django REST Framework wouldn't generate route names properly, leading to errors in reverse lookups.

🚀 Summary
✔ lookup='cart' → Creates a dynamic URL parameter (cart_pk) for views. 
✔ basename='cart-items' → Defines named routes for referencing cart item endpoints. 
✔ Used when registering nested resources (cart items under carts). 
✔ Ensures correct API structure and dynamic routing.







🚀 What Is basename in DRF Routers?
✔ basename is a unique name assigned to viewsets when registering them in Django REST Framework (DRF) routers. 
✔ It is used internally by DRF to generate named URL patterns that can be referenced elsewhere in the application.

📌 Example Without basename: If we register a viewset without specifying basename, DRF automatically tries to infer it from the viewset’s queryset. But if queryset is missing or overridden (like in get_queryset()), DRF cannot determine it, causing errors.

📌 Example With basename:
carts_router.register('items', views.CartItemViewSet, basename='cart-items')
🚀 Effect: 
✔ DRF manually assigns cart-items as the prefix for URL pattern names. 
✔ This ensures URLs can be referenced without errors, even if queryset is overridden in the viewset.

🚀 Where Does basename Appear?
✔ The basename is used in DRF to generate named URL patterns, which can be referenced in views or templates.

📌 Generated Named Routes for cart-items:

DRF Named Route	                Corresponding Endpoint
cart-items-list	         /carts/{cart_pk}/items/ (list view)
cart-items-detail	    /carts/{cart_pk}/items/{item_id}/ (single item)

✔ These names allow Django to generate URLs dynamically using the reverse() function.




🚀 How Does basename Affect reverse()?
✔ In Django, we use reverse() to dynamically generate URLs based on view names.

📌 Example Without basename (Would Cause Error If queryset Is Overridden):
reverse('items-list', kwargs={'cart_pk': '123'})
❌ Error: DRF cannot determine the correct URL pattern, because the viewset lacks a default queryset.

📌 Example With basename (Correct Usage):
reverse('cart-items-list', kwargs={'cart_pk': '123'})
🚀 Effect: ✔ DRF knows exactly which viewset this belongs to, avoiding errors. 
✔ URLs remain consistent even if queryset is overridden in the viewset.

🚀 Summary
✔ basename manually sets the prefix for named URL patterns in DRF. 
✔ Required when queryset is overridden to prevent errors. 
✔ Used in reverse() to generate URLs dynamically.

🚀 Final Takeaway: 
✔ Without basename, DRF cannot generate named routes properly, leading to errors. 
✔ Always use basename when registering nested or dynamic routes to ensure smooth URL resolution.












Adding a Cart Item:
-------------------
Adding an item to a shopping cart involves dynamically handling product selection, quantity updates, and validation.

🚀 Steps to Implement Adding a Cart Item
✔ Step 1: Define a separate serializer (AddCartItemSerializer) for handling cart item creation. 
✔ Step 2: Dynamically select the serializer in CartItemViewSet based on request method. 
✔ Step 3: Override save() in AddCartItemSerializer to handle existing item updates. 
✔ Step 4: Validate product selection and ensure quantity is always greater than zero.

1. Creating AddCartItemSerializer for Adding Cart Items
📌 Problem: 
✔ When adding a product, the API currently expects a product object, which is unnecessary. 
✔ Instead, only product_id and quantity should be passed in the request.

📌 Solution: Define a Separate Serializer for Adding Items
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()  # ✅ Accept product ID instead of a full product object

    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No product with the given ID was found.')  # ✅ Ensure the product exists
        return value

    def save(self, **kwargs):
        cart_id = self.context['cart_id']
        product_id = self.validated_data['product_id']
        quantity = self.validated_data['quantity']

        try:
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity  # ✅ Increment quantity if item already exists
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)  # ✅ Create new item
        
        return self.instance

    class Meta:
        model = CartItem
        fields = ['id', 'product_id', 'quantity']
		
🚀 Effect: 
✔ Accepts product_id instead of requiring a full product object. 
✔ Updates quantity if the product already exists instead of creating duplicates. 
✔ Validates product selection to prevent errors.




2. Dynamically Selecting the Serializer in CartItemViewSet
📌 Problem: ✔ CartItemViewSet must use different serializers for different actions:
Adding (POST) → Uses AddCartItemSerializer.
Updating (PATCH) → Uses UpdateCartItemSerializer.
Retrieving (GET) → Uses CartItemSerializer.

📌 Solution: Override get_serializer_class() to Select the Correct Serializer
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ✅ Restrict allowed HTTP methods

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer  # ✅ Use specialized serializer for adding items
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer  # ✅ Use different serializer for updating items
        return CartItemSerializer  # ✅ Default for retrieval and deletion

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}  # ✅ Pass cart ID from URL to serializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ✅ Optimize queries
				
🚀 Effect: 
✔ Automatically selects the correct serializer based on request type. 
✔ Ensures cart ID is passed via context for proper reference in serializers.





3. Testing Cart Item Creation in API
📌 Step 1: Create a New Cart Using /carts/ ✔ Expected Response:
json
{
    "id": "5f7b36b4-3d48-43b2-92b7-12a3d2e2e567",
    "items": [],
    "total_price": 0
}
🚀 Effect: ✔ The cart is created successfully.


📌 Step 2: Add a New Item to the Cart (POST /carts/{id}/items/) ✔ Request Body:
json
{
    "product_id": 1,
    "quantity": 10
}

✔ Expected Response:
json
{
    "id": 12,
    "product_id": 1,
    "quantity": 10
}

🚀 Effect: ✔ The item is successfully added to the cart.


📌 Step 3: Add the Same Product Again (Quantity Should Update) ✔ Request Body:

json
{
    "product_id": 1,
    "quantity": 10
}

✔ Expected Response:
json
{
    "id": 12,
    "product_id": 1,
    "quantity": 20
}

🚀 Effect: ✔ Quantity updates instead of creating a duplicate entry.


📌 Step 4: Handle Invalid Product Selection (POST /carts/{id}/items/) ✔ Request Body:

json
{
    "product_id": 999,
    "quantity": 1
}
✔ Expected Response:

json
{
    "product_id": ["No product with the given ID was found."]
}

🚀 Effect: ✔ Prevents adding non-existent products.


📌 Step 5: Handle Invalid Quantity (POST /carts/{id}/items/)
✔ Request Body:
json
{
    "product_id": 1,
    "quantity": 0
}

✔ Expected Response:
json
{
    "quantity": ["The quantity should be at least 1."]
}

🚀 Effect: ✔ Prevents adding items with zero or negative quantities.






codes learned in this lesson:

serializers.py:
class AddCartItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    def validate_product_id(self, value):
        if not Product.objects.filter(pk=value).exists():
            raise serializers.ValidationError('No product with the given ID was found.')
        return value

    def save(self, **kwargs):
        cart_id = self.context['cart_id']
        product_id = self.validated_data['product_id']
        quantity = self.validated_data['quantity']

        try: 
            cart_item = CartItem.objects.get(cart_id=cart_id, product_id=product_id)
            cart_item.quantity += quantity
            cart_item.save()
            self.instance = cart_item
        except CartItem.DoesNotExist:
            self.instance = CartItem.objects.create(cart_id=cart_id, **self.validated_data)
        
        return self.instance

    class Meta:
        model = CartItem
        fields = ['id', 'product_id', 'quantity']


views.py:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')






📌 Key Takeaways
✔ Created a separate serializer (AddCartItemSerializer) for handling cart item creation. 
✔ Overrode save() to handle quantity updates instead of creating duplicates. 
✔ Dynamically selected the appropriate serializer in CartItemViewSet. 
✔ Validated product selection and enforced a minimum quantity limit. 
✔ Next steps: Implementing updating a cart item (PATCH /carts/{id}/items/{item_id}/).















Updating a Cart Item:
---------------------

Updating a cart item allows users to modify the quantity of an item in their shopping cart.

🚀 Steps to Implement Updating a Cart Item
✔ Step 1: Define a separate serializer (UpdateCartItemSerializer) for updating cart items. 
✔ Step 2: Dynamically select the serializer in CartItemViewSet based on request method (PATCH). 
✔ Step 3: Restrict allowed HTTP methods to prevent unnecessary operations. 
✔ Step 4: Verify API functionality for updating quantities.


1. Creating UpdateCartItemSerializer for Updating Cart Items
📌 Problem: 
✔ By default, CartItemSerializer expects an entire cart item object to be sent for updates. 
✔ Instead, only quantity should be updated—not the full object.

📌 Solution: Define a Separate Serializer for Updating Quantity
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ['quantity']  # ✅ Only allow updating quantity
		
🚀 Effect: 
✔ Ensures only quantity is sent in the request, avoiding unnecessary fields. 
✔ Prevents modifications to other attributes (like product ID).




2. Dynamically Selecting the Serializer in CartItemViewSet
📌 Problem: ✔ CartItemViewSet needs to use different serializers for different actions:
Adding (POST) → Uses AddCartItemSerializer.
Updating (PATCH) → Uses UpdateCartItemSerializer.
Retrieving (GET) → Uses CartItemSerializer.

📌 Solution: Override get_serializer_class() to Select the Correct Serializer
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ✅ Restrict allowed HTTP methods

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer  # ✅ Use specialized serializer for adding items
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer  # ✅ Use different serializer for updating items
        return CartItemSerializer  # ✅ Default for retrieval and deletion

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}  # ✅ Pass cart ID from URL to serializer

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')  # ✅ Optimize queries
				
🚀 Effect: 
✔ Automatically selects the correct serializer based on request type. 
✔ Ensures cart ID is passed via context for proper reference in serializers.




3. Restricting Allowed HTTP Methods
📌 Problem: 
✔ ModelViewSet supports all HTTP methods by default, including PUT. 
✔ However, we only want to allow PATCH, because updating only affects quantity.

📌 Solution: Explicitly Define Allowed HTTP Methods
http_method_names = ['get', 'post', 'patch', 'delete']  # ✅ Exclude `PUT`

🚀 Effect: 
✔ Removes PUT method from API, ensuring updates are handled via PATCH instead. 
✔ Prevents clients from replacing the entire cart item object.

📌 Browsable API Adjustment: 
✔ Before refresh → Shows PUT button (incorrect behavior). 
✔ After refresh → PUT button disappears, only PATCH remains (correct behavior).




4. Testing Cart Item Updates in API
📌 Step 1: Retrieve a Specific Cart Item (GET /carts/{id}/items/{item_id}/) 
✔ Expected Response Before Update:
json
{
    "id": 12,
    "product": {
        "id": 5,
        "title": "Coffee Mug",
        "unit_price": 8.99
    },
    "quantity": 20,
    "total_price": 179.80
}

🚀 Effect: ✔ Displays current quantity before updating.


📌 Step 2: Update Quantity (PATCH /carts/{id}/items/{item_id}/) 
✔ Request Body:
json
{
    "quantity": 10
}

✔ Expected Response After Update:
json
{
    "id": 12,
    "quantity": 10
}

🚀 Effect: ✔ Successfully updates only quantity, without modifying other fields.

📌 Step 3: Verify Quantity in Cart (GET /carts/{id}/items/) 
✔ Expected Response:
json
[
    {
        "id": 12,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 10,
        "total_price": 89.90
    }
]

🚀 Effect: ✔ Updated quantity is correctly reflected in cart items list.


📌 Step 4: Handle Invalid Quantity Update (PATCH /carts/{id}/items/{item_id}/) 
✔ Request Body:
json
{
    "quantity": -5
}

✔ Expected Response:
json
{
    "quantity": ["Ensure this value is greater than or equal to 1."]
}

🚀 Effect: ✔ Prevents negative values, enforcing a minimum quantity of 1.




codes learned in this lesson:

serializers.py:
class UpdateCartItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = CartItem
        fields = ['quantity']
		
		
views.py:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')





📌 Key Takeaways
✔ Created a separate serializer (UpdateCartItemSerializer) for handling quantity updates. 
✔ Overrode get_serializer_class() in CartItemViewSet to select the correct serializer. 
✔ Restricted HTTP methods to exclude PUT, ensuring only PATCH is allowed. 
✔ Verified functionality by updating a cart item via API calls. 
✔ Next steps: Implementing deletion of cart items (DELETE /carts/{id}/items/{item_id}/).
















Deleting a Cart Item:
---------------------

Deleting a cart item allows users to remove individual items from their shopping cart, ensuring unwanted items are no longer stored.

🚀 Steps to Implement Deleting a Cart Item
✔ Step 1: Ensure DELETE functionality is enabled in CartItemViewSet. 
✔ Step 2: Verify that allowed HTTP methods are correctly defined. 
✔ Step 3: Test deletion to confirm that cart items are removed properly. 
✔ Step 4: Ensure API returns correct responses (204 No Content for success, 404 Not Found for missing items).

1. Verifying DELETE Functionality in CartItemViewSet
📌 Problem: 
✔ Since CartItemViewSet extends ModelViewSet, all CRUD operations (including DELETE) are automatically supported. 
✔ However, we need to explicitly allow the DELETE method to ensure proper routing.

📌 Solution: Ensure http_method_names Includes DELETE
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']  # ✅ Allow only necessary HTTP methods
	
🚀 Effect: 
✔ Restricts allowed HTTP methods to prevent unsupported operations (e.g., PUT). 
✔ Ensures that cart items can be deleted (DELETE /carts/{id}/items/{item_id}/).

📌 Important Note: 
✔ Method names in http_method_names must be lowercase. 
✔ If delete is capitalized, the API will not recognize it, causing the DELETE button to disappear in the browsable API UI.




2. Testing Cart Item Deletion in API
📌 Step 1: Retrieve Cart Items (GET /carts/{id}/items/) 
✔ Expected Response (Before Deletion):
json
[
    {
        "id": 12,
        "product": {
            "id": 5,
            "title": "Coffee Mug",
            "unit_price": 8.99
        },
        "quantity": 2,
        "total_price": 17.98
    },
    {
        "id": 15,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

🚀 Effect: ✔ Shows all items currently in the cart, ready for deletion.


📌 Step 2: Delete a Cart Item (DELETE /carts/{id}/items/{item_id}/) 
✔ Sending DELETE /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/12/. 
✔ Expected Response:
json
{}

✔ Status Code: 204 No Content 🚀 Effect: ✔ Cart item is successfully deleted.


📌 Step 3: Verify That Item No Longer Exists (GET /carts/{id}/items/{item_id}/) 
✔ Sending GET /carts/16882329-b7a0-4ce6-ab32-467d4d927ab9/items/12/. 
✔ Expected Response:
json
{
    "detail": "Not found."
}
✔ Status Code: 404 Not Found 🚀 Effect: ✔ Confirms that the item no longer exists on the server.


📌 Step 4: Refresh Cart Items (GET /carts/{id}/items/) 
✔ Expected Response (After Deletion):
json
[
    {
        "id": 15,
        "product": {
            "id": 8,
            "title": "T-Shirt",
            "unit_price": 25.00
        },
        "quantity": 1,
        "total_price": 25.00
    }
]

🚀 Effect: ✔ The deleted item is removed from the list, confirming successful deletion.



Codes used in this lesson:
class CartItemViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete']
   
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return AddCartItemSerializer
        elif self.request.method == 'PATCH':
            return UpdateCartItemSerializer
        return CartItemSerializer

    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_pk']}

    def get_queryset(self):
        return CartItem.objects \
                .filter(cart_id=self.kwargs['cart_pk']) \
                .select_related('product')




📌 Key Takeaways
✔ Verified DELETE functionality using ModelViewSet in CartItemViewSet. 
✔ Ensured DELETE method was explicitly allowed via http_method_names. 
✔ Confirmed deletion success (204 No Content) and missing item response (404 Not Found). 















Django Authentication System:
-----------------------------


In this section, you will learn about Django's authentication system for identifying users. So we'll start off by talking about how the authentication system works under the hood, so you understand all its building blocks. We'll then talk about the user model and how to customize it to fit the requirements of your application. So as part of this, we'll look at extending the user model and creating profiles. Next, we'll talk about permissions and groups for controlling users access.

- How the authentication system works
- user model and customizing it
- Extending the User model
- Creating Profiles
- Managing groups and permissions





Django Authentication System:
-----------------------------

Django comes with a built-in authentication system that provides user management, login, logout, password handling, and access control.

🚀 Overview of Django's Authentication System
✔ User management → Create, modify, and authenticate users. 
✔ Permissions & Groups → Assign different levels of access.
✔ Secure password storage → Uses hashing algorithms for security. 
✔ Authentication middleware → Automatically detects the logged-in user.


1. Installed Authentication Apps
📌 Django's Authentication System Comes Preinstalled 
✔ Defined inside INSTALLED_APPS in settings.py:
INSTALLED_APPS = [
    ...
    'django.contrib.auth',  # ✅ Provides user authentication and permissions management
]

🚀 Effect: 
✔ Enables user models (User, Group, Permission) for authentication.




2. Database Tables for Authentication

📌 Django Auth System Uses the Following Tables:
Table Name	                   Purpose
auth_user	                   Stores user information (username, password, etc.).
auth_group	                   Defines user groups for role-based access.
auth_permission	               Handles individual permissions for models.
auth_user_groups	           Links users to groups.
auth_user_user_permissions	   Links users to specific permissions.

🚀 Effect: ✔ Provides fine-grained user access control using groups and permissions.

📌 Example User Table Fields (auth_user) 
✔ User ID → Unique identifier for the user. 
✔ Password → Encrypted storage to protect credentials. 
✔ Last login → Tracks the last authentication timestamp. 
✔ Superuser status (is_superuser) → Grants full admin access. 
✔ Username, first name, last name, email → Stores basic user details. 
✔ Staff status (is_staff) → Determines admin panel access. 
✔ Active status (is_active) → Enables or disables user accounts. 
✔ Date joined → Stores user registration timestamp.

🚀 Effect: ✔ Django automatically manages authentication-related tables to ensure security and scalability.




3. Authentication Middleware: How Django Detects Users
📌 Middleware is a Function That Processes Requests Before They Reach a View 
✔ Middleware modifies the request object before passing it to a view function. 
✔ AuthenticationMiddleware is responsible for attaching the user to the request.

📌 Defined in MIDDLEWARE (settings.py)
MIDDLEWARE = [
    ...
    "django.contrib.auth.middleware.AuthenticationMiddleware",  # ✅ Detects the logged-in user
]

🚀 Effect: 
✔ Ensures each incoming request contains a user attribute. 
✔ The request’s user is either:
	An actual user object (if logged in).
	An instance of AnonymousUser (if not logged in).

📌 Usage in Views (views.py)
def delete_collection(request):
    if request.user.is_authenticated:
        print(f"User {request.user.username} is deleting a collection")

🚀 Effect: 
✔ request.user identifies the logged-in user. 
✔ If a user is authenticated, request.user holds their user object. 
✔ If not logged in, Django assigns AnonymousUser.



code references in this lesson:
INSTALLED_APPS -->	'django.contrib.auth' -->  contains this

tables --> auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions

MIDDLEWARE --> "django.contrib.auth.middleware.AuthenticationMiddleware" -->

request.user




📌 Key Takeaways
✔ Django’s authentication system provides built-in user management and security. 
✔ The auth_user table stores user details, including encrypted passwords. 
✔ Authentication middleware ensures requests contain user information (request.user). 
✔ Users can be assigned roles (is_staff, is_superuser) for access control. 
✔ Next steps: Customizing the User model for additional fields and advanced authentication!














Customizing the User Model:
---------------------------
Django provides a default User model, but sometimes applications need additional attributes for user management. There are two main approaches to customizing the user model:


1. Extending the User Model (Inheritance) → Creates a custom user model with extra authentication-related attributes. 
2. Creating a Profile Model (Composition) → Stores additional user-related information in a separate table.


🚀 Two Approaches to Customizing the User Model

1. Approach: Extending the User Model (Inheritance)
✔ Create a custom user model that inherits from Django’s AbstractUser. 
✔ This approach modifies the main user table directly. 
✔ Used only for authentication-related attributes, like login behavior.

📌 Example Implementation:
from django.contrib.auth.models import AbstractUser
from django.db import models

class AppUser(AbstractUser):  
    phone_number = models.CharField(max_length=15, blank=True, null=True)  # ✅ Example additional field
	
🚀 Effect: 
✔ Adds extra fields directly to the auth_user table. 
✔ Allows for custom authentication logic.

📌 When to Use This Approach? 
✔ If modifying login behavior (e.g., using email instead of username). 
✔ If storing authentication-related fields (e.g., password reset settings). 
✔ Not recommended in an existing project—switching models mid-project is complex.




2. Approach: Creating a Profile Model (Composition)
✔ Create a separate profile model linked to Django’s default User. 
✔ This approach keeps authentication logic in Django’s default user system. 
✔ Best for storing user-related data that is not authentication-specific.

📌 Example Implementation:
from django.contrib.auth.models import User
from django.db import models

class Profile(models.Model):  
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")  # ✅ Establishes link with User
    birth_date = models.DateField(blank=True, null=True)
    address = models.CharField(max_length=255, blank=True, null=True)
	
🚀 Effect: 
✔ Keeps authentication logic separate from user attributes. 
✔ Allows each app to define its own user profile concept.

📌 When to Use This Approach? 
✔ If storing general user information (e.g., birthdate, address). 
✔ If multiple apps need different user profiles (HR, sales, training). 
✔ Best for existing projects—does not require replacing Django’s default user model.




🚀 Practical Differences Between Inheritance and Composition
Feature	                                   Extending User Model (Inheritance)	                 Creating a Profile Model (Composition)

Database Structure	                       Extra fields stored in auth_user table	             Separate table with a one-to-one link to auth_user
Authentication Use Case	                   ✅ Ideal for modifying login/authentication logic	     ❌ Not suitable for authentication changes
General User Info (Address, Birthdate)	   ❌ Not recommended	                                 ✅ Best for storing profile data
Multiple User Profile Types	               ❌ Hard to manage multiple roles	                     ✅ Each app can define different profiles

🚀 Conclusion: 
✔ Use Inheritance for authentication-related modifications. 
✔ Use Composition for general user attributes. 
✔ Most projects use the Profile approach due to flexibility.



📌 Key Takeaways
✔ Django’s default user model can be customized using inheritance or composition. 
✔ Use inheritance (AbstractUser) only for authentication-related attributes. 
✔ Use a separate profile model (OneToOneField) for general user information. 
✔ Switching to a custom user model mid-project is complex—composition is preferred for flexibility. 
✔ Next steps: Exploring these approaches in detail with real-world use cases!



Further Refining this:
---------------------
Django comes with a built-in User model that stores basic authentication details like usernames, passwords, and login status. However, many applications need extra user information—such as phone numbers, addresses, or birthdays.

We have two main ways to customize the user model:

1. Approach: Extending the User Model (Inheritance)
✔ We create a new user model that inherits from Django’s AbstractUser. 
✔ This allows us to add extra authentication-related fields directly to the user table in the database.

📌 Example: Adding a phone_number field
from django.contrib.auth.models import AbstractUser
from django.db import models

class AppUser(AbstractUser):  
    phone_number = models.CharField(max_length=15, blank=True, null=True)  # ✅ New field added directly to user table
	
🚀 Effect: 
✔ Adds the phone_number field directly inside the auth_user table. 
✔ Customizes authentication logic, such as logging in with a phone number instead of a username.

📌 When to Use This Approach? 
✔ If modifying authentication (e.g., using email or phone instead of username). 
✔ If storing authentication-related attributes (e.g., login method changes). 
❌ Not recommended for an existing project—replacing Django’s default user model mid-project is complex.




2. Approach: Creating a Separate Profile Model (Composition)
✔ We keep Django’s default User model but create an extra table for storing additional user details. 
✔ The profile model is linked to Django’s User model using a OneToOneField.

📌 Example: Creating a Profile Table
from django.contrib.auth.models import User
from django.db import models

class Profile(models.Model):  
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")  # ✅ Linked to User
    birth_date = models.DateField(blank=True, null=True)
    address = models.CharField(max_length=255, blank=True, null=True)

🚀 Effect: 
✔ Stores general user details in a separate table (profile). 
✔ The Profile table is linked to User, so each user has exactly one profile.

📌 When to Use This Approach? 
✔ If storing personal information like birthdate, address, or preferences. 
✔ If multiple apps need different types of user profiles (e.g., customers, employees, students). 
✔ Best for existing projects—avoids the complexity of changing Django’s built-in user model.




🚀 Practical Differences Between Inheritance and Composition
Feature	Extending User Model (Inheritance)	Creating a Profile Model (Composition)
Database Structure	Extra fields inside auth_user table	Separate profile table linked to auth_user
Authentication Changes	✅ Ideal for modifying login behavior	❌ Not meant for authentication changes
General User Info (Address, Birthdate)	❌ Not recommended	✅ Best for storing profile data
Multiple User Profile Types	❌ Hard to manage	✅ Each app can define different profiles
🚀 Conclusion: ✔ Use Inheritance if changing authentication logic (e.g., login method). ✔ Use Composition if storing general user details (e.g., address, birthdate). ✔ Most projects prefer the profile approach for flexibility.




📌 Key Takeaways
✔ Django’s default user model stores authentication details. 
✔ We can customize it using inheritance (AbstractUser) or composition (Profile). 
✔ Use inheritance if modifying authentication behavior. 
✔ Use a profile table for storing personal user details. 
✔ Switching to a custom user model mid-project is difficult — composition is the safer option. 
✔ Next steps: Implementing these approaches in real-world applications!









Extending the User Model:
-------------------------
Django provides a default User model, but sometimes projects need extra authentication features—such as logging in with an email instead of a username. In such cases, we extend the User model to customize authentication.

🚀 Why Extend the User Model?
✔ Modify authentication logic (e.g., using email instead of username). 
✔ Add authentication-specific fields (e.g., phone number, login preferences). 
✔ Ensure flexibility for future authentication changes.

📌 Example Change: 
✔ By default, Django requires a unique username, but email is not unique. 
✔ If we want users to log in with their email, we must add a unique constraint.

1. Creating a Custom User Model
📌 Steps to Extend the User Model: 
✔ Create a new User model that inherits from Django’s AbstractUser. 
✔ Redefine the email field to enforce uniqueness.

📌 Implementation (core/models.py):
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    email = models.EmailField(unique=True)  # ✅ Enforce unique emails
	
	
🚀 Effect: 
✔ A new User model is created with a unique email field. 
✔ Existing authentication logic remains unchanged.




2. Informing Django About the Custom User Model

📌 Django Needs to Know Which User Model to Use 
✔ Modify settings.py to reference the new User model.

📌 Implementation (settings.py):
AUTH_USER_MODEL = 'core.User'  # ✅ Tell Django to use the custom User model

🚀 Effect: 
✔ Ensures Django uses the new User model instead of the default. 
✔ All future references to User will now point to core.User.




3. Resolving Foreign Key Issues in Other Apps

📌 Problem: 
✔ Other apps (e.g., likes) may reference the default auth_user model. 
✔ Since we changed the user model, we must update these references.

📌 Solution: Use settings.AUTH_USER_MODEL Instead of Hardcoding User 
✔ Modify apps that have foreign keys to User.

📌 Implementation (likes/models.py):
from django.conf import settings
from django.db import models

class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)  # ✅ Dynamically reference user model
	
🚀 Effect: 
✔ Prevents direct dependency on auth_user. 
✔ Ensures compatibility with future authentication changes.




4. Handling Migrations and Database Updates
📌 Problem: 
✔ Since we changed the user model, existing migrations may not apply correctly. 
✔ Django may throw errors related to user dependencies.

📌 Solution: 
Create Fresh Migrations and Reinitialize the Database

📌 Steps: 
✔ Create migrations for the new User model:
python manage.py makemigrations

✔ Apply migrations:
python manage.py migrate

🚀 Effect: 
✔ The database now uses the new User model.

📌 If Migration Errors Occur: 
✔ Some applications depend on the default user model, causing errors. 
✔ If necessary, drop and recreate the database (only if changing mid-project).




5. Registering Custom User Model in Django Admin
📌 Problem: 
✔ The Django Admin panel does not automatically recognize the new User model. 
✔ We must register it manually.

📌 Solution: Register the Model in core/admin.py
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib import admin
from .models import User

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'password1', 'password2', 'email', 'first_name', 'last_name'),
        }),
    )
	
🚀 Effect: 
✔ Users can now be managed in Django Admin. 
✔ Adds email, first name, and last name to user creation form.

📌 Testing:
✔ Create a new user via Django Admin. 
✔ Ensure email is now required and unique.




codes in this lesson:
core/models.py:
from django.contrib.auth.models import AbstractUser
from django.db import models

# Create your models here.
class User(AbstractUser):
  email = models.EmailField(unique=True)


settings.py:
AUTH_USER_MODEL = 'core.User'

likes/models.py:
from django.conf import settings
from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey


class LikedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey()


core/admin.py:
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'password1', 'password2', 'email', 'first_name', 'last_name'),
        }),
    )





📌 Key Takeaways
✔ Extended the User model to support unique email authentication.
✔ Modified settings to reference the new user model. 
✔ Updated foreign key references to ensure compatibility. 
✔ Handled migrations to apply changes safely. 
✔ Registered the new user model in Django Admin for easy management. 
✔ Next steps: Exploring different authentication mechanisms and login methods!













Creating User Profiles:
-----------------------
A user profile allows applications to store extra user information beyond authentication details. Instead of modifying the authentication system, we create a separate model for user profiles.

🚀 Why Create a User Profile?
✔ Keeps authentication separate from user details → The built-in User model handles authentication only. 
✔ Makes applications reusable → The profile model can adapt to different user models across projects. 
✔ Ensures flexibility → Multiple apps (Sales, HR, Training) can have different profiles linked to users.

📌 Example Use Case: 
✔ A customer profile in an e-commerce app should store details like membership, phone number, and birthdate. 
✔ These do not belong in the authentication system, so they are stored separately.

1. Creating the User Profile Model
📌 Steps: 
✔ Define a Customer model as a one-to-one relationship with the User model. 
✔ Reference settings.AUTH_USER_MODEL instead of hardcoding the User model.

📌 Implementation (models.py):
from django.conf import settings
from django.db import models
from django.contrib import admin

class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE
    )
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )  # ✅ Establish one-to-one link with User

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
		
🚀 Effect: 
✔ Customer stores additional details for each user, without modifying the User model. 
✔ Uses one-to-one relationship (OneToOneField) to link each customer to a user. 
✔ Ensures flexibility—works with any user model across different projects.




2. Updating the Django Admin Panel
📌 Problem: 
✔ The Customer model is not automatically registered in Django Admin. 
✔ Sorting by first and last name does not work properly.

📌 Solution: 
✔ Register the model in admin.py. 
✔ Optimize sorting using admin.display.

📌 Implementation (admin.py):
from django.contrib import admin
from .models import Customer
from django.urls import reverse
from django.utils.http import urlencode
from django.utils.html import format_html
from django.db.models import Count

@admin.register(Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'membership', 'orders']  # ✅ Display first & last name dynamically
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']  # ✅ Optimize queries
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']

    @admin.display(ordering='orders_count')
    def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist') + '?' + urlencode({'customer__id': str(customer.id)})
        )
        return format_html('<a href="{}">{} Orders</a>', url, customer.orders_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(orders_count=Count('order'))
		
🚀 Effect: 
✔ Enables customer management in Django Admin. 
✔ Allows sorting customers by first and last name. 
✔ Optimizes queries using list_select_related to prevent redundant lookups.




3. Handling Migrations and Database Updates
📌 Problem: 
✔ Adding user as a non-nullable field requires default values for existing customers. 
✔ Without a default, Django will not apply migrations properly.

📌 Solution: 
✔ Provide a temporary default value when running migrations.

📌 Steps: 
✔ Create a migration for adding the user field:
python manage.py makemigrations

✔ Django will prompt for a default value → Choose 1 (Admin User ID). 
✔ Apply the migration:
python manage.py migrate

🚀 Effect: 
✔ The Customer model now links each user to their profile. 
✔ Older customers are temporarily assigned to Admin (ID = 1).

📌 Verifying Changes in the Database: 
✔ Refresh the customer table → user_id is now a foreign key to the user table. 
✔ First name, last name, and email columns are removed (handled via the linked user model).




4. Testing in Django Admin
📌 Step 1: Create a New Customer 
✔ Go to Admin → Customers → Add Customer. 
✔ Provide phone, membership level, and select a user from the dropdown. 
✔ Save → A new customer profile is linked to the selected user.

📌 Step 2: Sorting Customers by Name 
✔ Before fixing → Sorting does not work by first or last name. 
✔ After fixing → Sorting works correctly, allowing admin users to organize customers efficiently.

📌 Step 3: Verify Customer List in Admin 
✔ Customers now display first name and last name dynamically. 
✔ Sorting, searching, and linking to orders work as expected.





Codes in this lesson:
models.py:
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
		
		
admin.py:
@admin.register(models.Customer)
class CustomerAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name',  'membership', 'orders']
    list_editable = ['membership']
    list_per_page = 10
    list_select_related = ['user']
    ordering = ['user__first_name', 'user__last_name']
    search_fields = ['first_name__istartswith', 'last_name__istartswith']

    @admin.display(ordering='orders_count')
    def orders(self, customer):
        url = (
            reverse('admin:store_order_changelist')
            + '?'
            + urlencode({
                'customer__id': str(customer.id)
            }))
        return format_html('<a href="{}">{} Orders</a>', url, customer.orders_count)

    def get_queryset(self, request):
        return super().get_queryset(request).annotate(
            orders_count=Count('order')
        )
		




📌 Key Takeaways
✔ Created a user profile model (Customer) with a one-to-one relationship to User. 
✔ Used settings.AUTH_USER_MODEL to ensure compatibility with any user model. 
✔ Registered the profile model in Django Admin with optimized sorting and search functionality. 
✔ Handled database migrations safely to link existing customers to users. 
✔ Next steps: Implementing authentication features with Django’s built-in login system!












Groups and Permissions:
-----------------------
Django provides a built-in permissions system, allowing users to manage access rights across different models. Instead of assigning permissions individually, groups help organize users into roles with predefined permissions.

🚀 What Are Groups and Permissions?
✔ Permissions → Define what users can and cannot do (e.g., view, add, change, delete). 
✔ Groups → Collections of permissions that can be assigned to multiple users for easier management.

📌 Example Use Case: 
✔ Instead of manually assigning permissions to each customer service representative, we create a Customer Service Group with permissions to manage customers and orders. 
✔ Users added to this group inherit these permissions automatically.




1. Understanding Django's Built-in Permissions System
📌 Django Automatically Creates Permissions for Each Model 
✔ When a model is migrated, Django generates four permissions:

Permission	    Purpose
add_<model>	    Allows adding new records
change_<model>	Allows modifying records
delete_<model>	Allows removing records
view_<model>	Allows reading records

🚀 Effect: ✔ Every model has its own set of permissions, stored in the auth_permission table.

📌 Locating Permissions in the Database (auth_permission Table) ✔ Each permission includes:
id → Unique identifier.
name → Human-readable name (Can view user).
codename → Unique string for referencing in code (view_user).
content_type_id → Links permission to a specific model (via django_content_type).

✔ Example Record:
id | name         | codename    | content_type_id
---|-------------|------------|----------------
32 | Can view user | view_user  | 19  # Linked to "User" model

🚀 Effect: ✔ Ensures permissions are tied to specific models, allowing precise access control.




2. Creating a Group in Django Admin
📌 Steps to Create a "Customer Service" Group 
✔ Navigate to Django Admin → Groups → Add Group. 
✔ Name the group Customer Service. 
✔ Select permissions for managing customers and orders:
	view_customer, add_customer, change_customer, delete_customer
	view_order, add_order, change_order, delete_order ✔ Save the group.

🚀 Effect: ✔ The Customer Service Group now has predefined permissions, making role management easier.




3. Assigning a User to a Group
📌 Steps to Assign "John Smith" to Customer Service Group 
✔ Navigate to Django Admin → Users → John Smith. 
✔ Mark John as a Staff Member (needed for admin access). 
✔ Select Customer Service Group under "Groups". ✔ Save changes.

🚀 Effect: 
✔ John now inherits all group permissions, allowing him to manage customers and orders. 
✔ Admin users do not need individual permission assignments.

📌 Verifying Permissions 
✔ Log out and log in as John Smith. 
✔ John can now access Django Admin, but only manage customers and orders—no extra permissions.




4. Where Are Groups Stored in the Database?
📌 Django Stores Groups in the auth_group Table 
✔ Groups are assigned to users via the auth_user_groups Table.

Table Name	             Purpose
auth_group	             Stores group names
auth_group_permissions	 Stores permissions assigned to groups
auth_user_groups	     Links users to groups

🚀 Effect: 
✔ Each user can belong to multiple groups for flexible role management. 
✔ Groups streamline permission assignments, reducing manual effort.




📌 Key Takeaways
✔ Permissions allow granular control over user actions. 
✔ Groups simplify user management by bundling permissions together. 
✔ Django automatically generates permissions for each model. 
✔ Users assigned to groups inherit permissions dynamically. 
✔ Next steps: Creating custom permissions for specific business needs!















Creating Custom Permissions: 
----------------------------
Django provides built-in permissions (add, change, delete, view), but sometimes certain actions don’t fit these categories. Custom permissions allow fine-grained control over user actions.

🚀 Why Create Custom Permissions?
✔ Certain operations don’t fit into add, change, or delete (e.g., canceling an order). 
✔ Users should have permission for specific actions (e.g., canceling orders without full update access). 
✔ Fine-grained control over user access → Assign permissions without affecting broader roles.

📌 Example Use Case: 
✔ We want users to cancel orders, but not edit other order details. 
✔ Built-in update permission (change_order) allows too much access — we need a custom permission.

1. Defining Custom Permissions in a Model
📌 Steps: 
✔ Add a Meta class inside the model. 
✔ Set permissions as a list of tuples (codename, human-readable name).

📌 Implementation (models.py):
class Order(models.Model):
    status = models.CharField(max_length=20)

    class Meta:
        permissions = [
            ("cancel_order", "Can cancel order"),  # ✅ Custom permission for order cancellation
        ]
		
🚀 Effect: 
✔ Creates a new permission (cancel_order). 
✔ Users can be assigned permission to cancel orders, without broader update access.




2. Applying Migrations to Save Custom Permissions
📌 Steps: 
✔ Generate a migration for the new permission:
python manage.py makemigrations

✔ Apply migrations:
python manage.py migrate

🚀 Effect: 
✔ The new permission appears in the database (auth_permission table).

📌 Verifying in Database (auth_permission Table) 
✔ Open permission table in the database. 
✔ Look for the newly created permission record:
id	name	            codename	    content_type_id
35	Can cancel order	cancel_order	21 (linked to Order)

🚀 Effect: ✔ The permission is correctly linked to the Order model using content_type_id.




3. Assigning Custom Permissions to Users
📌 Steps: 
✔ Navigate to Django Admin → Users → John Smith. 
✔ Search for "cancel order" in the permissions list. 
✔ Select and assign this permission to John Smith. 
✔ Save changes.

🚀 Effect: 
✔ John now has permission to cancel orders, but cannot modify other order details.

📌 Verifying Permissions 
✔ John should be able to cancel orders but not fully update them. 
✔ Next step: Apply permission checks in the API.





Codes in this lession:

models.py:
class Order(models.Model):
    PAYMENT_STATUS_PENDING = 'P'
    PAYMENT_STATUS_COMPLETE = 'C'
    PAYMENT_STATUS_FAILED = 'F'
    PAYMENT_STATUS_CHOICES = [
        (PAYMENT_STATUS_PENDING, 'Pending'),
        (PAYMENT_STATUS_COMPLETE, 'Complete'),
        (PAYMENT_STATUS_FAILED, 'Failed')
    ]

    placed_at = models.DateTimeField(auto_now_add=True)
    payment_status = models.CharField(
        max_length=1, choices=PAYMENT_STATUS_CHOICES, default=PAYMENT_STATUS_PENDING)
    customer = models.ForeignKey(Customer, on_delete=models.PROTECT)

    class Meta:
        permissions = [
            ('cancel_order', 'Can cancel order')
        ]




📌 Key Takeaways
✔ Custom permissions allow fine-grained control over user actions. 
✔ Defined in the Meta class inside models using permissions list. 
✔ Stored in the auth_permission table after migrations are applied. 
✔ Assigned to users via Django Admin or programmatically. 
✔ Next steps: Implementing permission checks in the API to enforce security!













Securing APIs:
--------------
Introduction:

In this section, you're going to learn how to secure your API endpoints using permissions. So we'll start off by talking about token-based authentication, which is the de facto standard for authenticating users with RESTful APIs. Then we'll add authentication endpoints to our API and allow users to register, log in, log out, and so on. And finally, we'll apply a bunch of permissions to some of our API endpoints so they are not accessible by just anyone. So now let's jump in and get started.

In this section: 
Token-based authentication
Adding authentication endpoints
Registering, logging in, etc
Applying permissions






Token-based Authentication:
---------------------------
Token-based authentication is the standard approach for securing RESTful APIs. It allows clients to authenticate and access protected resources using tokens instead of session-based authentication.

🚀 How Token-Based Authentication Works
✔ Step 1: User Registration → The client sends user details to the server, which creates an account. 
✔ Step 2: User Login → The client sends credentials (username & password) to the authentication endpoint. 
✔ Step 3: Token Generation → If credentials are valid, the server returns a token to the client. 
✔ Step 4: Client Stores Token → The token is stored locally (in memory, local storage, or cookies). 
✔ Step 5: Accessing Protected Resources → The client sends requests with the token in the header. 
✔ Step 6: Token Validation → The server verifies the token before granting access.

🚀 Effect: ✔ Users authenticate once, then use a token for future requests instead of re-entering credentials.


1. Registering a New User
📌 Client Request (POST /users/) 
✔ The client sends registration details to the server:
json
{
    "username": "johnsmith",
    "email": "john@example.com",
    "password": "securepassword"
}

🚀 Effect: ✔ The server stores user details and creates an account.




2. Logging In & Obtaining a Token
📌 Client Request (POST /auth/login/) 
✔ The client sends credentials to the authentication endpoint:
json
{
    "username": "johnsmith",
    "password": "securepassword"
}

📌 Server Response (200 OK) 
✔ If credentials are valid, the server returns a token:
json
{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

🚀 Effect: 
✔ The client stores this token locally for future authentication.




3. Accessing Protected Resources

📌 Client Request (GET /users/profile/) 
✔ The client sends a request with the token in the header:

http
GET /users/profile/
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

🚀 Effect: ✔ The server validates the token and grants access if it’s valid and not expired.




4. Token Expiration & Validation
📌 Token Validation Process on Server 
✔ The server checks:
Is the token correctly formatted?
Has the token expired?
Is the token issued for this user?

📌 Server Response for Invalid Token (401 Unauthorized) 
✔ If the token is expired or invalid, access is denied:
json
{
    "detail": "Token is invalid or expired."
}

🚀 Effect: ✔ Users must log in again to obtain a new token.




📌 Key Takeaways
✔ Token-based authentication eliminates the need for repeated logins. 
✔ Clients send a token in the header to access protected resources. 
✔ Tokens must be validated on the server before granting access. 
✔ Expired or invalid tokens require re-authentication. 
✔ Next steps: Implementing token-based authentication in Django REST Framework!











Adding the Authentication Endpoints:
------------------------------------

Django provides a full-fledged authentication system, but it does not include an API layer. This means there are no built-in endpoints for user registration, login, logout, or password reset. Instead of building this manually, we use Djoser, a RESTful authentication implementation.

🚀 What Is Djoser?
✔ Djoser extends Django’s authentication system with a set of API endpoints. 
✔ Provides ready-made views for user registration, login, logout, password reset, and account management. 
✔ Eliminates the need to manually implement authentication APIs.

📌 Example Endpoints Added by Djoser: 
✔ /auth/users/ → Manage users 
✔ /auth/users/me/ → Get current user 
✔ /auth/token/login/ → Login 
✔ /auth/token/logout/ → Logout 
✔ /auth/users/reset_password/ → Password reset

🚀 Effect: 
✔ All authentication-related functionality is available via API. 
✔ The backend does the heavy lifting, while frontend apps simply call these endpoints.

🔗 Djoser Documentation: https://djoser.readthedocs.io/en/latest/




1. Installing Djoser and Required Libraries
📌 Step 1: Install Djoser
pipenv install djoser

🚀 Effect: 
✔ Djoser is added to the project, enabling authentication APIs.


📌 Step 2: Add Djoser to INSTALLED_APPS (settings.py)
INSTALLED_APPS = [
    ...
    'rest_framework',  # ✅ REST Framework
    'djoser',  # ✅ Djoser authentication API
]

🚀 Effect: ✔ The app recognizes Djoser, enabling built-in authentication endpoints.




2. Choosing an Authentication Backend
Djoser does not handle authentication directly—it relies on an authentication backend to validate credentials.

✔ Two Options: 
1.Token-Based Authentication (rest_framework.authtoken) → Stores authentication tokens in the database. 
2. JSON Web Token (JWT) Authentication (rest_framework_simplejwt) → Uses signed tokens, eliminating database queries.

🚀 JWT Authentication Is Preferred 
✔ Does not require a database lookup for token validation. 
✔ Uses digital signatures to verify authenticity.

📌 Step 1: Install Simple JWT Library
pipenv install djangorestframework-simplejwt

📌 Step 2: Configure JWT Authentication in Django (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
}
🚀 Effect: ✔ The backend now uses JWT tokens for authentication.

📌 Step 3: Configure JWT Settings (settings.py)
SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),  # ✅ Prefix authentication tokens with 'JWT'
}

🚀 Effect: ✔ When sending a request, tokens must be prefixed with JWT in the header. 
✔ Example:
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...




3. Registering Authentication Routes in Django URLs
📌 Step 1: Add Djoser Routes to urls.py
from django.urls import path, include

urlpatterns = [
    ...
    path('auth/', include('djoser.urls')),  # ✅ Core authentication endpoints
    path('auth/', include('djoser.urls.jwt')),  # ✅ JSON Web Token endpoints
]

🚀 Effect: 
✔ Users can register, login, logout, and reset passwords via API calls. 
✔ JWT tokens can be generated and validated via the authentication routes.

📌 Step 2: Test Endpoints in Browser 
✔ Visit /auth/users/ → Should return 401 Unauthorized (protected). 
✔ Visit /auth/token/login/ → Users can authenticate.




4. Validating Authentication API
📌 Step 1: Attempt to Access /auth/users/ Without Authentication 
✔ Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: 
✔ Users must log in and obtain a JWT token to access protected endpoints.


📌 Step 2: Login and Obtain a Token (POST /auth/token/login/) 
✔ Request Body:
json
{
    "username": "johnsmith",
    "password": "securepassword"
}

✔ Expected Response:
json
{
    "auth_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
🚀 Effect: ✔ Token is generated—now the client can authenticate future requests.


📌 Step 3: Access /auth/users/ Using Token 
✔ Request Header:
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

🚀 Effect: 
✔ The request is authenticated, and the user can retrieve their account details.



codes/notes in this lesson:

https://djoser.readthedocs.io/en/latest/


pipenv install djoser


AUTH Engines:
Token-based Authentication
JSON Web Token Authentication



📌 Key Takeaways
✔ Django’s authentication system lacks an API layer—Djoser provides it. 
✔ Djoser simplifies user registration, login, logout, and password reset via API. 
✔ Authentication backend choices: Token-based (authtoken) vs. JWT-based (simplejwt). 
✔ JWT authentication eliminates database queries, improving performance. 
✔ Protected endpoints require authentication tokens in the request header. 
✔ Next steps: Registering users and implementing authentication workflows!












Registering the Users:
----------------------

Djoser provides a ready-to-use API layer for Django’s authentication system, allowing users to register, login, and manage accounts via RESTful endpoints.

🚀 Steps for User Registration
✔ Step 1: Users send a POST request to /auth/users/ with their registration details. 
✔ Step 2: Django validates the input, including password strength checks. 
✔ Step 3: Upon successful registration, a new user ID is returned. 
✔ Step 4: Users can customize registration by extending the serializer to include additional fields.


1. Validating User Registration
📌 Client Request (POST /auth/users/)
json
{
    "email": "user1@domain.com",
    "username": "user1",
    "password": "ILoveDjango"
}

🚀 Effect: 
✔ The request is processed, and a new user is created. 
✔ Password strength checks validate security requirements.

📌 Password Validation (AUTH_PASSWORD_VALIDATORS in settings.py)
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

🚀 Effect: 
✔ Ensures passwords meet minimum security criteria.

📌 Common Validation Errors 
✔ Too short → "Ensure this value has at least 8 characters." 
✔ Too common → "This password is too common." 
✔ Entirely numeric → "This password is entirely numeric."




2. Customizing the Registration Serializer
📌 Problem: 
✔ By default, Djoser does not capture first name & last name in registration. 
✔ To include additional fields, we need to override Djoser’s serializer.

📌 Solution: Extend Djoser’s Default Serializer (UserCreateSerializer) 
✔ Create a new serializer in core/serializers.py 
✔ Add fields for first name, last name 
✔ Register the serializer in settings.py

📌 Implementation (core/serializers.py)
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer

class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password', 'email', 'first_name', 'last_name']  # ✅ Includes additional fields
		
🚀 Effect: 
✔ First name & last name are now included in registration requests.

📌 Register the Custom Serializer (settings.py)
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
    }
}

🚀 Effect: 
✔ Djoser now uses our custom serializer for handling user registration.




3. Testing Registration with Custom Fields
📌 Client Request (POST /auth/users/)
json
{
    "username": "user2",
    "password": "ILoveDjango",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

✔ Expected Response:
json
{
    "id": 4,
    "username": "user2",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

🚀 Effect: 
✔ User is successfully created with first & last name included.




4. Handling Profile Data Separately
📌 Why Not Include Profile Fields in Registration? 
✔ The User model handles authentication, while the Customer model manages profile details. 
✔ Mixing profile fields violates separation of concerns—each component should handle one responsibility.

📌 Correct Approach: Two Separate API Calls 
✔ First request: Register user (POST /auth/users/) → Handles authentication fields. 
✔ Second request: Create a profile (POST /profiles/) → Stores profile-specific data (e.g., birthdate, address).

🚀 Effect: 
✔ More maintainable API → Authentication and profile management remain independent. 
✔ Better flexibility → Profile features can evolve separately from authentication logic.




codes and other notes in this lesson:

127.0.0.1:8000/auth/users/


AUTH_PASSWORD_VALIDATORS = {....}

POST:
{
	"email":"user1@domain.com",
	"username":"user1",
	"password":"ILoveDjango"
}
	
	
core/serializers.py:
from djoser.serializers import UserCreateSerializer as BaseUserCreateSerializer


class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password',
                  'email', 'first_name', 'last_name']




settings.py:
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
    }
}


POST:
{    
	"username":"user2",
	"password":"ILoveDjango",
	"email":"user2@domain.com",
	"first_name": "Joe", 
	"last_name": "Smith"
}
	





📌 Key Takeaways
✔ Djoser provides an easy way to register users via REST API. 
✔ Password validation ensures strong security standards. 
✔ Custom serializers allow capturing additional user fields. 
✔ User authentication and profile management should remain separate for scalability. 
✔ Next steps: Implementing the profile API for managing user details!












Building the Profile API:
-------------------------
Djoser handles user authentication, but user profiles are specific to an application. Since Djoser does not provide profile-related endpoints, we need to build a customer profile API ourselves.

🚀 Steps to Implement the Profile API
✔ Step 1: Create a serializer for the Customer model to expose relevant fields. 
✔ Step 2: Define a viewset with only necessary operations (create, retrieve, update). 
✔ Step 3: Register the endpoint in urls.py to make it accessible via API. 
✔ Step 4: Ensure that user profiles are linked to authenticated users.

1. Creating the Customer Serializer
📌 Purpose: 
✔ The CustomerSerializer controls data representation, ensuring only essential profile fields are exposed. 
✔ Explicitly define user_id since Django does not automatically include it in model serializers.

📌 Implementation (serializers.py):
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)  # ✅ Ensures `user_id` is correctly referenced

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']  # ✅ Exposes profile data

🚀 Effect: 
✔ Displays user ID, phone number, birth date, and membership status when retrieving customer data. 
✔ Prevents user_id from being modified directly—user is assigned via authentication.




2. Defining the Customer ViewSet
📌 Purpose: 
✔ We don’t need all CRUD operations—only create, retrieve, and update are necessary. 
✔ Users should manage their own profiles, not see a list of all customers.

📌 Implementation (views.py):
class CustomerViewSet(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet):
    queryset = Customer.objects.all()  # ✅ Retrieves customer records
    serializer_class = CustomerSerializer  # ✅ Uses the serializer to structure responses
	
🚀 Effect: 
✔ Ensures users can create, retrieve, and update their profiles. 
✔ Does not allow deleting customers, as profiles should be automatically removed when users are deleted. 
✔ Does not return a list of all customers, preventing unnecessary exposure of user data.




3. Registering the Profile API Route
📌 Purpose: 
✔ Adds a /customers/ endpoint for managing user profiles. 
✔ Ensures API clients can interact with user profiles via structured requests.

📌 Implementation (urls.py):
router.register('customers', views.CustomerViewSet)  # ✅ Registers `/customers/` endpoint

🚀 Effect: 
✔ POST /customers/ → Creates a customer profile. 
✔ GET /customers/{id}/ → Retrieves a specific profile. 
✔ PATCH /customers/{id}/ → Updates profile details.

📌 Accessing the API in Browser: 
✔ Visit 127.0.0.1:8000/store/customers/ → Shows profile management options.




4. Testing the Profile API
📌 Step 1: Creating a Profile (POST /customers/) 
✔ Client Request:
json
{
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

✔ Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}
🚀 Effect: ✔ A profile is created for User 4 with the specified attributes.


📌 Step 2: Retrieving the Profile (GET /customers/1/) 
✔ Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

🚀 Effect: 
✔ Users can retrieve their profile details via API.


📌 Step 3: Updating the Profile (PATCH /customers/1/) 
✔ Client Request:
json
{
    "phone": "9876"
}

✔ Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "9876",
    "birth_date": "2000-01-01",
    "membership": "B"
}

🚀 Effect: 
✔ Users successfully update profile details.




5. Improving API Security
📌 Problem: 
✔ Right now, anyone can manually specify a user_id when creating a profile. 
✔ Authenticated users should automatically be linked to their profile, removing the need for user_id input.

📌 Solution: Extract user_id From JWT Token Instead of Request Body 
✔ Authenticate users before allowing profile creation. 
✔ Retrieve user_id from token instead of passing it manually in the request.

🚀 Effect: 
✔ Only authenticated users can manage their own profile. 
✔ Prevents unauthorized users from modifying other users’ profiles.

📌 Next Steps: 
✔ Implement authentication checks to secure the profile API. 
✔ Use JWT tokens to link users without requiring user_id in requests.





Codes/Notes in this lesson:
serializers.py:
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']        




views.py:
class CustomerViewSet(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet):
	queryset = Customer.objects.all()
	serializer_class = CustomerSerializer
	
	
	
urls.py:
router.register('customers', views.CustomerViewSet)



POST:
{
	"user_id" : 4,
	"phone": "1234"
	"birth_date": 2000-01-01"
	"membership": "B"
}




📌 Key Takeaways
✔ Djoser manages authentication, but profiles must be implemented separately. 
✔ The Profile API enables users to manage personal details. 
✔ The ViewSet only includes necessary actions (create, retrieve, update). 
✔ User authentication should be enforced to prevent unauthorized profile modifications. 
✔ Next steps: Implementing authentication checks to secure the profile API!













Logging In:
-----------

Django REST Framework provides two authentication backends: 
1. Token-Based Authentication → Requires a database lookup for each request. 
2. JWT Authentication → Uses digitally signed tokens, eliminating the need for a database query.

In this implementation, we use JWT for authentication since it's more efficient.

🚀 Steps for Logging In
✔ Step 1: Users send a POST request to /auth/jwt/create/ with credentials. 
✔ Step 2: If credentials are valid, the server responds with two tokens (Access & Refresh). 
✔ Step 3: The client stores the access token to authenticate future requests. 
✔ Step 4: If the access token expires, the client requests a new one using the refresh token.

📌 Login Endpoint
http
POST /auth/jwt/create/

🚀 Effect: ✔ Authenticates the user and provides tokens for securing API calls.




1. Authenticating Users via API
📌 Client Request (POST /auth/jwt/create/) 
✔ Users send their username and password for authentication:
json
{
    "username": "user1",
    "password": "ILoveDjango"
}

📌 Possible Responses: ✔ Success (200 OK)
json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

✔ Failure (401 Unauthorized)
json
{
    "detail": "No active account found with the given credentials."
}

🚀 Effect: 
✔ The server verifies credentials, returning tokens if valid. 
✔ Incorrect credentials result in a 401 Unauthorized error.




2. Understanding Access & Refresh Tokens
📌 Access Token 
✔ Short-lived token (~5 minutes by default). 
✔ Used to authenticate API requests. 
✔ Expires quickly for security reasons.

📌 Refresh Token 
✔ Long-lived token (~1 day by default). 
✔ Used to generate a new access token once expired.

🚀 Effect: 
✔ Clients use the access token for authentication. 
✔ When the access token expires, the refresh token generates a new one instead of logging in again.




3. Configuring Token Expiration in Django
📌 Default Token Lifetimes (SIMPLE_JWT in settings.py)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),  # ✅ Access token expires in 5 minutes
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),  # ✅ Refresh token expires in 1 day
}

📌 Increasing Access Token Lifetime (Example)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),  # ✅ Extends validity to 1 day
}

🚀 Effect: 
✔ The access token now remains valid for 1 day, reducing re-authentication overhead.




4. Storing Tokens on the Client
📌 Problem: 
✔ The server does not store JWT tokens — clients must manage authentication.

📌 Solution: 
✔ Web apps store tokens inside browser local storage. 
✔ Mobile apps store tokens in secure local storage provided by the platform.

🚀 Effect: 
✔ Clients send the stored token in every API request header for authentication.

📌 Example Request Using JWT
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

✔ Sent in every request to protected endpoints.

📌 How to Logout? 
✔ Remove the tokens from local storage. 
✔ No need to call an API — JWT tokens are not stored on the server. (Because these tokens are not stored in a database. That's why we're using JSON web tokens.) 




Codes and other notes in this lesson:
loggin endpoint:
127.0.0.1:8000/auth/jwt/create/


POST:
{
	"username": "user1",
	"password": "ILoveDjango"
}



google django rest framework simplejwt : https://django-rest-framework-simplejwt.readthedocs.io/en/latest/




📌 Key Takeaways
✔ Users authenticate via /auth/jwt/create/ by sending credentials. 
✔ If valid, Django returns an access and refresh token. 
✔ Tokens must be stored by the client for future authentication requests. 
✔ Access tokens expire quickly (~5 minutes), requiring a refresh token to generate a new one. 
✔ Logging out is handled on the client by deleting stored tokens. 
✔ Next steps: Securing API endpoints using JWT authentication!

🔗 Reference: Django REST Framework Simple JWT Documentation:  https://django-rest-framework-simplejwt.readthedocs.io/en/latest/







Inspecting a JSON Web Token: 
----------------------------
JSON Web Tokens (JWT) are widely used for secure authentication in web applications. A JWT consists of three main components: Header, Payload, and Signature—each serving a specific function.

🚀 JWT Components
✔ Header → Specifies metadata, including the token type (JWT) and the hashing algorithm (HS256). 
✔ Payload → Contains user-related claims (e.g., user ID, expiration time). 
✔ Signature → Ensures data integrity, preventing unauthorized modifications.

📌 Example JWT Structure
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

🚀 Effect: ✔ Encapsulates authentication details in a compact, encoded format.




1. Exploring JWTs with jwt.io
🔗 JWT Debugger (jwt.io) → Allows decoding and inspecting JSON Web Tokens.
📌 Using the Debugger 
✔ Paste a JWT in the left panel. 
✔ The decoded structure appears on the right, showing Header, Payload, and Signature.

📌 Example Decoded JWT
json
{
    "typ": "JWT",
    "alg": "HS256"
}
✔ typ → Token type (JWT). ✔ alg → Algorithm used (HS256).

🚀 Effect: ✔ Helps visualize how JWT data is structured.




2. Understanding the JWT Payload
✔ Contains user-specific claims (e.g., user ID, expiration time). 
✔ Used to identify authenticated users.

📌 Example JWT Payload
json
{
    "token_type": "access",
    "exp": 1712345678,
    "jti": "unique-id-123",
    "user_id": 4
}

✔ token_type → Specifies access or refresh token. 
✔ exp → Expiration timestamp (Unix time). 
✔ jti → Unique identifier for this token. 
✔ user_id → Identifies the authenticated user.

🚀 Effect: ✔ The token automatically carries user credentials, eliminating the need for additional lookups.




3. Why Is the Signature Important?
✔ Prevents token manipulation — ensures integrity. 
✔ Created using a secret key, stored only on the server.

📌 Formula for Signature Generation
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

🚀 Effect: 
✔ If a hacker modifies the payload, the signature must be regenerated. 
✔ Servers reject tokens with mismatched signatures, blocking unauthorized access.

📌 Example Attack Scenario ❌ Changing user_id in JWT
json
{
    "user_id": 1  # Trying to change from "4" to "1"
}

🚀 Outcome: 
✔ The signature does not match, making the token invalid. 
✔ Hacker cannot regenerate the correct signature without access to the server's secret key.




📌 Key Takeaways
✔ JWT consists of Header, Payload, and Signature. 
✔ Payload contains user-specific claims (e.g., user_id, exp). 
✔ The signature prevents unauthorized modifications. 
✔ JWT.io allows debugging and inspecting tokens. 
✔ Next steps: Using JWTs to secure API endpoints!

















Refreshing Tokens:
------------------
JSON Web Tokens expire after a set duration to enhance security. To maintain access to protected resources, clients must refresh their expired access tokens using a refresh token.

🚀 Overview of Token Refreshing
✔ Access Token → Short-lived (~5 minutes by default). Used for making authenticated requests. 
✔ Refresh Token → Longer-lived (~1 day by default). Used to generate a new access token. 
✔ Token Expiration Process → If the access token is expired, the client must request a new access token using the refresh token. 
✔ No Need to Re-login → Instead of asking users to enter credentials again, the refresh token renews the session silently.

🚀 Effect: 
✔ Users stay authenticated without repeatedly logging in. 
✔ The system remains secure by ensuring access tokens expire periodically.


1. Accessing the Refresh Endpoint
📌 Client Request (POST /auth/jwt/refresh/) 
✔ The client sends the refresh token to the server.
json
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

📌 Expected Server Response (200 OK) ✔ The server returns a new access token.
json
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

🚀 Effect: ✔ The client can now use the new access token for future API requests.

📌 Refresh Token Endpoint:
http
POST 127.0.0.1:8000/auth/jwt/refresh/




2. Token Expiration & Renewal Process
📌 Scenario: Calling a Protected API With an Expired Token 
✔ If a request is made with an expired access token, the server responds with:
json
{
    "detail": "Token is invalid or expired."
}

✔ HTTP Status Code: 401 Unauthorized

📌 How to Fix It? 
✔ The client must call /auth/jwt/refresh/ with the refresh token. 
✔ A new access token is issued. 
✔ The client retries the request using the new access token.

🚀 Effect: ✔ Users seamlessly renew authentication without needing to log in again.




3. Configuring Token Expiration in Django
📌 Default Token Expiration Settings (SIMPLE_JWT in settings.py)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),  # ✅ Access tokens expire in 5 minutes
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),  # ✅ Refresh tokens expire in 1 day
}

📌 Extending Access Token Lifetime (Example)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),  # ✅ Keeps access token valid for 1 day
}
🚀 Effect: ✔ Reduces the frequency of token renewals, making authentication more user-friendly.

📌 Import Required Modules in settings.py
from datetime import timedelta  # ✅ Enables custom token lifetimes




Notes in this discussion:
127.0.0.1:8000/auth/jwt/refresh


📌 Key Takeaways
✔ Access tokens expire quickly (~5 minutes) to enhance security. 
✔ Refresh tokens allow clients to obtain new access tokens without logging in.
✔ Expired access tokens trigger a 401 Unauthorized error, requiring renewal. 
✔ Django REST Framework Simple JWT provides configurable token expiration settings. 














Getting the Current User: 
-------------------------

Djoser provides an endpoint for retrieving the authenticated user's details, but requires authentication via an access token.

🚀 Steps to Retrieve the Current User
✔ Step 1: Authenticate the user by logging in (POST /auth/jwt/create/). 
✔ Step 2: Obtain the access token from the login response. 
✔ Step 3: Send a request to /auth/users/me/ with the access token in the request header. 
✔ Step 4: The server responds with the user’s details.

📌 Current User Endpoint (GET /auth/users/me/)http
GET 127.0.0.1:8000/auth/users/me/
Authorization: JWT <access_token>

🚀 Effect: ✔ The server returns authenticated user information.

1. Handling Unauthorized Access
📌 Problem: ✔ If no access token is provided, the server returns a 401 Unauthorized error:
json
{
    "detail": "Authentication credentials were not provided."
}

📌 Solution: ✔ Include Authorization: JWT <access_token> in the request header.

🚀 Effect: ✔ The request is authenticated, allowing access to user details.




2. Adding Authorization Header in Browser (ModHeader Plugin)
📌 Problem: 
✔ Browsers do not allow adding custom headers by default. 
✔ A plugin like ModHeader (Chrome) allows modifying headers for API requests.

📌 Steps to Install ModHeader Plugin: 
✔ Install ModHeader Extension in Chrome. 
✔ Pin the extension for easy access. 
✔ Add the following header:

Name: Authorization
Value: JWT <access_token>

🚀 Effect: ✔ Requests include authentication tokens automatically.
📌 Important Security Note: ✔ Remove the authorization header after testing to prevent authentication issues on other websites.




3. Customizing the Response to Include Additional Fields
📌 Problem: ✔ By default, /auth/users/me/ does not include first & last name.
📌 Solution: ✔ Extend Djoser’s UserSerializer to include these fields.

📌 Implementation (core/serializers.py)
from djoser.serializers import UserSerializer as BaseUserSerializer

class UserSerializer(BaseUserSerializer):
    class Meta(BaseUserSerializer.Meta):
        fields = ['id', 'username', 'email', 'first_name', 'last_name']  # ✅ Include additional fields
		
📌 Register the Custom Serializer in settings.py
DJOSER = {
    'SERIALIZERS': {
        'current_user': 'core.serializers.UserSerializer',
    }
}

🚀 Effect: ✔ The API now returns first & last name for authenticated users.




4. Testing the Updated Endpoint
📌 Client Request (GET /auth/users/me/) 
✔ With authentication token in header:
http
Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

✔ Expected Response:
json
{
    "id": 4,
    "username": "user2",
    "email": "user2@domain.com",
    "first_name": "Joe",
    "last_name": "Smith"
}

🚀 Effect: ✔ Users successfully retrieve their personal account details.





codes/notes in this lesson:
127.0.0.1:8000/auth/users/me 


modheader

SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('JWT',),
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1)
}



core/serializers.py:
from djoser.serializers import UserSerializer as BaseUserSerializer, UserCreateSerializer as BaseUserCreateSerializer

class UserCreateSerializer(BaseUserCreateSerializer):
    class Meta(BaseUserCreateSerializer.Meta):
        fields = ['id', 'username', 'password',
                  'email', 'first_name', 'last_name']


class UserSerializer(BaseUserSerializer):
    class Meta(BaseUserSerializer.Meta):
        fields = ['id', 'username', 'email', 'first_name', 'last_name']
		
		
settings.py:
DJOSER = {
    'SERIALIZERS': {
        'user_create': 'core.serializers.UserCreateSerializer',
        'current_user': 'core.serializers.UserSerializer',
    }
}





📌 Key Takeaways
✔ Authenticated users retrieve their details via /auth/users/me/. 
✔ Requests require an access token for authentication. 
✔ Unauthorized requests (401) must include the Authorization header. 
✔ Custom serializers allow returning extra fields like first and last name. 
✔ Remove authorization headers in ModHeader after use for security. 











Getting Current User's Profile:
------------------------------
Now that users can register and authenticate, they need a way to retrieve and update their profile details via an API endpoint.

🚀 Steps to Implement the Profile API
✔ Step 1: Define a custom action (me) in CustomerViewSet. 
✔ Step 2: Retrieve the authenticated user's profile using request.user.id. 
✔ Step 3: Allow users to update their profile information via PUT. 
✔ Step 4: Ensure that only authenticated users can access this endpoint.

📌 Current User Profile Endpoint (GET /store/customers/me/)
http
GET 127.0.0.1:8000/store/customers/me/
Authorization: JWT <access_token>

🚀 Effect: ✔ The server returns the authenticated user's profile details.




1. Implementing the me Action in CustomerViewSet
📌 Purpose: 
✔ Retrieves the customer profile linked to the authenticated user. 
✔ Allows users to update their profile details (phone, birth date, membership).

📌 Implementation (views.py)
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)

        if request.method == 'GET':  # ✅ Retrieve current user's profile
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)

        elif request.method == 'PUT':  # ✅ Update profile details
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
🚀 Effect: 
✔ Users can retrieve their profile (GET) or update it (PUT). 
✔ Ensures only authenticated users can access the endpoint.




2. Implementing the CustomerSerializer
📌 Purpose: 
✔ Defines which fields are exposed in the profile API. 
✔ Ensures user_id is read-only, preventing users from associating their profile with another account.

📌 Implementation (serializers.py)
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)  # ✅ Prevents user ID modification

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']
		
🚀 Effect: ✔ Users can update only their profile details (phone, birth date, membership).




3. Testing the Profile API

📌 Step 1: Retrieve Current User’s Profile (GET /store/customers/me/) ✔ Client Request:
http
Authorization: JWT <access_token>
GET 127.0.0.1:8000/store/customers/me/

✔ Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}
🚀 Effect: ✔ Users successfully retrieve their profile details.

📌 Step 2: Updating the Profile (PUT /store/customers/me/) 
✔ Client Request:
json
{
    "phone": "9876",
    "birth_date": "1998-05-15",
    "membership": "G"
}

✔ Expected Response:
json
{
    "id": 1,
    "user_id": 4,
    "phone": "9876",
    "birth_date": "1998-05-15",
    "membership": "G"
}
🚀 Effect: ✔ Users successfully update profile details.

📌 Step 3: Ensuring Unauthorized Users Cannot Access Profile (GET /store/customers/me/ Without Token) 
✔ Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: ✔ Users must authenticate before accessing profile details.






codes/notes in this lesson:
The endpoint: 127.0.0.1:8000/store/customers/me


views.py:
from rest_framework.decorators import action


class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
			
serializers.py:
class CustomerSerializer(serializers.ModelSerializer):
    user_id = serializers.IntegerField(read_only=True)

    class Meta:
        model = Customer
        fields = ['id', 'user_id', 'phone', 'birth_date', 'membership']    






📌 Key Takeaways
✔ The /store/customers/me/ endpoint allows authenticated users to retrieve & update their profile. 
✔ Users must send an access token in the request header for authentication. 
✔ Only authorized users can modify their profile—user_id is read-only. 
✔ Requests without authentication fail with 401 Unauthorized. 
✔ Next steps: Implementing permission checks to fully secure the API!











Applying Permissions: 
---------------------
Permissions control who can access API endpoints. By default, Django REST Framework allows unrestricted access (AllowAny), but we can restrict endpoints globally or per view.

🚀 Types of Permission Classes
✔ AllowAny → Open access (default setting). 
✔ IsAuthenticated → Requires users to be logged in. 
✔ IsAdminUser → Grants access only to admin users. 
✔ IsAuthenticatedOrReadOnly → Authenticated users can modify data, others can only read. 
✔ Custom Permissions → Define custom rules for access control.

📌 Reference: Django REST Framework - Permissions https://www.django-rest-framework.org/api-guide/permissions/

🚀 Effect: ✔ Ensures API endpoints remain secure and accessible only to authorized users.

1. Applying Permissions Globally
📌 Purpose: 
✔ Restricts all API endpoints to authenticated users. 
✔ Ensures every request must be logged in.

📌 Implementation (settings.py)
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated'  # ✅ Requires authentication globally
    ]
}

🚀 Effect: 
✔ All API requests require authentication (except explicitly overridden views). 
✔ Requests without authentication return 401 Unauthorized.

📌 Example Unauthorized Request (GET /store/products/ Without Token)
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: 
✔ Anonymous users cannot access any API endpoints.




2. Applying Permissions to Specific Views
📌 Purpose: 
✔ Restricts access to specific views, overriding global permissions.

📌 Implementation (views.py)
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAuthenticated]  # ✅ Requires login for customer-related actions
	
🚀 Effect: ✔ Only authenticated users can interact with customer profiles.




3. Defining Different Permissions for Each Action
📌 Problem: ✔ Some actions should be public (GET requests) while others require authentication (PUT, POST).

📌 Solution: ✔ Override get_permissions() in the viewset. 
✔ Apply different permissions based on the request method.

📌 Implementation (views.py)
from rest_framework.permissions import AllowAny, IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    def get_permissions(self):
        if self.request.method == 'GET':  # ✅ Public access for retrieving customer data
            return [AllowAny()]
        return [IsAuthenticated()]  # ✅ Authentication required for modifying customer data

🚀 Effect: ✔ GET requests are open to everyone. 
✔ POST, PUT, DELETE require authentication.

📌 Example Scenario (GET /store/customers/2/ Without Token) 
✔ Expected Response (Success):
json
{
    "id": 2,
    "user_id": 5,
    "phone": "1234",
    "birth_date": "2000-01-01",
    "membership": "B"
}

📌 Example Scenario (PUT /store/customers/2/ Without Token) 
✔ Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: ✔ Ensures public read access but restricts modifications to authenticated users.




4. Applying Permissions to Specific Actions
📌 Purpose: ✔ Ensures fine-grained access control for individual actions.

📌 Implementation (views.py)
from rest_framework.decorators import action

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ✅ Restricts access to authenticated users
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)

🚀 Effect: 
✔ Ensures only authenticated users can retrieve or modify their profile.

📌 Example Scenario (GET /store/customers/me/ Without Token) 
✔ Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}
🚀 Effect: ✔ Secures user profile endpoints, preventing anonymous access.








Codes/notes in this lesson:

Django rest framework website:  https://www.django-rest-framework.org/ --> API Guide --> Permissions


settings.py:

REST_FRAMEWORK = {
    'COERCE_DECIMAL_TO_STRING': False,
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
	'DEFAULT_PERMISSION_CLASSES': [
		'rest_framework.permissions.IsAuthenticated'
	]
}


views.py:
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAuthenticated]
	
	def get_permissions(self):
		if self.request.method == 'GET':
			return [AllowAny()]
		return [IsAuthenticated()]


    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)







📌 Key Takeaways
✔ Permissions control access to API endpoints. 
✔ Global permissions (DEFAULT_PERMISSION_CLASSES) apply across all views. 
✔ View-specific permissions override global settings. 
✔ Different actions (GET, POST, PUT) can have customized permissions. 
✔ Next steps: Creating custom permission classes for advanced access control!












Applying Custom Permissions:
----------------------------

Django REST Framework provides built-in permissions like IsAuthenticated and IsAdminUser, but sometimes we need fine-grained control—such as allowing admins to modify data while letting anonymous users view it.

In this case, we create a custom permission class: IsAdminOrReadOnly.

🚀 Steps to Implement Custom Permissions
✔ Step 1: Define a new permission class (IsAdminOrReadOnly). 
✔ Step 2: Apply it to specific viewsets (Products, Collections, Customers). 
✔ Step 3: Ensure admin users can modify, while anonymous users can only view. 
✔ Step 4: Override permissions for special cases (e.g., user profiles).

📌 Reference: Django REST Framework - Permissions

1. Creating a Custom Permission Class
📌 Purpose: 
✔ Admins should be able to modify data. 
✔ Everyone (including anonymous users) should be able to read data.

📌 Implementation (permissions.py)
from rest_framework import permissions

class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:  # ✅ Allows GET, HEAD, OPTIONS requests for everyone
            return True
        return bool(request.user and request.user.is_staff)  # ✅ Only admins can modify data
		
🚀 Effect: 
✔ GET, HEAD, OPTIONS → Open to everyone. 
✔ POST, PUT, DELETE → Restricted to admin users.

📌 Using Django REST Framework’s SAFE_METHODS
permissions.SAFE_METHODS  # Contains ['GET', 'HEAD', 'OPTIONS']

🚀 Effect: 
✔ Ensures read-only methods are unrestricted, while modifying data requires admin access.




2. Applying Custom Permissions to the Product API
📌 Purpose: ✔ Anyone can view products, but only admins can modify them.

📌 Implementation (views.py)
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [IsAdminOrReadOnly]  # ✅ Enforce custom permission
	
🚀 Effect: 
✔ GET /store/products/ → Open to everyone. 
✔ POST /store/products/ → Restricted to admin users. 
✔ PUT /store/products/{id}/ → Restricted to admin users.

📌 Example Unauthorized Request (POST /store/products/ Without Admin Access)
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ Prevents unauthorized users from modifying product data.




3. Securing Collections Endpoint
📌 Purpose: ✔ Apply the same rules for managing collections.

📌 Implementation (views.py)
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(products_count=Count('products')).all()
    serializer_class = CollectionSerializer
    permission_classes = [IsAdminOrReadOnly]  # ✅ Apply custom permission

🚀 Effect: 
✔ Ensures consistency across product and collection endpoints.




4. Handling Customer API Permissions
📌 Problem: ✔ Customers should only manage their own profile—admins should manage all users.

📌 Solution: 
✔ Use IsAdminUser for managing customers in general. 
✔ Override permissions for the /store/customers/me/ endpoint.

📌 Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ✅ Admins can manage customers

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ✅ Authenticated users can modify their own profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
🚀 Effect: 
✔ Admins manage all customers (GET /store/customers/). 
✔ Authenticated users manage their own profile (GET /store/customers/me/).

📌 Example Unauthorized Request (GET /store/customers/me/ Without Token) 
✔ Expected Response (401 Unauthorized):
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: ✔ Prevents anonymous users from accessing private profile data.








codes/notes learned in this lesson:
permissions.py:
from rest_framework import permissions

class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in permissions.SAFE_METHODS:
            return True
        return bool(request.user and request.user.is_staff)



views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitems.count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
		
		
class CollectionViewSet(ModelViewSet):
    queryset = Collection.objects.annotate(
        products_count=Count('products')).all()
    serializer_class = CollectionSerializer
    permission_classes = [IsAdminOrReadOnly]

    def delete(self, request, pk):
        collection = get_object_or_404(Collection, pk=pk)
        if collection.products.count() > 0:
            return Response({'error': 'Collection cannot be deleted because it includes one or more products.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)
        collection.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)



class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






📌 Key Takeaways
✔ Custom permissions allow fine-grained control over API access. 
✔ Admins can modify products & collections, while anonymous users can only view them. 
✔ Customer data is secured — admins manage all users, while users handle their own profiles. 
✔ Django REST Framework’s permission system ensures API security. 
✔ Next steps: Implementing role-based access control (RBAC) for even better security!










Applying Model Permissions:
---------------------------
Django model permissions provide fine-grained access control based on user groups and assigned permissions. This ensures that only authorized users can perform specific actions on model objects.

🚀 Steps to Implement Model-Based Permissions
✔ Step 1: Assign relevant permissions to user groups (e.g., Customer Service). 
✔ Step 2: Use DjangoModelPermissions to enforce model-level access control. 
✔ Step 3: Extend permissions to handle custom scenarios (e.g., allowing read-only access for anonymous users).

📌 Reference: Django REST Framework - Permissions https://www.django-rest-framework.org/api-guide/permissions/

🚀 Effect: ✔ Ensures that users must have specific model-level permissions to modify data.




1. Understanding DjangoModelPermissions
📌 Purpose: 
✔ Requires authentication and specific model permissions for CRUD operations.

📌 Default Permission Mapping (DjangoModelPermissions):

HTTP Method	   Required Permission
GET	           No permission required
POST	       add_<model>
PUT/PATCH	   change_<model>
DELETE	       delete_<model>

🚀 Effect: ✔ Authenticated users must have the appropriate permission to modify data.

📌 Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [DjangoModelPermissions]  # ✅ Enforces model-level permissions
	
🚀 Effect: ✔ Users must be logged in and have model permissions to modify customer records.

📌 Example Unauthorized Request (POST /store/customers/ Without Permission)
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ Users cannot create or update customers unless explicitly granted permissions.




2. Assigning Model Permissions to User Groups
📌 Problem: 
✔ The default implementation allows only admin users to modify customers. 
✔ Users in the "Customer Service" group should also manage customers.

📌 Solution: 
✔ Assign specific model permissions to the Customer Service group via Django Admin.

📌 Steps in Django Admin: 
✔ Navigate to Admin → Users → John Smith. 
✔ Assign Customer Service group to the user. 
✔ Ensure the group has add_customer, change_customer, delete_customer permissions. 
✔ Save changes.

🚀 Effect: ✔ Customer Service representatives can now manage customer records.

📌 Testing the Changes 
✔ Before Removing Customer Service Group:
John Smith can create, update, and delete customers. 

✔ After Removing Customer Service Group:
John Smith can only view customer records (GET requests).

🚀 Effect: ✔ User permissions are dynamically enforced based on group assignments.




3. Creating a Custom Model Permission Class
📌 Problem: 
✔ The default DjangoModelPermissions does not enforce view permissions for GET requests. 
✔ Anonymous users should NOT see customer records.

📌 Solution: 
✔ Create FullDjangoModelPermissions, extending DjangoModelPermissions. 
✔ Ensure view permissions (view_<model>) are required for GET requests.

📌 Implementation (permissions.py)
from rest_framework import permissions

class FullDjangoModelPermissions(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET'] = ['%(app_label)s.view_%(model_name)s']  # ✅ Requires "view" permission for read access
		
🚀 Effect: ✔ Only authorized users with "view" permission can access customer data.

📌 Applying Custom Permissions (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [FullDjangoModelPermissions]  # ✅ Enforces view permission for `GET`
	
🚀 Effect: ✔ Users must have "view_customer" permission to retrieve customer records.

📌 Example Unauthorized Request (GET /store/customers/ Without Permission)
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ Prevents unauthorized users from accessing customer records.




4. Using DjangoModelPermissionsOrAnonReadOnly
📌 Purpose: 
✔ Extends DjangoModelPermissions but allows anonymous users read-only access.

📌 Implementation
permission_classes = [DjangoModelPermissionsOrAnonReadOnly]  # ✅ Read-only for anonymous users

🚀 Effect: 
✔ Anonymous users can view data (GET requests) but cannot modify anything.

📌 Example Scenario (GET /store/customers/ Without Token) 
✔ Expected Response (Success):
json
[
    {
        "id": 2,
        "user_id": 5,
        "phone": "1234",
        "birth_date": "2000-01-01",
        "membership": "B"
    }
]

🚀 Effect: ✔ Anonymous users have read-only access but cannot modify records.




5. Final Implementation for Customer API
📌 Solution: 
✔ Use admin-only access for managing customers. 
✔ Restrict /store/customers/me/ to authenticated users.

📌 Implementation (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ✅ Restricts access to admin users

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ✅ Only authenticated users manage their own profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
🚀 Effect: 
✔ Admins manage all customers (GET /store/customers/). 
✔ Authenticated users manage their own profile (GET /store/customers/me/).



codes learned in this lesson:
permission_classes = [DjangoModelPermissions]

permissions.py:
class FullDjangoModelPermissions(permissions.DjangoModelPermissions):
    def __init__(self) -> None:
        self.perms_map['GET'] = ['%(app_label)s.view_%(model_name)s']
		
			
views.py:
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [FullDjangoModelPermissions]

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






📌 Key Takeaways
✔ Django model permissions ensure users can modify data only if they have explicit permissions. 
✔ Assigning users to groups dynamically controls access. 
✔ Extending DjangoModelPermissions enables fine-grained permission handling. 
✔ Using DjangoModelPermissionsOrAnonReadOnly allows read-only access for anonymous users. 











Quick QnA Session:
------------------
So the Django Model permission, refers the permission based on the user_groups in and not by the permission_classes parameter on each view_set. Is my understanding, correct?

Almost! Let me clarify.
Django Model Permissions work in combination with both:
1. User Groups & Assigned Permissions → Permissions are granted based on the user's membership in groups and the specific model permissions assigned to those groups.
2. permission_classes in ViewSets → The permission class determines when and how those model permissions are enforced.

Here's how it works:
 - Model permissions (add_<model>, change_<model>, delete_<model>, view_<model>) are assigned to individual users or groups in Django Admin.
 - If a user belongs to a group (e.g., "Customer Service") that has change_customer permission, Django allows that user to modify customers.
 - Viewsets use permission_classes to enforce model permissions globally. 
   For example:
   permission_classes = [DjangoModelPermissions]

This ensures that only users with the right model permissions can perform actions on the API.

🚀 Key Takeaway: 
✔ Django Model Permissions reference user groups and assigned model-level permissions. 
✔ But permission enforcement depends on permission_classes in each ViewSet. 
✔ If permission_classes = [AllowAny], model permissions are ignored, and anyone can access the API! 
✔ If permission_classes = [DjangoModelPermissions], then only users with assigned permissions can modify models.

Your understanding was close, but it’s both the user’s assigned permissions AND the viewset’s permission_classes that determine access.






















Applying Custom Model Permissions:
----------------------------------
Django allows us to define custom permissions within models, ensuring that specific users can access certain features. In this case, we create and apply a custom permission (view_history) for accessing customer history.

🚀 Steps to Implement Custom Model Permissions
✔ Step 1: Define custom permissions in the model (view_history). 
✔ Step 2: Apply migrations to register the permission in the database. 
✔ Step 3: Create a custom permission class (ViewCustomerHistoryPermission). 
✔ Step 4: Apply the permission in CustomerViewSet. 
✔ Step 5: Grant permission via Django Admin and test the behavior.

📌 Reference: Django REST Framework - Permissions

🚀 Effect: ✔ Ensures only authorized users can view customer history.

1. Defining a Custom Model Permission
📌 Purpose: 
✔ The customer model should have a "view history" permission.

📌 Implementation (models.py)
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
        permissions = [
            ('view_history', 'Can view history')  # ✅ Defines custom permission
        ]
🚀 Effect: 
✔ Registers a new permission called view_history. 
✔ Allows us to grant access to specific users or groups.

📌 Applying Migrations
python manage.py makemigrations
python manage.py migrate

🚀 Effect: ✔ The view_history permission is now stored in the database.




2. Creating a Custom Permission Class
📌 Purpose: 
✔ Restricts access to customer history only to users with the view_history permission.

📌 Implementation (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ✅ Enforces permission check
		
🚀 Effect: 
✔ Users must have view_history permission to access customer history.




3. Creating the history Action in CustomerViewSet
📌 Purpose: 
✔ Adds an API endpoint (GET /store/customers/{id}/history/) for retrieving customer history.

📌 Implementation (views.py)
from rest_framework.decorators import action
from rest_framework.response import Response

class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]  # ✅ Admin users manage customers

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ✅ Restricts access to users with `view_history` permission
    def history(self, request, pk):
        return Response('ok')

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])  # ✅ Allows authenticated users to manage their profile
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
			
🚀 Effect: ✔ Users without view_history permission cannot access the endpoint.

📌 Testing the Endpoint (GET /store/customers/1/history/) 
✔ Expected Response (403 Forbidden for unauthorized users):
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: 
✔ Prevents users without view_history permission from accessing customer history.




4. Granting Permissions via Django Admin
📌 Problem: ✔ John Smith cannot access the history endpoint because he lacks the view_history permission.
📌 Solution: ✔ Assign view_history permission to John Smith via Django Admin.
📌 Steps in Django Admin: 
✔ Navigate to Admin → Users → John Smith. 
✔ Assign store.view_history permission manually. 
✔ Save changes.

🚀 Effect: ✔ John Smith now has access to /store/customers/{id}/history/.

📌 Testing Access After Permission Assignment 
✔ Expected Response (200 OK):
json
"ok"

🚀 Effect: 
✔ Permission enforcement works as expected.

📌 Best Practice: Use Groups Instead of Ad-Hoc Permissions 
✔ Instead of manually assigning permissions, create a Customer Service group. 
✔ Assign view_history to the group, then add users to the group. 
✔ Groups allow filtering by role, making management easier.

🚀 Effect: ✔ Ensures structured permission management, avoiding chaos in large projects.





codes learned in this lesson:

models.py:
class Customer(models.Model):
    MEMBERSHIP_BRONZE = 'B'
    MEMBERSHIP_SILVER = 'S'
    MEMBERSHIP_GOLD = 'G'

    MEMBERSHIP_CHOICES = [
        (MEMBERSHIP_BRONZE, 'Bronze'),
        (MEMBERSHIP_SILVER, 'Silver'),
        (MEMBERSHIP_GOLD, 'Gold'),
    ]
    phone = models.CharField(max_length=255)
    birth_date = models.DateField(null=True, blank=True)
    membership = models.CharField(
        max_length=1, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

    def __str__(self):
        return f'{self.user.first_name} {self.user.last_name}'

    @admin.display(ordering='user__first_name')
    def first_name(self):
        return self.user.first_name

    @admin.display(ordering='user__last_name')
    def last_name(self):
        return self.user.last_name

    class Meta:
        ordering = ['user__first_name', 'user__last_name']
        permissions = [
            ('view_history', 'Can view history')
        ]


permissions.py:
class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # <app_label>.<permission_codename>


views.py:
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])
    def history(self, request, pk):
        return Response('ok')

    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        (customer, created) = Customer.objects.get_or_create(
            user_id=request.user.id)
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        elif request.method == 'PUT':
            serializer = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)






📌 Key Takeaways
✔ Custom model permissions (view_history) allow fine-grained access control. 
✔ Only users with explicit permission can access restricted endpoints (GET /store/customers/{id}/history/). 
✔ Permissions should be managed via groups instead of individual users. 
✔ Next steps: Implementing advanced role-based access control (RBAC) across the API!










Quick QnA Session:
------------------

🚀 Understanding Groups and Model Permissions in Django
Django allows us to control user access using Groups (assigned in the admin panel) and Model Permissions (defined in the code).

Think of Groups as roles (e.g., “Customer Service,” “Managers”). 
Think of Model Permissions as rules about what users in those roles can do.

Now, let’s go through both concepts separately, then see how they work together.

1. Groups in Django Admin
📌 What are Groups? 
✔ Groups let us manage permissions for multiple users at once. 
✔ Instead of manually assigning permissions to each user, we create a group (e.g., “Customer Service”) and assign permissions to that group. 
✔ Users added to that group automatically inherit those permissions.

📌 Steps to Assign Groups in Django Admin: 
✔ Navigate to Admin → Groups. 
✔ Click “Add Group” and name it (e.g., Customer Service). 
✔ Assign permissions to the group (e.g., add_customer, change_customer, view_customer). 
✔ Save the group. 
✔ Go to Admin → Users and add users (e.g., “John Smith”) to the group.

🚀 Effect: ✔ Now, everyone in the “Customer Service” group can manage customers without needing individual permission assignments.

📌 Example Scenario:
John Smith belongs to “Customer Service” → He inherits the ability to manage customers.
Alice is NOT in any group → She cannot manage customers unless manually assigned permissions.




2. Model Permissions in Code
📌 What are Model Permissions? 
✔ Model permissions define what actions can be performed on a database model (e.g., Customer). 
✔ These are assigned at the model level in Django’s code. 
✔ They determine what users (or groups) can do—view, add, edit, or delete records.

📌 Defining Model Permissions in Code (models.py)
class Customer(models.Model):
    class Meta:
        permissions = [
            ('view_history', 'Can view history')  # ✅ Defines custom permission
        ]
		
🚀 Effect: 
✔ A new permission (“view_history”) is now available in the admin panel. 
✔ Admins can assign this permission to specific users or groups.

📌 Applying Migrations to Store Permissions in the Database
python manage.py makemigrations
python manage.py migrate

🚀 Effect: ✔ Permissions are now available in the admin panel for assignment.




3. Applying Model Permissions in Code (Checking Access)
📌 Now that the permission exists, we need to enforce it in our API. 
✔ This is done using custom permission classes.

📌 Example Custom Permission Class (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ✅ Checks user permission
		
🚀 Effect: ✔ Users must have the “view_history” permission to access the endpoint.

📌 Using This Permission in the API (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ✅ Restricts access
    def history(self, request, pk):
        return Response('ok')
		
🚀 Effect: ✔ The API checks whether the user has view_history permission before allowing access.




4. Connecting Groups and Model Permissions
📌 How do groups and model permissions work together? 
✔ Groups are used in Django Admin to manage permissions for multiple users at once. 
✔ Model Permissions are defined in code, allowing us to restrict API access programmatically.

📌 Example Process: 
1. Create “Customer Service” group in Admin. 
2. Assign “view_history” permission to the group. 
3. Add users (e.g., John Smith) to the group. 
4. API checks if a user has view_history permission when accessing /store/customers/{id}/history/.

📌 Testing Results: 
✔ Before John is added to the group: → He cannot access customer history (403 Forbidden). 
✔ After John is added to the group: → He can access customer history (200 OK).

🚀 Effect: 
✔ Groups manage who gets permissions. 
✔ Model permissions enforce API restrictions in code.


📌 Key Takeaways
✔ Groups (assigned in Django Admin) organize users and permissions. 
✔ Model Permissions (defined in code) control API access. 
✔ Groups inherit model permissions—users in a group automatically get assigned permissions. 
✔ Django Admin makes permission management scalable. 
✔ Next steps: Implementing role-based access control (RBAC) with Django’s permission system!
			
			
			
			
			
			
			
			
			
			
Crystal clear explanation of permissions:
-----------------------------------------

🚀 Do We Have Two Types of Permissions?
✔ Yes! There are TWO types of permissions in Django:

1. Admin Interface Permissions → These are assigned manually via Django Admin. 
2. Backend (Code-Based) Permissions → These are defined in code and enforced via the API.

💡 Both types work together — Admin permissions control what users can do, and Backend permissions enforce rules in the API.



1. Admin Interface Permissions
✔ These are manually assigned in Django Admin. 
✔ No coding required — you just click buttons in the Admin interface.

📌 Where to Find Them? 
✔ Navigate to Admin → Users → Select a user. 
✔ Assign permissions or groups to the user. 
✔ Save changes.

📌 How Do They Work? 
✔ Users get access to models (database objects) based on permissions like:
add_customer → Allows creating a customer.
change_customer → Allows editing a customer.
delete_customer → Allows removing a customer.
view_customer → Allows reading customer data.

🚀 Example Scenario: 
1. You create a “Customer Service” group in Django Admin. 
2. You assign permissions to manage customers to that group. 
3. You add John Smith to the Customer Service group. 
4. John Smith can now create, update, and delete customer records!

💡 Why Use Groups? 
✔ Instead of manually assigning permissions to every user, you group users into roles (Customer Service, Managers, etc.), and permissions apply to everyone in the group.




2. Backend (Code-Based) Permissions
✔ These are defined in code and enforced via API rules. 
✔ Used to protect API endpoints (e.g., only authenticated users can access certain routes).

📌 How Do We Define Permissions in Code? 
✔ Permissions are defined in Django models (models.py) or as custom permission classes (permissions.py).

📌 Example: Defining Permissions in a Model (models.py)
class Customer(models.Model):
    class Meta:
        permissions = [
            ('view_history', 'Can view history')  # ✅ Custom model permission
        ]
		
✔ This creates a new permission (view_history). 
✔ Admin users can now assign this permission to specific users or groups.

📌 Example: Enforcing Permission in Code (permissions.py)
from rest_framework import permissions

class ViewCustomerHistoryPermission(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('store.view_history')  # ✅ Checks if the user has the right permission
		
✔ This checks if the user has view_history permission before allowing access to certain API routes.


📌 Example: Applying the Custom Permission in API (views.py)
class CustomerViewSet(ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer

    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])  # ✅ Enforces custom permission
    def history(self, request, pk):
        return Response('ok')
		
🚀 Effect: ✔ Users must have the “view_history” permission to access /store/customers/{id}/history/.

📌 Testing Results: 
✔ Before John is assigned view_history: → He cannot access /store/customers/{id}/history/ (403 Forbidden). 
✔ After assigning view_history: → He can access /store/customers/{id}/history/ (200 OK).




3. How Admin & Backend Permissions Work Together
✔ Admin Permissions → Determine who has access (groups & individual users). 
✔ Backend Permissions → Enforce rules via API (e.g., allow only authenticated users).

📌 How the System Works End-to-End? 
1. Define permissions in models (models.py) → (e.g., view_history). 
2. Create a group in Django Admin → (e.g., “Customer Service”). 
3. Assign permissions to the group in Admin → (e.g., view_history). 
4. Add users to the group → (e.g., John Smith). 
5. API checks permissions using code (permissions.py).

🚀 Final Outcome: ✔ Users must be in the right group AND pass API rules to access protected data.


📌 Key Takeaways
✔ Django has TWO types of permissions: Admin-based and Backend (code-based). 
✔ Admin permissions are manually assigned via Django Admin. 
✔ Backend permissions are defined in code and enforced via API rules. 
✔ Best practice: Use Django groups to manage permissions instead of individual user assignments. 
✔ Next steps: Implementing role-based access control (RBAC) for large-scale applications!














Designing and Building the Orders API:
--------------------------------------
In this section, we'll take our application to the next level and build the orders API. Once again, this is a great opportunity for you to get your hands dirty in code and practice a lot of stuff you have learned so far. So let's jump in and get started.

 
 
 
Designing the API:
------------------
We are building an API for managing orders in an e-commerce application. This endpoint will allow users to create, view, update, and delete orders, with permissions varying based on user roles.

🚀 Orders API Overview
✔ Authenticated users can create orders by providing their cart ID. 
✔ Users can view their own orders, while admins can access all orders. 
✔ Users can update or delete their orders, but only if permitted.

📌 Orders Endpoint Mapping:

HTTP Method	       URL	      Request Body	    Response
POST	        /orders/	   {cartID}	     order (created)
GET	            /orders/	     {}	         order[] (list of orders)
GET	            /orders/1	     {}	         order (single order)
PATCH	        /orders/1	     {}	        (update order details)
DELETE	        /orders/1	     {}	        (delete order)

🚀 Effect: 
✔ Users can create, view, and manage orders based on authentication & permissions.




1. Creating an Order (POST /orders/)
📌 Purpose: 
✔ Users submit their cart ID to create a new order. 
✔ The system automatically assigns the authenticated user using their JWT token.

📌 Request Example
json
{
    "cartID": 12
}

📌 Expected Response (201 Created)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "pending",
    "created_at": "2025-05-09T13:45:00Z"
}

🚀 Effect: ✔ A new order is created for the authenticated user.

2. Viewing Orders (GET /orders/)
📌 Permission-Based Access: 
✔ Regular users → Can only view their own orders. 
✔ Admins → Can view all orders.

📌 Request Example (GET /orders/) 
✔ No request body needed — only authentication is required.

📌 Expected Response (200 OK) 
✔ If regular user (GET /orders/)
json
[
    {
        "id": 2,
        "cart_id": 7,
        "status": "shipped",
        "created_at": "2025-05-08T12:30:00Z"
    },
    {
        "id": 5,
        "cart_id": 12,
        "status": "pending",
        "created_at": "2025-05-09T13:45:00Z"
    }
]

✔ If admin (GET /orders/)
json
[
    {
        "id": 1,
        "user_id": 3,
        "cart_id": 6,
        "status": "delivered"
    },
    {
        "id": 2,
        "user_id": 4,
        "cart_id": 7,
        "status": "shipped"
    },
    {
        "id": 5,
        "user_id": 4,
        "cart_id": 12,
        "status": "pending"
    }
]

🚀 Effect: ✔ Users can see their own orders, while admins can view all orders.





3. Viewing a Specific Order (GET /orders/1)
📌 Rules: 
✔ Regular users → Can only view their own orders. 
✔ Admins → Can view any order.

📌 Expected Response (200 OK)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "pending",
    "created_at": "2025-05-09T13:45:00Z"
}

🚀 Effect: ✔ Users can see order details, but only for their own orders unless they are admins.




4. Updating an Order (PATCH /orders/1)
📌 Purpose: 
✔ Allows order status updates (e.g., processing → shipped → delivered). 
✔ Restricted to authenticated users. 
✔ Admins can update any order.

📌 Request Example (PATCH /orders/1)
json
{
    "status": "shipped"
}

📌 Expected Response (200 OK)
json
{
    "id": 5,
    "user_id": 4,
    "cart_id": 12,
    "status": "shipped",
    "created_at": "2025-05-09T13:45:00Z"
}

🚀 Effect: 
✔ Orders can be updated, but only by users with correct permissions.




5. Deleting an Order (DELETE /orders/1)
📌 Rules: 
✔ Users can delete their own orders. 
✔ Admins can delete any order.

📌 Expected Response (204 No Content) 
✔ Order is successfully deleted.

🚀 Effect: ✔ Users can remove their own orders, while admins can manage all orders.




📌 Key Takeaways
✔ Users create orders by sending their cart ID. 
✔ Regular users can only view their own orders — admins can access all orders. 
✔ Orders can be updated based on permissions. 
✔ Admins can delete any order, users can delete their own. 
✔ Next steps: Implementing the actual API endpoints in Django!













Getting the Orders:
-------------------

We are starting with retrieving orders from the database before handling creation, updates, and deletions. This ensures we build a strong foundation before dealing with more complex logic.

🚀 Steps to Implement Order Retrieval
✔ Step 1: Define serializers to format order and order item data. 
✔ Step 2: Create a viewset (OrderViewSet) to handle order retrieval. 
✔ Step 3: Register the endpoint in urls.py. 
✔ Step 4: Test the endpoint by manually adding order data to the database. 
✔ Step 5: Ensure order items are nested within orders, including product details.

📌 Orders Endpoint:
http
GET /orders/      → Retrieve all orders  
GET /orders/{id}/ → Retrieve a single order  

🚀 Effect: ✔ Users can retrieve orders, including related order items and product details.



1. Creating the Order Serializer
📌 Purpose: 
✔ The OrderSerializer formats order data, including nested order items.

📌 Implementation (serializers.py)
from rest_framework import serializers
from store.models import Order, OrderItem

class OrderSerializer(serializers.ModelSerializer):
    items = serializers.SerializerMethodField()  # ✅ Retrieves order items

    class Meta:
        model = Order
        fields = ['id', 'customer', 'placed_at', 'payment_status', 'items']

    def get_items(self, obj):
        return OrderItemSerializer(obj.items.all(), many=True).data  # ✅ Ensures order items are nested
		
🚀 Effect: 
✔ Orders now include nested order items when retrieved via API.

📌 Expected Response (GET /orders/)
json
[
    {
        "id": 2,
        "customer": 3,
        "placed_at": "2021-09-01",
        "payment_status": "P",
        "items": [
            {
                "id": 5,
                "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
                "quantity": 1,
                "unit_price": 1000
            },
            {
                "id": 6,
                "product": {"id": 2, "title": "Mouse", "unit_price": 50},
                "quantity": 2,
                "unit_price": 50
            }
        ]
    }
]

🚀 Effect: 
✔ Orders include related order items and product details.




2. Creating the OrderItem Serializer
📌 Purpose: 
✔ The OrderItemSerializer formats each order item with nested product details.

📌 Implementation (serializers.py)
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()  # ✅ Ensures nested product details

    class Meta:
        model = OrderItem
        fields = ['id', 'product', 'unit_price', 'quantity']
		
🚀 Effect: 
✔ Each order item contains detailed product information.

📌 Example Nested Order Item Response
json
{
    "id": 5,
    "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
    "quantity": 1,
    "unit_price": 1000
}
🚀 Effect: ✔ The API returns complete order details, reducing extra API calls.




3. Implementing the Order ViewSet
📌 Purpose: 
✔ Handles retrieving orders, including user-based access restrictions.

📌 Implementation (views.py)
from rest_framework.viewsets import ModelViewSet
from store.models import Order
from store.serializers import OrderSerializer

class OrderViewSet(ModelViewSet):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer

		
🚀 Effect: 
✔ Users can retrieve orders without authentication checks (permissions will be added later).

📌 Testing Order Retrieval 
✔ Request → GET /orders/ 
✔ Expected Response → List of orders with nested order items & product details




4. Registering the Orders Endpoint

📌 Implementation (urls.py)
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

🚀 Effect: 
✔ The API now supports order retrieval (GET /orders/).




5. Testing Orders API with Seed Data

📌 Setting Up Test Orders 
✔ Open PostgreSQL Query Console and insert sample orders manually:
sql
INSERT INTO store_order (placed_at, payment_status, customer_id)
VALUES ('2021-09-01', 'P', 3);

INSERT INTO store_orderitem (order_id, product_id, quantity, unit_price)
VALUES (2, 1, 1, 1000), (2, 2, 2, 50);

🚀 Effect: ✔ Orders exist in the database for API testing.

📌 Verifying API Response (GET /orders/) 
✔ Expected JSON Output:
json
[
    {
        "id": 2,
        "customer": 3,
        "placed_at": "2021-09-01",
        "payment_status": "P",
        "items": [
            {
                "id": 5,
                "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
                "quantity": 1,
                "unit_price": 1000
            },
            {
                "id": 6,
                "product": {"id": 2, "title": "Mouse", "unit_price": 50},
                "quantity": 2,
                "unit_price": 50
            }
        ]
    }
]

🚀 Effect: ✔ Users can successfully retrieve orders via API.






Codes in this lesson:
serializers.py:
class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True)

    class Meta:
        model = Order
        fields = ['id', 'customer', 'placed_at', 'payment_status', 'items']
		
				
views.py:
class OrderViewSet(ModelViewSet):
	queryset = Order.objects.all()
	serializer_class = OrderSerializer

					
urls.py:
router.register('orders', views.OrderViewSet)


serializers.py:
class SimpleProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ['id', 'title', 'unit_price']

class OrderItemSerializer(serializers.ModelSerializer):
    product = SimpleProductSerializer()

    class Meta:
        model = OrderItem
        fields = ['id', 'product', 'unit_price', 'quantity']







📌 Key Takeaways
✔ Orders include nested order items and product details. 
✔ Admins see all orders, while users only see their own. 
✔ The API handles authentication & permissions properly. 












Applying Permissions:
---------------------
Right now, anyone (including anonymous users) can access the orders endpoint. This is a security issue. 
We need to ensure that: 
✔ Only authenticated users can access orders. 
✔ Regular users can only see their own orders. 
✔ Admins can access all orders.

🚀 Steps to Implement Order Permissions
✔ Step 1: Restrict order access to authenticated users (IsAuthenticated). 
✔ Step 2: Ensure only admins see all orders, while regular users see their own orders. 
✔ Step 3: Register a proper basename in the URL configuration. 
✔ Step 4: Handle cases where a user does not have a customer record.

📌 Orders Endpoint Rules:
User Type	      Can Access All Orders?	Can Access Own Orders?
Admin	               ✅ Yes	                 ✅ Yes
Regular User	        ❌ No	                 ✅ Yes
Anonymous	            ❌ No	                 ❌ No

🚀 Effect: ✔ Orders are only accessible to authenticated users, with different rules for admins vs regular users.




1. Restricting Access to Authenticated Users
📌 Problem: 
✔ Currently, anyone (even anonymous users) can view orders. 
✔ We need to restrict access to only logged-in users.

📌 Solution: Apply IsAuthenticated Globally (views.py)
from rest_framework.permissions import IsAuthenticated
from store.models import Order
from store.serializers import OrderSerializer

class OrderViewSet(ModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]  # ✅ Only authenticated users can access orders
	
🚀 Effect: 
✔ Anonymous users can no longer access orders. 
✔ If a user is not authenticated, they get 401 Unauthorized.

📌 Testing (GET /orders/ Without Authentication) 
✔ Expected Response:
json
{
    "detail": "Authentication credentials were not provided."
}

🚀 Effect: 
✔ Unauthenticated users are blocked from accessing the endpoint.




2. Ensuring Admins See All Orders, Regular Users See Their Own
📌 Problem: 
✔ Admins should see all orders, but regular users should only see their own. 
✔ Right now, everyone sees all orders, which is incorrect.

📌 Solution: Override get_queryset() to Filter Orders (views.py)
class OrderViewSet(ModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:  # ✅ Admins see all orders
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get_or_create(user_id=user.id)  # ✅ Ensure user has a customer record
        return Order.objects.filter(customer_id=customer_id)  # ✅ Regular users see only their orders
		
🚀 Effect: 
✔ Admins see all orders, while regular users only see their own orders.

📌 Testing Access Control 
✔ Regular User (GET /orders/) → Sees only their own orders. 
✔ Admin (GET /orders/) → Sees all orders.




3. Setting the basename in URL Configuration
📌 Problem: 
✔ Because we overrode get_queryset(), Django cannot infer the correct view name (orders-list, orders-detail). 
✔ This leads to errors in the API.

📌 Solution: Explicitly Set basename in urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet, basename='orders')  # ✅ Explicitly setting `basename`

urlpatterns = [
    path('', include(router.urls)),
]

🚀 Effect: 
✔ The API can correctly generate names for endpoints (orders-list, orders-detail).

📌 Testing API ✔ If the basename was missing, we’d get an error like:
"Base name argument not specified"

🚀 Effect: ✔ API now works correctly without errors.




4. Handling Missing Customer Records Gracefully
📌 Problem: 
✔ If a user does not have a customer record, get_queryset() will fail. 
✔ The get() method expects exactly one result, but if the customer record is missing, it throws an exception.

📌 Solution: Use get_or_create() to Avoid Errors (views.py)

python
(customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)

🚀 Effect: ✔ If the user does not have a customer profile, a new record is created without breaking the system.

📌 Testing Edge Case (User Without a Customer Record) 
✔ Before Fix → Customer matching query does not exist. 
✔ After Fix → API still works without errors.

💡 Issue With get_or_create(): 
✔ This solution automatically creates customer profiles when a user accesses their orders. 
✔ This violates Command Query Separation → The system is modifying data while retrieving it.

📌 A Better Approach (Fixing Command Query Separation) 
✔ Instead of automatically creating a customer record, return an empty result if the user has no profile.



Codes in this lesson:
in the OrderViewSet class ==> permission_classes = [IsAuthenticated]

class OrderViewSet(ModelViewSet):
	serializer_class = OrderSerializer
	permission_classes = [IsAuthenticated]
	

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)


urls.py:
router.register('orders', views.OrderViewSet, basename='orders')  #orders-list #orders-detail




📌 Key Takeaways
✔ Orders are now restricted to authenticated users (IsAuthenticated). 
✔ Regular users can only see their own orders, while admins see all orders. 
✔ URL basename must be explicitly set to avoid API errors. 
✔ get_or_create() prevents missing customer issues, but should be improved for better separation. 
✔ Next steps: Implementing order creation (POST /orders/)!















Creating an Order: 
------------------

We are now implementing order creation. Since creating an order involves moving items from the shopping cart, this requires custom logic that Django cannot handle automatically.

🚀 Steps to Implement Order Creation
✔ Step 1: Define a new serializer (CreateOrderSerializer) to handle cart ID input. 
✔ Step 2: Use custom logic inside the serializer to create an order. 
✔ Step 3: Ensure customer data is linked properly to the order. 
✔ Step 4: Override get_serializer_class() in the viewset to choose the correct serializer. 
✔ Step 5: Test the API to verify order creation.

📌 Orders Endpoint (POST /orders/) ✔ Users send only a cart ID, and the system automatically retrieves the user ID from the authentication token.

🚀 Effect: ✔ Orders are created properly, and cart items will be transferred to order items later.



1. Defining the Order Creation Serializer
📌 Purpose: 
✔ CreateOrderSerializer allows users to send only the cart_id, simplifying the API request. 
✔ We override save() to implement custom order creation logic.

📌 Implementation (serializers.py)
from rest_framework import serializers
from store.models import Order, Customer

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()  # ✅ Accepts cart ID as input

    def save(self, **kwargs):
        print(self.validated_data['cart_id'])  # ✅ Displays cart ID for debugging
        print(self.context['user_id'])  # ✅ Retrieves user ID from request context

        # ✅ Ensure customer exists before creating order
        (customer, created) = Customer.objects.get_or_create(user_id=self.context['user_id'])

        # ✅ Create the order
        order = Order.objects.create(customer=customer)
        return order
		
🚀 Effect: 
✔ Users only need to send cart_id, and the system automatically assigns the customer. 
✔ Next step: Transfer cart items to order items (covered later).

📌 Request Example (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

🚀 Effect: ✔ A new order is created for the authenticated user.




2. Choosing the Correct Serializer for Each Request
📌 Problem: 
✔ OrderSerializer retrieves order details, but we need CreateOrderSerializer for order creation.

📌 Solution: Override get_serializer_class() in OrderViewSet (views.py)
class OrderViewSet(ModelViewSet):
    permission_classes = [IsAuthenticated]  # ✅ Only authenticated users can create orders

    def get_serializer_class(self):
        if self.request.method == 'POST':  # ✅ Use special serializer for creating orders
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':  # ✅ Use another serializer for updating orders (later)
            return UpdateOrderSerializer
        return OrderSerializer  # ✅ Default serializer for retrieving orders
		
🚀 Effect: 
✔ CreateOrderSerializer handles POST requests, ensuring the correct data format. 
✔ Order creation logic works independently from order retrieval logic.




3. Passing User ID to the Serializer
📌 Problem: ✔ The serializer does not have direct access to the request object, so we cannot access user_id easily.

📌 Solution: Use get_serializer_context() to Pass User ID (views.py)
class OrderViewSet(ModelViewSet):
    def get_serializer_context(self):
        return {'user_id': self.request.user.id}  # ✅ Pass authenticated user ID to serializer
		
🚀 Effect: 
✔ User ID is available in the serializer via self.context['user_id']. 
✔ Orders are automatically linked to the correct customer.




4. Registering the Orders Endpoint
📌 Implementation (urls.py)

python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from store.views import OrderViewSet

router = DefaultRouter()
router.register('orders', OrderViewSet, basename='orders')  # ✅ Registers `/orders/` endpoint

urlpatterns = [
    path('', include(router.urls)),
]
🚀 Effect: ✔ The API now supports order creation (POST /orders/).




5. Testing Order Creation
📌 Step 1: Create a Shopping Cart (POST /carts/) 
✔ First, create a cart to retrieve a valid cart ID.
json
{
    "id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Step 2: Send Order Creation Request (POST /orders/) 
✔ Use the retrieved cart_id to create an order.
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

🚀 Effect: ✔ A new order is successfully created and linked to the correct user.




📌 Step 3: Verify Order Exists in Database (SELECT * FROM store_order;) 
✔ Expected Result:
sql
id | customer_id | placed_at           | payment_status
---|-------------|---------------------|---------------
5  | 4           | 2025-05-09 13:45:00 | pending

🚀 Effect: ✔ The order is correctly stored in the database.









Codes/notes in this lesson:

POST     /orders/        {cartID}      order

serializers.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()


	def save(self, **kwargs):
		print(self.validated_data['cart_id'])
		print(self.context['user_id'])

		(customer, created) = Customer.objects.get_or_create(user_id=self.context['user_id'])
		Order.objects.create(customer=customer)

views.py:
in OrderViewSet:
class OrderViewSet(ModelViewSet):
	permission_classes = [IsAuthenticated]
	
    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        (customer_id, created) = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)
	
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer
		
	def get_serializer_context(self):
		return {'user_id': self.request.user.id}
	
	





📌 Key Takeaways
✔ Users only send cart_id — the system handles everything else. 
✔ Orders are correctly linked to the authenticated user via user_id. 
✔ Custom logic in the serializer ensures proper order creation. 
✔ Next steps: Transferring cart items to order items.














Creating Order Items:
---------------------



Now that we have an order creation endpoint, we need to convert cart items into order items and store them in the database. Additionally, we must delete the shopping cart once the order is created. Since multiple database operations occur, we use transactions to ensure consistency.

🚀 Steps to Implement Order Item Creation
✔ Step 1: Retrieve all cart items from the user's shopping cart. 
✔ Step 2: Convert cart items into order items using list comprehension. 
✔ Step 3: Save all order items in bulk using bulk_create(). 
✔ Step 4: Delete the shopping cart once order creation is completed. 
✔ Step 5: Wrap all operations inside a transaction to ensure atomicity.

📌 Orders Endpoint (POST /orders/) 
✔ Users send a cart ID, and the system automatically: 
1. Creates an order. 
2. Converts cart items to order items. 
3. Saves order items in bulk. 
4. Deletes the shopping cart.

🚀 Effect: ✔ Orders and their corresponding items are successfully stored in the database.





1. Retrieving Cart Items for the Given Cart ID
📌 Purpose: 
✔ Retrieve all cart items from the specified cart_id. 
✔ Use select_related('product') to eager load products, avoiding extra queries.

📌 Implementation (serializers.py)
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()  # ✅ Accepts cart ID as input

    def save(self, **kwargs):
        with transaction.atomic():  # ✅ Ensures atomic execution
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])  # ✅ Get customer object
            order = Order.objects.create(customer=customer)  # ✅ Create order

            cart_items = CartItem.objects \
                .select_related('product') \  # ✅ Avoids extra queries when accessing products
                .filter(cart_id=cart_id)  # ✅ Retrieves cart items for the given cart ID
				
🚀 Effect: 
✔ Retrieves all cart items efficiently. 
✔ Ensures product data is preloaded, reducing extra queries.




2. Converting Cart Items Into Order Items Using List Comprehension
📌 Purpose: 
✔ Convert cart items into order items using list comprehension. 
✔ Extract product details, quantity, and unit price at the time of order placement.

📌 Implementation (serializers.py)
order_items = [
    OrderItem(
        order=order,
        product=item.product,
        unit_price=item.product.unit_price,  # ✅ Stores product price at order time
        quantity=item.quantity
    ) for item in cart_items
]

🚀 Effect: 
✔ Each cart item is mapped into an order item. 
✔ Order items retain product details from the time of purchase.

📌 Example Before List Comprehension 
✔ Without list comprehension, we'd have to manually iterate:
order_items = []
for item in cart_items:
    order_items.append(OrderItem(order=order, product=item.product, quantity=item.quantity))

🚀 Effect: ✔ Using list comprehension simplifies code readability and efficiency.




3. Saving Order Items in Bulk
📌 Problem: ✔ Inserting order items one-by-one generates multiple queries, slowing performance.

📌 Solution: Use bulk_create() to Insert All Order Items At Once
OrderItem.objects.bulk_create(order_items)

🚀 Effect: ✔ Saves all order items with a single query, reducing database overhead.




4. Deleting the Shopping Cart After Order Placement
📌 Problem: 
✔ Once an order is created, the user's cart is no longer needed. 
✔ Leaving it in the database may cause unnecessary clutter.

📌 Solution: Delete the Cart After Order Is Created
Cart.objects.filter(pk=cart_id).delete()

🚀 Effect: ✔ Removes the shopping cart, ensuring users start fresh for their next order.




5. Using Transactions to Ensure Data Consistency
📌 Problem: 
✔ If the database goes offline in the middle of processing, some data may save while others fail. 
✔ This causes inconsistent records (e.g., orders without items).

📌 Solution: Wrap Operations Inside transaction.atomic()
from django.db import transaction

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():  # ✅ Ensures all operations succeed together
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)
            order_items = [
                OrderItem(order=order, product=item.product, unit_price=item.product.unit_price, quantity=item.quantity)
                for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order

🚀 Effect: ✔ Guarantees that all operations are either fully completed or rolled back in case of failure.

📌 What Happens If the Database Crashes Midway? 
✔ Without transactions → Order may exist, but items may be missing. 
✔ With transactions → Everything is rolled back, preventing corruption.





6. Testing Order Item Creation
📌 Step 1: Add Items to Shopping Cart (POST /carts/{cart_id}/items/) 
✔ Add two products to the cart before creating an order.
json
[
    {
        "product_id": 1,
        "quantity": 10
    },
    {
        "product_id": 2,
        "quantity": 20
    }
]

📌 Step 2: Send Order Creation Request (POST /orders/) 
✔ Convert cart items into order items using this request.
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Step 3: Verify Order Items in Database (SELECT * FROM store_orderitem;) ✔ Expected Result:
sql
id | order_id | product_id | quantity | unit_price
---|---------|------------|---------|------------
5  | 4       | 1          | 10      | 1000
6  | 4       | 2          | 20      | 50
🚀 Effect: ✔ Order items are correctly stored with their respective order IDs.








codes/notes in this lesson:

serializers.py:
from django.db import transaction

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()


    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





📌 Key Takeaways
✔ Cart items are successfully converted into order items. 
✔ Bulk insertion (bulk_create) optimizes database performance. 
✔ The shopping cart is deleted after order placement. 
✔ Transactions ensure atomic operations, preventing data inconsistency. 
✔ Next steps: Updating & canceling orders (PATCH /orders/{id}/).
















Quick QnA session:

Yes! Your understanding is correct—let me break it down step by step in the clearest way possible.

🚀 Understanding the Order Creation Process
When a user wants to place an order, they first need a cart to store items. This process follows a sequence of steps, each serving a specific purpose.

📌 Step-by-Step Flow of Order Creation
1. Creating an Empty Shopping Cart (POST /carts/)
✔ A user creates an empty cart first. 
✔ The system generates a Cart ID (UUID) to uniquely identify the cart.

📌 Example Request:
json
POST /carts/

📌 Example Response:
json
{
    "id": "550e8400-e29b-41d4-a716-446655440000"
}
🚀 Effect: ✔ The user now has a cart, ready to store items.




2. Adding Items to the Shopping Cart (POST /carts/{cart_id}/items/)
✔ Users add products to the cart using the cart_id. ✔ Each item includes a product ID and quantity.

📌 Example Request:
json
POST /carts/550e8400-e29b-41d4-a716-446655440000/items/
{
    "product_id": 1,
    "quantity": 10
}

📌 Example Response:
json
{
    "id": 1,
    "cart_id": "550e8400-e29b-41d4-a716-446655440000",
    "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
    "quantity": 10
}

🚀 Effect: ✔ The shopping cart now contains items that the user wants to purchase.





3. Creating an Order (POST /orders/)
✔ Users send only the cart_id, and the system: 
1. Creates a new order linked to the user. 
2. Retrieves all cart items to be added to the order. 
3. Transfers cart items to order items. 
4. Deletes the shopping cart once the order is finalized.

📌 Example Request:
json
POST /orders/
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Example Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending"
}

🚀 Effect: ✔ The order is successfully created, and the cart will be deleted.





4. Converting Cart Items to Order Items (OrderItem.objects.bulk_create())
✔ After creating the order, the system retrieves all cart items. 
✔ Each cart item is transformed into an order item, storing:
	Product ID
	Quantity
	Unit price at the time of order placement

📌 Example Data Transformation:
json
Cart Items:
[
    {"product_id": 1, "quantity": 10, "unit_price": 1000},
    {"product_id": 2, "quantity": 20, "unit_price": 50}
]

🚀 Effect: ✔ These cart items are transferred into the order items table.

📌 Database Query (SELECT * FROM store_orderitem;)
sql
id | order_id | product_id | quantity | unit_price
---|---------|------------|---------|------------
5  | 4       | 1          | 10      | 1000
6  | 4       | 2          | 20      | 50

🚀 Effect: ✔ Order items are now properly stored in the database.




5. Deleting the Shopping Cart (Cart.objects.filter(pk=cart_id).delete())
✔ Once cart items are converted into order items, the cart is no longer needed. 
✔ The system deletes the cart, ensuring users start fresh for future orders.

📌 Database Check (SELECT * FROM store_cart;) 
✔ Before deletion → Cart exists. 
✔ After deletion → Cart is removed.

🚀 Effect: ✔ The cart is deleted, leaving only the order and its items.




📌 Final Summary
✔ Users create an empty cart (POST /carts/). 
✔ Users add items to the cart (POST /carts/{cart_id}/items/). 
✔ Users submit cart_id to create an order (POST /orders/). 
✔ The system converts cart items into order items (bulk_create). 
✔ The shopping cart is deleted after order placement.

🚀 Next steps: Updating & canceling orders (PATCH /orders/{id}/).













Returning the Created Order:
----------------------------
After creating an order, the API should return the complete order details instead of just the cart_id. To achieve this, we need to: 
✔ Use two different serializers: one for receiving data (CreateOrderSerializer), and another for returning order details (OrderSerializer). 
✔ Override the create method in OrderViewSet.

🚀 Steps to Implement Proper Order Creation Response
✔ Step 1: Identify why only cart_id is returned instead of an order object. 
✔ Step 2: Override the create method in OrderViewSet. 
✔ Step 3: Ensure the serializer returns the complete order object after creation. 
✔ Step 4: Remove unnecessary methods (get_serializer_context). 
✔ Step 5: Test the implementation to verify correct order details are returned.

📌 Orders Endpoint (POST /orders/) 
✔ Users send a cart ID, and the system: 
1.Creates an order. 
2.Converts cart items into order items. 
3.Deletes the shopping cart. 
4.Returns the full order object instead of just cart ID.

🚀 Effect: ✔ The API correctly returns order details after creation.



1. Understanding Why Only cart_id Is Returned
📌 Problem: 
✔ The CreateOrderSerializer only defines cart_id, so Django returns only this field. 
✔ The create method in ModelViewSet relies on the serializer itself to generate the response.

📌 Default Behavior in ModelViewSet 
✔ Before Fix (create method uses the same serializer to return the response):
serializer = CreateOrderSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
serializer.save()
return Response(serializer.data)  # 🚨 Returns only `cart_id`, not the order object

🚀 Effect: 
✔ The API returns only cart_id, instead of a full order object.





2. Overriding the create Method to Return the Full Order Object
📌 Solution: 
✔ Use CreateOrderSerializer to validate and process input. 
✔ Use OrderSerializer to return the newly created order.

📌 Updated create Method (views.py)
from rest_framework.response import Response

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})  # ✅ Use correct serializer
        serializer.is_valid(raise_exception=True)
        order = serializer.save()  # ✅ Save and retrieve order object
        serializer = OrderSerializer(order)  # ✅ Serialize order object for returning response
        return Response(serializer.data)  # ✅ API now returns the full order object
		
🚀 Effect: ✔ The API now correctly returns the newly created order with all details.

📌 Example Request (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Expected Response (201 Created)
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending",
    "items": [
        {
            "id": 6,
            "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
            "quantity": 1
        },
        {
            "id": 7,
            "product": {"id": 2, "title": "Mouse", "unit_price": 50},
            "quantity": 2
        }
    ]
}

🚀 Effect: ✔ The API now correctly returns full order details after creation.




3. Removing Unnecessary Methods (get_serializer_context)
📌 Problem: 
✔ get_serializer_context() was only useful when using Django's default create method. 
✔ Now that we override create, this method is no longer necessary.

📌 Solution: Remove get_serializer_context & Replace With Direct Context Assignment 
✔ Before (Unnecessary Method):
def get_serializer_context(self):
    return {'user_id': self.request.user.id}
	
✔ After (Direct Context Assignment in create Method):
serializer = CreateOrderSerializer(data=request.data, context={'user_id': self.request.user.id})

🚀 Effect: ✔ Removes unnecessary abstraction, making the code cleaner and more readable.




4. Ensuring Proper Queryset Handling
📌 Problem: ✔ Admin users should see all orders, but regular users should only see their own orders.

📌 Updated get_queryset() (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:  # ✅ Admin users see all orders
        return Order.objects.all()

    customer_id = Customer.objects.only('id').get(user_id=user.id)  # ✅ Retrieve customer ID
    return Order.objects.filter(customer_id=customer_id)  # ✅ Regular users see only their orders
	
🚀 Effect: ✔ Admins see all orders, regular users see only their own orders.




5. Validating Cart ID Before Processing
📌 Problem: ✔ If the user provides an invalid or empty cart, the system should return a validation error instead of failing silently.

📌 Solution: Validate Cart ID in CreateOrderSerializer (serializers.py)
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError('No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id
		
🚀 Effect: ✔ Prevents processing invalid carts, ensuring reliable order creation.

📌 Example Invalid Request (POST /orders/)
json
{
    "cart_id": "invalid-cart-id"
}
📌 Expected Response (400 Bad Request)

json
{
    "cart_id": ["No cart with the given ID was found."]
}

🚀 Effect: ✔ Ensures only valid carts can be processed.





codes in this lesson:
codes learned in this lesson:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)


views.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





📌 Key Takeaways
✔ The API now returns full order details instead of just cart ID. 
✔ Two serializers are used: One for receiving data (CreateOrderSerializer), one for returning data (OrderSerializer). 
✔ Admin users see all orders, while regular users see only their own. 
✔ Cart validation prevents errors when processing invalid data. 
















Data Validation:
----------------
We have implemented the happy path, where we process valid data correctly. Now, we need to handle invalid data scenarios to prevent errors and ensure reliability.

🚀 Scenarios That Require Validation
✔ Scenario 1: The user provides an invalid cart ID (cart does not exist). 
✔ Scenario 2: The user provides an empty cart (a cart with no items).

🚀 Effect: ✔ The system should reject invalid cart IDs and prevent empty orders from being created.

1. Handling Invalid Cart IDs
📌 Problem: ✔ Right now, the system creates an order even if the cart ID is invalid. 
✔ This results in orders with no items, which is incorrect.

📌 Solution: Use Field Validation for cart_id (serializers.py)
from rest_framework import serializers
from django.db import transaction
from store.models import Cart, CartItem, Order, OrderItem, Customer

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        """Ensures the provided cart ID exists in the database."""
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.'
            )
        return cart_id
		
🚀 Effect: ✔ If a user sends a cart ID that does not exist, the system raises a validation error before processing the order.

📌 Example Invalid Request (POST /orders/)
json
{
    "cart_id": "invalid-cart-id"
}

📌 Expected Response (400 Bad Request)
json
{
    "cart_id": ["No cart with the given ID was found."]
}

🚀 Effect: ✔ Prevents processing non-existent carts, ensuring data integrity.





2. Handling Empty Carts (No Items)
📌 Problem: 
✔ The system should not allow creating an order if the cart has no items. 
✔ Without this check, the system creates empty orders, leading to data inconsistency.

📌 Solution: Add a Check for Empty Carts in validate_cart_id (serializers.py)
def validate_cart_id(self, cart_id):
    """Ensures the provided cart ID exists and contains items."""
    if not Cart.objects.filter(pk=cart_id).exists():
        raise serializers.ValidationError('No cart with the given ID was found.')

    if CartItem.objects.filter(cart_id=cart_id).count() == 0:
        raise serializers.ValidationError('The cart is empty.')

    return cart_id
	
🚀 Effect: ✔ If a user sends an empty cart, the system raises a validation error before processing the order.

📌 Example Invalid Request (POST /orders/)
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}

📌 Expected Response (400 Bad Request)
json
{
    "cart_id": ["The cart is empty."]
}

🚀 Effect: ✔ Prevents creating orders without items, ensuring proper validation.




3. Updating the save Method to Process Orders
📌 Purpose: 
✔ Ensures only valid orders are processed by checking cart validity first. 
✔ Uses a transaction to keep operations atomic.

📌 Updated save() Implementation (serializers.py)
def save(self, **kwargs):
    with transaction.atomic():  # ✅ Ensures all database operations happen together
        cart_id = self.validated_data['cart_id']

        customer = Customer.objects.get(user_id=self.context['user_id'])
        order = Order.objects.create(customer=customer)

        cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)

        order_items = [
            OrderItem(
                order=order,
                product=item.product,
                unit_price=item.product.unit_price,
                quantity=item.quantity
            ) for item in cart_items
        ]
        OrderItem.objects.bulk_create(order_items)  # ✅ Saves all order items in bulk

        Cart.objects.filter(pk=cart_id).delete()  # ✅ Deletes shopping cart after order creation

        return order
		
🚀 Effect: ✔ Ensures orders are created only when valid carts exist. ✔ Uses bulk insert (bulk_create) for better performance. ✔ Deletes the shopping cart once the order is finalized.




4. Testing Order Validation
📌 Test 1: Sending an Invalid Cart ID (POST /orders/) 
✔ Expected Response (400 Bad Request):
json
{
    "cart_id": ["No cart with the given ID was found."]
}

📌 Test 2: Sending an Empty Cart (POST /orders/) 
✔ Expected Response (400 Bad Request):
json
{
    "cart_id": ["The cart is empty."]
}

📌 Test 3: Sending a Valid Cart ID (POST /orders/) 
✔ Expected Response (201 Created):
json
{
    "id": 5,
    "customer": 4,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "pending",
    "items": [
        {
            "id": 6,
            "product": {"id": 1, "title": "Laptop", "unit_price": 1000},
            "quantity": 1
        },
        {
            "id": 7,
            "product": {"id": 2, "title": "Mouse", "unit_price": 50},
            "quantity": 2
        }
    ]
}

🚀 Effect: ✔ Invalid carts are blocked, and valid carts successfully create orders.






Codes/Notes in this lesson:

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order





📌 Key Takeaways
✔ The system now properly validates cart IDs before processing orders. 
✔ Empty carts cannot be processed, preventing invalid orders. 
✔ Orders are created only when valid carts exist, ensuring data integrity. 
✔ Next steps: Implementing order updates (PATCH /orders/{id}/).















Revisiting the Permissions:
---------------------------

Currently, all authenticated users can update and delete orders, which is incorrect. We need to: 
✔ Restrict order modification (PATCH, DELETE) to admin users only. 
✔ Allow regular users to view their own orders (GET) but not modify them. 
✔ Enable HEAD and OPTIONS methods for API clients to check available operations.

🚀 Effect: ✔ Only admins can modify orders, regular users can only retrieve orders.

🚀 Steps to Fix Permissions
✔ Step 1: Override get_permissions() to restrict modifications (PATCH, DELETE). 
✔ Step 2: Remove PUT since orders should only be partially updated. 
✔ Step 3: Explicitly set allowed HTTP methods (http_method_names). 
✔ Step 4: Verify the API correctly hides the delete and update options for non-admins.

📌 Updated Order Management Rules:

User Type	  Can Modify Orders? (PATCH, DELETE)	Can View Orders? (GET)
Admin	                 ✅ Yes	                    ✅ Yes
Regular User	         ❌ No	                    ✅ Yes
Anonymous	             ❌ No	                    ❌ No


🚀 Effect: ✔ Admins can modify orders, but regular users can only retrieve them.

1. Restricting Order Modifications to Admins
📌 Problem: ✔ Right now, any authenticated user can update or delete orders.

📌 Solution: Override get_permissions() (views.py)
from rest_framework.permissions import IsAuthenticated, IsAdminUser

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'patch', 'delete', 'head', 'options']
    permission_classes = [IsAuthenticated]

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:  # ✅ Restrict updates & deletions to admins
            return [IsAdminUser()]
        return [IsAuthenticated()]  # ✅ Regular users can only retrieve orders
		
🚀 Effect: ✔ Non-admins can no longer update or delete orders.

📌 Testing (PATCH /orders/1/ as a regular user) 
✔ Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ The system blocks unauthorized modifications.





2. Removing PUT to Prevent Full Order Updates
📌 Problem: ✔ PUT allows complete replacement of an order, but we only need partial updates (PATCH).

📌 Solution: Remove PUT From Allowed Methods (views.py)
http_method_names = ['get', 'patch', 'delete', 'head', 'options']  # ✅ Removes `PUT`

🚀 Effect: ✔ Ensures orders are only updated partially (PATCH) rather than fully (PUT).





3. Explicitly Defining Allowed HTTP Methods
📌 Problem: ✔ Some API clients need HEAD and OPTIONS to discover available operations.

📌 Solution: Include HEAD and OPTIONS in http_method_names

http_method_names = ['get', 'patch', 'delete', 'head', 'options']

🚀 Effect: ✔ API clients can now check supported methods before making a request.

📌 Testing (OPTIONS /orders/) ✔ Expected Response (200 OK):
json
{
    "allow": ["GET", "PATCH", "DELETE", "HEAD", "OPTIONS"]
}

🚀 Effect: ✔ Clients can now inspect available operations before making requests.




4. Verifying Admin Access to Order Modification
📌 Problem: ✔ Admins should still be able to update and delete orders.

📌 Solution: Test admin access (PATCH /orders/1/) 
✔ Expected Response (200 OK):
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "completed"
}

🚀 Effect: ✔ Admins can modify orders as expected.




5. Ensuring Proper Queryset Handling
📌 Problem: ✔ Regular users should only see their own orders, but admins should see all orders.

📌 Updated get_queryset() (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:  # ✅ Admin users see all orders
        return Order.objects.all()

    customer_id = Customer.objects.only('id').get(user_id=user.id)  # ✅ Retrieve customer ID
    return Order.objects.filter(customer_id=customer_id)  # ✅ Regular users see only their orders
	
🚀 Effect: ✔ Admins see all orders, regular users see only their own orders.








Codes/Notes in this lesson:

views.py:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)








📌 Key Takeaways
✔ Admin users can modify orders, but regular users cannot (PATCH, DELETE). 
✔ Regular users can only retrieve their orders (GET). 
✔ PUT is removed — only partial updates (PATCH) are allowed. 
✔ API clients can use HEAD and OPTIONS to inspect available operations. 
















Updating an Order:
------------------

Updating an order should be restricted to only changing the payment status, ensuring that critical fields (customer, order items, placed_at) remain read-only.

🚀 Steps to Implement Order Updates
✔ Step 1: Ensure only admin users can update orders (PATCH). 
✔ Step 2: Prevent full updates (PUT) — only allow partial updates (PATCH). 
✔ Step 3: Create a new serializer (UpdateOrderSerializer) to control which fields can be modified. 
✔ Step 4: Ensure get_serializer_class() dynamically switches between serializers. 
✔ Step 5: Test the update functionality to verify restricted updates.

📌 Orders Endpoint (PATCH /orders/{id}/) 
✔ Admins send a partial update request, modifying only payment_status.

🚀 Effect: ✔ Orders are updated correctly, while preventing unintended modifications.

1. Creating a Serializer for Updating Orders
📌 Problem: ✔ Right now, updating an order allows modifying all fields, which is incorrect.

📌 Solution: Create UpdateOrderSerializer with Only payment_status (serializers.py)
from rest_framework import serializers
from store.models import Order

class UpdateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = ['payment_status']  # ✅ Restrict updates to only payment status
		
🚀 Effect: ✔ Only payment_status can be modified, ensuring critical fields remain unchanged.

📌 Testing PATCH /orders/{id}/ 
✔ Request (PATCH /orders/1/)
json
{
    "payment_status": "C"
}

✔ Expected Response (200 OK)
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "C"
}

🚀 Effect: ✔ The order is successfully updated, but only payment status is modified.




2. Ensuring Only Admins Can Modify Orders
📌 Problem: ✔ Right now, all authenticated users can modify orders. 
✔ We need to restrict updates (PATCH, DELETE) to admin users only.

📌 Solution: Override get_permissions() in OrderViewSet (views.py)
from rest_framework.permissions import IsAuthenticated, IsAdminUser

class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:  # ✅ Restrict updates & deletions to admins
            return [IsAdminUser()]
        return [IsAuthenticated()]  # ✅ Regular users can only retrieve orders
		
🚀 Effect: ✔ Admins can modify orders, but regular users can only retrieve them.

📌 Testing as a Non-Admin (PATCH /orders/1/) 
✔ Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ Unauthorized modifications are blocked, ensuring security.





3. Dynamically Switching Serializers in ViewSet
📌 Problem: 
✔ Right now, OrderSerializer handles both retrieving and updating orders, leading to potentially unsafe modifications. 
✔ We need to switch between different serializers dynamically.

📌 Solution: Override get_serializer_class() in OrderViewSet (views.py)
class OrderViewSet(ModelViewSet):
    def get_serializer_class(self):
        if self.request.method == 'POST':  # ✅ Use `CreateOrderSerializer` for new orders
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':  # ✅ Use `UpdateOrderSerializer` for updates
            return UpdateOrderSerializer
        return OrderSerializer  # ✅ Default serializer for retrieving orders
		
🚀 Effect: ✔ Uses the correct serializer based on request type (POST, PATCH, GET).

📌 Testing PATCH /orders/{id}/ 
✔ Request → API correctly applies UpdateOrderSerializer, ensuring only payment_status can be modified.





4. Removing PUT From Allowed Methods
📌 Problem: ✔ PUT allows complete replacement of an order, but we only need partial updates (PATCH).

📌 Solution: Remove PUT From http_method_names (views.py)
http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']  # ✅ Removes `PUT`

🚀 Effect: ✔ Ensures orders are only updated partially (PATCH) rather than fully (PUT).

📌 Testing PUT /orders/{id}/ 
✔ Expected Response (405 Method Not Allowed):
json
{
    "detail": "Method \"PUT\" not allowed."
}

🚀 Effect: ✔ Prevents unintended full order modifications, ensuring integrity.





5. Testing Order Update Functionality
📌 Test 1: Updating Payment Status (PATCH /orders/{id}/) 
✔ Expected Response (200 OK):
json
{
    "id": 1,
    "customer": 3,
    "placed_at": "2025-05-09T13:45:00Z",
    "payment_status": "completed"
}

📌 Test 2: Trying to Update Non-Editable Fields (PATCH /orders/{id}/) 
✔ Request:
json
{
    "customer": 5,
    "payment_status": "C"
}
✔ Expected Response (400 Bad Request):

json
{
    "customer": ["This field cannot be modified."]
}

📌 Test 3: Unauthorized User Trying to Update Order (PATCH /orders/{id}/) ✔ Expected Response (403 Forbidden):
json
{
    "detail": "You do not have permission to perform this action."
}

🚀 Effect: ✔ Only valid updates are processed, while unauthorized modifications are blocked.






Codes/Notes in this lesson:
serializers.py:
class UpdateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = ['payment_status']



views.py:
class OrderViewSet(ModelViewSet):
    http_method_names = ['get', 'post', 'patch', 'delete', 'head', 'options']

    def get_permissions(self):
        if self.request.method in ['PATCH', 'DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()]

    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(
            data=request.data,
            context={'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer

    def get_queryset(self):
        user = self.request.user

        if user.is_staff:
            return Order.objects.all()

        customer_id = Customer.objects.only(
            'id').get(user_id=user.id)
        return Order.objects.filter(customer_id=customer_id)






📌 Key Takeaways
✔ Orders can only be updated by admin users (PATCH /orders/{id}/). 
✔ Regular users can only retrieve orders (GET /orders/{id}/). 
✔ Only payment_status is editable — other fields remain read-only. 
✔ Full updates (PUT) are disabled—only partial updates (PATCH) are allowed. 
✔ Next steps: Implementing order cancellations (DELETE /orders/{id}/).










Signals:
--------



Django signals allow apps to communicate without direct dependencies, making the system more modular and maintainable. They help ensure event-driven responses, such as automatically creating a customer record when a new user registers.

🚀 Steps to Implement Signals for Customer Creation
✔ Step 1: Identify the violation of the Command Query Separation principle. 
✔ Step 2: Use signals (post_save) to automatically create a customer when a new user registers. 
✔ Step 3: Define the signal handler function (create_customer_for_new_user). 
✔ Step 4: Register the signal in Django's app initialization (apps.py). 
✔ Step 5: Ensure signals are correctly triggered and tested.

📌 Real-Life Application: 
✔ Previously, the get_queryset() method was incorrectly modifying data while querying. 
✔ Using signals, we can separate these concerns, triggering customer creation when a user registers.

🚀 Effect: 
✔ When a new user registers, a customer record is automatically created. 
✔ The OrderViewSet no longer needs to modify data during queries, ensuring correctness.



1. Understanding the Problem in get_queryset()
📌 Problem: 
✔ The get_queryset() method was responsible for both retrieving and modifying data, violating Command Query Separation. 
✔ When querying orders, it sometimes had to create a customer record, which is incorrect.

📌 Example Before Fix (views.py)
def get_queryset(self):
    user = self.request.user

    if user.is_staff:
        return Order.objects.all()

    (customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)  # 🚨 This modifies data!
    return Order.objects.filter(customer_id=customer_id)
	
🚀 Effect: ✔ Every time a user accessed orders, a customer record was created if missing, leading to unwanted side effects.

📌 Fix: Use Signals Instead 
✔ Automatically create customer records when users register, preventing modifications in get_queryset().





2. Creating a Signal to Automatically Create Customers
📌 Solution: 
✔ Define a function (create_customer_for_new_user) to handle customer creation when a user is saved. 
✔ Use Django’s post-save signal for event-driven execution.

📌 Implementation (signals.py)
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from store.models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
    """Automatically create a customer when a new user registers."""
    if kwargs['created']:  # ✅ Ensure the user was newly created
        Customer.objects.create(user=kwargs['instance'])  # ✅ Create the customer linked to this user
		
🚀 Effect: 
✔ Every time a new user registers, a customer record is automatically created. 
✔ OrderViewSet no longer needs to create customer records when querying orders.

📌 What is Happening? 
✔ Django listens for a post_save signal when a new user is created. 
✔ The create_customer_for_new_user function executes immediately, ensuring proper customer creation.

📌 Example When a New User Registers (POST /users/) 
✔ A new user is created, automatically triggering customer creation.

🚀 Effect: ✔ The system ensures every registered user has a corresponding customer record.





3. Registering the Signal in Django’s App Initialization
📌 Problem: 
✔ Django does not run signals unless they are explicitly imported. 
✔ We need to ensure the signal is registered when the app starts.

📌 Solution: Import Signals in apps.py
from django.apps import AppConfig

class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals  # ✅ Ensure signals are loaded when the app starts
		
🚀 Effect: ✔ Django now listens for user creation events automatically.

📌 Testing the Signal: 
Creating a User ✔ Expected Behavior: 
1.User registers (POST /users/). 
2.Signal is triggered (post_save). 
3.Customer record is automatically created.

📌 Verifying in the Database (SELECT * FROM store_customer;)
sql
id | user_id
---|--------
1  | 6

🚀 Effect: ✔ User ID 6 now has an associated customer record, confirming that signals work correctly.




4. Fixing Queryset Retrieval in OrderViewSet
📌 Problem: ✔ Previously, get_queryset() had to create a customer if missing, which is incorrect.

📌 Solution: Remove Data Modification in get_queryset() (views.py)
class OrderViewSet(ModelViewSet):
    def get_queryset(self):
        user = self.request.user

        if user.is_staff:  # ✅ Admin users see all orders
            return Order.objects.all()

        customer_id = Customer.objects.only('id').get(user_id=user.id)  # ✅ Query only—no modifications!
        return Order.objects.filter(customer_id=customer_id)  # ✅ Ensures correct access control
		
🚀 Effect: ✔ The function now purely retrieves data, following Command Query Separation.




5. Applying the Fix to Other Modules
📌 Problem: 
✔ Other methods still call get_or_create(), modifying data unintentionally. 
✔ We need to fix them to only query customer records.

📌 Solution: 
Replace get_or_create() With get() in Related Places 

✔ Before (Modifies Data)
(customer_id, created) = Customer.objects.only('id').get_or_create(user_id=user.id)  # 🚨 Modifies Data!

✔ After (Only Queries Data)
customer_id = Customer.objects.only('id').get(user_id=user.id)  # ✅ Retrieves customer ID without modifications

🚀 Effect: ✔ The system no longer creates customers in unexpected places.

📌 Places Updated: 
✔ Order creation serializer (serializers.py) 
✔ User profile retrieval (views.py - me action)

🚀 Effect: ✔ The store app correctly handles customer creation through signals, preventing side effects.





Codes/Notes in this lesson:
pre_save
post_save
pre_delete
post_delete


signals.py:
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
	if kwargs['created']:
		Customer.objects.create(user=kwargs['instance'])
		
		
apps.py:
from django.apps import AppConfig


class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals.handlers		
		
		



📌 Key Takeaways
✔ Signals automate customer creation when a new user registers (post_save). 
✔ User creation is now properly separated from other app concerns. 
✔ OrderViewSet no longer modifies data during queries—only retrieves data. 
✔ Next steps: Implementing custom signals for real-time event handling.












Creating Custom Signals: 
------------------------

🚀 Creating Custom Signals in Django:
Django signals allow different parts of an application to communicate without being tightly coupled. Now, we are creating a custom signal (order_created), which notifies other apps whenever a new order is placed.

🚀 Steps to Implement Custom Signals
✔ Step 1: Define a new custom signal (order_created). 
✔ Step 2: Fire this signal when an order is created (CreateOrderSerializer). 
✔ Step 3: Set up a signal handler to respond to this event (core/signals/handlers.py). 
✔ Step 4: Register the signal handler in Django’s app initialization (apps.py). 
✔ Step 5: Test the signal to verify that external apps receive order updates.

📌 Real-Life Application: 
✔ The store app fires an event when an order is created (order_created). 
✔ The core app listens for this event and handles order-related actions. 
✔ Other apps (e.g., email notifications, analytics) can also subscribe to this signal, reacting when an order is placed.

🚀 Effect: ✔ The store app does not need to directly depend on the core app, keeping the system modular and scalable.




1. Defining the Custom Signal
📌 Problem: 
✔ Right now, Django only provides built-in signals (post_save, post_delete). 
✔ We need a custom signal (order_created), so that external apps can listen for order placements.

📌 Solution: Define order_created in signals/__init__.py
from django.dispatch import Signal

order_created = Signal()  # ✅ Custom signal for order creation event

🚀 Effect: ✔ We now have a custom signal that can be triggered when an order is placed.

📌 What Happens Now? ✔ Other parts of the system can subscribe to order_created and respond accordingly.




2. Triggering the Custom Signal When an Order Is Created
📌 Problem: ✔ When an order is placed, we need to fire the custom signal (order_created).

📌 Solution: Trigger the Signal in CreateOrderSerializer (serializers.py)
from store.signals import order_created

class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects.select_related('product').filter(cart_id=cart_id)
            order_items = [
                OrderItem(order=order, product=item.product, unit_price=item.product.unit_price, quantity=item.quantity)
                for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)
            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)  # ✅ Send signal with order details

            return order
			
🚀 Effect: 
✔ Every time an order is created, the signal (order_created) is fired, notifying other apps that need this data.

📌 Why send_robust Instead of send? 
✔ If one handler fails, send_robust ensures other handlers still receive the signal.




3. Creating a Signal Handler to Respond to the Event
📌 Problem: 
✔ The core app needs to listen for the order_created event and perform additional actions.

📌 Solution: Define a Handler in core/signals/handlers.py
from django.dispatch import receiver
from store.signals import order_created

@receiver(order_created)
def on_order_created(sender, **kwargs):
    print(kwargs['order'])  # ✅ Logs order details in the core app
	
🚀 Effect: ✔ The core app now listens for the order_created event, handling it when an order is placed.

📌 What Happens Now? 
✔ The store app fires the signal (order_created). 
✔ The core app receives the signal and prints the order details. 
✔ Other apps can also subscribe to order_created, handling order events as needed.

📌 Potential Expansions: 
✔ Send confirmation emails after an order is placed. 
✔ Update inventory stock when an order is received. 
✔ Log analytics data for sales tracking.




4. Registering the Signal Handler in Django’s App Initialization
📌 Problem: 
✔ Django does not execute signals unless they are explicitly imported. 
✔ We need to ensure the signal handler is loaded when the app starts.

📌 Solution: Import the Signal Handler in core/apps.py
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self) -> None:
        import core.signals.handlers  # ✅ Load signal handlers when the app starts
		
🚀 Effect: ✔ Signal handlers are now active when the core app is initialized.

📌 Now, when an order is created, the core app automatically gets notified!




5. Testing the Custom Signal
📌 Step 1: Create an Order (POST /orders/) 
✔ Expected Request:
json
{
    "cart_id": "550e8400-e29b-41d4-a716-446655440000"
}


📌 Step 2: Verify That Signal Was Received in core/signals/handlers.py 
✔ Expected Output in Terminal:
bash
<Order: id=5, customer=4, placed_at=2025-05-09T13:45:00Z>
🚀 Effect: ✔ Confirms that the signal fired and was received by the core app.


📌 Step 3: Add Another App to Listen for order_created 
✔ The email app or inventory app can also subscribe to this signal, further decoupling the system.

🚀 Effect: ✔ The system is now modular—new apps can easily react to order placements.







Codes/Notes in this lesson:

handlers.py:
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from store.models import Customer

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_customer_for_new_user(sender, **kwargs):
  if kwargs['created']:
    Customer.objects.create(user=kwargs['instance'])
	
	
apps.py:
from django.apps import AppConfig


class StoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'store'

    def ready(self) -> None:
        import store.signals.handlers
	


signals/__init__.py:
from django.dispatch import Signal

order_created = Signal()

	
	
serializers.py:
class CreateOrderSerializer(serializers.Serializer):
    cart_id = serializers.UUIDField()

    def validate_cart_id(self, cart_id):
        if not Cart.objects.filter(pk=cart_id).exists():
            raise serializers.ValidationError(
                'No cart with the given ID was found.')
        if CartItem.objects.filter(cart_id=cart_id).count() == 0:
            raise serializers.ValidationError('The cart is empty.')
        return cart_id

    def save(self, **kwargs):
        with transaction.atomic():
            cart_id = self.validated_data['cart_id']

            customer = Customer.objects.get(
                user_id=self.context['user_id'])
            order = Order.objects.create(customer=customer)

            cart_items = CartItem.objects \
                .select_related('product') \
                .filter(cart_id=cart_id)
            order_items = [
                OrderItem(
                    order=order,
                    product=item.product,
                    unit_price=item.product.unit_price,
                    quantity=item.quantity
                ) for item in cart_items
            ]
            OrderItem.objects.bulk_create(order_items)

            Cart.objects.filter(pk=cart_id).delete()

            order_created.send_robust(self.__class__, order=order)

            return order



core/signals/handlers.py:
from django.dispatch import receiver
from store.signals import order_created

@receiver(order_created)
def on_order_created(sender, **kwargs):
  print(kwargs['order'])
  
  
  
core/apps.py:
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self) -> None:
        import core.signals.handlers 


📌 Key Takeaways
✔ Custom signals (order_created) allow apps to react to events asynchronously. 
✔ Signal handlers (@receiver(order_created)) process events without direct dependencies. 
✔ The store app fires an order event, while other apps (core, email, analytics) subscribe to it. 
✔ Django apps remain modular and scalable—new features can be added without modifying existing code. 



-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Django Part - 3



🔰 Getting Started

✅ Purpose  
This is the final part of a 3-part Django series. Parts 1 & 2: built a REST API for an online store.  
In this part → focus on real-world, production-ready features.

📦 Topics Covered  
- File Uploads : How to accept and manage file input in forms, store files in the server, and serve uploaded files securely.  
- Email Support ('send_mail'): Techniques to send emails using Django's built-in send_mail() function and configuring email backends.  
- Background Tasks (Celery + Redis): Leveraging tools like Celery + Redis to offload long-running tasks for performance.  
- Automated Testing ('unittest', coverage): Writing unit tests using Django's test client, unittest, and coverage analysis.  
- Performance Testing (Locust, JMeter): Measuring system responsiveness using tools like Locust or Apache JMeter.  
- Caching (Redis, Memcached, file-based cache): Implementing caching via Memcached, Redis, or Django’s file-based cache for optimizing load times.

⚠️ Pre-requisite  
Requires completion of Parts 1 & 2:  
- Project architecture  
- DRF concepts  
- Authentication  
- Shortcuts & best practices






















2. Setting Up the Project:



🚀 Project Setup – Storefront Part 3

This phase lays the groundwork for working with advanced Django features. Even if you’ve cloned the repo, make sure to follow all steps precisely to avoid configuration issues.



✅ Step-by-Step Setup Guide:

1. Create a New MySQL Database
Open DataGrip (or your preferred DB tool) and create a fresh database:

'''sql
CREATE DATABASE storefront3;
'''

This ensures you're working in isolation from previous project phases.



2. Download the Project Starter Files
Download the '.zip' file attached with the course and extract it. Inside:

'''
📂 code/
   └── 📂 section-1/
         └── 📂 start/
'''

Open the 'start' folder in VS Code.



3. Update Database Credentials
Navigate to:

'''
storefront3/settings.py
'''

Update the 'DATABASES' section with your local MySQL password:

'''python
'PASSWORD': 'your_mysql_password',
'''



4. Install Dependencies
Open the terminal in VS Code and run:

'''bash
pipenv install
'''

This installs all required Python packages from 'Pipfile'.



5. Activate the Virtual Environment
'''bash
pipenv shell
'''

Then, configure VS Code to use this Python interpreter:
- Run 'which python' (Linux/Mac) or 'where python' (Windows) inside the shell.
- Copy the path and open the Command Palette (⇧⌘P / Ctrl+Shift+P).
- Search: 'Python: Select Interpreter'
- Choose 'Enter interpreter path', paste the path, and replace 'activate' with 'python' at the end.


6. Run Migrations
'''bash
python manage.py migrate
'''

> Creates all database tables based on models.



7. Populate the Database (New Approach!)
We’ll seed data using a custom management command rather than a raw '.sql' import.

📁 File Structure:
'''
store/
└── management/
    └── commands/
        └── seed_db.py  ← custom command
        └── seed.sql    ← SQL data file
'''



📌 'seed_db.py' Implementation

from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os

class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)


📌 Run the command:
'''bash
python manage.py seed_db
'''

✅ “Populating the database...” – your data is now seeded.



8. Create a Superuser
'''bash
python manage.py createsuperuser
'''
Fill in:
- Username: 'admin'
- Email: 'admin@example.com'
- Password: 'yourpassword'



9. Run the Server
'''bash
python manage.py runserver
'''

Visit:
- [http://localhost:8000/](http://localhost:8000/) → Blank homepage
- [http://localhost:8000/store/collections](http://localhost:8000/store/collections) → Confirm seeded collections
- [http://localhost:8000/store/products](http://localhost:8000/store/products) → Should show 1000 products with pagination



10. Login to Admin Panel
Go to:
'''
http://localhost:8000/admin
'''

Login with the credentials created in step 8.



📊 Summary Flow Diagram:
┌──────────────────────────────────────────────┐
│        Project Setup Flow (Storefront 3)     │
├───────────────────────┬──────────────────────┤
│ Create DB             │ storefront3          │
│ Download project      │ Code → Section 1     │
│ Update DB settings    │ settings.py          │
│ pipenv install        │ Install dependencies │
│ pipenv shell          │ Activate env         │
│ Interpreter setup     │ Use env Python       │
│ migrate               │ Create tables        │
│ seed_db               │ Populate DB          │
│ createsuperuser       │ Create admin user    │
│ runserver             │ Launch server        │
└───────────────────────┴──────────────────────┘


💡 Troubleshooting Tip
If you face any errors during setup:
- ✅ Check forums: [forum.codewithmosh.com](https://forum.codewithmosh.com)
- ✅ Use Google or Stack Overflow






Codes and other notes in this discussion: 

storefront3\store\management\commands\seed_db.py:

from django.core.management.base import BaseCommand
from django.db import connection
from pathlib import Path
import os


class Command(BaseCommand):
    help = 'Populates the database with collections and products'

    def handle(self, *args, **options):
        print('Populating the database...')
        current_dir = os.path.dirname(__file__)
        file_path = os.path.join(current_dir, 'seed.sql')
        sql = Path(file_path).read_text()

        with connection.cursor() as cursor:
            cursor.execute(sql)



Then in the terminal:
python manage.py seed_db



















Uploading Files:
----------------
In this section, we're going to talk about uploading files. So together, we'll build a RESTful API that client apps can call for uploading images. It's going to be a lot of fun, so let's jump in and get started.

Managing Media Files:
---------------------




📌 Managing Media Files in Django
To support file uploads (e.g. images), Django must know where to store user-uploaded files and how to serve them in development. These files are commonly referred to as media files, and they must be configured separately from static files.



📌 1. Creating the 'media/' Directory
✔ In the root of your project, create a folder named:
'''
media/
'''

✔ This is where Django will save user-uploaded content.  
✔ Although you could name it something like 'uploads', 'media/' is standard and widely used in Django documentation.




📌 2. Configuring 'settings.py'

Open your 'settings.py' and add the following:

'''python
import os

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
'''

# 🔍 Explanation:
| Setting       | Purpose                                                                 |
|---------------|-------------------------------------------------------------------------|
| 'MEDIA_URL'   | Public-facing URL path where media files will be served ('/media/').   |
| 'MEDIA_ROOT'  | Absolute filesystem path to the folder where uploaded files are stored. |

✔ 'BASE_DIR' is already defined in 'settings.py', pointing to the root project directory.





📌 3. Testing the Setup (Optional)
✔ Place any image (e.g. 'dog.jpg') into the 'media/' directory.  
✔ This simulates a file that might have been uploaded by a user.





📌 4. Updating 'urls.py' to Serve Media

✔ In development, Django must be explicitly told to serve media files via a URL route.

In 'storefront/urls.py':

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


🔍 Explanation:
- 'static()' connects the '/media/' URL endpoint to the actual 'MEDIA_ROOT' on the disk.
- Only executes in development ('DEBUG = True'), not in production.

> ⚠️ In production, you should serve media files using a dedicated web server (e.g. NGINX) instead.





📌 5. Verifying Your Setup
✔ Run your development server:
'''bash
python manage.py runserver
'''

✔ Visit this URL in your browser:
'''
http://localhost:8000/media/dog.jpg
'''

✅ If the image loads, Django is correctly serving files from the 'media/' folder.






Codes and other notes in this discussion: 

settings.py:

MEDIA_URL = '/media'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')



urls.py:
from django.conf import settings 
from django.conf.urls.static import static


urlpatterns = [
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


A better way to write this code: 

if settings.DEBUG:
	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)






📌 Key Takeaways
✔ Media files are user-uploaded content and must be handled separately from static assets.  
✔ Define 'MEDIA_URL' and 'MEDIA_ROOT' in 'settings.py'.  
✔ Use 'static()' in 'urls.py' only in development (guarded by 'if settings.DEBUG').  
✔ In production, serve media files using a web server—not Django.  
✔ Placing files in 'media/' and verifying via browser confirms proper configuration.

























Adding Images to Products: 
--------------------------
📌 Adding Images to Products in Django
Each product can now have zero or more images, which requires creating a new model and establishing a one-to-many relationship between 'Product' and 'ProductImage'.



📌 1. Defining the 'ProductImage' Model
✔ Add this new class right after the existing 'Product' model in 'store/models.py', since they are closely related.

class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])





📌 2. Explanation of Fields
➤ 'product = models.ForeignKey(...)'
- Relation: One-to-many — each product can have multiple images.
- on_delete=models.CASCADE': If a product is deleted, its images are deleted too.
- related_name='images'': Enables reverse lookup using 'product.images.all()'.

➤ 'image = models.ImageField(...)'
- Purpose: Stores image files associated with products.
- upload_to='store/images'': Images are stored under 'MEDIA_ROOT/store/images/'.
- validators=[validate_file_size]': Optional custom validator to restrict max file size.

✔ Note: Use 'ImageField' for image validation and dimension support. Use 'FileField' only for generic files (e.g., PDFs, DOCs).





📌 3. Why Store Image Files in the Filesystem
✔ Do NOT store images in the database.  
✔ Images are stored in the filesystem, and only their file paths are saved in the DB.

 ✳️ Advantages:
- Keeps the database lightweight.
- Improves query performance.
- Easier to serve files directly from disk (or a CDN in production).





📌 4. Installing Pillow (Image Support Library)
pipenv install pillow

✔ 'Pillow' is required for Django to process and validate image files.





📌 5. Creating and Running Migrations
python manage.py makemigrations
python manage.py migrate

✔ This will create the corresponding database table to store product image references.





📌 6. Project Structure Reference
Media files will be stored in the following structure:

project_root/
├── media/               ← MEDIA_ROOT
│   └── store/
│       └── images/      ← Image upload folder
├── store/
│   └── models.py        ← Product & ProductImage models





Codes and Other Notes in this discussion: 

store/models.py:
class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])
		
		
pipenv install pillow 

python manage.py makemigrations
python manage.py migrate 





📌 Key Takeaways
✔ A ProductImage model adds image upload functionality with a clear one-to-many structure.  
✔ ImageField ensures proper validation for image uploads.  
✔ Uploaded files are saved under 'MEDIA_ROOT/store/images/', not in the database.  
✔ Use 'related_name' for clean reverse lookups like 'product.images.all()'.  
✔ Install Pillow to enable Django’s image handling features.



Next up: Building an API that enables clients to upload images tied to specific products. Let me know if you'd like to bundle this and the next section into a printable PDF cheat sheet 🧾📁.
















Building an API to Upload Images: 
----------------------------------



📌 Uploading Images for Products in Django
To allow users to upload images for products, we implement a one-to-many relationship between 'Product' and a new model 'ProductImage', and expose it through a nested API endpoint.



📌 1. Defining the Image Upload Endpoint
✔ The endpoint is designed as:  
'''
/products/<product_id>/images/
'''
✔ Follows a nested resource structure, where each product can have multiple images.

✔ Django REST Framework requires three core components:
- Serializer
- ViewSet
- Router





📌 2. Creating the Serializer
✔ In 'store/serializers.py', define 'ProductImageSerializer'.

class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, validated_data)

    class Meta:
        model = ProductImage
        fields = ['id', 'image']


✔ Why product ID isn't included in 'fields':
- It is already present in the URL ('product_pk'), so no need to duplicate it in the form body or JSON.

✔ 'create()' method uses the 'product_id' from 'context' to associate the image.





📌 3. Creating the ViewSet
✔ In 'store/views.py', define 'ProductImageViewSet'.


class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}

    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])


✔ 'product_pk' is automatically extracted from the URL using 'kwargs'.
✔ 'get_queryset()' filters only images for the specified product.





📌 4. Configuring the Nested Router
✔ In 'store/urls.py', use 'NestedDefaultRouter' to register the image sub-resource.

'''python
router = routers.DefaultRouter()
router.register('products', views.ProductViewSet, basename='products')

products_router = routers.NestedDefaultRouter(router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet, basename='product-reviews')
products_router.register('images', views.ProductImageViewSet, basename='product-images')
'''

✔ 'lookup='product'' creates a route like '/products/<product_pk>/images/'.





📌 5. Handling Form Uploads
✔ When posting an image using a form or JSON, you don’t include the 'product_id'—it’s derived from the route.

✔ If you see the error:
'''
Column 'product_id' cannot be null
'''
➡ It means the 'product_id' wasn’t manually injected, which is why we override 'create()' and use 'context'.





📌 6. Testing the API
- Upload images at '/products/1/images/'.
- Files are stored in:
  '''
  media/store/images/
  '''
- Django automatically appends suffixes to filenames if duplicates are uploaded (e.g., 'dog_xxx.jpg').





📌 7. Key Takeaways
✔ Use a nested router to expose image upload routes per product.  
✔ Do not include 'product_id' in the form—it is inferred from the URL.  
✔ Override 'create()' in the serializer to inject 'product_id'.  
✔ Use 'get_serializer_context()' to pass the context into the serializer.  
✔ Uploaded files are saved to the file system, not the database.  
✔ This design keeps the API clean, secure, and scalable.






Codes and Other Notes in this Discussion: 

/products/1/images/1


serializers.py:
class ProductImageSerializer(serializers.ModelSerializer):
    def create(self, validated_data):
        product_id = self.context['product_id']
        return ProductImage.objects.create(product_id=product_id, **validated_data)

    class Meta:
        model = ProductImage
        fields = ['id', 'image']

		


views.py:
class ProductImageViewSet(ModelViewSet):
    serializer_class = ProductImageSerializer

    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk']}

    def get_queryset(self):
        return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])




urls.py:

router = routers.DefaultRouter()
router.register('products', views.ProductViewSet, basename='products')


products_router = routers.NestedDefaultRouter(
    router, 'products', lookup='product')
products_router.register('reviews', views.ReviewViewSet,
                         basename='product-reviews')
products_router.register(
    'images', views.ProductImageViewSet, basename='product-images')






📌 8. Summary
| Component                    | Purpose                                                                      |
|------------------------------|------------------------------------------------------------------------------|
| 'ProductImageSerializer'     | Validates and saves uploaded image. Uses 'context' to retrieve 'product_id'. |
| 'ProductImageViewSet'        | Filters images by 'product_pk' and injects it into serializer context.       |
| 'products_router.register()' | Sets up the nested route '/products/<product_pk>/images/'.                   |



















Returning Images from the API:
------------------------------


📌 Returning Images with Products via the API

After implementing the product image upload feature, we want to ensure that product images are included in the product list API response. This avoids requiring the client to make multiple requests to fetch images for each product, improving efficiency and performance.



📌 1. Extending the Product Serializer

📄 File: 'store/serializers.py'

✔ Modify the 'ProductSerializer' to include an 'images' field:

class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ['id', 'image']


✔ Move 'ProductImageSerializer' above 'ProductSerializer' in the file to avoid reference issues.
✔ Then add the nested field to 'ProductSerializer':

class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = [
            'id', 'title', 'description', 'slug', 'inventory',
            'unit_price', 'price_with_tax', 'collection', 'images'
        ]

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)


🔍 Explanation:
- 'many=True': Because a product can have multiple images.
- 'read_only=True': Prevents images from being submitted during product creation.
- 'ProductImageSerializer': Used to serialize the nested list of images for each product.





📌 2. Eager Loading Images to Avoid Duplicate Queries
✔ Without optimization, Django performs a separate query to fetch images for each product, leading to duplicate queries and inefficient performance.
✔ To prevent this, update the 'ProductViewSet' to use eager loading via 'prefetch_related()':

📄 File: 'store/views.py'

class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}


🔍 Explanation:
- 'prefetch_related('images')': Preloads all product images in a single query.
- Prevents N+1 query problem, reducing the number of queries from one per product to just two.





📌 3. Testing in Browser
✔ Navigate to '/store/products/'.  
✔ Each product now includes an 'images' key, which is a list of associated image objects:

"images": [
    {
        "id": 1,
        "image": "http://localhost:8000/media/store/images/dog.jpg"
    }
]


✔ Clicking the image URL should display the uploaded image.
✔ Confirm performance using Django Debug Toolbar:  
- Before optimization: ~14 queries  
- After adding 'prefetch_related('images')': reduced to ~6 queries






Codes and Other Notes in this Discussion: 


serializer.py:
class ProductSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = ['id', 'title', 'description', 'slug', 'inventory',
                  'unit_price', 'price_with_tax', 'collection', 'images']

    price_with_tax = serializers.SerializerMethodField(
        method_name='calculate_tax')

    def calculate_tax(self, product: Product):
        return product.unit_price * Decimal(1.1)
		
		
		
views.py:
class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)




📌 Key Takeaways
✔ To include related media in list responses, use nested serializers.  
✔ Set 'many=True' and 'read_only=True' when returning related lists that aren't modified directly.  
✔ Always use 'prefetch_related()' in the view to optimize query performance.  
✔ Including images in the product list response avoids excessive API calls by the client.  
✔ This approach keeps the API lean and responsive under load.














Validating Uploading Files:
---------------------------


📌 Validating Uploaded Files in Django
Django provides some built-in mechanisms for validating uploaded content. However, certain validations—such as file size checks—require custom logic. This note outlines how image and file validation works, including how to implement custom validators for uploads.



📌 1. Default Validation via 'ImageField'
✔ In 'ProductImage' model, the 'image' field is defined using 'models.ImageField'.  
✔ This field automatically validates that the uploaded file is a valid image format (e.g. JPEG, PNG).  
✔ Internally, Django uses the Pillow library to perform this check.

📌 Therefore, we must install Pillow:
pipenv install pillow


✔ If a user uploads a non-image file (like '.pdf'), Django will raise an error automatically.





📌 2. Validating File Size (Custom Validator)
Django does not validate the size of an uploaded file by default. To implement this, create a custom validator.

📄 File: 'store/validators.py'
from django.core.exceptions import ValidationError

def validate_file_size(file):
    max_size_kb = 500

    if file.size > max_size_kb * 1024:
        raise ValidationError(f'Files cannot be larger than {max_size_kb}KB!')


📌 This validator:
- Limits uploaded files to 500 KB
- Raises a 'ValidationError' with a descriptive message





📌 3. Applying the Validator to 'ImageField'

In 'store/models.py':

from .validators import validate_file_size

class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])


✔ The 'validators' argument accepts a list of one or more validator functions.




📌 4. Testing the File Size Validator

To test:
- Upload an image larger than 500 KB via '/products/<id>/images/'
- Django will raise:
Files cannot be larger than 500KB!


✔ ✅ This confirms the custom size validator works as expected.





📌 5. Validating File Extensions (For 'FileField')
✔ When using 'FileField' (for generic uploads like PDFs or docs), Django does not check file types.  
✔ To restrict allowed extensions (e.g. '.pdf' only), use 'FileExtensionValidator'.

🧪 Temporary demo — change 'ImageField → FileField' in 'models.py':

from django.core.validators import FileExtensionValidator

file = models.FileField(
    upload_to='store/files',
    validators=[FileExtensionValidator(allowed_extensions=['pdf'])]
)


✔ This restricts uploads to only files with '.pdf' extension.
✔ If a '.jpg' file is uploaded, error:
File extension “jpg” is not allowed. Allowed extensions are: pdf.


⚠️ You do not need this with 'ImageField' since it validates file type automatically using Pillow.




📌 6. Final Cleanup
✔ After testing 'FileField' + 'FileExtensionValidator', switch back:

- Replace 'FileField' with 'ImageField'
- Restore the custom file size validator

image = models.ImageField(
    upload_to='store/images',
    validators=[validate_file_size])





Codes and Other Notes in this discussion: 

validators.py:
from django.core.exceptions import ValidationError


def validate_file_size(file):
    max_size_kb = 500

    if file.size > max_size_kb * 1024:
        raise ValidationError(f'Files cannot be larger than {max_size_kb}KB!')




models.py:
class ProductImage(models.Model):
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(
        upload_to='store/images',
        validators=[validate_file_size])
		
		
		
For files --> from django.core.validators import FileExtensionValidator		

validators = [FileExtensionValidator(allowed_extensions=['pdf'])






📌 Key Takeaways
✔ 'ImageField' automatically validates uploaded images using Pillow  
✔ Create a custom validator to limit file size  
✔ Use 'FileExtensionValidator' to restrict file type for FileField uploads  
✔ Apply validators using the 'validators=[...]' argument  
✔ Raising 'ValidationError' ensures clean feedback for invalid uploads


















Setting Up the Client App:
--------------------------


📌 Setting Up the Client App for File Uploads
In this lesson, we set up a simple front-end client to test file uploads to our Django API. The client is a basic JavaScript application, but no prior knowledge of JavaScript is required to follow this setup.



📌 1. Locate the Client App Folder
✔ Inside the provided course zip file, under:
Section 2 → Uploading Files → client-app/

✔ This folder contains the complete source code of a lightweight client built for demo and testing purposes.
✔ Purpose: Help full-stack developers understand how file uploads work from both the front-end and back-end.




📌 2. Open the Project in VS Code
✔ Launch a new instance of Visual Studio Code.
✔ Drag and drop the 'client-app' folder into the new window to open it as a project workspace.





📌 3. Install Node.js (if not already installed)
✔ This project runs on Node.js, a JavaScript runtime environment.

✔ If Node.js is not installed:
- Visit [https://nodejs.org](https://nodejs.org)
- Download and install the latest LTS version

✔ You can verify installation using the terminal:
node -v


📌 Example:
v17.x.x




📌 4. Install Project Dependencies
✔ In the terminal (within the 'client-app' folder), run:
npm install

✔ This will install all required packages from 'package.json'.
✔ You may see warnings during installation — they are harmless and can be ignored for now.




📌 5. Start the Development Server

✔ Run the app locally using:
npm start

✔ This will spin up a development server on 'localhost:8001'.
✔ Open your browser and navigate to:
http://localhost:8001






📌 6. Confirm the Interface Loads
✔ You’ll see a simple web page with an input field for uploading images.
✔ Note: The upload feature doesn’t work yet — there’s a cross-origin issue that will be addressed in the next lesson.



📌 Key Takeaways
✔ A minimal JavaScript client project is provided to simulate file uploads to the Django API.  
✔ Node.js is required to run the app — install it from nodejs.org if not already installed.  
✔ Use 'npm install' to install dependencies and 'npm start' to launch the app.  
✔ The app runs at 'http://localhost:8001' and provides a basic upload interface.  
✔ Current functionality is limited — we’ll fix connectivity with the Django server in the next lesson.






















Enabling CORS:
--------------
📌 Enabling CORS in Django for File Uploads
When a frontend application (hosted on a different port or domain) attempts to make requests to a Django API, it triggers browser-enforced Cross-Origin Resource Sharing (CORS) restrictions. This step outlines how to configure Django to safely accept such requests, especially for file uploads.




📌1. Understanding the Problem

➤ Scenario:
- Client app is served at: 'http://localhost:8001'
- Django API runs at: 'http://localhost:8000'

Even though both run on the same machine, they are considered different origins due to port mismatch.

➤ Result:
The browser blocks requests from the client to the API, showing:
Could not reach the server.





📌 2. What Is CORS?
CORS (Cross-Origin Resource Sharing) is a browser security mechanism that:
- Prevents unauthorized cross-origin requests
- Ensures APIs only accept requests from approved sources

In our case, we must tell Django to explicitly allow requests from 'localhost:8001'.





📌 3. Installing Required Library
Use the official package: ['django-cors-headers'](https://pypi.org/project/django-cors-headers/)
pipenv install django-cors-headers




📌 4.Configuration in 'settings.py'

➤ a) Add to Installed Apps:

INSTALLED_APPS = [
    # Django built-ins
    'django.contrib.admin',
    ...

    # Third-party apps
    'corsheaders',

    # Local apps
    'store',
    ...
]


➤ b) Add Middleware (must be near the top):
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    ...
]

🔍 *CORS middleware must appear before 'CommonMiddleware' to ensure proper processing.*


➤ c) Define Allowed Origins:
CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]


✔ This allows requests from both domain variants.




📌 5. Testing the Setup

➤ Initial Behavior:
- Uploading a file from client app: Fails with CORS error

➤ After Enabling CORS:
- Upload succeeds
- Backend returns an image URL
- Upload progress is visible via the progress bar




📌 6. Using Chrome DevTools to Inspect Requests

✔ Go to Developer Tools → Network Tab → Throttling → Slow 3G  
✔ Upload a file to watch request flow in slow motion

🔍 Request Breakdown:
1. OPTIONS request  
   - Used for preflight check
   - Server responds with headers:
     '''
     Access-Control-Allow-Origin: http://localhost:8001
     '''
2. POST request  
   - File upload is executed upon CORS approval

✔ After successful upload, Chrome shows both requests sequentially.





📌 7. Restoring Default Network Mode

✔ Don’t forget to disable throttling after testing:
- DevTools → Network tab → Throttling → No throttling




Codes and Other Notes in this discussion: 

django cors headers --> https://pypi.org/project/django-cors-headers/


in settings.py:

CORS_ALLOWED_ORIGINS = [
    'http://localhost:8001',
    'http://127.0.0.1:8001',
]





📌 Key Takeaways
✔ CORS prevents clients from different origins from accessing APIs by default.  
✔ Use 'django-cors-headers' to allow trusted frontend domains to send requests.  
✔ Register the middleware early in the list.  
✔ Use 'CORS_ALLOWED_ORIGINS' to explicitly whitelist client domains.  
✔ Preflight 'OPTIONS' requests are automatically handled by the middleware.  
✔ Use browser dev tools to confirm CORS headers and troubleshoot file uploads.



























Managing Images in the Admin:
-----------------------------
📌 Managing Product Images in the Django Admin Interface
This section covers the full implementation of managing and previewing product images inside the Django admin using inline editing and thumbnail previews.




📌 1. Displaying Product Images Inline

➤ Context:
By default, the Product admin page doesn't show associated images.  
We want to manage images just like we do with tags—using inlines.

➤ Refresher: Admin Layers
| Admin Class Location | Responsibility                                                              |
|----------------------|-----------------------------------------------------------------------------|
| 'store/admin.py'     | Reusable logic specific to the store app (e.g. 'ProductAdmin')              |
| 'core/admin.py'      | Project-specific logic that extends 'ProductAdmin' via 'CustomProductAdmin' |




📌 2. Defining an Inline for ProductImage

📄 store/admin.py:
class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''


✔ 'thumbnail()' renders the image as an HTML tag  
✔ 'readonly_fields' registers it in the UI  
✔ 'format_html()' is used to safely inject HTML  




📌 3. Registering the Inline in Both Admin Classes

📄 In 'store/admin.py' → ProductAdmin:

@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    ...
    inlines = [ProductImageInline]



📄 In 'core/admin.py' → CustomProductAdmin

class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]

✔ Django combines reusable logic from the 'store' app with project-specific enhancements in 'core'.





📌 4. Styling the Image as a Thumbnail

➤ Define a CSS class:
📁 'store/static/store/styles.css'

'''css
.thumbnail {
  width: 100px;
  height: 100px;
  object-fit: cover;
}
'''

✔ 'width' & 'height': Forces a square frame  
✔ 'object-fit: cover': Prevents image distortion





📌 5. Loading the CSS in Admin via Media Class

📄 Inside ProductAdmin:
class ProductAdmin(admin.ModelAdmin):
    ...

    class Media:
        css = {
            'all': ['store/styles.css']
        }


✔ This loads 'styles.css' on all product admin views  
✔ ''all'' is a CSS media type (applies to screen, print, etc.)





📌 6. Namespacing Static Files to Avoid Conflicts

✔ By default, Django collects all static files from installed apps  
✔ If two apps have a file named 'styles.css', one could overwrite the other

📁 Organize like this:

store/
└── static/
    └── store/
        └── styles.css


✔ Update the 'Media' class to use: ''store/styles.css''






Codes and Other Notes in this Discussion: 


core/admin.py:

class TagInline(GenericTabularInline):
    autocomplete_fields = ['tag']
    model = TaggedItem


class CustomProductAdmin(ProductAdmin):
    inlines = [TagInline, ProductImageInline]


admin.site.unregister(Product)
admin.site.register(Product, CustomProductAdmin)




store/admin.py:
from django.utils.html import format_html, urlencode

class ProductImageInline(admin.TabularInline):
    model = models.ProductImage
    readonly_fields = ['thumbnail']

    def thumbnail(self, instance):
        if instance.image.name != '':
            return format_html(f'<img src="{instance.image.url}" class="thumbnail" />')
        return ''


@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    autocomplete_fields = ['collection']
    prepopulated_fields = {
        'slug': ['title']
    }
    actions = ['clear_inventory']
    inlines = [ProductImageInline]
    list_display = ['title', 'unit_price',
                    'inventory_status', 'collection_title']
    list_editable = ['unit_price']
    list_filter = ['collection', 'last_update', InventoryFilter]
    list_per_page = 10
    list_select_related = ['collection']
    search_fields = ['title']

    def collection_title(self, product):
        return product.collection.title

    @admin.display(ordering='inventory')
    def inventory_status(self, product):
        if product.inventory < 10:
            return 'Low'
        return 'OK'

    @admin.action(description='Clear inventory')
    def clear_inventory(self, request, queryset):
        updated_count = queryset.update(inventory=0)
        self.message_user(
            request,
            f'{updated_count} products were successfully updated.',
            messages.ERROR
        )

    class Media:
        css = {
            'all': ['store/styles.css']
        }
		


store\static\store\styles.css:
		
.thumbnail {
  width: 100px;
  height: 100px;
  object-fit: cover;
}




📌 Key Takeaways

✔ Define a 'TabularInline' for displaying related 'ProductImage' entries.  
✔ Render thumbnails via a method using 'format_html()' and 'instance.image.url'.  
✔ Apply custom CSS to style images as thumbnails.  
✔ Use 'Media' class to load static assets in the admin.  
✔ Namespace static files inside 'static/store/' to avoid conflicts across apps.















Sending Emails:
---------------
In this section, we'll be talking about sending emails from your Django applications. 



Setting up a Fake SMTP Server:
------------------------------
📧 Setting Up a Fake SMTP Server for Email Testing
In order to simulate email sending in a development environment, we need a local SMTP server. Instead of using a real (often paid) SMTP provider during development, we'll set up a fake SMTP server using SMTP4DEV, a powerful testing tool.



📌 1. What Is SMTP?
- SMTP stands for *Simple Mail Transfer Protocol*.
- It is a protocol used to send and receive emails.
- Real SMTP servers (e.g., Gmail, SendGrid) are used in production, and usually require authentication and sometimes cost money.





📌 2. Why Use a Fake SMTP Server in Development?
✔ Avoids sending real emails  
✔ Lets developers preview emails sent by the application  
✔ Offers an admin panel to visualize email content




📌 3. Introducing SMTP4DEV

GitHub link: [https://github.com/rnwood/smtp4dev](https://github.com/rnwood/smtp4dev)
SMTP4DEV is a fake SMTP server designed for developers. It captures sent emails and displays them in a web-based interface.




📌 4. Installation Options

You can install SMTP4DEV in one of two ways:

➤ Option 1: Using .NET Core (v3.1+)
dotnet tool install Rnwood.Smtp4dev --global
smtp4dev

✔ Recommended for systems that already use .NET SDK.



➤ Option 2: Using Docker (Preferred)
Docker is a container platform used to run applications in isolated environments.

📌 If Docker is not installed:
- Visit [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
- Download and install Docker Desktop for your OS

📌 Then run the following command:
docker run --rm -it -p 3000:80 -p 25:25 rnwood/smtp4dev


✔ This pulls the SMTP4DEV Docker image from Docker Hub and exposes:
- Port 25 for sending emails
- Port 3000 for the browser-based admin panel





📌 5. Confirming It Works

➤ Access the Admin Panel
- Open your browser and navigate to:
  '''
  http://localhost:3000
  '''

- This panel functions like a mock email inbox.
- Any emails sent by your Django app during development will appear here.



📌 Visual Overview:
[Django App] --(send email)--> [SMTP4DEV @ localhost:25]
                             ↳ View messages at http://localhost:3000


✔ Acts like an inbox (Outlook/Webmail)  
✔ Helps visualize subject, recipients, headers, HTML content, and attachments



Codes and Other Notes in this discussion:

smtp4dev --> https://github.com/rnwood/smtp4dev



📌 Key Takeaways
✔ SMTP4DEV helps you test email functionality without sending real emails  
✔ You can view and debug email content in a browser-friendly admin panel  
✔ Installation is quick using Docker or .NET CLI  
✔ This setup is only for local development — production uses real SMTP providers



Once set up, you’re ready to configure your Django project to use this SMTP server. That’s what we’ll cover next. Let me know if you want a Docker-free setup or help integrating this with Django's 'EMAIL_BACKEND'. 📮🚀

















Configuring the Email Backend: 
------------------------------


📩 Configuring the Email Backend in Django
Django provides multiple email backends for different environments and use cases. This setup explains how to configure Django to send emails via an SMTP server, specifically using a fake SMTP server like smtp4dev in a development environment.



📌 1. What is an Email Backend?

An email backend in Django is a component responsible for handling the actual sending of emails. Django supports various backends for different scenarios:

| Backend Type | Description |
|--------------|-------------|
| SMTP         | Default backend. Sends emails via an SMTP server. |
| Console      | Prints emails to the terminal instead of sending them (used for local dev/testing). |
| File         | Writes emails to files in a designated directory. |
| LocMem       | Stores emails in memory (typically for testing). |
| Dummy        | Discards all email actions (used for disabling email entirely). |

📌 Reference: ''django.core.mail.backends.smtp.EmailBackend'' is Django’s default backend.





📌 2. Configuring the SMTP Backend in 'settings.py'

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'             # Address of the SMTP server
EMAIL_HOST_USER = ''                 # Not required for fake SMTP
EMAIL_HOST_PASSWORD = ''            # Not required for fake SMTP
EMAIL_PORT = 2525                   # Default SMTP is 25; smtp4dev uses 2525
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'


✅ Even though the SMTP backend is default, specifying it makes the configuration explicit.  
✅ 'localhost' refers to where our SMTP server (e.g., smtp4dev) is hosted.  
✅ 'EMAIL_PORT = 2525' because smtp4dev maps port 2525 for incoming email requests.





📌 3. Avoid Hardcoding Credentials in Production

For real SMTP services (SendGrid, Mailgun, etc.):
- You will need to supply valid 'EMAIL_HOST_USER' and 'EMAIL_HOST_PASSWORD'.
- Avoid hardcoding passwords in 'settings.py'.

⚠️ Best Practice:
Use environment variables to securely store credentials:

import os

EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')

You can load these using '.env' files and libraries like 'python-decouple' or 'django-environ'.




✅ Final Sample Snippet for Development

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_PORT = 2525
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'






Codes and Other Notes in this discussion: 

Backends: 
SMTP(Default)
Console
File
Locmem
Dummy


settings.py:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525   #by default smtp servers runs on port 25
DEFAULT_FROM_EMAIL = 'from@moshbuy.com'





📌 Key Takeaways
✔ Django provides several email backends; SMTP is the default.  
✔ Use 'smtp4dev' during development for safe and local email testing.  
✔ Set 'EMAIL_BACKEND', 'EMAIL_HOST', and 'EMAIL_PORT' to connect to your SMTP server.  
✔ In real applications, use environment variables to protect credentials.  
✔ You can switch to the console backend for quick debugging:
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'


























Sending Emails:
---------------
📧 Sending Emails in Django
With the email backend and SMTP server (like smtp4dev) configured, Django can now send emails using its built-in utilities. This note covers how to send emails to users and site admins with support for plain text and HTML content, and how to handle common errors safely.



📌 1. Django’s Built-in Email Utilities

Import these tools from 'django.core.mail':

from django.core.mail import send_mail, mail_admins, BadHeaderError


Available Functions:

| Function          | Purpose                                   |
|-------------------|-------------------------------------------|
| 'send_mail()'     | Sends a single email                      |
| 'send_mass_mail()'| Sends multiple emails over one connection |
| 'mail_admins()'   | Sends email to site admins (from settings)|
| 'mail_managers()' | Sends email to site managers              |

⚠️ 'send_mail()' opens a new connection per email;  
'send_mass_mail()' reuses a single connection — better for bulk sending.





📌 2. Sending a Basic Email:

Example: 'playground/views.py'

def say_hello(request):
    try:
        send_mail(
            subject='subject',
            message='message',
            from_email='info@moshbuy.com',        # overrides DEFAULT_FROM_EMAIL
            recipient_list=['bob@moshbuy.com']
        )
    except BadHeaderError:
        pass  # should ideally return an error response
    return render(request, 'hello.html', {'name': 'Mosh'})


🔍 Notes:
- 'BadHeaderError' is raised if malicious users inject headers (e.g., spoofing).
- Always catch and handle this exception securely.





📌 3. Verifying in smtp4dev (Port 3000)

After triggering this view (e.g., visiting '/playground/hello'), smtp4dev will display the sent email:
- View subject, recipient, and body
- Confirm delivery without actually sending to external servers





📌 4. Sending Email to Site Admins

Django can email site admins using 'mail_admins()'.

def say_hello(request):
    try:
        mail_admins(
            subject='subject',
            message='message',
            html_message='<strong>message</strong>'
        )
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})


🧩 Configuration in 'settings.py'

ADMINS = [
    ('Mosh', 'admin@moshbuy.com')
]

'mail_admins()' ignores the 'User' model — it relies solely on the 'ADMINS' setting.





📌 5. Plain Text vs HTML Emails

- 'message' → plain text content (suitable for all mail clients)
- 'html_message' → optional HTML version of the email

🔍 Why Send Both?
Some clients (e.g., screen readers or legacy devices) may only support plain text. Including both ensures maximum compatibility.

💡 smtp4dev Insight:
In the "Parts" tab of the email preview:
- You’ll see both 'text/plain' and 'text/html' versions.
- Clients will render the preferred format based on support.






Codes and Other Notes in this Discussion: 

playground/views.py:

from django.core.mail import send_mail, mail_admins, BadHeaderError 

def say_hello(request):
	try:
		send_mail('subject', 'message', 'info@moshbuy.com', ['bob@moshbuy.com'])
	except BadHeaderError:
		pass
	return render(request, 'hello.html', {'name': 'Mosh'})
	
	
#to mail_admins
def say_hello(request):
	try:
		mail_admins('subject', 'message', html_message='message')
	except BadHeaderError:
		pass
	return render(request, 'hello.html', {'name': 'Mosh'})
	
in settings.py:
ADMINS = [
    ('Mosh', 'admin@moshbuy.com')
]
	
	
	
	
	
✅ Summary

| Task                        | Description                                                  |
|-----------------------------|--------------------------------------------------------------|
| 'send_mail()'               | Sends a user-facing email                                    |
| 'mail_admins()'             | Sends site-wide alerts to configured admins                  |
| 'BadHeaderError'            | Protects against header injection attacks                    |
| 'html_message'              | Sends a formatted HTML version along with plain text         |
| 'ADMINS' in settings        | Registers recipients for admin-level notifications           |


















Attaching Files:
----------------


📎 Attaching Files in Django Emails
By default, Django provides utility functions like 'send_mail()' and 'mail_admins()' for basic email functionality. However, if you want finer control over email content—such as adding attachments, CC/BCC support, or setting specific headers—you should use the 'EmailMessage' class directly.



📌 1. Why Use 'EmailMessage'?
Internally, helper functions like 'send_mail()' use 'EmailMessage' behind the scenes. But by constructing an 'EmailMessage' yourself, you unlock additional features like:
- File attachments
- Multiple recipients
- CC/BCC support
- Inline image support (advanced use cases)



📌 2. Attaching a File to an Email
✔️ Step-by-Step Setup
🧱 File Structure (Relative to Project Root):

playground/
└── static/
    └── images/
        └── dog.jpg


You can drag-and-drop your image into this folder to simulate attaching a file.



🧾 Sample Implementation
📄 File: 'playground/views.py':
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render

def say_hello(request):
    try:
        message = EmailMessage(
            subject='subject',
            body='message',
            from_email='from@moshbuy.com',
            to=['bob@moshbuy.com']
        )
        message.attach_file('playground/static/images/dog.jpg')
        message.send()
    except BadHeaderError:
        pass  # In production, log and return proper error response

    return render(request, 'hello.html', {'name': 'Mosh'})





📌 3. Explanation of Key Elements

| Parameter          | Description                                          |
|--------------------|------------------------------------------------------|
| 'subject'          | Email subject line                                   |
| 'body'             | Body of the message (can be plain text or HTML)     |
| 'from_email'       | Sender’s email address                               |
| 'to'               | List of recipient email addresses                    |
| 'attach_file(path)'| Attaches the file from the given path                |

⚠️ The file path is relative to the project root.



✅ Result

After triggering the view (e.g., reloading '/playground/hello/'), smtp4dev will show:
- An email with the subject line and body message
- A file attachment: 'dog.jpg'
- You can preview and download the attached file in the admin UI





Codes and Other Notes in this discussion: 

from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render


def say_hello(request):
    try:
       message = EmailMessage('subject', 'message', 'from@moshbuy.com', ['bob@moshbuy.com']
       message.attach_file('playground/static/images/dog.jpg')
	   message.send()
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})
	
	
		

📌 Key Takeaways

✔ Use 'EmailMessage' when you need more control than 'send_mail()' provides  
✔ Attach files using '.attach_file(path)' with correct file path  
✔ Always wrap 'send()' in a 'try-except' block to catch 'BadHeaderError'  
✔ Use smtp4dev to test your email setup without sending real emails  
✔ Useful for order receipts, invoices, downloadable reports, or any file delivery use case

	
	
	
	
	
	
	
	
	
	
Sending Templated Emails:
-------------------------	
📩 Sending Templated Emails in Django
Hardcoding email messages directly in your views can quickly become unmanageable—especially when emails grow in length or need to support dynamic content. Instead, we can use the 'django-templated-mail' library to manage email messages through reusable templates.



📌 1. Install 'django-templated-mail'

pipenv install django-templated-mail

This package provides the 'BaseEmailMessage' class—an extension of Django’s built-in 'EmailMessage'—with support for rendering subject, plain text, and HTML bodies via Django templates.



📌 2. Create a Templated Email:
📁 File: 'playground/templates/emails/hello.html'

{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}


🔍 Explanation:
- '{% block subject %}' → Defines the email subject
- '{% block html_body %}' → Contains HTML-formatted message content
- '{{ name }}' → Dynamically rendered using a context dictionary

✔ You may also define a '{% block text_body %}' for plain-text clients (optional).

> ⚠️ To avoid formatting issues in VS Code when editing block templates, use Auto Save and avoid manual saving (which may reformat blocks poorly).



📌 3. Using 'BaseEmailMessage' in Views

📄 File: 'playground/views.py':
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage
from django.core.mail import BadHeaderError

def say_hello(request):
    try:
        message = BaseEmailMessage(
            template_name='emails/hello.html',
            context={'name': 'Mosh'}
        )
        message.send(['john@moshbuy.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})


🔍 Key Points:
| Parameter        | Purpose                                               |
|------------------|--------------------------------------------------------|
| 'template_name'  | Relative path to the email template                    |
| 'context'        | Dictionary of variables to be rendered in the template |
| '.send(to=[])'   | Required list of recipient emails                      |

✔ 'BaseEmailMessage.send()' expects the 'to' parameter to be passed explicitly.



✅ Final Output (via smtp4dev):

When triggered:
- The recipient receives an email with the subject:  
  _"This is a long subject"_
- The body renders:
  '''html
  <h1>Hello</h1>
  My name is Mosh
  '''

✔ You can preview both HTML and plain text sections in the 'Parts' tab of smtp4dev.





Codes and Other Notes in this Discussion: 	
		
pipenv install django-templated-mail	

playground\templates\emails\hello.html:
{% block subject %}This is a long subject{% endblock %}

{% block html_body %}
<h1>Hello</h1>
My name is {{ name }}
{% endblock %}


views.py:	
from django.core.mail import EmailMessage, BadHeaderError
from django.shortcuts import render
from templated_mail.mail import BaseEmailMessage


def say_hello(request):
    try:
       message = BaseEmailMessage(
           template_name='emails/hello.html',
           context={'name': 'Mosh'}
       )
       message.send(['john@moshbuy.com'])
    except BadHeaderError:
        pass
    return render(request, 'hello.html', {'name': 'Mosh'})
	
	
	
	
	
📌 Key Takeaways
✔ Use 'django-templated-mail' to cleanly separate email content from Python logic.  
✔ Email content is stored and rendered from template files.  
✔ Templates support plain text and HTML blocks—along with dynamic variables.  
✔ Use 'BaseEmailMessage' with 'template_name' and 'context' to generate and send the email.  
✔ Always namespace your templates (e.g., 'emails/hello.html') to avoid collisions.




















Running Background Tasks:
-------------------------

In this section, we'll be talking about running background tasks in Django applications. 


Introduction to Celery:
-----------------------
📌 Introduction to Celery — Running Background Tasks in Django

Modern web applications often deal with resource-intensive tasks like:
- Sending emails
- Processing uploaded files (images, videos)
- Generating reports
- Running machine learning models
- Importing/exporting large data sets

These operations are typically slow and CPU-heavy, and should not block the request-response cycle of the main application. For a responsive and scalable system, such tasks should be offloaded to the background.



🔄 Real-World Scenario
Let’s say a user uploads a video to your app.  
❌ If the backend processes the video in the same request cycle, the user experiences long wait times.  

✅ Instead, we send the video to a background worker, and respond immediately:  
“We’re processing your video. You’ll be notified when it’s ready.”


🧠 Why Offload Background Tasks?

| Problem                         | Background Solution                     |
|---------------------------------|-----------------------------------------|
| Long-running tasks block server | Offload work to background worker       |
| Risk of request timeouts        | Reduce load on main process             |
| Poor user experience            | Immediate response improves UX          |
| Inflexible scaling              | Easily add workers to process more jobs |



🚀 Meet Celery
Celery is a popular Python framework for executing asynchronous tasks and scheduling periodic jobs.  
Website: [https://docs.celeryq.dev](https://docs.celeryq.dev)


🌟 Key Benefits:
- Offloads long-running tasks from the Django app
- Manages distributed task queues
- Supports scheduling (e.g., run every Monday 9 AM)
- Scales easily with multiple worker processes
- Is fault-tolerant: if a task fails, the Django app isn’t impacted



⚙️ How Celery Works (Conceptual Flow):
[Django App] ──▶ [Task Queue] ◀──▶ [Celery Workers]
       │                               ▲
       └─────────── Immediate Response │


1. App pushes a task to the queue (e.g., send email).
2. Celery worker picks up the task.
3. Worker processes the task and marks it complete.
4. Django remains responsive to other users.


🕒 Bonus: Task Scheduling
Celery can run periodic (cron-like) jobs:
- Run cleanup every day at midnight
- Rebuild cache every 6 hours
- Send weekly reports

This is done using Celery Beat (a scheduler that kicks off tasks based on a defined interval).




Codes and Other Notes in this Discussion: 

Long-Running Tasks:
Processing images and videos
Generating reports 
Sending emails
Running machine learning models 



📌 Key Takeaways:
✔ Celery enables running tasks asynchronously, outside the main Django process  
✔ Great for heavy, blocking, or scheduled tasks  
✔ Frees up Django to continue handling user requests instantly  
✔ Makes your app more responsive, scalable, and robust














Message Brokers:
----------------
📌 Understanding Message Brokers in Celery
In Celery-based architecture, tasks are sent to a queue by the main application and picked up by Celery workers for background execution. The message broker serves as the middleman between the application and the workers.


📌 1. What Is a Message Broker?
A message broker is software that:
- Acts as a queueing system for message delivery.
- Ensures reliable communication between producers (e.g., Django app) and consumers (e.g., Celery workers).
- Stores messages temporarily until they can be processed.

Think of it like a pipe that holds tasks and delivers them to available workers in order.


📌 2. Real-World Analogy
In English, the word "broker" means a middleman. For example:
- If you want insurance, instead of contacting every company yourself, you talk to an insurance broker.
- The broker connects you with the best option based on your needs.

In the same way, a message broker connects sender and receiver systems — even if one of them is offline — and guarantees message delivery.



📌 3. Message Flow Architecture:

[Django App] ── Send Task ──▶ [Message Broker (Queue)] ──▶ [Celery Worker]

- The Django app creates a task and sends it to the message broker.
- The broker queues the task for the next available Celery worker.
- If the worker is offline, the broker stores the task and retries later.

✔ If the message broker fails, you can configure a cluster of brokers for fault tolerance.



📌 4. Popular Message Brokers

| Broker     | Type                         | Notes                                                   | 
|------------|------------------------------|---------------------------------------------------------|
| Redis      | In-memory data store         | Simple, lightweight, easy to set up                     |
| RabbitMQ   | Full-featured message broker | Enterprise-grade, supports complex routing, more robust |

✔ Redis is not originally a broker—but supports broker functionality.  
✔ RabbitMQ is a dedicated broker with greater reliability and advanced features—but more complex to manage.




📌 5. Which One Should You Use?

For most Django projects:
- Start with Redis: Fast, minimal setup, works well for most use cases.
- Move to RabbitMQ only if Redis no longer meets your needs (e.g., delayed messaging, guaranteed ordering, or advanced routing).

🔁 Flexibility: Celery abstracts the broker behind an interface, so you can easily switch from Redis to RabbitMQ with minimal changes.




Codes and Other Notes in this Discussion: 

Brokers:
Redis(in-memory data store)
RabbitMQ(real, enterprise-grade broker)



✅ Summary

✔ A message broker is essential for offloading tasks from Django to Celery workers.  
✔ It guarantees message delivery even if the recipient (worker) is temporarily unavailable.  
✔ Redis is an excellent starting point—simple and versatile.  
✔ RabbitMQ provides enterprise-grade control but adds complexity.  
✔ You can cluster brokers for high availability.














Installing Redis: 
-----------------
📦 Installing Redis with Docker for Django Projects:
To enable background task processing with Celery, we need a message broker, and in this course we’ll be using Redis. The fastest and most convenient way to install Redis locally is via Docker, a lightweight containerization platform.


📌 1. What Is Redis?
- Redis is an in-memory data store that can be used as:
  - A database
  - A cache
  - A message broker for Celery tasks



📌 2. Why Use Docker for Redis?
✔ Running Redis in Docker:
- Avoids manual installation on your OS
- Keeps Redis isolated from the host system
- Easily configurable with port mapping
- Lightweight and restartable

💡 Think of Docker containers as lightweight virtual machines—fully isolated and disposable environments.



📌 3. Running Redis in Detached Mode
Open your terminal and run:
docker run -d -p 6379:6379 redis

🔍 Command Breakdown:
| Part               | Description                                      |
|--------------------|--------------------------------------------------|
| 'docker run'       | Launch a new container                           |
| '-d'               | Run in detached mode (in the background)         |
| '-p 6379:6379'     | Map port 6379 on localhost to container          |
| 'redis'            | Official Docker image for Redis (downloaded from Docker Hub) |

✔ Port 6379 is Redis's default port for accepting connections.



📌 4. Verifying the Redis Container
To confirm Redis is running:
docker ps

You should see output similar to:
CONTAINER ID   IMAGE     PORTS                    STATUS
123abc456def   redis     0.0.0.0:6379->6379/tcp   Up 2 minutes

✔ This confirms that:
- Redis is running inside a container
- Port '6379' on your machine is forwarded to port '6379' in the container



📌 5. Installing the Redis Python Package
For Django to communicate with Redis, install the 'redis' Python client in your Pipenv environment:
pipenv install redis

✔ This will allow libraries like Celery to connect to Redis via Python.

📌 Visual Summary:

[Your Django Project] ─────────▶ Redis (localhost:6379)
        ▲                            ▲
        │   pipenv install redis     │
        └──── docker run -p 6379 ────┘


Redis now acts as a message queue that will later be consumed by Celery workers.



Code and Other Notes in this Discussion: 

docker run -d -p 6379:6379 redis 

docker ps

pipenv install redis 



✅ Key Takeaways:
✔ Redis is essential as a message broker for Celery in Django.  
✔ Docker provides a clean and quick way to run Redis without installing it natively.  
✔ Use '-p 6379:6379' to expose Redis on the expected port.  
✔ Use 'docker ps' to confirm Redis is running.  
✔ Install the Python 'redis' package to enable Django/Celery communication.











Celery and Windows:
-------------------
📌 Using Celery on Windows with WSL
Celery no longer supports Windows natively since version 4. This means you cannot run Celery workers directly on a standard Windows environment.


🧭 Why Celery Doesn’t Work on Windows
✔ Celery depends heavily on UNIX-based multiprocessing internals and signal handling, which are not fully supported by Windows OS.  
✔ Therefore, the recommended solution is to run Django and Celery inside a Linux shell, even on Windows machines.



🖥️ Solution: Windows Subsystem for Linux (WSL)
➤ What is WSL?
- WSL stands for Windows Subsystem for Linux
- It allows you to run a complete Linux distribution alongside your Windows OS —no need for dual boot or full virtualization.
- Provides access to a separate Linux file system, Bash shell, and package manager ('apt', 'pip', etc.)

💡 Think of it as a lightweight Ubuntu shell running side-by-side with Windows apps.



⚙️ Benefits of Using WSL:
| Benefit                    | Description                                      |
|----------------------------|--------------------------------------------------|
| Native Linux support       | Run tools like Celery without compatibility issues |
| Separate environment       | Doesn’t interfere with your Windows system       |
| Access to Linux utilities  | Use Bash, 'apt', 'systemd', etc.                 |
| Persistent environment     | Installed packages stay even after reboot        |



📥 Setup Requirements
✔ You’ll need:
- WSL 2 installed
- A Linux distribution (e.g., Ubuntu) from the Microsoft Store
- Docker Desktop (if using Celery with Docker)
- Your Django project cloned or moved into the Linux file system



🗂️ Workflow Summary

Windows (host)
  └── WSL (Linux shell)
        ├── Django App
        ├── Celery Worker
        └── Redis Server or Docker-based broker



✔ You’ll open WSL (e.g., 'Ubuntu') and run commands like:
pipenv shell
celery -A storefront worker -l info
python manage.py runserver



📌 Important Notes:
- Setting up WSL with Django may take 30 minutes to an hour the first time.
- A detailed setup guide (PDF) is typically provided to walk you through steps like:
  - Installing WSL via PowerShell
  - Installing Ubuntu from the Microsoft Store
  - Installing Python, pipenv, and dependencies inside WSL
  - Running Django & Celery services from within Linux



✅ Key Takeaways

✔ Celery dropped native Windows support—use WSL to run it on a Windows machine  
✔ WSL provides a fully functional Linux environment inside Windows  
✔ The process requires one-time setup but ensures compatibility and stability  
✔ Once set up, you’ll be running Django + Celery exactly as on Linux or macOS





















Setting Up Celery:
------------------
📦 Setting Up Celery in a Django Project
To execute background tasks asynchronously, we integrate Celery into our Django application. Celery connects to Redis (our message broker) and runs in a separate process that listens for task requests from the main Django app.



📌 1. Installing Celery
In your Django environment, install Celery:
pipenv install celery



📌 2. Creating the Celery Configuration Module
📄 File: 'storefront/celery.py'

import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()

🔍 Explanation:
- 'os.environ.setdefault(...)' ensures Celery knows which settings module to load.
- 'Celery('storefront')' assigns the app a name (used for logging).
- 'config_from_object(...)' loads Celery settings from Django’s settings module.
- 'namespace='CELERY'' means all Celery config variables in settings must start with 'CELERY_'.
- 'autodiscover_tasks()' allows Celery to detect tasks defined in 'tasks.py' within installed apps.



📌 3. Configuring Redis as the Message Broker
📄 File: 'storefront/settings.py'
CELERY_BROKER_URL = 'redis://localhost:6379/1'

✔ This URL points to Redis running locally on port '6379', using DB #1.  
✔ Redis must already be running (e.g., via Docker).




📌 4. Registering the Celery App
📄 File: 'storefront/__init__.py'
from .celery import celery

✔ This ensures the Celery app gets loaded when Django starts.





📌 5. Starting the Celery Worker
In a separate terminal window, run the Celery worker:
celery -A storefront worker --loglevel=info

🔍 Flags:
- '-A storefront' → Points to the Django project where the Celery app is defined.
- 'worker' → Starts a worker process to handle tasks.
- '--loglevel=info' → Outputs detailed log messages.

✅ Expected Output:
- 'celery@hostname ready' → Indicates the worker is successfully connected.
- 'transport=redis' → Confirms Redis is being used as the broker.
- 'concurrency=8' → Number of worker threads (based on CPU cores).


⚠️ You may see a warning about 'settings.DEBUG' causing memory leaks — this is harmless in development.


📁 Terminal Sessions Required to Run the Project

| Terminal | Command                                      | Purpose                    |
|----------|----------------------------------------------|----------------------------|
| 1        | 'python manage.py runserver'                 | Start Django development server |
| 2        | 'docker run -p 6379:6379 redis'              | Run Redis in a container        |
| 3        | 'celery -A storefront worker --loglevel=info'| Start Celery worker             |

💡 We’ll later replace this manual process with a single Docker command using Docker Compose.





Code and Other Notes in this Discussion: 

pipenv install celery

storefront/celery.py:

import os 
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()



storefront/settings.py:
CELERY_BROKER_URL = 'redis://localhost:6379/1'



storefront/__init__.py:
from .celery import celery



celery -A storefront worker --loglevel=info 


Three terminal windows: 
python manage.py runserver #for running webserver 
docker run -p 6379:6379 redis #for running redis
celery -A storefront worker # for running celery 





✅ Key Takeaways

✔ Install Celery and create a 'celery.py' module inside your Django project.  
✔ Define Redis as the broker in your Django 'settings.py'.  
✔ Register the Celery app in '__init__.py' to ensure it loads on startup.  
✔ Launch Celery with the 'worker' command and verify Redis connectivity.  
✔ You'll need three terminal sessions (Django server, Redis, Celery worker) during development.















Creating and Executing Tasks: 
-----------------------------
📌 Creating and Executing Background Tasks with Celery in Django
Now that Celery is installed and configured, we can start defining tasks that execute asynchronously in the background. This allows long-running operations to be handled outside the main web server process, improving performance and user experience.



📌 1. Defining a Celery Task
📄 File: 'playground/tasks.py'
from time import sleep
from celery import shared_task  # ✅ Better, reusable pattern

@shared_task
def notify_customers(message):
    print("Sending 10k emails...")
    print(message)
    sleep(10)  # Simulates a long-running process
    print("Emails were successfully sent!")


🔍 Why use '@shared_task'?
- ✅ Avoids direct dependency on the project’s 'celery.py' module.
- ✅ Keeps your app reusable and independent.
- 🚫 Avoid using 'from storefront.celery import celery' with '@celery.task' if your app is intended to be reusable.




📌 2. Executing the Task from a View
📄 File: 'playground/views.py':
from django.shortcuts import render
from .tasks import notify_customers

def say_hello(request):
    notify_customers.delay('Hello')  # ⚠️ Use '.delay()' to queue the task!
    return render(request, 'hello.html', {'name': 'Mosh'})


📌 Note:
- Don’t call 'notify_customers('Hello')' directly—that would run it immediately.
- '.delay()' sends the task to the Celery worker via Redis, allowing it to run in the background.






📌 3. Auto-Discovery of Tasks

Recall from the Celery setup:
celery.autodiscover_tasks()

✔ This ensures Celery automatically picks up all 'tasks.py' modules in installed Django apps.





📌 4. Running and Debugging Tasks

❗ Common Issue:
When Celery is already running and you define a new task:
Received unregistered task of type 'playground.tasks.notify_customers'


✅ Solution:
- Stop and restart the worker:
ctrl + C
celery -A storefront worker --loglevel=info


Now Celery loads the updated code and registers the new task.





📌 5. Background Execution with Reliability

- When 'notify_customers.delay()' is called, the task runs in the background.
- The Django view returns immediately (even though the task sleeps for 10 seconds).
- You can monitor the logs in the Celery worker terminal.






📌 6. Message Broker Guarantees Delivery

Even if the Celery worker is offline:
- Redis stores the message.
- When the worker restarts, Redis retries and delivers the task.

🔍 Example Workflow:
[User Hits /hello/] ─▶ Django App ─▶ Redis Queue ─▶ (Celery Worker is Offline)
                                               ▲
                                   [Retry When Worker is Online]

✔ This demonstrates asynchronous execution and guaranteed task delivery, key advantages of using a message broker like Redis.





Codes and Other Notes in this Discussion: 

playground/tasks.py:

from time import sleep
from storefront.celery import celery


@celery.task
def notify_customers(message):
    print('Sending 10k emails...')
    print(message)
    sleep(10)
    print('Emails were successfully sent!')





Better way: 
playground/tasks.py:

from time import sleep
from celery import shared_task


@shared_task
def notify_customers(message):
    print('Sending 10k emails...')
    print(message)
    sleep(10)
    print('Emails were successfully sent!')



playground/views.py:
from django.shortcuts import render
from .tasks import notify_customers


def say_hello(request):
    notify_customers.delay('Hello')
    return render(request, 'hello.html', {'name': 'Mosh'})




✅ Key Takeaways:
✔ Define background tasks using '@shared_task' for flexibility and decoupling.  
✔ Trigger tasks using '.delay()' to enqueue them for Celery workers.  
✔ Celery workers must be restarted when new tasks are introduced.  
✔ Redis ensures task delivery, even if Celery workers are temporarily offline.  
✔ This pattern improves responsiveness and scalability by freeing the web server.




















Scheduling Periodic Tasks: 
--------------------------
📌 Scheduling Periodic Tasks with Celery Beat
In many applications, we need to run certain tasks on a schedule, such as:
- Generating periodic reports
- Sending batch emails
- Running maintenance routines (e.g., cleanup jobs)

To automate these tasks, we use Celery Beat, a periodic task scheduler that triggers Celery tasks at specific intervals.





📌 1. What Is Celery Beat?
Celery Beat is a scheduler process that:
- Runs alongside your app and worker processes
- Kicks off tasks at scheduled intervals
- Delegates actual task execution to Celery workers

Analogy: Just as a heartbeat triggers blood flow at regular intervals, Celery Beat triggers tasks periodically while workers handle the actual processing.






📌 2. Defining the Periodic Task Schedule:
📄 File: 'storefront/settings.py'
from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5,  # Every 5 seconds (for demo purposes)
        'args': ['Hello World'],
    }
}

🔍 Key Parameters:
| Setting         | Description                                                |
|-----------------|------------------------------------------------------------|
| 'task'          | Full import path to your Celery task function              |
| 'schedule'      | When to trigger the task (in seconds or using 'crontab')   |
| 'args'          | Positional arguments to pass to the task                   |
| 'kwargs'        | (Optional) Keyword arguments as a dictionary               |

✔ Naming convention: Task key (''notify_customers'') can be anything, but using the function name improves clarity.







📌 3. Customizing the Schedule with 'crontab()'

For more granular control (e.g., specific days or hours), use the 'crontab' object:
'schedule': crontab(day_of_week=1, hour=7, minute=30)  # Every Monday at 7:30 AM

Additional Examples:
crontab(minute='*/15')  # Every 15 minutes
crontab(hour=3)         # Every day at 3 AM
crontab(day_of_week='0', hour=23, minute=0)  # Every Sunday at 11 PM


📌 Reference: [Celery Beat Schedule Documentation](https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html)





📌 4. Starting the Celery Beat Scheduler

In a new terminal window, run:
celery -A storefront beat

✔ This starts the Beat scheduler process  
✔ Beat connects to the message broker and begins triggering tasks as defined in 'CELERY_BEAT_SCHEDULE'





📌 5. Verifying Task Execution
Open the Celery worker terminal window:
- You’ll see 'notify_customers' firing every 5 seconds (or at your defined schedule).
- Each task is enqueued and processed by Celery workers in the background.




Codes and Other Notes in this Discussion: 

Periodic Tasks: 

Generating periodic reports 
Sending emails 
Running maintenance jobs 


Celery Beat 


storefront/settings.py:
from celery.schedules import crontab  

CELERY_BEAT_SCHEDULE = {
    'notify_customers': {
        'task': 'playground.tasks.notify_customers',
        'schedule': 5,   # or 'schedule': crontab(day_of_week=1, hour=7, minute=30),
        'args': ['Hello World'],
    }
}


celery -A storefront beat 




✅ Summary

| Step | Action |
|------|--------|
| 1    | Define 'CELERY_BEAT_SCHEDULE' in 'settings.py' |
| 2    | Use raw seconds or 'crontab()' for scheduling |
| 3    | Pass arguments using 'args' or 'kwargs' |
| 4    | Start Celery Beat with 'celery -A storefront beat' |
| 5    | Observe task execution in the worker logs |



Using Celery + Beat + Redis gives you a reliable and extensible platform for background and scheduled task execution. 






















Monitoring Celery Tasks: 
------------------------
📊 Monitoring Celery Tasks with Flower:
Once you’ve defined and executed tasks with Celery, it's important to monitor their status and worker activity. For that, we use Flower—a real-time web-based monitoring tool for Celery.



📌 1. What is Flower?

Flower (pronounced *flow-er*) is a lightweight monitoring tool that provides a browser-based UI for:
- Tracking active, scheduled, and failed tasks
- Viewing task details and metadata
- Managing and inspecting Celery workers
- Viewing task queues and broker information


📌 2. Installing Flower
Use Pipenv to install Flower in your Django environment:
pipenv install flower




📌 3. Starting Flower
Run Flower as a separate process using the Celery CLI:
celery -A storefront flower

✔ '-A storefront' tells Celery to look for the 'celery' app in your Django project.




📌 4. Accessing the Flower Dashboard

Open your browser and navigate to:
http://localhost:5555

You’ll see a real-time dashboard with several key sections.



📌 5. Dashboard Features Overview
🔹 Workers Panel
- Shows list of connected workers
- Displays:
  - Uptime
  - Status (online/offline)
  - Number of active, reserved, and completed tasks

🔹 Tasks Panel
- Lists task execution history with metadata:
  - Task name
  - Unique task ID
  - Status: success, failed, received, etc.
  - Arguments and return value
  - Start and end timestamps

🔹 Broker Panel
- Shows broker type (e.g., Redis)
- Displays active queues and routing stats
- Confirms that Flower is successfully connected to the broker





📌 6. Example Usage:
After triggering some Celery tasks (like 'notify_customers'), Flower will display:

- Real-time status updates
- Log outputs from those tasks
- Argument payloads (e.g., '["Hello World"]')
- Whether the task succeeded or failed

✔ Makes it easy to troubleshoot and verify if background jobs are completing as expected.





Codes and Other Notes in this Discussion: 
Flower --> (flow-er)

pipenv install flower


celery -A storefront flower 


localhost:5555



✅ Key Takeaways:
✔ Flower provides real-time visibility into Celery task execution  
✔ Install it with 'pipenv install flower' and run it via 'celery -A storefront flower'  
✔ Access the UI at 'http://localhost:5555' to monitor workers, tasks, and brokers  
✔ Ideal for diagnosing task failures, verifying job completion, and checking queue health



With Flower running alongside Celery, you now have complete transparency into your background task system. 





















Automated Testing:
------------------

Introduction: 
In this section, we'll be talking about automated testing. Now a lot of people find automated testing confusing, so I'm going to simplify it for you and give you a practical recipe you can follow to test your applications. Now, let's jump in and get started.



What is Automated Testing:
--------------------------
✅ Introduction to Automated Testing
As your application grows in complexity, manual testing becomes increasingly time-consuming and error-prone. Automated testing solves this by allowing you to write code that programmatically verifies the behavior of your system.



📦 Why Testing Matters
During development, we implemented multiple API endpoints for:
- Collections
- Products
- Carts
- Orders

Each of these endpoints supports actions like:
- 'POST' (create)
- 'GET' (retrieve)
- 'PUT/PATCH' (update)
- 'DELETE' (remove)

However, many of these actions are governed by rules. For instance:
🔐 Only admin users can modify products.  
❌ Anonymous users or regular users should be restricted.

Testing these rules manually in the browser is fine at first, but over time:
- The number of edge cases increases
- Test coverage becomes inconsistent
- Repeating tests slows down your workflow




🤖 What Is Automated Testing?
Automated testing is the practice of:
1. Writing test scripts (just like code)
2. Running them to simulate interactions with your app
3. Verifying that the actual behavior matches expected outcomes

This allows you to:
- Catch regressions quickly
- Save time with repeatable, fast tests
- Release updates confidently

You write the test once, and run it as often as needed.




🧠 Hidden Rules + Forgotten Logic
Over time, you'll forget the small rules and assumptions built into each endpoint unless:
- You document them rigorously (which rarely happens)
- Or automate them in tests

⚠️ Without tests, even small changes can unexpectedly break features you didn’t think were related.



⚔️ The Double-Edged Sword of Automated Testing:
Automated testing is extremely powerful when used correctly:
✔️ It ensures long-term stability  
✔️ It prevents careless regressions  
✔️ It boosts confidence in your codebase

But when done poorly:
❌ It creates brittle, hard-to-maintain test cases  
❌ It slows down development  
❌ It leads to frustration and test fatigue




💬 A Common Misconception:
You might hear people like the mythical “John Smith” say:
"Automated testing is a waste of time."

And sure, it can feel that way—especially if:
- You’re testing the wrong things
- You write fragile tests
- You follow outdated practices

Even seasoned developers fall into the trap of writing “useless” tests. But with the right strategies and principles, tests become tools—not obstacles.



✅ Key Takeaways
- Manually testing APIs is not scalable.
- Automated tests are written once and run repeatedly.
- They improve speed, reliability, and developer confidence.
- If poorly written, they can become a burden.
- Understanding the *right* way to test is essential (and covered in upcoming lessons).



















Test Behaviours, Not Implementations:
-------------------------------------
✅ Test Behaviors, Not Implementations
A common pitfall in automated testing is focusing on how the code is implemented, rather than how it behaves from an external perspective. This section explains why behavior-based testing is essential for writing resilient and maintainable tests.



🎯 What Does It Mean to Test Behavior?
Imagine testing a microwave:

- You press the Start button.
- You observe the monitor to see if the timer counts down from one minute.

You're verifying whether the microwave behaves correctly—not whether each transistor inside is firing properly.  
✅ You're testing the outcome, not the internal mechanics.



🧪 How This Applies to Software Testing
When testing a web application (e.g., a Django API), people often write tests for the internal components:
- Models
- Views
- Serializers
- Routers

But these components may evolve:
| Change                                 | Example                              |
|----------------------------------------|--------------------------------------|
| Function-based view → class-based view | You restructure for readability      |
| One model becomes two models           | You normalize your database          |
| API routing is revised                 | You switch from 'urls.py' to routers |

🛑 If your tests are too closely tied to these implementation details, they’ll break with every refactor—even if the behavior remains the same.





✅ What Should We Test?
Focus on external behaviors:
- What requests are allowed?
- What responses are returned?
- What side effects (e.g., database changes, emails) should occur?





💡 Practical Example: Testing Collection Creation
We want to verify how the '/collections/' POST endpoint behaves, not how it’s implemented.

Behavior Scenarios:
1. Unauthorized Access
   - Request: Client is *not authenticated*
   - Expected Response: '401 Unauthorized'

2. Non-admin Access
   - Request: Client is authenticated, but not an admin
   - Expected Response: '403 Forbidden'

3. Missing Required Data
   - Request: Admin user submits request without a 'name'
   - Expected Response: '400 Bad Request'
   - Response Body: Should include an error for 'name' field

4. Valid Request
   - Request: Admin user submits a valid 'name'
   - Expected Response: '201 Created' (or '200 OK')
   - Response Body: Should include the new collection’s ID

These tests should simulate real API requests and validate expected responses—regardless of how views or models are structured internally.



⚠️ Why Testing Implementation Can Be Risky
- Increases test brittleness
- Slows down refactoring
- Leads to redundant or low-value tests
- Obscures your app’s actual business logic and behavior

“Test the *what*, not the *how*.”



✅ Key Takeaways
✔ Write tests that validate what the system does, not how it’s built  
✔ Focus on the API contract: inputs, outputs, and side effects  
✔ Avoid coupling tests to views, serializers, or database schemas  
✔ Well-written tests should survive refactors as long as behavior remains intact











Tooling:
--------
📦 Tooling: Choosing a Test Framework in Django

Just as Django gives us a framework for building APIs, we also need a framework for writing and running tests. A good test framework provides:

- A structure to define tests
- A test runner to execute them
- Clear reports showing which tests passed or failed



🧪 Python Testing Frameworks

Two of the most popular options for testing Python applications are:

| Framework     | Description                                                |
|---------------|------------------------------------------------------------|
| 'unittest'    | Built into Python, inspired by Java’s JUnit                |
| 'pytest'      | Third-party tool with more features, plugins, and less boilerplate |



🤏 Why Choose Pytest?
✔ Cleaner, shorter test syntax  
✔ Huge ecosystem and active community  
✔ Tons of plugins for advanced workflows (e.g. test coverage, fixtures, mocking)  
✔ Easier to scale across large projects

Here’s a comparison:
# Using unittest
class TestAddition(unittest.TestCase):
    def test_sum(self):
        self.assertEqual(1 + 1, 2)

# Using pytest
def test_sum():
    assert 1 + 1 == 2


🎯 Pytest is clearly more concise and beginner-friendly.




🧰 Installing Pytest for Django Projects
Since tests are only used during development, we install Pytest as a development dependency:
pipenv install --dev pytest

✔ Adds 'pytest' under '[dev-packages]' in your 'Pipfile'  
✔ Keeps production deployments clean and lightweight

You’ll see something like:

'''toml
[dev-packages]
pytest = "*"
'''



🔌 Django Integration: pytest-django
To test Django apps more effectively with Pytest, install the official integration plugin:
pipenv install --dev pytest-django

✔ Enables database testing, Django settings access, fixtures like 'client', and more  
✔ Compatible with Pytest syntax and Django testing patterns




Codes and Other Notes in this Discussion: 
Test Frameworks:
unittest
pytest - More Features, Tons of plugins, Less boilerplate 


pipenv install --dev pytest 

pipenv install --dev pytest-django 




✅ Summary

| Tool             | Purpose                               |
|------------------|---------------------------------------|
| 'pytest'         | Core test framework with clean syntax |
| 'pytest-django'  | Pytest plugin for Django projects     |


















Your First Test:
----------------
✅ Writing Your First Automated Test with Pytest & Django REST Framework
Let’s walk through building a clean and maintainable test using Pytest and Django REST Framework. This serves as the foundation for testing API behavior in your Django projects.


📁 1. Organize Test Files Properly

In your app directory (e.g. 'store/'):

- Create a folder named 'tests/'  
  🔸 Important: Must be plural ('tests') — Pytest looks for this naming convention by default.

- Inside that, create a test file:  
  📄 'test_collections.py'  
  🔸 Test file names must start with 'test_' to be picked up by Pytest.





🧪 2. Structure of a Test

Each test should follow the AAA structure:

| Stage   | Meaning                      | Description                                                       |
|---------|------------------------------|-------------------------------------------------------------------|
| Arrange | Set up test state            | Create objects, define data, prepare environment                  |
| Act     | Perform the action           | Trigger API call or code you want to test                         |
| Assert  | Verify outcome               | Check status codes, responses, database changes, etc.             |





💡 3. Naming Conventions Matter

Test discovery depends on naming. Follow these rules:
- Functions: start with 'test_'
- Classes (optional): start with 'Test' (e.g. 'TestCreateCollection')
- Use descriptive function names (e.g. 'test_if_user_is_anonymous_returns_401')

✔️ Clear naming ensures your tests communicate what behavior is being validated.





🧾 4. Sample Test Implementation

📄 File: 'store/tests/test_collections.py'

from rest_framework.test import APIClient
from rest_framework import status

class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self):
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'a'})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


🧠 Notes:
- No need to over-name collections — ''a'' is sufficient in tests to avoid noise
- The endpoint must end with a trailing slash ('/') unless you’ve changed Django’s default router settings
- The test simulates a POST request with an anonymous user (not authenticated)
- Expected result: '401 Unauthorized'



🔎 Behavior Under Test

| Scenario                                        | Expected Result                |
|-------------------------------------------------|--------------------------------|
| Anonymous user tries to create a collection     | ❌ Request denied with '401'    |
| Authenticated non-admin → '403' (tested later)  |
| Missing name → '400'                            |
| Valid admin & payload → '201 Created'           |





Codes and other Notes in this Discussion: 

store/tests/test_collections.py:

from rest_framework.test import APIClient 
from rest_framework import status

class TestCreateCollection: 
	def test_if_user_is_anonymous_returns_401(self): 
	# Arrange
	
	
	# Act
	client = APIClient()
	response = client.post('store/collections/', {'title': 'a'})
	
	# Assert
	assert response.status_code == status.HTTP_401_UNAUTHORIZED
	
	
	
	

✅ Key Takeaways
✔ Follow naming conventions strictly for Pytest to auto-discover tests  
✔ Organize tests based on use case (e.g. collection creation vs deletion)  
✔ Use clear, behavior-focused function names — avoid vague names like 'test_create'  
✔ Stick to the Arrange → Act → Assert structure  
✔ Validate API behavior, not implementation details















Running Tests:
--------------
✅ Running Tests in Django with Pytest
Once your tests are written, it's time to run them and verify that your application behaves as expected. This note outlines how to configure, validate, and selectively run tests using Pytest in a Django project.



📁 1. Configuring Pytest for Django
Pytest needs to know which Django settings module to use. You do this by creating a configuration file at the project root:

📄 File: 'pytest.ini'
[pytest]
DJANGO_SETTINGS_MODULE=storefront.settings

✔ This allows you to run 'pytest' without manually exporting environment variables.



🧪 2. Running All Tests
From your terminal, run:
pytest

You should see an output like:
collected 1 item
.                          [100%]
1 passed in 0.30s




❗ 3. Ensuring Tests Are Reliable (No "Lying Tests")
Even if a test passes, it may not be testing anything meaningful. To verify integrity:
- Comment out or remove the logic in your views that the test expects
- Run the test again
- It should fail if the test is written correctly

If it still passes — it's a "lying test" ✅⚠️


Example: Testing Permissions in a View
You remove a permission class from your view, and rerun the test. Now it should raise:
AssertionError: assert 201 == 401


✔ This confirms the test was correctly detecting unauthorized behavior.




📌 4. Fixing "Database Access Not Allowed" Error:
Pytest restricts database access by default. To allow test functions to use the DB, mark them with the '@pytest.mark.django_db' decorator.

Instead of adding it to each test:
@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self):
        ...

✔ This applies the marker to all test methods inside the class.




✅ 5. Summary Test Example
📄 'store/tests/test_collections.py':

import pytest
from rest_framework.test import APIClient
from rest_framework import status

@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self):
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'a'})
        assert response.status_code == status.HTTP_401_UNAUTHORIZED




🔍 6. Selectively Running Tests

When dealing with large test suites, it's helpful to run a targeted subset:

'pytest store/tests' = Run all tests in the 'store/tests' folder 
'pytest store/tests/test_collections.py' = Run tests in a single module 
'pytest store/tests/test_collections.py::TestCreateCollection'  = Run all tests in a class 
'pytest store/tests/test_collections.py::TestCreateCollection::test_if_user_is_anonymous_returns_401' =  Run a specific test method 
'pytest -k anonymous' = Run any tests with "anonymous" in their name 




Codes and Other Notes in this Discussion: 

pytest.ini:

[pytest]
DJANGO_SETTINGS_MODULE=storefront.settings


in the terminal:
pytest 


store/tests/test_collections.py:
from rest_framework.test import APIClient 
from rest_framework import status
import pytest 

@pytest.mark.django_db 
class TestCreateCollection: 
	
	def test_if_user_is_anonymous_returns_401(self): 
	# Arrange
	
	
	# Act
	client = APIClient()
	response = client.post('store/collections/', {'title': 'a'})
	
	# Assert
	assert response.status_code == status.HTTP_401_UNAUTHORIZED
	
	
	
different ways of running pytest:	
pytest store/tests
pytest store/tests/test_collections.py::TestCreateCollection::test_if_user_is_anonymous_returns_401
pytest -k anonymous 





🎯 Key Takeaways

✔ Use a 'pytest.ini' file to configure settings  
✔ Decorate tests or classes with '@pytest.mark.django_db' to allow DB access  
✔ Always verify that tests fail when the expected logic is removed  
✔ Use 'pytest -k' and scoped test paths to run selected tests efficiently  
✔ Well-written tests check behavior, not implementation













Skipping Tests:
---------------
✅ Skipping Tests Temporarily in Pytest
During development, you may encounter a failing test that you're not ready to fix—perhaps because you’re focused on another task or feature. Rather than leaving the test in a failing state (which can cause noise or distract you), you can temporarily skip it using Pytest’s built-in tools.



📌 Why Skip Tests?
- You’re in the middle of another feature.
- Fixing the failure requires significant refactoring.
- You want to prevent unnecessary test noise while working.

✔ Skipping the test hides the failure temporarily while keeping the test code intact.  
✔ It allows the rest of your test suite to run cleanly.



🧪 Applying the Skip Decorator
To skip a test, use '@pytest.mark.skip' as a decorator.

📄 Example:
import pytest
from rest_framework.test import APIClient
from rest_framework import status

@pytest.mark.django_db
class TestCreateCollection:
    
    @pytest.mark.skip
    def test_if_user_is_anonymous_returns_401(self):
        client = APIClient()
        response = client.post('/store/collections/', {'title': 'a'})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


✔ This tells Pytest to skip this test method when the suite is executed.

📟 Running Pytest After Skipping
pytest

You’ll see output like:
collected 1 item
s                          [100%]
==================== 1 skipped in 0.05s =====================

✔ The 's' stands for “skipped”  
✔ Pytest does not raise any failure alerts, allowing you to stay focused.



✅ When You're Ready...
Once you're ready to revisit the skipped test:
- Simply remove the '@pytest.mark.skip' decorator.
- Rerun the test to confirm it’s fixed and passing.




Codes and Other Notes in this Discussion:

@pytest.mark.django_db 
class TestCreateCollection: 
	@pytest.mark.skip
	def test_if_user_is_anonymous_returns_401(self): 
	client = APIClient()
	response = client.post('store/collections/', {'title': 'a'})
	
	assert response.status_code == status.HTTP_401_UNAUTHORIZED
	
	

🧠 Key Takeaways

| Action                        | Description                                      |
|-------------------------------|--------------------------------------------------|
| '@pytest.mark.skip'           | Skips a test without removing it from the file  |
| Ideal for                     | Temporary suppression of failing or in-progress tests |
| Skipped tests result          | Tests marked with an 's' in the Pytest report   |
| Best practice                 | Add a comment or TODO so you remember to revisit |


	








Continuous Testing:
-------------------
✅ Continuous Testing with Pytest-Watch
Running tests continuously during development allows you to catch issues the moment they’re introduced. This practice, known as continuous testing, provides instant feedback and improves code quality.


🔄 Two Ways to Run Tests

| Method              | Description                                           |
|---------------------|-------------------------------------------------------|
| On Demand           | Run manually before commits, merges, or deployments   |
| Continuous Testing  | Tests re-run automatically as you edit files      |

While some developers worry that continuous testing might slow down machines (especially with large test suites), many others—especially those using efficient tools like 'pytest'—find it incredibly helpful.



🚀 Setting Up Continuous Testing:
🔧 Step 1: Install 'pytest-watch'

This Pytest plugin watches your code and test files for changes and re-runs tests automatically.
pipenv install --dev pytest-watch

✔ This adds 'pytest-watch' to your '[dev-packages]' in 'Pipfile'.


🔧 Step 2: Run Pytest Watcher
ptw

- Short for PyTestWatch
- Starts a persistent watcher in your terminal
- Re-runs tests every time a file changes

You can dedicate a separate terminal or monitor to keep 'ptw' running during development.




🧪 Live Feedback Example:
1. Edit a file under 'store/tests/'
2. Save your changes
3. ✅ 'ptw' automatically detects the change and re-runs all tests

This lets you immediately see:
- Which test failed
- Why it failed
- If your recent change introduced a bug

💡 Similarly, editing your application code (e.g. 'views.py') triggers the same behavior.



🔁 Example Workflow:
[Code Editor] -->     [App / View / Serializer]
              <--     
      │
      ▼
[Test Change Detected] → [ptw] re-runs tests → ✅ or ❌ feedback instantly




🧠 Best Practices:
- Use 'ptw' while developing new features or debugging test failures
- Turn off continuous testing on resource-constrained systems if needed
- Always run full test suite ('pytest') before:
  - Committing changes
  - Merging pull requests
  - Deploying code




Codes and Other Notes in this Discussion: 

pipenv install --dev pytest-watch 

ptw




✅ Summary

| Tool                | Description                                |
|---------------------|--------------------------------------------|
| 'pytest-watch'      | Pytest plugin for automatic test re-runs   |
| 'ptw'               | Starts the watcher                         |
| Benefits            | Faster feedback, fewer bugs, confident coding |










  

Running and Debugging Tests in VSCode:
--------------------------------------
✅ Running and Debugging Tests in VS Code
Visual Studio Code (VS Code) offers a powerful Test Explorer that allows you to seamlessly run and debug your automated tests from within the editor. This makes it easier to observe test behavior and troubleshoot failures without switching to the terminal.



🧭 1. Initial Setup: Configuring Test Explorer
➤ Step-by-step:
1. Open the Testing panel from the Activity Bar on the left.
2. Click “Configure Python Tests”.
3. Choose Pytest as your test framework.
4. Select the project root folder (not just the app folder) — so tests across all apps are recognized.

✅ After setup:
- VS Code discovers and displays your test structure in a tree:

  storefront/
    └── store/
         └── tests/
              └── test_collections.py
                   └── TestCreateCollection
                        ├── test_if_user_is_anonymous_returns_401
 
✔ Grouping tests by class improves clarity and visual organization — each behavior becomes easy to locate.



🧪 2. Running and Viewing Test Results

- Click the play icon to run:
  - All tests in the workspace
  - A single test file
  - A test class or method
- A green check indicates a passing test ✅  
- A red X shows a failing test ❌

🔍 Failure Output:
- Error messages appear in the left panel, but aren’t color-coded
- The terminal output from 'pytest' is more readable (colorful and structured)



3. Debugging a Failing Test
Let’s say a test fails and you want to explore why.

➤ Debugging Workflow:
1. Open the test file
2. Add a breakpoint (click left of the line number)
3. In the Test Explorer, right-click the test → “Debug Test”
4. The debugger starts, and execution pauses at your breakpoint

✅ Inside the Debugger:
- Use:
  - Step Over / Into / Out to move through code
  - Watch panel to inspect variable values
  - Call stack to trace function flow
- Stop debugging once you've finished analysis




🧠 Quick Fix Cycle

1. Test fails (red ❌ in panel)
2. Set breakpoint → debug the test
3. Identify issue → correct logic or assertion
4. Save file → re-run test
5. Confirm green ✅ before moving on




✅ Key Takeaways
| Feature                | Benefit                                        |
|------------------------|------------------------------------------------|
| VS Code Test Explorer  | Visualizes your entire test suite             |
| Test Class Grouping    | Helps organize behaviors by use case          |
| In-editor Execution    | Run tests without switching to terminal       |
| Integrated Debugging   | Step into failing tests and inspect variables |
| Manual + Visual Flow   | Perfect for rapid feedback and iteration      |













Authenticating the User:
------------------------
✅ Authenticating the User in API Tests (Non-Admin Scenario)
This note explains how to simulate an authenticated user who is not an admin and test authorization behavior in your Django REST Framework API.



📌 Use Case
We’re testing the '/store/collections/' endpoint which is restricted to admin users for POST requests (i.e., creating new collections).

Goal:
Verify that an authenticated **non-admin** user receives a **403 Forbidden** response when attempting to create a collection.



🧪 Test Structure & Strategy
We start with a class that groups related test cases for collection creation:

import pytest
from rest_framework.test import APIClient
from rest_framework import status

Decorator:
@pytest.mark.django_db

✔ Allows the test to interact with the database (required for auth, ORM, etc.)


Class-Based Grouping:

class TestCreateCollection:

✔ Groups all "create collection" related tests  
✔ Makes test discovery and organization easier



🔍 Test 1: Anonymous User

Already implemented for reference:

def test_if_user_is_anonymous_returns_401(self):
    client = APIClient()
    response = client.post('/store/collections/', {'title': 'a'})
    assert response.status_code == status.HTTP_401_UNAUTHORIZED




💻 Test 2: Authenticated but Not Admin

🔑 Using 'force_authenticate()'

def test_if_user_is_not_admin_returns_403(self):
    client = APIClient()
    client.force_authenticate(user={})  # Placeholder non-admin user

    response = client.post('/store/collections/', {'title': 'a'})
    assert response.status_code == status.HTTP_403_FORBIDDEN

✅ Explanation:
- 'force_authenticate()' bypasses the login flow and directly injects an authenticated user.
- Passing 'user={}' is a **minimal placeholder** to simulate a non-privileged user.
- The API correctly returns '403 Forbidden', confirming the permission policy.

🧠 You could also use Django's User model or a fixture to create a non-admin user explicitly, which is a more realistic approach for integration testing.





Codes and Other Notes in this Discussion:

@pytest.mark.django_db 
class TestCreateCollection: 

	def test_if_user_is_anonymous_returns_401(self): 
	client = APIClient()
	response = client.post('store/collections/', {'title': 'a'})
	
	assert response.status_code == status.HTTP_401_UNAUTHORIZED
	
    def test_if_user_is_not_admin_returns_403(self):
        client = APIClient()
		client.force_authenticate(user={})

        response = client.post('store/collections/', {'title': 'a'})

        assert response.status_code == status.HTTP_403_FORBIDDEN
		
		



✅ Final Notes

| Scenario                     | Expected Response |
|------------------------------|-------------------|
| Anonymous user               | '401 Unauthorized' |
| Authenticated non-admin user | '403 Forbidden'     |
| Authenticated admin user     | '201 Created'       *(covered in future tests)*

✔ This approach ensures that your API **respects permission constraints**  
✔ Keeps your test focused on *behavior*, not *internal implementation*






		
		
		
		
		
		
		




Single or Multiple Assertions:
------------------------------
✅ Single vs Multiple Assertions in API Testing:
When writing automated tests, there’s a common principle that each test should have a single responsibility. However, that doesn't mean you must limit yourself to only one assertion per test. This note explains how to handle multiple logically related assertions effectively, with practical examples.



🧪 Scenario 1: Admin User Posts Invalid Data
We want to test how the API responds when an authenticated admin user submits invalid input (e.g. empty title) when creating a collection.

✔ Test Setup:
from django.contrib.auth.models import User
from rest_framework.test import APIClient
from rest_framework import status
import pytest

@pytest.mark.django_db
class TestCreateCollection:
    
    def test_if_data_is_invalid_returns_400(self):
        client = APIClient()
        client.force_authenticate(user=User(is_staff=True))  # Simulated admin user (in-memory)

        response = client.post('/store/collections/', {'title': ''})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None


🔍 Analysis

| Aspect                         | Reasoning |
|--------------------------------|-----------|
| 'status_code' check            | Validates HTTP response for bad input |
| 'response.data['title']' check | Ensures proper validation error for the missing title |

✔ These two assertions are logically related. They're both verifying the behavior of the response for invalid input — not testing unrelated concerns.





🧪 Scenario 2: Admin User Posts Valid Data
This test validates API behavior when valid input is submitted.

def test_if_data_is_valid_returns_201(self):
    client = APIClient()
    client.force_authenticate(user=User(is_staff=True))

    response = client.post('/store/collections/', {'title': 'a'})

    assert response.status_code == status.HTTP_201_CREATED
    assert response.data['id'] > 0


🧠 Why We Avoid DB or API Lookups Here:
Alternative approaches often seen:
- Querying the database to confirm the collection was saved
- Sending a follow-up GET request to retrieve the created object

❌ Problems with those approaches:
- Tightly couples tests to internal implementation (e.g. models)
- Compounds failures if unrelated parts of the system (e.g. list endpoint) are buggy
- Violates the principle of testing one behavior at a time

✅ Instead:
- Confirming that the 'id > 0' means the collection was created (since the database auto-generates IDs)



🧠 On the Principle of "Single Assertion"
- The intent is to ensure each test focuses on one behavior or outcome
- You can use multiple assertions *if* they validate the same behavior

✔ Multiple assertions
   → Valid if they're logically tied to the same outcome
✘ Separate assertions
   → Split into distinct tests if verifying unrelated features



📍 Bonus: Navigating Tests in VS Code
- Test explorer displays each test case and class
- You can navigate between scenarios (e.g., valid vs invalid) efficiently
- Clicking the class (e.g. 'TestCreateCollection') shows all related tests grouped by use case



Codes and Other Notes in this Discussion: 

from django.contrib.auth.models import User 


@pytest.mark.django_db 
class TestCreateCollection: 

    def test_if_data_is_invalid_returns_400(self):
        client = APIClient()
		client.force_authenticate(user=User(is_staff=True))

        response = client.post('store/collections/', {'title': ''})
		
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None



    def test_if_data_is_valid_returns_201(self):
        client = APIClient()
		client.force_authenticate(user=User(is_staff=True))

        response = client.post('store/collections/', {'title': 'a'})
		
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0





✅ Key Takeaways
✔ You can write multiple assertions in a test if they verify different aspects of the same behavior  
✔ Avoid testing implementation details like model structure or endpoint internals  
✔ Use 'User(is_staff=True)' in memory to simulate admin authentication  
✔ Clear, descriptive test names and class-based grouping improve maintainability  
✔ Automated tests significantly reduce manual effort and increase confidence in your code














Fixtures:
---------
✅ Pytest Fixtures: DRY and Reusable Testing in Django:
As your Django test suite grows, duplicating setup code (like creating authenticated clients or sending HTTP requests) can make your tests bulky and harder to maintain. Fixtures are a powerful Pytest feature that lets you extract and reuse setup logic, keeping your tests clean, scalable, and readable.



🧱 What Are Fixtures?
Fixtures are reusable functions that prepare dependencies needed for tests—such as authenticated clients, test data, or helper utilities.

✔ They prevent repetition  
✔ They're easily composable and injectable via function parameters  
✔ Pytest auto-discovers them when placed inside a 'conftest.py' file



📁 'conftest.py': Global Fixtures:
📄 'store/tests/conftest.py'

from django.contrib.auth.models import User
from rest_framework.test import APIClient
import pytest

@pytest.fixture
def api_client():
    return APIClient()

@pytest.fixture
def authenticate(api_client):
    def do_authenticate(is_staff=False):
        return api_client.force_authenticate(user=User(is_staff=is_staff))
    return do_authenticate


🔍 Explanation:
- 'api_client': Returns an instance of 'APIClient'
- 'authenticate': Returns a function (a closure) that creates and authenticates a user on demand
- 'is_staff' is defaulted to 'False', allowing quick setup for both admin and non-admin roles

Fixtures in 'conftest.py' are globally available—no need to import them in test files.





🧪 File-Specific Fixture for Posting Collections

📄 'store/tests/test_collections.py'
@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post('/store/collections/', collection)
    return do_create_collection


✅ Why It Works:
- Instead of writing '.post(...)' in every test, we abstract it into a fixture
- This fixture returns a function (a higher-order function) that takes a dynamic payload as input
- Keeps your tests concise and focused


🔎 Example: End-to-End Test Class
@pytest.mark.django_db
class TestCreateCollection:

    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({'title': 'a'})
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        authenticate()
        response = create_collection({'title': 'a'})
        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)
        response = create_collection({'title': ''})
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)
        response = create_collection({'title': 'a'})
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0




📐 Test Format: Arrange → Act → Assert
Maintaining clear structure helps readability:

# Arrange
authenticate(is_staff=True)

# Act
response = create_collection({'title': ''})

# Assert
assert response.status_code == 400

✔ Even with fixtures, make sure to visually separate setup, action, and verification steps.





Codes and Other Notes in this Discussion: 

store/tests/conftest.py:

from django.contrib.auth.models import User
from rest_framework.test import APIClient
import pytest


@pytest.fixture
def api_client():
    return APIClient()


@pytest.fixture
def authenticate(api_client):
    def do_authenticate(is_staff=False):
        return api_client.force_authenticate(user=User(is_staff=is_staff))
    return do_authenticate



store/tests/test_collections.py:

from store.models import Collection, Product
from rest_framework import status
import pytest
from model_bakery import baker


@pytest.fixture
def create_collection(api_client):
    def do_create_collection(collection):
        return api_client.post('/store/collections/', collection)
    return do_create_collection


@pytest.mark.django_db
class TestCreateCollection:
    def test_if_user_is_anonymous_returns_401(self, create_collection):
        response = create_collection({'title': 'a'})

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_user_is_not_admin_returns_403(self, authenticate, create_collection):
        authenticate()

        response = create_collection({'title': 'a'})

        assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_returns_400(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({'title': ''})

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data['title'] is not None

    def test_if_data_is_valid_returns_201(self, authenticate, create_collection):
        authenticate(is_staff=True)

        response = create_collection({'title': 'a'})

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['id'] > 0





🎯 Key Concepts Recap

| Feature                | Purpose                                                   |
|------------------------|-----------------------------------------------------------|
| 'conftest.py'          | Auto-loaded by Pytest for shared fixtures                 |
| Function fixture       | Returns data (e.g. API client)                           |
| Closure fixture        | Returns a function (e.g. post request builder)           |
| Dynamic arguments      | Keep fixtures flexible using function parameters         |
| DRY principle          | Avoid repetitive code for setup and request handling     |


















Creating Model Instances:
-------------------------
✅ Creating and Retrieving Model Instances in Django Tests
This note walks through writing tests for retrieving a single collection in a Django API, along with how to cleanly set up test data using 'model_bakery'.



📌 1. Objective: Test Collection Retrieval Endpoint
We aim to test the 'GET /store/collections/{id}/' endpoint, particularly the behavior when:
- The collection exists → expect '200 OK' with valid data
- The collection does not exist → expect '404 Not Found' (exercise for the reader)



📁 2. Test Class Structure
Group collection retrieval tests into a class:

import pytest
from rest_framework import status
from model_bakery import baker
from store.models import Collection

@pytest.mark.django_db
class TestRetrieveCollection:
    def test_if_collection_exists_returns_200(self, api_client):
        collection = baker.make(Collection)

        response = api_client.get(f'/store/collections/{collection.id}/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data == {
            'id': collection.id,
            'title': collection.title,
            'products_count': 0
        }





🧪 3. Why Use Model Bakery?
Instead of:
Collection.objects.create(title="...")


We write:
collection = baker.make(Collection)


🔍 Benefits:
- Auto-generates values for all fields
- Reduces test noise by avoiding manual data setup
- Maintains test independence (tests don’t rely on each other)



🔁 Managing Related Models with Bakery
For foreign key relationships (e.g. Products → Collection):
product = baker.make('Product')

✔ Bakery will auto-create the related 'Collection'.

To reuse a specific collection across multiple products:
collection = baker.make(Collection)
baker.make('Product', collection=collection, _quantity=10)


✔ All 10 products now belong to the same collection.



⚠️ 4. Common Test Errors & Fixes
🟥 301 Redirect
- Cause: Django enforces trailing slashes in URLs
- Fix: Make sure your test request ends with '/'

# Correct:
'/store/collections/1/'

# Incorrect:
'/store/collections/1'


🟥 AssertionError – Extra Field in Response
- Response may contain additional fields (e.g., 'products_count')
- Fix: Update your assertion to account for the complete response

assert response.data == {
    'id': collection.id,
    'title': collection.title,
    'products_count': 0
}




💽 5. Test Database Lifecycle

Pytest + Django will:
- Create a test database automatically (e.g. 'test_storefront3')
- Run all tests in isolation
- Drop the database after tests complete

✔ Keeps your development and test environments isolated  
✔ No chance of accidentally polluting your real data




Codes and Other Notes in this Discussion: 

pipenv install --dev model_bakery

from model_bakery import baker

@pytest.mark.django_db
class TestRetrieveCollection:
    def test_if_collection_exists_returns_200(self, api_client):
        collection = baker.make(Collection)

        response = api_client.get(f'/store/collections/{collection.id}/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data == {
            'id': collection.id,
            'title': collection.title,
            'products_count': 0
        }




✅ Final Thoughts:
| Practice                          | Rationale                                               |
|-----------------------------------|----------------------------------------------------------|
| Use 'baker.make()'                | To auto-generate test model instances cleanly           |
| Avoid dependency on other tests   | Each test must be self-contained                   |
| Test behavior, not implementation | Don’t tie tests to specific model internals             |
| Validate only API contract        | Don’t query the DB or test other endpoints here         |
| Always terminate URLs with '/'    | Django redirects otherwise ('301')                      |



















Performance Tesing:
-------------------

Introduction:
In this section, we'll be talking about performance testing. So we're going to throw a few hundred users on our application and see how it performs. 




Why Performance Testing:
------------------------
🚀 Why Performance Testing Matters (and When to Do It)

Performance testing is just as critical as functional testing when developing applications. It's not a “nice-to-have” — it's essential, especially for mission-critical systems where speed and reliability are non-negotiable.




🧭 What Is Performance Testing?
Performance testing involves evaluating an application's speed, responsiveness, scalability, and stability under expected and stress conditions.

Common goals include:
- Measuring response times of API endpoints or views
- Detecting bottlenecks in code, infrastructure, or database
- Ensuring that the system can handle concurrent users or data loads



💡 Why You Shouldn't Skip It

🔍 The Reality:
Many teams leave performance testing to the end — just before release. Due to time pressure, it often gets rushed or skipped altogether.

❗ Consequences:
- Hidden bottlenecks surface in production
- System crashes or becomes unresponsive under load
- Angry users, business disruption, or even revenue loss

“Skipping performance testing is like launching a plane before checking the engine load limits.”



🧨 Real-World Risk Example
Imagine you're building an air traffic control system:
- 🚫 Downtime is unacceptable
- ✅ Uptime must be 24/7
- ⏱️ Response times must remain within a tight tolerance

Even a minor lag can lead to critical failures in high-stakes environments.



💪 The Value of Early and Continuous Performance Testing

| Practice               | Impact                                      |
|------------------------|---------------------------------------------|
| Run performance tests during development | Detect issues before they grow costly |
| Integrate with CI/CD   | Catch regressions with every code push      |
| Tune system early      | Improve architecture and scalability        |

Remember:
Your app may work — but is it fast, resilient, and scalable?


🧰 What You'll Learn Next:
Performance testing is a broad discipline — but you don’t need a PhD to get started. In the upcoming sections, you'll learn:

- The fundamentals of performance testing
- When to use load tests, stress tests, and profiling tools
- Hands-on practice with tools that help reveal performance issues fast















Installing Locust:
------------------
🐛 Installing Locust for Performance Testing in Python Projects
Before diving into performance testing, it's essential to choose the right tool. Among the many available options, Locust stands out for its simplicity, elegant UI, and Python-native scripting style—making it a favorite for developers who already work in Python-based environments like Django or Flask.



⚙️ Why Locust?
- ✅ Write load test scenarios in plain Python
- ✅ Beautiful, real-time web UI
- ✅ Simulates thousands of users without complex setup
- ✅ Easy to integrate into existing Python workflows
- ✅ Lightweight and extensible

Locust lets you define user behaviors (like hitting an API endpoint) as Python classes and methods, then scale those interactions over time to simulate realistic load conditions.



🧰 Step-by-Step: Installing Locust
📄 Use Pipenv (for dependency isolation)

In your project root directory, run:
pipenv install --dev locust


| Flag             | Explanation                                 |
|------------------|---------------------------------------------|
| '--dev'          | Adds Locust to the '[dev-packages]' section in your 'Pipfile' |
| 'locust'         | Installs the Locust load testing framework  |

After installation, Locust will be available as a CLI command in your virtual environment.



Codes and Other Notes in this Discussion: 

pipenv install --dev locust



🔍 Next Step

You’re all set to write your first performance test script using Python. In the next step, we’ll:

- Set up a 'locustfile.py'
- Define user behavior via the 'HttpUser' class
- Simulate traffic against a target endpoint














Creating a Test Script:
-----------------------

📄 Creating a Locust Test Script for Simulating Core User Behavior
As part of performance testing, we start by identifying the core use cases that are vital to the business. For an e-commerce platform, some critical flows include:

- Browsing products
- Viewing individual product details
- Adding products to the shopping cart
- (Other use cases like registration, login/logout can be added similarly)



🗂️ 1. Project Structure

Create a dedicated directory for your test scripts:
/locustfiles/
    └── browse_products.py

The folder name is arbitrary — choose any name that's meaningful.




2. Writing the Locust Test Script

📄 'locustfiles/browse_products.py'

from locust import HttpUser, task, between
from random import randint

class WebsiteUser(HttpUser):
    wait_time = between(1, 5)  # Simulate realistic user think time

    def on_start(self):
        response = self.client.post('/store/carts/')
        result = response.json()
        self.cart_id = result['id']  # Store cart ID for add-to-cart task

    @task(2)
    def view_products(self):
        collection_id = randint(2, 6)
        self.client.get(
            f'/store/products/?collection_id={collection_id}',
            name='/store/products'  # Grouped name for simplified reporting
        )

    @task(4)
    def view_product(self):
        product_id = randint(1, 1000)
        self.client.get(
            f'/store/products/{product_id}',
            name='/store/products/:id'  # Grouped path variable
        )

    @task(1)
    def add_to_cart(self):
        product_id = randint(1, 10)  # Small range for repeated items
        self.client.post(
            f'/store/carts/{self.cart_id}/items/',
            name='/store/carts/items',
            json={'product_id': product_id, 'quantity': 1}
        )




🔍 3. Key Components Explained

| Element                      | Description |
|------------------------------|-------------|
| 'HttpUser'                   | Base class Locust uses to simulate HTTP behavior |
| '@task(weight)'              | Decorator marking a method as a simulated task with priority |
| 'on_start()'                 | Special method called once per user (setup tasks like cart creation) |
| 'self.client.get/post(...)' | Simulated HTTP requests |
| 'name=...'                   | Custom label in Locust reports to prevent verbose breakdown by URL params |
| 'between(1, 5)'              | Random delay between tasks (in seconds) to simulate user think time |




🎯 4. Weight Distribution of Tasks

| Task              | Relative Weight | Real-World Interpretation |
|-------------------|-----------------|----------------------------|
| 'view_products()' | 2               | General browsing           |
| 'view_product()'  | 4               | More frequent individual views |
| 'add_to_cart()'   | 1               | Less frequent purchase intent |

Locust picks tasks randomly but honors the probability weights to simulate realistic traffic patterns.



🧠 Why This Approach Is Powerful

- The test script is written in Python — no need to learn a DSL or JSON
- It's version-controlled like application code
- Enables regression performance testing (re-run whenever code changes)
- Flexible and scalable with just a few lines of Python




Codes and Other Notes in this Discussion: 

Core Use Cases: 
Browse Products
Register, sign in, sign out 



locustfiles/browse_products.py:

from locust import HttpUser, task, between
from random import randint

class WebsiteUser(HttpUser):
  wait_time = between(1, 5)

  @task(2) 
  def view_products(self):
    collection_id = randint(2, 6)
    self.client.get(
      f'/store/products/?collection_id={collection_id}', 
      name='/store/products')


  @task(4)
  def view_product(self):
    product_id = randint(1, 1000)
    self.client.get(
      f'/store/products/{product_id}',
      name='/store/products/:id')

  @task(1)
  def add_to_cart(self):
    product_id = randint(1, 10)
    self.client.post(
      f'/store/carts/{self.cart_id}/items/',
      name='/store/carts/items',
      json={'product_id': product_id, 'quantity': 1}
    )

  def on_start(self):
    response = self.client.post('/store/carts/')
    result = response.json()
    self.cart_id = result['id']





✅ Summary

- Created a structured Locust script simulating real user flows
- Defined tasks for browsing, viewing, and adding to cart
- Weighted task execution for realism
- Added delay intervals to mimic real-world usage
- Grouped URLs for clean reporting



















Running a Test Script:
----------------------

🧪 Running a Locust Performance Test Script
Now that we’ve written a Locust test script ('browse_products.py'), it’s time to run it and observe how Locust simulates user activity and gathers performance insights. This note walks you through step-by-step execution and highlights key features in Locust’s web UI.



🚀 1. Preparing the Script with Task Markers

To visualize how Locust invokes each task, add 'print()' statements inside every task method:

@task(2)
def view_products(self):
    print("View Products")
    ...
    
@task(4)
def view_product(self):
    print("View Product Details")
    ...

@task(1)
def add_to_cart(self):
    print("Add to Cart")
    ...


These help you track task execution in the terminal while running the test.



⚙️ 2. Running the Locust Script

In your terminal (with your Django server running on port 8000), launch Locust:
locust -f locustfiles/browse_products.py

✔ '-f' tells Locust which file to use.




🌐 3. Accessing the Locust Web Interface

- Open a browser and go to: 'http://localhost:8089'
- Fill in:
  - Number of users to simulate (e.g., '1')
  - Spawn rate (e.g., '1' user/second)
  - Host: 'http://localhost:8000' (no trailing slash)

Then click Start Swarming.



📊 4. Exploring Real-Time Stats

Locust launches your virtual users and begins executing tasks based on the defined weights and wait times.

🧮 Table Metrics:
| Column              | Meaning                                                           |
|---------------------|-------------------------------------------------------------------|
| # requests          | Count of successful requests to each endpoint                     |
| # fails             | Number of failed responses (e.g., 500s, timeouts, refused)         |
| Median / 90%        | Response time percentiles for realistic latency tracking          |
| Average / Min / Max | Full spread of response time                             |
| Avg size   | Average size of the response payload                              |

✔ URLs grouped with 'name=...' parameter reduce clutter in the table.

📈 Charts:
- Requests per second (RPS)
- Response time distribution

Both update in real time as users interact with your app.





🧾 5. Task Execution Output
In the terminal where Locust is running, you’ll see:

View Product Details
View Products
Add to Cart
...


This confirms that:
- Tasks are running repeatedly in a loop
- Wait time (1–5s) between tasks simulates human browsing





🧱 6. Locust Lifecycle Recap
Each user thread →
    executes one random task →
        prints to terminal →
        waits 1–5 seconds →
        picks another task (weighted probability)




🧯 7. Other Useful Panels
- Failures tab: Shows when requests fail (e.g., connection refused, 500 errors)
- Exceptions: Detailed Python exceptions thrown during tasks
- Tasks: Overview of each defined '@task' method
- Download CSV: Export raw stats for post-test analysis





Codes and Other Notes in this Discussion: 


locustfiles/browse_products.py:

from locust import HttpUser, task, between
from random import randint

class WebsiteUser(HttpUser):
  wait_time = between(1, 5)

  @task(2) 
  def view_products(self):
	print("View Products")
    collection_id = randint(2, 6)
    self.client.get(
      f'/store/products/?collection_id={collection_id}', 
      name='/store/products')


  @task(4)
  def view_product(self):
	print("View Product Details")
    product_id = randint(1, 1000)
    self.client.get(
      f'/store/products/{product_id}',
      name='/store/products/:id')

  @task(1)
  def add_to_cart(self):
	print("Add to Cart")
    product_id = randint(1, 10)
    self.client.post(
      f'/store/carts/{self.cart_id}/items/',
      name='/store/carts/items',
      json={'product_id': product_id, 'quantity': 1}
    )

  def on_start(self):
    response = self.client.post('/store/carts/')
    result = response.json()
    self.cart_id = result['id']




locust -f locustfiles/browse_products.py





✅ Wrap-Up

| Step                | Description                                         |
|---------------------|-----------------------------------------------------|
| Print statements    | Help track task execution sequence                  |
| Grouped requests    | Simplify UI by reducing report noise                |
| Web interface       | Real-time metrics and visualization                 |
| Accurate test setup | Host config without trailing slash; spawn rate = 1 |
| Task weights        | Influence behavior likelihood realistically         |

















Running a Performance Test:
---------------------------
🚦 Running a Performance Test with Locust to Identify Bottlenecks
In this exercise, we intentionally degrade performance to observe how Locust helps identify slow endpoints. This is a crucial practice in performance testing—validating how different parts of your system behave under load.



🧪 Step 1: Inducing a Performance Bottleneck

📍 Context:
The 'ProductViewSet' is originally optimized using:

Product.objects.prefetch_related('images').all()

This eagerly loads related 'ProductImage' objects in a single query, preventing N+1 issues.

🐌 Change Introduced:
To simulate inefficiency, we temporarily remove the 'prefetch_related()' call:
Product.objects.all()


This will result in one query per product for related images—slowing response time, especially under heavy load.





🔧 Step 2: Disabling Django Debug Toolbar

Since debug middleware introduces overhead, comment it out in 'settings.py':
MIDDLEWARE = [
    # 'debug_toolbar.middleware.DebugToolbarMiddleware',  # Disabled during performance testing
    ...
]

✔️ Ensures accurate measurements unaffected by development tools.




📊 Step 3: Running the Locust Test
💻 Terminal:
First, stop and restart the Locust process to clear the previous session:
locust -f locustfiles/browse_products.py


Then, navigate to the web UI:
http://localhost:8089


⚙️ Web UI Input:
| Setting              | Value         |
|----------------------|---------------|
| Number of Users      | '500'         |
| Spawn Rate (users/s) | '10'          |
| Host                 | 'http://localhost:8000' (no trailing slash) |

Click Start Swarming.

✔ Locust will gradually spin up 500 virtual users (10/sec), each executing defined tasks like viewing product lists and adding items to cart.





⏱️ Step 4: Monitoring the Load Test
Let Locust run for ~30 seconds after reaching peak concurrency to stabilize metrics.
Key metrics in the Statistics Table:

| Column              | Meaning                                                   |
|---------------------|-----------------------------------------------------------|
| # Requests          | Total number of successful requests                       |
| Failures            | Count of failed (4xx, 5xx, or connection errors)          |
| Avg / 90% / Max     | Response time percentiles — used to detect slow endpoints |
| Response Size       | Helpful in identifying unusually large payloads           |
| Requests/s          | Total throughput                                           |





🎯 Step 5: Interpreting the Results

- Focus on relative performance, not exact millisecond values.
- Don’t assume:
  - "179ms average" = production-ready.
  - or that you'll see the same numbers on every run.


Why?
- This is a development server, not optimized for concurrency.
- Results vary by:
  - Machine load
  - Django settings
  - Network state
  - Test script randomness





🔎 Performance Bottleneck Observed
- Without 'prefetch_related', you’ll likely notice:
  - Higher average and 90th percentile response times
  - Longer delay in the '/store/products/' endpoint
- This helps validate the importance of query optimization





Codes and Other Notes in this Discussion: 


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.all() # earlier it was --> Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, kwargs)




✅ Key Takeaways

| Practice                             | Purpose                                           |
|--------------------------------------|---------------------------------------------------|
| Remove optimization                  | Simulate a performance flaw intentionally         |
| Disable dev tooling                  | Ensure accurate benchmarking                      |
| Use high concurrency + ramp-up rate | Simulate realistic load and measure degradation   |
| Focus on relative trends             | Avoid treating raw values as exact performance    |
| Analyze endpoint-by-endpoint         | Identify slowest parts of your API                |



















Performance Optimization Techniques:
-------------------------------------
🚀 Performance Optimization Techniques in Django
After running a performance test to identify bottlenecks, the next step is to optimize those slow endpoints. In most cases (90%+), the root cause lies in inefficient queries or database access patterns. Here's a structured summary of proven optimization techniques.



📌 1. Optimize Django ORM Usage (Python-Level Improvements)
🔹 a. Preload Related Objects
Avoid the N+1 query problem by using:

Product.objects.select_related('category')         # For ForeignKey
Product.objects.prefetch_related('images')         # For reverse relations or M2M


🔹 b. Load Only What You Need
Avoid loading full models when only a few fields are required.

Product.objects.only('title')                      # Loads only specified fields
Product.objects.defer('description')               # Skips loading large fields


🔹 c. Use Lightweight Projections
Return primitive types instead of full model instances when model behavior isn’t required.

Product.objects.values('id', 'title')              # Dicts with key-value pairs
Product.objects.values_list('title', flat=True)    # Simple flat list

✅ Useful for lightweight responses and reporting queries


🔹 d. Count Objects Properly
Never use 'len(queryset)'—it loads all objects into memory.

Product.objects.count()                            # ✅ Efficient
len(Product.objects.all())                         # ❌ Inefficient


🔹 e. Bulk Create / Update
For batch operations:

Product.objects.bulk_create([...])                 # Single INSERT statement
Product.objects.bulk_update([...], ['price'])      # Single UPDATE statement

✔ Reduces ORM overhead and speeds up database writes.





🧮 2. Rewriting Queries Manually (SQL-Level Optimization)

If ORM tuning isn’t enough, rewrite your query using custom SQL:

from django.db import connection
with connection.cursor() as cursor:
    cursor.execute("SELECT ...")


- ORM-generated queries may not be optimal for complex joins or aggregations.
- Write hand-crafted SQL when precision and performance matter most.





🧩 3. Tune the Database (Schema-Level Improvements)

If queries are still slow:

- Add indexes on frequently filtered or joined fields.
- Refactor schema to normalize or denormalize where needed.
- Use EXPLAIN plans to inspect query performance.

Database tuning requires knowledge of data volume, access patterns, and index usage.




🗃️ 4. Cache Query Results (Memory-Level Optimization)

Store expensive query results in memory:

from django.core.cache import cache

data = cache.get('products')
if not data:
    data = Product.objects.prefetch_related('images').all()
    cache.set('products', data, timeout=600)

⚠️ Considerations:
- Caching can be faster but not always—especially if cache is remote.
- Use when:
  - Query is expensive
  - Data doesn't change frequently
- Avoid for trivial queries that are already fast





🧠 5. Scale Hardware (Infrastructure-Level Optimization)

If performance issues persist under high concurrency:

📈 Step 1: Vertical Scaling
- Upgrade to faster CPU
- Add more RAM

🪜 Step 2: Horizontal Scaling
- Add more web servers
- Deploy load balancers and clusters

⚠️ Cost increases with scale. Prioritize this only if optimizations are insufficient.




🎯 6. Pick Your Battles Wisely

Not all performance problems need solving.

“A report run once every quarter doesn’t need to be blazing fast.”

Focus optimization efforts on:
- High-traffic endpoints
- Business-critical paths
- User-facing features with tight latency constraints



✅ Optimization Pyramid

	+------------------------+
	|  Hardware (Scaling)    |
	+------------------------+
	|     Caching Layer      |
	+------------------------+
	|   Query / DB Tuning    |
	+------------------------+
	|   ORM / Code Optim     |
	+------------------------+




Codes and Other Notes in this Discussion:

Optimizations:
Optimize the Python Code 
Re-write the query 
Tune the database 
Cache the result 
Buy more hardware 


#Preload related objects
Product.objects.select_related('...')
Product.objects.prefetch_related('...')


#Load only what you need
Product.objects.only('title')
Product.objects.defer('description')


#Use values
Product.objects.values()
Product.objects.values_list()


#Count properly
Product.objects.count()
len(Product.objects.all())  #BAD


#Bulk create/update
Product.objects.bulk_create([])




🔚 Summary

| Layer                | Techniques                                                                 |
|----------------------|---------------------------------------------------------------------------|
| Python / ORM         | 'select_related', 'only()', 'values()', 'bulk_create()'                   |
| Raw SQL              | Write optimized queries when ORM isn’t sufficient                         |
| Database Tuning      | Indexes, normalization, query plans                                       |
| Caching              | Store heavy results in memory if accessed repeatedly                      |
| Infrastructure       | Scale up or out, but only as a last resort                                |



















Profiling with Silk:
--------------------
🧪 Profiling with Django Silk
While Locust helps you identify slow endpoints, it doesn’t reveal the root cause—especially if the bottleneck lies in your database queries. This is where Django Silk comes in—a lightweight profiling tool to inspect execution time, SQL queries, and request-level performance.



🔍 What is Silk?
Silk is a middleware-based profiler for Django. It:
- Captures every request made to your app
- Tracks SQL queries per request
- Shows execution time per query
- Helps pinpoint inefficient patterns (like N+1 queries)



📦 Step-by-Step: Installing and Setting Up Silk
1. Install Silk as a dev dependency
pipenv install --dev django-silk




2. Register Silk in 'settings.py'
a. Add Silk to 'INSTALLED_APPS'

INSTALLED_APPS += [
    'silk',
]


b. Conditionally add the middleware:
Avoid enabling Silk in production—it's resource-heavy.

if DEBUG:
    MIDDLEWARE += ['silk.middleware.SilkyMiddleware']





3. Register the Silk URL route
📄 In 'storefront/urls.py':

if settings.DEBUG:
    urlpatterns += [path('silk/', include('silk.urls', namespace='silk'))]


✔ This enables access to Silk at '/silk/'



4. Run Migrations

Silk stores profiling data in its own DB tables:
python manage.py migrate




🎛️ Using Silk During Testing
🔁 Option A: Browse manually

Hit a few endpoints in your app and then visit 'http://localhost:8000/silk/'


🔁 Option B: Use Locust (preferred)\
Instead of simulating 500 users, run:
locust -f locustfiles/browse_products.py


Set Users to 1–5 and spawn rate to 1. This sends traffic through the app for Silk to profile.

⚠️ You’ll notice slower response times due to Silk's introspection overhead.



📊 Exploring the Silk Dashboard

Visit [http://localhost:8000/silk/](http://localhost:8000/silk/)

Key Sections:
🟦 Most Time Overall
- Identify which endpoints are slowest
- E.g. '/store/products/' may show high latency and excessive queries

🟥 Most DB Time
- Highlights endpoints spending the most time in database operations

🟨 Most Queries
- Detect endpoints causing N+1 issues

🔄 Request Table
- Switch to table view
- Sort by # of queries to find inefficient requests


📌 Request Details
Click any request row to view:
- Query params & headers
- Response time breakdown
- Full SQL query list
- Execution time per SQL statement




🛠 Example Bottleneck: N+1 Query

If '/store/products/?collection_id=5' triggers 13 separate queries to 'ProductImage', it's likely you're missing:
Product.objects.prefetch_related('images')


Silk confirms exactly which queries fired—and how long each took.



🧹 Resetting Silk's Data
Before re-running a test:
1. Go to Silk’s summary page
2. Click "Clear DB" to remove existing logs

Useful for a clean performance benchmark after making optimizations.



Codes and Other Notes in this Discussion:

django silk --> https://github.com/jazzband/django-silk




✅ Summary

| Task                         | Tool          | Purpose                                  |
|------------------------------|---------------|------------------------------------------|
| Load Test Behavior           | Locust        | Simulate concurrent users                |
| Identify Endpoint Bottlenecks| Locust Stats  | Pinpoint high-latency routes             |
| Root Cause Diagnostics       | Silk          | Analyze SQL queries & per-request timing |
| Confirm Fixes                | Silk + Locust | Rerun tests post-optimization            |




















Verifying Optimizations:
------------------------

✅ Verifying Performance Optimizations with Locust
Once we’ve optimized our application based on Silk's insights, it’s critical to verify those improvements using a repeatable performance test. This ensures we're not just guessing—we’re measuring actual impact. Here's how to systematically confirm that prefetching related images has successfully optimized our '/store/products/' endpoint.



🛠️ Step 1: Implement the Optimization:
In 'ProductViewSet', we previously removed eager loading. Now we restore it:
queryset = Product.objects.prefetch_related('images').all()

✔ This preloads all related 'ProductImage' objects in a single query, resolving the N+1 query issue.



🔕 Step 2: Disable Silk to Ensure Clean Metrics
Silk is useful for profiling but adds overhead during performance tests, which skews results.

# In 'settings.py', comment out:

# if DEBUG:
#     MIDDLEWARE += ['silk.middleware.SilkyMiddleware']


This ensures Locust results are not affected by Silk’s processing hooks.



🔁 Step 3: Reset Your Locust Session
In the terminal running Locust:
ctrl + C
locust -f locustfiles/browse_products.py


✔ This clears the previous test session and ensures accurate results.



🌐 Step 4: Run the Same Load Test
To ensure a fair comparison, use the same parameters:

| Parameter             | Value             |
|------------------------|-------------------|
| Users to simulate      | '500'             |
| Spawn rate             | '10 users/second' |
| Host                   | 'http://localhost:8000' |

Let the test run until:
- All 500 users are active
- Minimum ~7,200–7,800 total requests have been sent

✔ This ensures your metrics are comparable to your pre-optimization baseline.





📊 Step 5: Analyzing the Results

🔹 Products Endpoint

| Metric                   | Before Optimization | After Optimization |
|---------------------------|----------------------|---------------------|
| 90th Percentile Response  | ~3000ms (3s)         | ~540ms              |

✅ A dramatic 5.5x improvement in tail latency for product listing


🔹 Side Effects: System-Wide Gains

| Endpoint             | Pre-Optimization 90% | Post-Optimization 90% |
|----------------------|----------------------|------------------------|
| POST '/store/carts/' | ~670ms               | ~160ms                 |
| POST '/carts/items/' | ~710ms               | ~89ms                  |

Even unrelated endpoints show better performance due to:
- Lower DB load
- Faster response pipeline
- Fewer concurrent requests clogging queues


🔹 Overall System Stats

| Metric                      | Before      | After       |
|-----------------------------|-------------|-------------|
| Total Request Time (90%)    | ~2000ms     | ~650ms      |
| Requests per Second (RPS)   | ~120 RPS    | ~140 RPS    |

✅ This shows our app is now faster and can handle more traffic.



Codes and Other Notes in this Discussion: 


class ProductViewSet(ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_class = ProductFilter
    pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, kwargs)





📌 Key Takeaways

| Step                         | Why It Matters                                         |
|------------------------------|--------------------------------------------------------|
| Always re-test after tuning  | Validates if the optimization actually worked          |
| Keep test conditions equal   | Ensures an accurate A/B comparison                     |
| Don’t assume improvements    | Sometimes "optimizations" backfire without measurement |
| Measure system-wide ripple effects | Even a localized fix can boost overall performance |



📐 Visual Summary:
Before Optimization:
  /store/products/ → 13 queries → 3000ms avg → 120 RPS

After Optimization:
  /store/products/ → 1 query (prefetched) → 540ms avg → 140 RPS


















Stress Testing:
---------------
🧪 Stress Testing with Locust: Understanding System Limits
Stress testing is a specialized form of performance testing aimed at uncovering the upper limits of your application’s capacity. The goal is to simulate extreme load and determine how your system behaves when overwhelmed—whether it fails gracefully or crashes entirely.



🚨 What Is Stress Testing?

- It identifies the point where your application starts to degrade or fail.
- Helps determine max concurrency thresholds (e.g. max users or RPS).
- Especially critical for seasonal traffic spikes (e.g. flash sales, holiday events).



🧰 Test Setup
📌 Locust Parameters Used:

| Setting                 | Value         | Purpose                                         |
|------------------------|---------------|-------------------------------------------------|
| Number of Users         | 1000          | Simulate extreme user load                     |
| Spawn Rate              | 10/sec        | Control ramp-up speed for concurrency          |
| Host                    | 'http://localhost:8000' | App server under test                   |

- Use 'locust -f locustfiles/browse_products.py' to restart the test cleanly.
- Ensure you’re running this test in an environment that resembles production, not your local dev server.



🖥️ Choosing the Right Environment

While running stress tests on a development machine can illustrate basic behavior, it's not sufficient for meaningful results:

| Environment         | Best For                |
|---------------------|--------------------------|
| Dev server           | Debugging setup         |
| Production-like test env | Reliable upper limit benchmarks |

Even testing on just one production-equivalent server gives valuable insight into load handling.



📊 Observations from Stress Test Results
- Application started failing after ~600 users
- Failure rate began at 1.5 requests/sec and climbed to ~11 requests/sec
- RPS dropped from ~140 → as low as 10 once saturation occurred

📈 Visual Indicators

- Red failure line appeared at ~700 concurrent users on the Locust chart
- RPS curve declined sharply as server struggled to keep up
- Confirmed limits of the development environment



✅ Key Takeaways
| Topic                           | Summary                                                                 |
|----------------------------------|--------------------------------------------------------------------------|
| Purpose                          | Find app’s failure threshold under high load                           |
| When to stress test              | Before known peak events, deployment, or scaling decisions              |
| Environment matters              | Should resemble production for valid results                            |
| Failure signs                    | Rising error rate, falling RPS, increased response times                |
| Dev server ≠ reality             | Results from local dev environments are for approximation only      |

Always document stress thresholds and use them to guide scaling decisions and emergency capacity planning.





















Caching: 
--------

Introduction: 
-------------
In this Section, we'll be talking about Caching which is a performance optimization technique 



What is Caching: 
----------------
🚀 Introduction to Caching in Web Applications
Caching is a powerful optimization strategy used to reduce response times and server load by storing frequently accessed data in memory. Instead of repeatedly executing complex database queries or external API calls, cached data is served to the user, providing faster and more efficient performance.



🧠 How Caching Works

1. Initial Request:
   - A client triggers a query (e.g., fetching product listings).
   - The server queries the database and receives the data.

2. Storage in Cache:
   - The result is stored in memory (e.g., Redis, in-memory cache).

3. Subsequent Requests:
   - Data is served directly from the cache, not the database.
   - Response time is typically faster, and database load is reduced.

[First Query]      → DB Lookup → Store in Cache → Return
[Subsequent Query] → Check Cache → Return




✅ Benefits of Caching

| Advantage                          | Description                                                    |
|-----------------------------------|----------------------------------------------------------------|
| ⏱️ Faster Response Times           | Memory access is faster than disk or DB calls                  |
| 🖥️ Reduced Server Load            | Frees up database and web server resources                     |
| ♻️ Consistent Data Access         | Cached results remain available even if the DB slows down      |
| ☁️ Resilient to API Failures      | Cache can serve stale data if a third-party API is down        |



⚠️ The Problem of Stale Data
One key drawback of caching is data staleness:

- If the database changes, cached data may not reflect those changes immediately.
- To avoid this, cached entries are given an expiration time, e.g.:
  - 5 minutes for product listings
  - 1 hour for category trees
  - 24 hours for rarely updated static content

When NOT to Cache:
- If data changes rapidly and users must always see the most current version
- If the cache adds more latency than a lightweight query would



🌐 Beyond Database Caching
Caching can also be used for:
- ❗ Third-party API results
   - Avoid delays if the API is slow or unavailable.
- 📦 Computed results
   - Like generating product recommendations or complex reports.
- 🔄 Background refresh with Celery
   - Use Celery to refresh the cache periodically with fresh data.



⚠️ Tradeoffs to Consider
| Concern                          | Impact                                                       |
|----------------------------------|---------------------------------------------------------------|
| 🔄 Stale data                    | Must manage expiry and invalidation strategies                |
| 💾 Memory usage                 | Aggressive caching requires more memory, increasing cost      |
| 🚫 Over-caching                  | Can actually degrade performance if cache access is slower     |
| 🎯 Use data-driven decisions     | Always validate caching gains with performance testing        |

"Premature optimization is the root of all evil."  
Run a performance test before and after introducing cache to prove its worth.



✅ Summary
- Cache improves app performance by storing frequently used data in memory
- Must balance cache freshness, memory usage, and actual performance gain
- Cache selectively—don’t guess, benchmark before and after
- Suitable for slow DB queries, API calls, or frequently requested static data












Cache Backends:
---------------
⚙️ Django Cache Backends: Overview and Use Cases
In Django, cache backends (or engines) define where and how cached data is stored and retrieved. Choosing the right backend depends on your environment, performance needs, and deployment infrastructure.



🧠 Why Use a Cache Backend?
- Store frequently accessed results (e.g., expensive DB queries) temporarily
- Serve faster responses
- Reduce database load
- Support offline or fallback behavior for external APIs



🔌 Supported Cache Backends in Django:
| Backend      | Description                                                                          | Performance                | Default | Production Ready |
|--------------|----------------------------------------------------------------------------------|--------------------------|---------|------------------|
| Local Memory | Stores cache in the same Python process; very fast but not shared across processes   | Fast (single process)    | ✅      | ❌ Development only |
| Memcached    | External cache server; highly performant; used in enterprise setups                  | Very Fast                | ❌      | ✅ |
| Redis        | Versatile in-memory data store; can be used for caching, pub-sub, queues, and more   | Very Fast + Rich Features| ❌ | ✅ |
| Database     | Stores cached data in your existing database (e.g., PostgreSQL, SQLite)              | Moderate                 | ❌      | ⚠️ (fallback option) |
| File System  | Stores cached data as files on disk                                                  | Slowest                  | ❌      | ⚠️ (rarely used) |



🔎 Additional Notes on Each Backend
🔹 1. Local Memory (Default)
- Stores cache in-memory inside each Django process.
- Easy setup, no extra config, great for development/testing.
- ⚠️ Not shared between multiple processes or servers.

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
    }
}




🔹 2. Memcached
- High-performance, widely adopted cache server.
- Requires installation and configuration of a Memcached daemon.
- Excellent for shared caching across multiple app servers.

Documentation: [Django Memcached Cache](https://docs.djangoproject.com/en/stable/topics/cache/#memcached)



🔹 3. Redis (Recommended)
- Full-featured in-memory key-value store.
- Acts as both a cache backend and message broker (we're already using it for Celery).
- Requires installing an external library:

pipenv install django-redis


Example config:

'''python
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
    }
}



🔹 4. Database Cache
- Uses Django's existing DB to store cached data.
- Ideal fallback when no external cache server is available.
- Run migrations to create the cache table:

python manage.py createcachetable


🔹 5. File-Based Cache
- Cache values stored as individual files on disk.
- Simple but limited—slow for large-scale use or concurrent access.

Example:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}




Codes and Other Notes in this Discussion: 
Local Memory(Default)
Memcached
Redis 
Database 
File system 




📌 Summary:

| Use Case                  | Recommended Backend    |
|---------------------------|------------------------|
| Local development         | Local Memory           |
| Production performance    | Redis or Memcached     |
| No external dependencies  | Database Cache         |
| Very infrequent caching   | File-Based Cache       |















Simulating a slow API:
----------------------

🐢 Simulating a Slow API Endpoint in Django
In this example, we’ll simulate a slow third-party API within a Django view so we can observe how external delays impact our application performance. This is especially useful when evaluating the benefits of optimization techniques like asynchronous requests or caching.



🔧 Step-by-Step: Modifying the 'say_hello' View
📁 File: 'playground/views.py'

1. Remove outdated logic (e.g., notifications):
   '''python
   # Remove unused code related to notifying customers
   '''

2. Import the 'requests' library:
   '''python
   import requests
   '''

3. Simulate a delayed API call:

   Replace the original view code with:
   '''python
   from django.shortcuts import render
   import requests

   def say_hello(request):
       requests.get('https://httpbin.org/delay/2')  # Simulated 2-second delay
       return render(request, 'hello.html', {'name': 'Mosh'})
   '''

   # ⚠️ Explanation:
   - This hits 'https://httpbin.org/delay/2', which purposefully delays for 2 seconds before responding.
   - Mimics the behavior of a slow third-party service, such as a payment gateway or analytics API.



🌐 Testing the Endpoint
1. Start your Django development server:
   '''bash
   python manage.py runserver
   '''

2. In your browser, visit:
   '''
   http://localhost:8000/playground/hello
   '''

3. Observe:
   - The page takes ~2 seconds to respond.
   - This confirms the delay is successfully simulated.



🎯 Purpose

This setup allows you to:
- Profile slow endpoints
- Benchmark your baseline latency before optimization
- Explore async execution, timeouts, retries, or caching as performance strategies





Codes and Other Notes in this Discussion: 

from django.shortcuts import render
import requests 


def say_hello(self, request):
	requests.get('https://httpbin.org/delay/2')
	return render(request, 'hello.html', {'name': 'Mosh'})
	


🧠 Next Step
As always, before applying any optimizations:
1. Measure performance (e.g., using Locust or Django Silk)
2. Record baseline metrics
3. Implement improvements
4. Validate with a follow-up test


	
	
	
	
	
	
	
	
	
	

Getting a Baseline Performance Benchmark:
-----------------------------------------

📏 Establishing a Baseline Performance Benchmark with Locust
Before applying optimizations like caching, it’s essential to measure your current system’s response time under realistic load. This process helps establish a performance baseline for meaningful before/after comparisons.



🧪 Step 1: Add the Test Task for the Slow Endpoint

In your Locust script ('locustfiles/browse_products.py'), define a new task method inside the 'WebsiteUser' class:

from locust import HttpUser, task

class WebsiteUser(HttpUser):

    @task
    def say_hello(self):
        self.client.get('/playground/hello/')  # ⚠️ Ensure trailing slash


✔ This task simulates a user hitting the intentionally slow endpoint at '/playground/hello/'.



🚀 Step 2: Run the Test

# Restart Locust:

'''bash
locust -f locustfiles/browse_products.py
'''

# In the Locust UI ('http://localhost:8089'):

| Input                    | Value                  |
|--------------------------|------------------------|
| Number of users      | '500'                  |
| Spawn rate           | '10' users/second      |
| Host                 | 'http://localhost:8000' |

Click Start swarming.



⏱️ Step 3: Let the Test Run
- Allow Locust to simulate up to ~7,000 requests
- This gives us enough data to extract 90th percentile latency, averages, and request per second (RPS)



📊 Step 4: Review the Metrics

Sample Metrics for '/playground/hello/' (Simulated Slow Endpoint):

| Metric                      | Value                  |
|-----------------------------|------------------------|
| 90th Percentile Latency     | ~2,600 ms              |
| Aggregated Average Latency  | ~2,400 ms              |
| Request Volume              | ~7,000 requests total  |

✔ These values become our baseline performance metrics.



📌 Why This Matters

- By capturing this baseline, we’ll be able to measure how much caching improves the endpoint
- Without baseline metrics, you’re flying blind — unsure if performance changes are effective or not



Codes and Other Notes in this Discussion: 

class WebsiteUser(HttpUser):

    @task
    def say_hello(self):
        self.client.get('/playground/hello/')



✅ Key Takeaways

| Best Practice               | Purpose                                                |
|-----------------------------|---------------------------------------------------------|
| Include a task for each endpoint | Ensures realistic simulation of critical routes    |
| Use consistent load params | Keeps comparisons valid across test runs               |
| Run enough requests         | Stabilizes statistical metrics like 90th percentile     |
| Save benchmark report       | Use later to validate optimizations (e.g. caching)     |





















Installing Redis:
-----------------

Here’s a clean, well-organized version of your notes on Installing Redis using Docker, including all relevant technical explanations and clarifications. It’s formatted to be notebook-ready and includes minor enhancements for clarity:



🧱 Installing Redis with Docker
In our earlier sessions, we discussed multiple ways to install Redis. Among these, Docker is the most convenient and portable approach. Let’s ensure Redis is up and running before moving on to configuring caching.



✅ Step-by-Step: Running Redis in Docker
To start a Redis container using Docker, run the following command in your terminal:

'''bash
docker run -d -p 6379:6379 redis
'''

🔍 Explanation:
- 'docker run': Command to create and start a new container.
- '-d': Runs the container in detached mode (in the background).
- '-p 6379:6379': Port mapping — maps port '6379' on your host machine to port '6379' on the container.  
  - Redis listens on port '6379' by default.
- 'redis': Official Redis image from Docker Hub.



❗ Handling Common Errors

If you receive an error like:
'''
docker: Error response from daemon: driver failed programming external connectivity on endpoint...: Bind for 0.0.0.0:6379 failed: port is already allocated.
'''

💡 It means Redis (or another service) is already running on port 6379, possibly in another terminal or container.

You can verify this by checking Docker containers:

'''bash
docker ps
'''

If needed, stop or remove the container before rerunning the command.



✅ Redis is Now Running!

Once you run the command successfully, Redis is ready for use. We can now move on to configuring caching.



Codes and Other Notes in this Discussion: 

docker run -d -p 6379:6379 redis 



🧠 Bonus Tip: Visual Overview (Optional)

Here’s a simple illustration of what’s happening with port mapping:

+---------------------+           +-------------------+
|     Host Machine    | 6379 ---> |   Docker Redis    |
+---------------------+           +-------------------+


Redis container’s port '6379' is exposed to your local machine’s 'localhost:6379'.










Configuring Caching:
--------------------
⚙️ Configuring Redis as a Cache Backend in Django
To enable caching in your Django project using Redis, you need to install and configure an external package—'django-redis'—and integrate it into your settings. This will allow Django to store and retrieve cache data via Redis.


🧱 Step 1: Install 'django-redis'
Use Pipenv to install the Redis client library as a development dependency:
'''bash
pipenv install django-redis
'''

This installs the 'django-redis' package from [PyPI](https://pypi.org/project/django-redis/), which allows Django to interface directly with a Redis instance.



🧰 Step 2: Configure Redis in 'settings.py'
In your 'storefront/settings.py', add or update the 'CACHES' configuration at the end of the file:

'''python
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",  # Use DB 2 for cache (avoid DB 1 if used by Celery)
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
'''



🔍 Explanation of Settings:

| Key             | Purpose                                                         |
|------------------|------------------------------------------------------------------|
| 'BACKEND'        | Specifies Redis as the caching backend                          |
| 'LOCATION'       | Address of Redis server ('redis://host:port/db')                |
| 'CLIENT_CLASS'   | Defines client behavior ('DefaultClient' is usually sufficient) |

> Important:  
If you’re already using Redis for other purposes (e.g. Celery is using Redis DB 1), use a different Redis database (e.g. DB 2 or DB 3) for caching to avoid conflicts.




Codes and Other Notes in this Discussion: 


django-redis --> https://pypi.org/project/django-redis/

pipenv install django-redis 


storefront/settings.py:

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}





✅ Summary

| Step                 | Action                                                   |
|----------------------|----------------------------------------------------------|
| 1.Install Package   | 'pipenv install django-redis'                            |
| 2.Update Settings   | Configure 'CACHES' block with Redis details              |
| 3.Use Unique DB     | Avoid DB collisions by using a separate Redis database  |















Using the Low-level Cache API:
------------------------------

🧠 Using Django's Low-Level Cache API
When using Redis (or any cache backend) with Django, the low-level cache API provides full control for caching data programmatically. This is ideal for dynamic responses, third-party API calls, or computational results you want to reuse temporarily.



📄 Step-by-Step Implementation
1. Import Required Modules
In your 'views.py':

'''python
from django.core.cache import cache
from django.shortcuts import render
import requests
'''



2. Define the View Logic
'''python
def say_hello(request):
    key = 'httpbin_result'

    if cache.get(key) is None:
        response = requests.get('https://httpbin.org/delay/2')  # Simulates 2s API delay
        data = response.json()
        cache.set(key, data, timeout=10 * 60)  # 10-minute cache

    return render(request, 'hello.html', {'name': cache.get(key)})
'''

🔍 Explanation:
- Step 1: Attempt to retrieve data using 'cache.get(key)'
- Step 2: If not cached:
  - Make external API call
  - Parse the JSON
  - Store it in the cache using 'cache.set(key, value, timeout)'
- Step 3: Return cached data in the template

✔ Using a variable like 'key = 'httpbin_result'' avoids repeating string literals and prevents typos.



⏱️ Verifying It Works
- First request: ~2s delay (API call + caching)
- Subsequent requests: ⚡ Instant (served from cache)
  
Browser Test:
Visit:
'''
http://localhost:8000/playground/hello/
'''

Refresh the page:
- First load is slow
- Second and later loads are immediate



⏳ Timeout Control
By default, cached items expire after 300 seconds (5 min)

# Options to Modify Timeout:

A. Per-call (dynamic):
'''python
cache.set(key, data, timeout=10 * 60)  # 10 minutes
'''

B. Globally (in settings.py):

'''python
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",
        "TIMEOUT": 10 * 60,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
'''



⚠️ Considerations
- Precision: This method gives you complete control over keys and logic
- Drawback: Logic gets repetitive if used in many views
- Next Step: We'll explore *higher-level* caching (e.g., decorators or template fragment caching) to simplify common patterns




Codes and Other Notes in this Discussion: 

from django.core.cache import cache
from django.shortcuts import render
import requests 


def say_hello(self, request):
	key = 'httpbin_result'
	if cache.get(key) is None: 
		response = requests.get('https://httpbin.org/delay/2')
		data = response.json()
		cache.set(key, data, 10 * 60)
	return render(request, 'hello.html', {'name': cache.get(key)})
		
		

Or we can set the timeout globally: 
 
storefront/settings.py:

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
		"TIMEOUT": 10 * 60, 
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}




✅ Summary

| Operation             | Method                |
|-----------------------|-----------------------|
| Get cached value      | 'cache.get(key)'      |
| Set cached value      | 'cache.set(key, value, timeout)' |
| Use shared config     | 'settings.py → TIMEOUT' key      |

The low-level cache API is powerful but verbose—ideal for explicit, fine-grained caching scenarios.



	
	









Caching Views:
--------------

⚡️ Caching Views in Django: Function- and Class-Based Approaches
To avoid repetitive manual caching logic using the low-level API, Django provides decorators for caching views in a cleaner and more maintainable way.



✅ 1. Caching a Function-Based View (FBV)
📄 'playground/views.py'

'''python
from django.views.decorators.cache import cache_page
import requests
from django.shortcuts import render

@cache_page(5 * 60)  # Cache this view for 5 minutes (300 seconds)
def say_hello(request):
    response = requests.get('https://httpbin.org/delay/2')  # Simulate slow external call
    data = response.json()
    return render(request, 'hello.html', {'name': data})
'''

🔍 How it Works
- On first request, Django calls the view, processes the response, and stores the rendered HTML in cache.
- On subsequent requests (until cache expires), Django skips the view and serves the cached response immediately.
- The cache key is auto-generated by Django and tied to the request path, headers, and optional query parameters.

⚠️ Caveat
If the view logic or template output changes during development, those changes won’t be visible until the cache expires.



🔁 Updating the View After It's Cached
Making changes like:

'''python
return render(request, 'hello.html', {'name': 'Mosh'})
'''

will not reflect immediately if the previous output is still cached. You must wait for cache expiry or manually clear the cache to see updated content.



🔄 2. Caching a Class-Based View (CBV)
📄 'playground/views.py'
'''python
from rest_framework.views import APIView
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.shortcuts import render
import requests

class HelloView(APIView):
    @method_decorator(cache_page(5 * 60))  # Apply cache_page to the get method
    def get(self, request):
        response = requests.get('https://httpbin.org/delay/2')
        data = response.json()
        return render(request, 'hello.html', {'name': 'Mosh'})
'''


📄 'playground/urls.py'
'''python
from django.urls import path
from . import views

urlpatterns = [
    path('hello/', views.HelloView.as_view())
]
'''

🚨 Why 'method_decorator'?
- '@cache_page' works only on function-based views.
- For CBVs, use '@method_decorator(...)' to wrap specific class methods like '.get()' or '.post()'.



🧪 Testing Behavior

| Scenario                          | Observation                                  |
|----------------------------------|----------------------------------------------|
| First request                    | Waits 2 seconds, renders live response        |
| Next request (within 5 minutes)  | Instant response from cache                  |
| Change in view logic             | Not visible until cache expires              |




Codes and Other Notes in this Discussion: 

playground/views.py:

from django.views.decorators.cache import cache_page

@cache_page(5 * 60)
def say_hello(request):
	response = requests.get('https://httpbin.org/delay/2')
	data = response.json()
	return render(request, 'hello.html', {'name': data})




playground/views.py:

from django.core.cache import cache
from django.shortcuts import render
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from rest_framework.views import APIView
import requests


class HelloView(APIView):
    @method_decorator(cache_page(5 * 60))
    def get(self, request):
        response = requests.get('https://httpbin.org/delay/2')
        data = response.json()
        return render(request, 'hello.html', {'name': 'Mosh'})



urls.py:
from django.urls import path
from . import views

# URLConf
urlpatterns = [
    path('hello/', views.HelloView.as_view())
]




🧠 Summary

| View Type         | Decorator                       | Notes                                   |
|-------------------|----------------------------------|-----------------------------------------|
| Function-Based     | '@cache_page(timeout)'           | Simplest way to cache a view            |
| Class-Based        | '@method_decorator(cache_page)'  | Wrap specific methods (e.g. '.get()')   |

💬 Next: Learn how to manually clear cache or cache parts of templates using fragment caching.





















Verifying Optimizations:
------------------------
✅ Verifying Caching Optimization with Locust
Once caching is implemented, it's important to confirm its actual performance impact. This ensures that perceived optimizations result in measurable gains. Here’s how a controlled performance test was conducted using Locust.



🧪 Test Setup
🧾 Load Parameters:
| Test Stage               | Value               |
|--------------------------|---------------------|
| Number of Users          | 200                 |
| Spawn Rate               | 10 users/second     |
| Target Endpoint          | '/playground/hello/' |
| Request Volume (per run) | ~2000 requests      |

Originally, 500 users were used, but due to rapid response times from caching, the test overwhelmed the development server, leading to errors. Reducing the concurrency to 200 users eliminated these failures.



🔁 Step-by-Step Comparison Procedure
1. Disable Caching:
   - In the view logic, the caching line was commented out.
   - Ran Locust to simulate 200 users and let the test run until 2000 requests were made.

2. Enable Caching Again:
   - Re-enabled the cache logic in the view.
   - Restarted Locust with the *same* test parameters.

3. Compare Metrics:
   - Ensured the only difference between the tests was the presence of caching.



📊 Performance Comparison

| Metric                          | Without Caching        | With Caching           |
|----------------------------------|--------------------------|--------------------------|
| 90th Percentile Response Time    | 2300 ms                 | 51 ms               |
| Total Requests Executed         | ~2000                   | ~2000                   |
| Current Requests/Second (RPS)   | 62.4                    | 64.9                |


🔍 Observations:
- Response Time:  
  The response time dropped by over 97% for 90% of users — from 2.3 seconds to 51 milliseconds.
  
- System Throughput:  
  Although RPS only improved slightly, it reflects greater stability under load, since the server spent far less time processing individual requests.



✅ Key Takeaways:
| Insight                                  | Description                                             |
|------------------------------------------|---------------------------------------------------------|
| Use consistent test parameters           | Ensures a fair before-and-after comparison              |
| Measure impact using real request volumes| Results are statistically significant at ~2000 requests |
| Caching made a massive difference        | Drastically reduced response latency                    |
| Not all optimizations improve throughput | But latency and server responsiveness improved notably  |





















Managing Redis Cache Content:
-----------------------------

🧹 Managing Redis Cache Content (via Docker)
When using Redis for caching in Django, it’s often helpful to manually inspect or clear cached data, especially during development or debugging. Here’s how to interact with your Redis instance from the command line using Docker.



🐳 Accessing Redis CLI via Docker
1. Check Running Redis Container
'''bash
docker ps
'''

You’ll see a container running Redis. Note the Container ID (e.g., 'dfeab123...').



2. Open Redis CLI Inside the Container

'''bash
docker exec -it dfeab redis-cli
'''

- '-it': Interactive terminal
- 'dfeab': First few characters of the container ID (yours may differ)
- 'redis-cli': Command to enter Redis command line interface


🗄️ Navigating Redis Databases
Redis uses numeric indexes for databases (default: 0–15).
- Database 1 is often used for Celery message broker
- Database 2 might be configured as your Django cache

Switch to Cache DB:
'''bash
select 2
'''



🔍 Viewing Keys in the Cache
List all keys:
'''bash
keys *
'''

You’ll see results like:
'''
1) ":1:views.decorators.cache.cache_header..GET.playground.hello."
2) ":1:views.decorators.cache.cache_page..GET.playground.hello."
'''

✔ These keys are automatically generated by Django when you cache views.



🧽 Deleting Cached Content
# Delete a Single Key

'''bash
del your_key_name_here
'''

(Replace with the exact key string.)

# Delete All Keys in Current DB

'''bash
flushall
'''

⚠️ *This clears all data across all databases in Redis.*

To only flush the selected DB (e.g., 'DB 2'), use:
'''bash
flushdb
'''



🧪 Testing It Works

1. Hit a cached endpoint (e.g., '/playground/hello/') in the browser  
2. Check Redis:
   - First request → key is generated
   - After 'flushdb' → cache is cleared  
   - Revisit endpoint → slower response confirms it's uncached again



Codes and Other Notes in this Discussion: 

docker ps

docker exec -it dfeab redis-cli

select 2

keys *  




✅ Summary:

| Command                      | Purpose                                   |
|------------------------------|-------------------------------------------|
| 'docker ps'                 | View running containers                   |
| 'docker exec -it <id> redis-cli' | Enter Redis CLI in Docker container     |
| 'select <db>'              | Switch between Redis databases            |
| 'keys *'                    | List all cache keys in current DB         |
| 'del <key>'                 | Delete a specific cache entry             |
| 'flushdb' / 'flushall'      | Clear current/all Redis DB(s)             |


















Preparing for Production:
-------------------------
Introduction: 

In this section, we'll be talking about the necesssary steps to prepare our application for production. 



Adding the Home Page:
---------------------
🏠 Adding a Home Page to the Django Application

By default, navigating to 'http://localhost:8000/' in our project shows a “Page Not Found” error because we haven’t defined a homepage view. Here’s how to quickly set up a basic homepage using Django's generic views and template structure.



📂 1. Create a URL Configuration for the Core App

📄 File: 'core/urls.py'
'''python
from django.views.generic import TemplateView
from django.urls import path

urlpatterns = [
    path('', TemplateView.as_view(template_name='core/index.html'))
]
'''

✅ Notes:
- Uses 'TemplateView' to render a static template with no business logic.
- Avoids having to create a separate view function or class.




🗂 2. Create the Template Folder and File

Folder structure:

'''
core/
└── templates/
    └── core/
        └── index.html
'''

📄 'index.html'

For now, initialize with a minimal HTML5 structure:
'''html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Home - Storefront</title>
</head>
<body>
  <h1>Welcome to the Storefront</h1>
</body>
</html>
'''

✔ The inner folder 'core/' under 'templates/' provides namespace isolation, preventing conflicts if other apps also contain a 'index.html'.





🔗 3. Register the Core App’s Routes in the Main Router

📄 File: 'storefront/urls.py'

Add this line to the main 'urlpatterns' list:
'''python
path('', include('core.urls')),
'''

This allows root-level ('/') requests to be handled by the 'core' app.

📌 Final 'storefront/urls.py' Snippet
'''python
urlpatterns = [
    path('', include('core.urls')),  # Home page
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
]
'''





🧪 4. Verify in Browser
- Visit: 'http://localhost:8000/'
- ✅ You should see a basic “Welcome to the Storefront” page
- This confirms that the root URL is now mapped correctly





Codes and Other Notes in this Discussion: 

localhost:8000 --> Page not found 


core/urls.py:
from django.views.generic import TemplateView
from django.urls import path

# URLConf
urlpatterns = [
    path('', TemplateView.as_view(template_name='core/index.html'))
]




storefront/urls.py:

urlpatterns = [
    path('', include('core.urls')),
    path('admin/', admin.site.urls),
    path('playground/', include('playground.urls')),
    path('store/', include('store.urls')),
    path('auth/', include('djoser.urls')),
    path('auth/', include('djoser.urls.jwt')),
    path('__debug__/', include(debug_toolbar.urls)),
]





💡 Summary

| Task                          | Action Taken                                  |
|-------------------------------|-----------------------------------------------|
| URL pattern for homepage      | Added 'core/urls.py' with 'TemplateView'      |
| View template                 | Created 'core/templates/core/index.html'      |
| Namespace-safe template       | Namespaced under app to avoid conflicts       |
| Root route mapping            | Included 'core.urls' in 'storefront/urls.py'  |















Adding Static Assets:
---------------------
🖼️ Adding Static Assets in Django to Enhance the Homepage
To make your homepage visually appealing, you can add static assets such as images, CSS, and JavaScript files. These files are served separately from your backend logic and bundled with your Django application.



📁 1. What Are Static Files?
Static files include:
- Images (e.g. logos, icons, banners)
- CSS stylesheets
- JavaScript scripts

In Django, these are stored in a '/static/' directory inside your apps.



🧱 2. Adding Static Assets to the 'core' App
1. Inside the 'core' app, create a directory called:

'''bash
core/static/core/
'''

2. Move your provided assets into this folder:
   - 'logo.svg' (image)
   - 'styles.css' (stylesheet)

Namespacing under 'core/' prevents naming collisions with other apps.



🎨 3. Creating and Configuring the Template
📄 'core/templates/core/index.html'

'''django
{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home</title>

    <!-- Link to the stylesheet -->
    <link rel="stylesheet" href="{% static 'core/styles.css' %}" />
  </head>

  <body>
    <div class="home-page">
      <img src="{% static 'core/logo.svg' %}" alt="Logo" class="logo" />
    </div>
  </body>
</html>
'''

🔎 Highlights:
- '{% load static %}' enables you to reference static files.
- '{% static 'core/styles.css' %}' safely resolves the path to your CSS file.
- The image 'logo.svg' is also loaded using the same static tag.





🧬 4. CSS Styling for the Homepage
📄 'core/static/core/styles.css'
'''css
body {
  margin: 0;
}

.home-page {
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #1ec8aa;
  height: 100vh;
  width: 100vw;
}

.logo {
  width: 300px;
}

.thumbnail {
  object-fit: cover;
  width: 100px;
  height: 100px;
}
'''

✔ The '.home-page' container uses Flexbox to center the logo both vertically and horizontally.  
✔ The '.logo' class controls the image width.





🔍 5. Final Folder Structure
'''
core/
│
├── static/
│   └── core/
│       ├── styles.css
│       └── logo.svg
│
└── templates/
    └── core/
        └── index.html
'''





✅ Result
After refreshing 'http://localhost:8000/':

- You’ll see a centered logo on a teal background.
- The page now has a clean, styled appearance thanks to CSS and proper static file loading.




Codes and Other Notes in this Discussion: 

core/static/styles.css:

body { 
  margin: 0;
}

.home-page { 
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #1ec8aa;
  height: 100vh;
  width: 100vw;
}

.logo {
  width: 300px;
}

.thumbnail {
  object-fit: cover;
  width: 100px;
  height: 100px;
}


core/templates/core/index.html:

{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'core/styles.css' %}" />
  </head>
  <body>
    <div class="home-page">
      <img src="{% static 'core/logo.svg' %}" alt="Logo" class="logo" />
    </div>
  </body>
</html>
















Collecting Static Assets:
-------------------------
📦 Collecting Static Assets in Django (for Production Readiness)
While static files like CSS and images "just work" during development, it’s important to understand how Django handles them, especially when preparing for production. Here's a breakdown of how static asset management works and what you need to configure.



🔍 What Happens in Development Mode

When 'DEBUG = True', Django:
- Searches each app for a '/static/' directory.
- Serves static files automatically using the development server.
- Combines static content from all apps into a single virtual namespace.

🎩 This makes it feel like everything works "magically"—but only while developing.




🚫 Why This Doesn’t Work in Production

In production:
- Django doesn’t serve static files by itself.
- Static content needs to be gathered into a central folder (e.g. '/static/') that’s served by your web server (like Nginx).
- For this, Django provides the 'collectstatic' command.




⚙️ Step-by-Step Setup

1. Configure Static & Media Settings

📄 'storefront/settings.py'
'''python
# Static assets (CSS, JS, images)
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')  # Where collectstatic dumps files

# Media files (user uploads)
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
'''

| Setting       | Purpose                                      |
|---------------|----------------------------------------------|
| 'STATIC_URL'  | Public URL to serve static assets            |
| 'STATIC_ROOT' | Physical directory to gather static files    |
| 'MEDIA_URL'   | Public URL for media content                 |
| 'MEDIA_ROOT'  | Folder to store user uploads                 |





2. Run 'collectstatic'

In your terminal:
'''bash
python manage.py collectstatic
'''

- This command scans all installed apps and copies static files into 'STATIC_ROOT'.
- Output:
  '''
  233 static files copied to /your/project/path/static/
  '''

📁 Now you’ll find a central 'static/' directory containing:
- Assets from Django admin
- CSS/images from your apps (e.g. 'core/static/core/')
- Other shared assets




🧠 Important Notes

- If you forget to include an app in 'INSTALLED_APPS', its static files will NOT be collected.
- Each time you deploy to production, you must re-run 'collectstatic'.
- You can serve the 'STATIC_ROOT' directory via Nginx, Apache, or a CDN.



🔒 Optional: Exclude Static Folder from Git
Since static files are generated automatically, you typically don’t commit them to version control.

📄 '.gitignore' entry:
'''
/static/
'''

✔ Prevents cluttering your repository with build artifacts  
✔ Keeps your codebase clean and lean



Codes and Other Notes in this Discussion: 

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')


python manage.py collectstatic --> all static files will be collected in the separate folder 'static'







✅ Summary

| Task                       | Outcome                                     |
|----------------------------|---------------------------------------------|
| Define 'STATIC_ROOT'       | Tells Django where to collect assets        |
| Run 'collectstatic'        | Gathers static files from every app         |
| Serve static manually      | Done by your production web server (e.g. Nginx) |
| Add to '.gitignore'        | Avoid tracking generated files              |













Serving Static Assets:
----------------------
🗃️ Serving Static Assets in Production with WhiteNoise
By default, Django does not serve static files (e.g., CSS, images, JS) in production for performance and security reasons. To enable static file serving without relying on a separate web server like Nginx, Django can be extended with a lightweight package called WhiteNoise.



🔧 Why WhiteNoise?
WhiteNoise allows Django to efficiently serve its own static files directly. It’s especially useful for:
- Simple deployments (e.g., Heroku, single-server setups)
- Avoiding additional reverse proxy configurations



🧰 Step-by-Step Setup
1. Install WhiteNoise

Use Pipenv to add it as a dependency:
'''bash
pipenv install whitenoise
'''



2. Update Django Middleware

Modify your 'MIDDLEWARE' list in 'settings.py' to include:
'''python
'whitenoise.middleware.WhiteNoiseMiddleware',
'''

🔍 Placement Matters:
- It must come after ''django.middleware.security.SecurityMiddleware''
- It should appear as high as possible in the list to intercept static requests early

📄 Final Example:
'''python
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
'''

✅ Now Django is capable of serving static assets directly in production using WhiteNoise.



🧪 Test it:
1. Run 'python manage.py collectstatic' to gather static files in the 'STATIC_ROOT' directory.
2. Deploy and ensure requests for static files (e.g., CSS, images) return correctly in your production environment.



Codes and Other Notes in this Discussion:

pipenv install whitenoise 

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]



















Configuring Logging:
--------------------
🧾 Configuring Logging in Django
Logging is a critical aspect of application monitoring and debugging—especially in production environments. By capturing and writing log messages, you can troubleshoot issues, track performance, and maintain operational visibility.



⚙️ 1. Purpose of Django Logging
- Capture application activity and errors
- Output logs to console, files, or external systems
- Enable dynamic control over log visibility using severity levels
- Customize log formats for clarity and auditing





📁 2. Django Logging Structure
Logging is configured in the 'settings.py' file via a dictionary assigned to the 'LOGGING' variable.

'''python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    ...
}
'''


🔍 Required Root Keys
| Key                        | Purpose                                                                 |
|----------------------------|-------------------------------------------------------------------------|
| 'version'                  | Schema version (always set to '1')                                     |
| 'disable_existing_loggers'| Keep Django and third-party loggers active ('False' is best practice)  |





📦 3. Defining Log Handlers

Handlers specify where to send log messages (e.g., console or file).

'''python
'handlers': {
    'console': {
        'class': 'logging.StreamHandler'
    },
    'file': {
        'class': 'logging.FileHandler',
        'filename': 'general.log',
        'formatter': 'verbose'
    }
}
'''

✔ Common Handlers:
- 'StreamHandler': Writes to the terminal (stdout)
- 'FileHandler': Writes logs to a file (e.g., 'general.log')





📣 4. Declaring Loggers

Loggers determine which parts of your app generate logs, and which handlers and levels to apply.

'''python
'loggers': {
    '': {
        'handlers': ['console', 'file'],
        'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO')
    }
}
'''

🔎 Notes:
- The empty string '''' captures all log messages project-wide
- You can also define specific loggers for:
  - An app (''playground'')
  - A module (''playground.views'')

🧠 Tip:
Log levels (in increasing severity) are:
'''
DEBUG < INFO < WARNING < ERROR < CRITICAL
'''

Using environment variables allows flexible control:

'''python
'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO')
'''





🖋️ 5. Adding Formatters

Formatters define how log messages appear (e.g. timestamp, level, origin, content).

'''python
'formatters': {
    'verbose': {
        'format': '{asctime} ({levelname}) - {name} - {message}',
        'style': '{'
    }
}
'''

🔤 Log Record Attributes Used:
- '{asctime}': Timestamp of the log entry
- '{levelname}': Severity level (INFO, ERROR, etc.)
- '{name}': Logger or module name
- '{message}': Actual log content

🔧 Style Options:
- '{' = uses 'str.format()'
- '$' = uses 'string.Template'



🧪 Example: Full Logging Configuration
'''python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,

    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'general.log',
            'formatter': 'verbose',
        },
    },

    'loggers': {
        '': {
            'handlers': ['console', 'file'],
            'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO'),
        }
    },

    'formatters': {
        'verbose': {
            'format': '{asctime} ({levelname}) - {name} - {message}',
            'style': '{',
        }
    }
}
'''




Codes and Other Notes in this Discussion: 

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler'
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'general.log',
            'formatter': 'verbose'
        }
    },
    'loggers': {
        '': {
            'handlers': ['console', 'file'],
            'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO')
        }
    },
    'formatters': {
        'verbose': {
            'format': '{asctime} ({levelname}) - {name} - {message}',
            'style': '{' 
        }
    }
}




✅ Key Takeaways

| Concept            | Summary                                                  |
|--------------------|----------------------------------------------------------|
| 'handlers'         | Control output destinations (console, file, etc.)        |
| 'loggers'          | Define what parts of the app generate logs               |
| 'formatters'       | Customize appearance of logs                             |
| Environment control| Read log level dynamically from 'DJANGO_LOG_LEVEL'       |
| 'collectstatic'    | Log messages can help debug problems in deployment       |



















Logging: 
--------
📝 Logging in Django Views: Writing and Testing Log Messages:
After configuring your logging system, you can start emitting log messages from different parts of your application. This section demonstrates how to use Django’s built-in logging infrastructure inside views to track events and handle errors.



🧩 1. Setting Up Logging in the View
📁 'playground/views.py'

Start by importing Python’s built-in logging module:

'''python
import logging
'''

Then, initialize a logger instance scoped to the module:

'''python
logger = logging.getLogger(__name__)
'''

'__name__' evaluates to ''playground.views'', which will match any specific logger name in your logging config.  
Using '__name__' is recommended because it adapts if you refactor or rename the file.





🧪 2. Writing Log Statements in the View

Here’s an example of logging around an external API call:

'''python
from rest_framework.views import APIView
from django.shortcuts import render
import logging, requests

logger = logging.getLogger(__name__)

class HelloView(APIView):
    def get(self, request):
        try:
            logger.info("Calling httpbin")
            response = requests.get('https://httpbin.org/delay/2')  # Simulated delay
            logger.info("Received the response")
            data = response.json()
        except requests.ConnectionError:
            logger.critical("httpbin is offline")

        return render(request, 'hello.html', {'name': 'Mosh'})
'''

🧠 Log Levels:
- 'logger.debug(...)' – for development insight
- 'logger.info(...)' – useful for normal operation messages
- 'logger.warning(...)' – for unexpected conditions
- 'logger.error(...)' – for handling errors
- 'logger.critical(...)' – for application failure or external outages





📝 3. Console Output vs File Output:
- In the terminal, you'll see messages logged via the console handler.
- To see structured logs with formatting (timestamp, severity, origin), ensure your file handler uses a formatter.

📄 Example snippet from settings:
'''python
'file': {
    'class': 'logging.FileHandler',
    'filename': 'general.log',
    'formatter': 'verbose'
}
'''

Then inside 'general.log':

'''
2025-06-23 22:45:10,123 (INFO) - playground.views - Calling httpbin
2025-06-23 22:45:12,457 (INFO) - playground.views - Received the response
'''

💡 This structure is controlled by the formatter in the logging config.





🔐 4. Logging Best Practices:
| Practice                                     | Reason |
|----------------------------------------------|--------|
| Don’t overuse log statements                 | Keep code maintainable and readable |
| Avoid logging sensitive data                 | Logs are plaintext and may expose PII (e.g., credit cards, SSNs) |
| Use structured formatting                    | Helps diagnose issues by including timestamps, levels, and source modules |
| Use environment variables for log levels     | Adjust verbosity in dev vs prod without code changes |


Example:
'''python
'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO')
'''



🧹 5. Managing the Log File:
Since logs are dynamic and don't belong in version control, add the log file to your '.gitignore':

📄 '.gitignore'

'''
general.log
'''




Codes and Other Notes in this Discussion:

playground/views.py:

from django.core.cache import cache
from django.shortcuts import render
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from rest_framework.views import APIView
import logging
import requests

logger = logging.getLogger(__name__) 

class HelloView(APIView):
    def get(self, request):
        try:
            logger.info('Calling httpbin')
            response = requests.get('https://httpbin.org/delay/2')
            logger.info('Received the response')
            data = response.json()
        except requests.ConnectionError:
            logger.critical('httpbin is offline')
        return render(request, 'hello.html', {'name': 'Mosh'})











 ✅ Summary

| Step                       | Description                                  |
|----------------------------|----------------------------------------------|
| 'getLogger(__name__)'      | Creates a module-specific logger             |
| Log calls ('info', 'critical') | Writes events with contextual metadata     |
| Logs stored in 'general.log'   | File contains formatted records             |
| Environment-based levels   | Customize what messages are captured         |
| Avoid sensitive data       | Treat logs as public                         |

















Managing Development and Production Settings:
---------------------------------------------
⚙️ Managing Development and Production Settings in Django
A well-structured Django project separates development and production settings to maintain security, reduce configuration errors, and simplify deployment.



🧱 1. Why Separate Settings?
- Development settings are lenient (e.g. 'DEBUG=True', local DB, hardcoded keys).
- Production settings require security best practices (e.g. 'SECRET_KEY' in env vars, 'DEBUG=False', restrictive 'ALLOWED_HOSTS').
- Never expose production secrets in source-controlled files.




🗂 2. Restructure the Settings Module
Create a modular settings layout:
'''
storefront/
│
└── settings/
    ├── __init__.py
    ├── common.py      # Shared across environments
    ├── dev.py         # Dev-specific settings
    └── prod.py        # Production-specific settings
'''




🧩 3. Define Environment-Specific Settings

📄 'dev.py'

'''python
from .common import *

DEBUG = True

SECRET_KEY = 'your-dev-secret'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'MyPassword'
    }
}
'''



📄 'prod.py'

'''python
import os
from .common import *

DEBUG = False

SECRET_KEY = os.environ['SECRET_KEY']
ALLOWED_HOSTS = ['your-production-domain.com']  # To be defined later
'''



📌 4. Move Critical Settings from 'common.py'

In 'common.py', retain only environment-agnostic configurations:

- 'INSTALLED_APPS'
- 'MIDDLEWARE'
- 'TEMPLATES'
- Logging, Caches, Internationalization
- Static and media configuration

Remove or relocate:
- 'DEBUG'
- 'SECRET_KEY'
- 'ALLOWED_HOSTS'
- 'DATABASES'



⚠️ 5. Correct the Project Base Path
In 'common.py', correct 'BASE_DIR' to reflect the new folder hierarchy:

'''python
BASE_DIR = Path(__file__).resolve().parent.parent.parent
'''

This ensures static/media paths resolve correctly despite moving files into the 'settings/' directory.



🔁 6. Update All Environment References

Anywhere you reference settings via environment variables ('DJANGO_SETTINGS_MODULE'), update them to point to the dev or prod files:

✅ References to update:

| File         | Update to                             |
|--------------|----------------------------------------|
| 'manage.py'  | ''storefront.settings.dev''            |
| 'pytest.ini' | 'DJANGO_SETTINGS_MODULE=storefront.settings.dev' |
| 'asgi.py'    | 'storefront.settings.dev'              |
| 'wsgi.py'    | 'storefront.settings.dev'              |
| 'celery.py'  | 'storefront.settings.dev'              |




🧪 7. Verify Application Functionality

Run Dev Server:

'''bash
python manage.py runserver
'''

Check:  
✅ App loads correctly at 'http://localhost:8000/store/collections/'



🧪 Run Tests:
'''bash
pytest
'''

⚠ Warning: Missing Static Directory
WhiteNoise may raise a warning if the static root path is misconfigured. Ensure the static directory is correctly defined in your project root and that 'STATIC_ROOT' is resolved relative to 'BASE_DIR'.



👮 8. Don’t Commit Secrets or Artifacts

Add sensitive and generated files to '.gitignore':

'''gitignore
/static/
*.log
.env
'''




Codes and Other Notes in this Discussion: 


settings/
   common.py
   dev.py
   prod.py
   

   
dev.py:

from .common import *

DEBUG = True

SECRET_KEY = 'django-insecure-hs6j037urx6iav+7#10%-vu4l4f5@@-1_zo)oft4g7$vf2$jmp'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'MyPassword'
    }
}



prod.py:

import os
from .common import *

DEBUG = False

SECRET_KEY = os.environ['SECRET_KEY']

ALLOWED_HOSTS = []



Changing the references of 'DJANGO_SETTINGS_MODULE' in our project:

in manage.py:
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')


in pytest.ini:

[pytest]
DJANGO_SETTINGS_MODULE=storefront.settings.dev



in asgi.py:
import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')

application = get_asgi_application()



in celery.py:
import os 
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')

celery = Celery('storefront')
celery.config_from_object('django.conf:settings', namespace='CELERY')
celery.autodiscover_tasks()



in wsgi.py:
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')

application = get_wsgi_application()




Note: 
in common.py:
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent






✅ Summary

| Task                              | Purpose                                                       |
|-----------------------------------|---------------------------------------------------------------|
| Isolate environment-specific configs | Simplifies deployment and increases security               |
| Use env vars for production secrets | Prevents credential leakage                                 |
| Modify project path references     | Ensures correct loading of modules and static files         |
| Update settings references         | Align 'DJANGO_SETTINGS_MODULE' across app components        |
| Commit only the common and public configs | Keeps secrets and temp files out of version control    |




















Serving the Application with Gunicorn:
--------------------------------------
🚀 Serving the Django Application with Gunicorn:
Django’s built-in development server ('runserver') is great for local development—it auto-reloads with code changes, making iteration easy. However, this server is not suitable for production due to performance and reliability limitations.

To serve your Django app in production, use Gunicorn (short for *Green Unicorn*), a high-performance WSGI HTTP server.



🧰 1. Install Gunicorn:
Use Pipenv to add it as a project dependency:

'''bash
pipenv install gunicorn
'''



🔌 2. Understand the WSGI Interface:
WSGI (Web Server Gateway Interface) is the standard interface between web servers (like Gunicorn) and Python web applications (like Django).

📄 Your Django project includes a WSGI module:

'''
storefront/wsgi.py
'''

This file:

- Loads the environment variable 'DJANGO_SETTINGS_MODULE', e.g., ''storefront.settings.dev''
- Calls Django’s 'get_wsgi_application()' to return the application instance

'''python
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')
application = get_wsgi_application()
'''



🏁 3. Running the App with Gunicorn:
From your project root, start the application with:

'''bash
gunicorn storefront.wsgi
'''

This command:
- Loads the 'wsgi.py' module from the 'storefront' package
- Starts serving the app at 'http://127.0.0.1:8000/' (by default)

✔ The homepage should now load, just like with Django’s dev server—but with better production-grade performance.




⚠️ 4. Key Differences in Production Behavior

| Feature                   | Django Dev Server     | Gunicorn (Production)      |
|---------------------------|------------------------|-----------------------------|
| Auto-reload on file save  | ✅ Yes                  | ❌ No (requires manual restart) |
| Debug stack trace         | ✅ Verbose              | ❌ Hidden (DEBUG=False)      |
| Performance               | 🚫 Not optimized        | ✅ High-performance WSGI     |
| Static file serving       | ✅ Built-in             | ❌ Must use WhiteNoise or external server |

# 🧠 Note:
In production, any code change requires manually restarting Gunicorn:
'''bash
pkill gunicorn  # or CTRL+C
gunicorn storefront.wsgi
'''





Codes and Other Notes in this Discussion: 

pipenv install gunicorn 


in the terminal:
# to start our application with gunicorn
gunicorn storefront.wsgi




✅ Summary

| Step                         | Action                           |
|------------------------------|----------------------------------|
| Install Gunicorn             | 'pipenv install gunicorn'        |
| Understand WSGI              | Used as interface for app serving |
| Run server                   | 'gunicorn storefront.wsgi'       |
| Use only in production       | In dev, use 'python manage.py runserver' |























Deployment:

Introduction:
In this section, we'll talk about deploying our application. So, by end of the section, we'll have a live backend running in the cloud.  



Hosting Options:
----------------
🌐 Hosting Options for Deploying Django Applications
When it's time to deploy your Django application, you generally have two categories of hosting to choose from:



🚀 1. Virtual Private Server (VPS)
A VPS is essentially a virtual machine hosted on a physical server.

✅ Pros:
- Often less expensive
- Full control over the server environment
- Suitable for custom configurations

⚠️ Cons:
- Requires in-depth knowledge of system administration
- You must manually install:
  - The web server (e.g., Nginx)
  - WSGI server (e.g., Gunicorn)
  - Database and SSL certificates
- Time-consuming and error-prone

Recommendation: Use VPS only if you're already comfortable with Linux server administration and automation tools like Ansible or Docker.




☁️ 2. Platform-as-a-Service (PaaS)

A PaaS provides infrastructure, deployment automation, and scalability without having to manage the server manually.

✨ Common PaaS Options:
| Provider                    | Description                                                                 |
|-----------------------------|------------------------------------------------------------------------------|
| Heroku                      | Beginner-friendly, elegant CLI, strong Django support, well-documented       |
| DigitalOcean App Platform   | Supports Dockerized deployments, better suited for DevOps-literate users |
| Microsoft Azure App Service | Integrates well with Microsoft ecosystem, powerful but complex |
| Google App Engine           | Scalable infrastructure with built-in load balancing and monitoring     |

✅ Pros:
- Minimal setup and configuration
- Handles provisioning, scaling, and monitoring
- Easier integrations with CI/CD workflows

⚠️ Cons:
- Slightly more expensive than VPS
- Less flexibility for advanced server-level customization



👉 What We’re Using in This Course: Heroku
- Simple to use
- Great documentation and support
- Ideal for beginners and small-to-medium projects

Note: There’s no official affiliation with Heroku; it's simply chosen here for clarity and ease of use.



🔐 Next Step: Source Control Setup
Before deploying to Heroku (or any PaaS), the first step is to add your project to version control, typically via Git. We'll cover that in the upcoming section.




Codes and Other Notes in this Discussion:
Virtual Private Server(VPS)
Platform-as-a-Service(PaaS)
  - Heroku
  - Digital Ocean 
  - MS Azure 
  - Google Cloud 
  
  
  
  











Adding Project to Git:
---------------------- 
🗂️ Adding a Django Project to Git Version Control
Version control is essential for managing code history, collaborating with others, and rolling back changes when necessary. Git is the most widely used version control system today, and it's a must-have skill in any developer's toolkit.



🧰 Prerequisites
1. Make sure Git is installed on your machine.  
   If not, download it from [https://git-scm.com](https://git-scm.com) and follow the installation instructions.

2. Open your project in Visual Studio Code (VS Code) or your preferred terminal.


✅ Step-by-Step: Initialize Git Repository

1. Initialize Git
'''bash
git init
'''

- This creates a '.git/' folder in your project—Git now begins tracking your project.



2. Stage Files for Commit

'''bash
git add .
'''

- Adds all modified and untracked files to the staging area.
- The staging area holds your changes temporarily before committing them.



3. Create Your First Commit

'''bash
git commit -m "Initial commit"
'''

- Commits the staged files to your Git repository.
- '"Initial commit"' is a conventional message for first-time commits.



📜 View Commit History

Use this command to view a compact list of commits:

'''bash
git log --oneline
'''

You’ll see something like:

'''
3a1f2ab Initial commit
91e4a19 Add login form and CSS
e67a2cc Implement product serializer
'''

Press 'q' to exit the log viewer.





📦 What Is a Git Commit?
A commit is a "snapshot" of your project at a specific moment in time.  
With each commit, Git tracks:
- What changed
- When it changed
- Who made the change (if configured)
- A short message describing the change





🧠 Why This Matters
- You can roll back to any previous commit if you break something
- You can see when (and why) a change was made
- Enables collaborative workflows using GitHub, GitLab, Bitbucket, etc.



Codes and Other Notes in this Discussion: 

git init 
git add . 
git commit -m "Initial Commit"

git log --oneline 




✅ Summary:

| Git Command                 | Purpose                               |
|-----------------------------|----------------------------------------|
| 'git init'                  | Initialize Git in the project folder   |
| 'git add .'                 | Stage all files for commit             |
| 'git commit -m "message"'   | Save a snapshot of the project         |
| 'git log --oneline'         | View commit history in short format    |











Getting Started with Heroku:
----------------------------

🚀 Getting Started with Heroku Deployment
To deploy your Django application to Heroku, a beginner-friendly Platform-as-a-Service (PaaS), you'll need to perform some initial setup tasks. Here’s a detailed walkthrough of every step to get up and running.



📝 1. Create a Free Heroku Account
- Visit [https://heroku.com](https://heroku.com)
- Sign up using your email and password (takes ~1 minute)
- ✅ Required for pushing your Django app to the cloud




🧰 2. Install the Heroku CLI (Command Line Interface)
The Heroku CLI lets you manage and deploy applications directly from your terminal.

🔗 Download Instructions:
- Visit: [Heroku CLI Installation Docs](https://devcenter.heroku.com/articles/heroku-cli)
- Choose the appropriate installer for your OS (Windows, macOS, or Linux)
- Follow the installation guide—it only takes a few minutes




🧪 3. Verify the CLI Installation
Open your terminal (e.g., inside VS Code) and run:

'''bash
heroku --version
'''

Example output:

'''
heroku/8.0.3 linux-x64 node-v18.15.0
'''

✔ If you see this, the CLI was installed successfully  
❗ If there’s an error, search online or visit the [Heroku CLI Troubleshooting Guide](https://devcenter.heroku.com/articles/heroku-cli#troubleshooting)




🔐 4. Log Into Heroku
Run the following command in the terminal:

'''bash
heroku login
'''

- Press any key when prompted
- A browser window will open—log into your Heroku account
- Once logged in, close the browser tab and return to the terminal

You should see confirmation like:

'''
Logged in as your-email@example.com
'''




✅ Summary

| Step            | Task                                           |
|------------------|------------------------------------------------|
| 1.Sign Up       | Create a free account at Heroku.com            |
| 2.Install CLI   | Download and install Heroku CLI                |
| 3.Verify CLI    | Run 'heroku --version'                        |
| 4.Authenticate  | Use 'heroku login' to log in via browser       |
















Creating a Heroku App:
----------------------
☁️ Creating a Heroku App and Linking It to Your Django Project
Once you've installed and logged into the Heroku CLI, you’re ready to create and configure your Heroku app. Here's a detailed and organized breakdown of the steps involved.



🛠️ Step 1: Create a New Heroku App
From the terminal, run the following command:

'''bash
heroku create moshbuy-prod
'''

🔍 What Happens:
1. A new Heroku app is created at:  
   'https://moshbuy-prod.herokuapp.com'  
   → This is the production domain where your app will be hosted.

2. A remote Git repository is created at:  
   'https://git.heroku.com/moshbuy-prod.git'  
   → This acts as the deployment target.

You now have two Git repositories:
- A local Git repo on your machine
- A remote Git repo on Heroku's infrastructure

🧠 Why Two Repositories?
Heroku monitors its Git repo. When you push code to it, Heroku:
- Pulls the latest commit
- Builds the app (runs dependencies, collects static files, etc.)
- Deploys the build to the live domain



🔐 Step 2: Update Production Settings
Heroku needs to recognize its domain as allowed. Open your 'settings/prod.py' and add the domain to 'ALLOWED_HOSTS':

'''python
ALLOWED_HOSTS = ['moshbuy-prod.herokuapp.com']
'''

✅ Do not prefix with 'http://' or 'https://', and do not add a trailing slash.

This setting ensures that Django won’t block requests to your app's public URL.




Codes and Other Notes in this Discussion: 

heroku create moshbuy-prod 


settings/prod.py:

ALLOWED_HOSTS = ['moshbuy-prod.herokuapp.com']






✅ Summary

| Task                              | Command / Change                                             |
|-----------------------------------|---------------------------------------------------------------|
| Create Heroku App                 | 'heroku create <unique-name>'                                |
| App URL                           | e.g. 'https://moshbuy-prod.herokuapp.com'                     |
| Heroku Git Repo                   | e.g. 'git@heroku.com:moshbuy-prod.git'                        |
| Add Domain to 'ALLOWED_HOSTS'     | 'ALLOWED_HOSTS = ['moshbuy-prod.herokuapp.com']'              |
















Setting Environment Variables:
------------------------------

🔐 Setting Environment Variables in Heroku for Django Production
In production, it's critical to protect sensitive data such as the 'SECRET_KEY' and correctly configure your environment for security and deployment behavior. Heroku provides a simple way to set environment variables through the CLI.


⚠️ Why Set Environment Variables?
In your 'settings/prod.py', you likely have:

'''python
SECRET_KEY = os.environ['SECRET_KEY']
'''

and

'''python
DJANGO_SETTINGS_MODULE = os.environ.get('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')
'''

- The 'SECRET_KEY' must be kept secret and should never be hardcoded into your codebase.
- The 'DJANGO_SETTINGS_MODULE' ensures that Django uses the correct configuration file when deploying.




🧪 Step 1: Generate a Django Secret Key

Use a secure tool such as [djecrety.ir](https://djecrety.ir) to generate a cryptographically strong Django secret key.

- Simply visit the site and click Generate.
- It will automatically copy the key to your clipboard.





🧰 Step 2: Set the Secret Key in Heroku

In your terminal:

'''bash
heroku config:set SECRET_KEY='your-copied-secret-key'
'''

⚠️ Remember to wrap the key in single quotes ''...'', especially if it contains special characters.





🧾 Step 3: Set the DJANGO_SETTINGS_MODULE Variable

Heroku doesn’t know which settings file to use unless you explicitly tell it. Set the module to your production settings file:

'''bash
heroku config:set DJANGO_SETTINGS_MODULE=storefront.settings.prod
'''

📌 Be very careful with spelling here ('DJANGO_SETTINGS_MODULE') — Heroku will not raise a warning if it's incorrect, but your app will fail to start.


📂 Code Reference: 'wsgi.py'

This file provides a default fallback for local development:

'''python
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'storefront.settings.dev')
'''

In production, Heroku overrides this using the environment variable you just set.




Codes and Other Notes in this Discussion: 

Djecrety (Django Secret Key Generator)


heroku config:set SECRET_KEY='' 

heroku config:set DJANGO_SETTINGS_MODULE=storefront.settings.prod 




✅ Summary

| Variable Name             | Value                               | Purpose                                |
|---------------------------|--------------------------------------|----------------------------------------|
| 'SECRET_KEY'              | ''randomly-generated-key''          | Keeps cryptographic operations secure  |
| 'DJANGO_SETTINGS_MODULE'  | ''storefront.settings.prod''        | Loads production Django settings       |



You're now ready to move on to creating a Procfile, which tells Heroku how to launch your Django application in production.














Creating a Procfile:
--------------------

📦 Creating a Procfile for Heroku Deployment
The Procfile is a special configuration file used by Heroku to determine how to run your application and its background processes. Without it, Heroku won't know how to start your Django app properly.



🧾 Step-by-Step: Creating the Procfile

📍 1. File Location & Naming
- Create the file in your project root directory
- Name it exactly: 'Procfile'  
  - Capital "P", all other letters lowercase  
  - No file extension (e.g., '.txt' ❌)

'''
storefront/
├── manage.py
├── storefront/
├── requirements.txt
└── Procfile   ✅
'''




📝 2. Define Processes

Open the 'Procfile' and add the following lines:

'''bash
release: python manage.py migrate
web: gunicorn storefront.wsgi
worker: celery -A storefront worker
'''

🔍 Explanation:

| Process Type | Command                       | Description |
|--------------|-------------------------------|-------------|
| 'release'    | 'python manage.py migrate'    | Runs database migrations automatically during deployments (optional, but common) |
| 'web'        | 'gunicorn storefront.wsgi'    | Starts the main web application using Gunicorn (production-ready WSGI server) |
| 'worker'     | 'celery -A storefront worker' | Launches a Celery worker for background task processing |



⚠️ Notes:
- If you prefer running migrations manually, remove or comment out the 'release:' line. Later, you can run them via:
  '''bash
  heroku run python manage.py migrate
  '''
- Ensure 'gunicorn' and 'celery' are listed in your 'Pipfile' or 'requirements.txt'.



✅ Final Output

'''Procfile
release: python manage.py migrate
web: gunicorn storefront.wsgi
worker: celery -A storefront worker
'''



With this setup, Heroku will:
- Run your migrations each time you deploy ('release')
- Serve your app through Gunicorn ('web')
- Start a Celery worker for asynchronous tasks ('worker')

Next up: configuring your database and add-ons like Heroku Postgres 🔧📊. Let me know if you’d like to visualize the app architecture too.



Codes and Other Notes in this Discussion: 

Procfile: 

release: python manage.py migrate
web: gunicorn storefront.wsgi
worker: celery -A storefront worker















Provisioning a MySQL Database: 
------------------------------
🗄️ Provisioning a MySQL Database on Heroku with ClearDB
To run your Django app in production on Heroku, you need to connect it to a database. While Django typically runs with PostgreSQL on Heroku, you can also provision a MySQL database using the ClearDB add-on.



🧰 Step 1: Add the ClearDB MySQL Add-on
🔗 Navigate to Your Heroku Dashboard

1. Go to [Heroku Dashboard](https://dashboard.heroku.com/)
2. Open your app (e.g. 'moshbuy-prod')
3. Click “Configure Add-ons” in the Resources tab


🔍 Search for MySQL Provider
- Type 'Clear MySQL' in the add-on search box  
- Select ClearDB MySQL

💡 You can also browse Heroku add-ons by category (e.g. logging, databases) to explore more options.
🆓 Choose a Plan

- Select the Ignite plan (free tier; suitable for testing only)
- Click Submit Order Form





🧪 Step 2: Retrieve & Clean the Connection URL

After ClearDB is added, run:
'''bash
heroku config
'''

Look for this environment variable:
'''plaintext
CLEARDB_DATABASE_URL=mysql://username:password@host/dbname?reconnect=true
'''

❌ The '?reconnect=true' suffix is Rails-specific and not compatible with Django.
✅ Create a Proper Connection Variable


Strip everything after the database name. Example:
'''bash
heroku config:set DATABASE_URL='mysql://username:password@host/dbname'
'''

Now 'DATABASE_URL' is a clean connection string Django can understand.



📦 Step 3: Install and Configure 'dj-database-url'

This package converts the 'DATABASE_URL' environment variable into Django’s database dictionary format.

'''bash
pipenv install dj-database-url
'''



🛠 Step 4: Update Production Database Settings

In your 'settings/prod.py', add:
'''python
import dj_database_url

DATABASES = {
    'default': dj_database_url.config()
}
'''

✔️ This instructs Django to:
- Look for the 'DATABASE_URL' environment variable
- Parse it
- Automatically configure your database connection

> Do NOT hardcode user, password, or host in production.



🔍 Reference: Development vs. Production

# 📄 'settings/dev.py'

'''python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'MyPassword'
    }
}
'''

# 📄 'settings/prod.py'

'''python
import dj_database_url

DATABASES = {
    'default': dj_database_url.config()
}
'''




Codes and Other Notes in this Discussion: 

pipenv install dj-database-url 


dev.py:
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'localhost',
        'USER': 'root',
        'PASSWORD': 'MyPassword'
    }
}



prod.py:

DATABASES = {
    'default': dj_database_url.config()
}





✅ Summary

| Task                     | Action                                                  |
|--------------------------|----------------------------------------------------------|
| Add DB Add-on            | 'ClearDB MySQL' via Heroku Resources tab                |
| Clean the URL            | Strip '?reconnect=true' from 'CLEARDB_DATABASE_URL'     |
| Set final var            | 'heroku config:set DATABASE_URL='...''                 |
| Install helper           | 'pipenv install dj-database-url'                        |
| Use dynamic config       | 'dj_database_url.config()' in 'prod.py'                 |













Provisioning a Redis Instance:
------------------------------
📦 Provisioning a Redis Instance on Heroku for Django
Redis is commonly used in Django applications for:
- Celery: acting as a message broker for background task queues
- Caching: improving performance by reducing database and API calls



🧱 Redis Usage in Development
In development ('settings/dev.py'), Redis is used via two separate databases:

'''python
# Celery message broker
CELERY_BROKER_URL = 'redis://localhost:6379/1'

# Django cache backend
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/2',
        'TIMEOUT': 10 * 60,  # 10 minutes
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
'''

Redis databases are simple key-value stores (not relational), so using the same one for both tasks is fine in production.



☁️ Provisioning Redis on Heroku
🔍 Step 1: Add Heroku Redis Add-on

1. Go to your app’s dashboard on [Heroku](https://dashboard.heroku.com)
2. Navigate to the Resources tab
3. Click “Configure Add-ons”
4. Search for 'Heroku Redis'
5. Select the Free plan (good for testing; paid plans start at $15)
6. Submit the order

🕒 Note
Provisioning the Redis service may take 5–10 minutes.



🔑 Step 2: Access the Redis URL

Once provisioned, run:
'''bash
heroku config
'''

You'll see:
'''
REDIS_URL=redis://h:password@hostname:port
'''

You'll use this URL in production to configure both Celery and Django's cache backend.



🛠️ Step 3: Move Redis-Specific Configurations

To keep environment-specific code clean, move Redis settings out of 'common.py' and place them in:


📄 'settings/dev.py'
'''python
CELERY_BROKER_URL = 'redis://localhost:6379/1'

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/2',
        'TIMEOUT': 10 * 60,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
'''



📄 'settings/prod.py'
'''python
REDIS_URL = os.environ['REDIS_URL']

CELERY_BROKER_URL = REDIS_URL

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': REDIS_URL,
        'TIMEOUT': 10 * 60,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
'''

This allows both Celery and Django to use the same Redis instance while keeping configurations environment-specific.




Codes and Other Notes in this Discussion: 


dev.py:

CELERY_BROKER_URL = 'redis://localhost:6379/1'

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/2',
        'TIMEOUT': 10 * 60,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}




prod.py:

REDIS_URL = os.environ['REDIS_URL']

CELERY_BROKER_URL = REDIS_URL

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': REDIS_URL,
        'TIMEOUT': 10 * 60,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}







✅ Summary

| Task                          | Detail                                                 |
|-------------------------------|--------------------------------------------------------|
| Use cases                     | Celery + Django cache                                  |
| Dev setup                     | Use two separate Redis DBs on localhost                |
| Heroku Redis add-on           | Add via dashboard → Resources → Configure Add-ons      |
| Unified use in production     | Use the same Redis URL for both cache and broker       |
| Config source                 | Extract 'REDIS_URL' from 'heroku config'               |




















Provisioning an SMTP Server:
----------------------------
✉️ Provisioning and Configuring an SMTP Server on Heroku with Mailgun
Sending emails is a common requirement for Django applications—whether for user registration, notifications, or password resets. In this setup, we use Mailgun, a popular SMTP provider, to handle outbound email through Heroku.



🔧 Step 1: Add Mailgun to Your Heroku App
1. Go to your [Heroku Dashboard](https://dashboard.heroku.com/)
2. Select your app (e.g. 'moshbuy-prod')
3. Click the “Configure Add-ons” button under the Resources tab
4. Search for Mailgun
5. Select the Starter plan (free tier)
6. Click Submit Order Form



🔐 Step 2: Retrieve Mailgun Environment Variables
Once Mailgun is provisioned, run:
'''bash
heroku config
'''

You will see environment variables like:
- 'MAILGUN_SMTP_SERVER'
- 'MAILGUN_SMTP_LOGIN'
- 'MAILGUN_SMTP_PASSWORD'
- 'MAILGUN_SMTP_PORT'

These are automatically injected by Heroku and must be read from environment variables in your Django settings.



🛠 Step 3: Move Email Configuration to Environment-Specific Settings

✂️ Clean Up 'common.py'

Remove or comment out this line if it exists:

'''python
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
'''

This is Django’s default and doesn’t need to be explicitly set unless you’re overriding it.



📄 'settings/dev.py' – Development Setup
'''python
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525  # or your local mail server’s port

DEBUG_TOOLBAR_CONFIG = {
    'SHOW_TOOLBAR_CALLBACK': lambda request: True
}


You may also use tools like [MailHog](https://github.com/mailhog/MailHog) for capturing emails locally during development.



📄 'settings/prod.py' – Production Setup with Mailgun
'''python
EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER']
EMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN']
EMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD']
EMAIL_PORT = os.environ['MAILGUN_SMTP_PORT']
'''

✅ These values are pulled securely from Heroku’s environment—no hardcoding required.



🔁 Final Directory Flow
'''text
storefront/
├── settings/
│   ├── common.py       # Shared defaults
│   ├── dev.py          # localhost email config
│   └── prod.py         # Mailgun + env vars from Heroku
'''



Codes and Other Notes in this Disucssion:

dev.py:

EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525

DEBUG_TOOLBAR_CONFIG = {
    'SHOW_TOOLBAR_CALLBACK': lambda request: True
}



prod.py:

EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER']
EMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN']
EMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD']
EMAIL_PORT = os.environ['MAILGUN_SMTP_PORT']




✅ Summary

| Action                        | Details                                                              |
|-------------------------------|----------------------------------------------------------------------|
| Add SMTP provider             | Use Mailgun via Heroku’s Add-ons tab                            |
| Use environment variables     | Read 'MAILGUN_*' configs in production settings                     |
| Separate dev & prod config    | Keeps local testing simple and production secure                    |
| Clean up defaults             | No need to explicitly define 'EMAIL_BACKEND' unless you override it |













Deploying the Application: 
--------------------------
🚀 Deploying a Django Application to Heroku: Step-by-Step
This guide outlines the full deployment process of your Django application to Heroku, including pushing your code, handling build errors, managing database migrations, and launching your production environment.



1. Commit Local Changes to Git
Before deploying, ensure your local changes are committed:

'''bash
git add .
git commit -m "Descriptive commit message"
'''

💡 This saves your latest code snapshot in the Git repository.





🌐 2. Identify Heroku's Remote Git Repository

Run this to confirm the remote repository created by Heroku:

'''bash
git remote -vv
'''

You should see:

'''
heroku  https://git.heroku.com/your-app-name.git (fetch)
heroku  https://git.heroku.com/your-app-name.git (push)
'''





🌿 3. Determine Local Git Branch

Check your current branch:

'''bash
git branch
'''

- Usually it's 'master' or 'main'
- Use this value in the next step





☁️ 4. Deploy to Heroku

'''bash
git push heroku master   # or 'main' depending on your branch name
'''

# 🔧 What Happens:
- Heroku detects Python and installs Python 3.9 and pip
- It installs dependencies from your 'Pipfile'
- Runs 'collectstatic' to collect static assets
- Executes the 'release:' step in your 'Procfile' (e.g., 'python manage.py migrate')





🛑 5. Handle Deployment Failures

If you see an error like:

'''
ModuleNotFoundError: No module named 'silk'
'''

It means 'django-silk' was installed as a development dependency only and not bundled into production.

Fix it:

'''bash
pipenv install django-silk
git add .
git commit -m "Install django-silk for production"
git push heroku master
'''





📦 6. Static Files and Migrations

During deployment:

- Heroku will run 'collectstatic' (from your 'Procfile')
- Then it executes 'python manage.py migrate' to apply DB changes

⚠ If you’re using ClearDB (MySQL):
- Migrations may take time (up to 20 minutes)
- If they timeout or perform poorly, consider switching to PostgreSQL





🛤 7. Switching to PostgreSQL (Optional but Recommended)

1. In Heroku Dashboard, search for and add the Heroku Postgres add-on
2. Run:

'''bash
heroku config
'''

Look for:

'''
HEROKU_POSTGRESQL_NAVY_URL=postgres://...
'''

3. Set it as your primary database connection:

'''bash
heroku config:set DATABASE_URL=postgres://...
'''

Your 'prod.py' already uses:

'''python
import dj_database_url
DATABASES = {
    'default': dj_database_url.config()
}
'''

So the switch is seamless.





🛠️ 8. Inspect Deployed Files (Optional)

You can SSH into your Heroku app's environment:

'''bash
heroku run bash
ls
'''

To exit:

'''bash
exit
'''





👤 9. Create a Django Admin User

'''bash
heroku run python manage.py createsuperuser
'''

- Follow the prompts to enter a username, email, and password






🌍 10. Launch Your Live App

'''bash
heroku open
'''

Visit a specific endpoint to confirm it works:

'''bash
https://your-app.herokuapp.com/store/collections/
'''

✅ If the page loads, your deployment is complete!



Codes and Other Notes in this Discussion: 

git remote -vv 

git branch 

git push heroku master 



heroku run bash 

heroku run python manage.py createsuperuser   


heroku open 



✅ Summary

| Task                              | Command                                          |
|-----------------------------------|--------------------------------------------------|
| Stage & Commit                    | 'git add . && git commit -m "message"'           |
| Deploy to Heroku                  | 'git push heroku master'                         |
| Debug issues                      | Resolve missing packages & push again            |
| PostgreSQL (Optional)             | Replace 'ClearDB' if migrations are slow         |
| Run commands on Heroku            | 'heroku run bash' or 'heroku run <command>'      |
| Create admin user                 | 'heroku run python manage.py createsuperuser'    |
| Open app in browser               | 'heroku open'                                    |









Populating the Database:
------------------------
🧪 Populating the Production Database on Heroku
Once your application is deployed, you'll want to seed the production database with initial data. This can be done either by executing a custom Django management command or by connecting directly via a database client like DataGrip. Here’s a breakdown of both methods.



🗃️ Option 1: Use Django’s Custom Seed Command
📁 Directory Structure

In the 'store' app, there's a custom command set up like this:
'''
store/
├── management/
│   └── commands/
│       └── seed_db.py  # Custom data seeder
'''

▶️ Execute the Seeder via Heroku CLI
To run this command in the production environment:

'''bash
heroku run python manage.py seed_db
'''

✔️ This executes any data seeding logic (like inserting categories, products, etc.) defined inside 'seed_db.py'.

🔄 Validate in Browser

After running the command, visit your live app in the browser:
'''
https://your-app.herokuapp.com/store/collections/
'''

✅ You should now see populated data like collections or product entries.





🧩 Option 2: Connect via DataGrip Using Connection URL

For direct inspection or custom SQL scripts, connect your ClearDB MySQL instance to a SQL client.

🧾 Step-by-Step
1. Run the following to get the MySQL connection string:

   '''bash
   heroku config:get DATABASE_URL
   '''

   Example output:

   '''
   mysql://username:password@host/dbname
   '''

2. Open DataGrip (or another SQL client)

3. Add a New Data Source → MySQL

4. Switch connection type to "URL only"

5. In the JDBC URL box, use:

   '''
   jdbc:mysql://username:password@host/dbname
   '''

   - Make sure the prefix remains 'jdbc:mysql://'
   - Replace all values with the actual connection string from Heroku

6. Test the connection → ✅ OK

7. After connecting, you can:
   - View tables and schema
   - Run custom SQL scripts
   - Inspect or edit data manually





🧠 Why Use Both?

| Method                   | Use Case                                  |
|--------------------------|--------------------------------------------|
| 'seed_db' custom command | Easily seed data via code + CLI integration |
| DataGrip (GUI)           | Deep inspection, query testing, manual edits |




Codes and Other Notes in this Discussion: 

heroku run python manage.py seed_db 




✅ Summary

| Task                        | Command/Action                                |
|-----------------------------|-----------------------------------------------|
| Seed database via CLI       | 'heroku run python manage.py seed_db'         |
| View DB connection string   | 'heroku config:get DATABASE_URL'              |
| Connect via DataGrip        | Use JDBC URL with 'mysql://...' credentials   |















Dockerizing the App:
--------------------

🐳 Dockerizing a Django Application (Local Dev Environment)
Docker allows you to define and run multi-container applications in a consistent environment across all development and deployment machines. Here’s a structured overview of how the application was containerized for development.



⚙️ Why Docker?
Without Docker:
- Developers must manually install and run MySQL, Redis, Celery, etc.
- Environment differences (e.g. MySQL versions) may lead to bugs
- Running services individually is tedious and error-prone

With Docker:
- All dependencies are encapsulated in containers
- Ensures identical environments for development and production
- Simplifies onboarding and scaling



📁 Setup: Docker Files
The 'deployment/docker/' folder contains four essential Docker-related files:

1. 'Dockerfile' – Defines how to build the Django app container
2. 'docker-compose.yml' – Configures services (web, MySQL, Redis, SMTP, Celery, Flower, etc.)
3. '.dockerignore' – Avoids copying unnecessary files into the container
4. 'entrypoint.sh' – Custom startup behavior for the Django container

These files should be moved to the project root.



📦 'docker-compose.yml': Defining Services

This file defines all required services:

| Service      | Purpose                               | Container Name     |
|--------------|----------------------------------------|--------------------|
| 'web'        | Django application server              | 'web'              |
| 'mysql'      | MySQL 8.0 (used as the database)       | 'mysql'            |
| 'redis'      | Redis (broker + cache)                 | 'redis'            |
| 'celery'     | Background task processor              | 'celery'           |
| 'celery-beat'| Periodic task scheduler                | 'celery-beat'      |
| 'flower'     | Celery monitoring dashboard            | 'flower'           |
| 'smtp4dev'   | Email testing server for development   | 'smtp4dev'         |
| 'tests'      | Continuous test runner with 'pytest'   | 'tests'            |

All services are coordinated with defined versioning to avoid surprises.





🛠️ Changes to 'settings/dev.py':

Adjust service hostnames to reflect Docker container names:

'''python
DATABASES = {
    'default': {
        'HOST': 'mysql',
        ...
    }
}

CELERY_BROKER_URL = 'redis://redis:6379/1'

CACHES = {
    'default': {
        'LOCATION': 'redis://redis:6379/2',
        ...
    }
}

EMAIL_HOST = 'smtp4dev'

DEBUG_TOOLBAR_CONFIG = {
    'SHOW_TOOLBAR_CALLBACK': lambda request: True
}
'''

This configuration ensures services can talk to one another inside the Docker network.





🚫 Stop Local Services

To prevent port conflicts:
- Stop any locally running instances of MySQL, Redis, Celery, etc.
- On macOS: stop MySQL from System Preferences
- On Windows: check Services or Task Manager





▶️ Starting the Dockerized Application

Option A: Foreground mode (shows logs)
'''bash
docker-compose up --build
'''

Option B: Detached/background mode
'''bash
docker-compose up -d --build
'''



📄 Viewing Logs

To avoid noisy shared logs, use targeted commands:

'''bash
docker-compose logs web
docker-compose logs tests
'''

To stream logs continuously:
'''bash
docker-compose logs -f tests
'''



🧪 Running Commands in Containers

To open a shell inside the 'web' container:

'''bash
docker-compose run web bash
'''

From here you can:

'''bash
python manage.py seed_db
python manage.py createsuperuser
'''

This helps you populate the database and set up admin users interactively.





🌐 Verify Application
- Visit: 'http://localhost:8000/'
- Navigate to '/store/collections/' to view seeded data



🧹 Stopping Services
When finished:

'''bash
docker-compose down
'''

This removes all running containers and frees associated ports.







Codes and Other Notes in this Discussion: 


Services: 
MySQL
Redis
Celery
Smtp4Dev
Flower


dev.py:

from .common import *

DEBUG = True

SECRET_KEY = 'django-insecure-hs6j037urx6iav+7#10%-vu4l4f5@@-1_zo)oft4g7$vf2$jmp'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'storefront3',
        'HOST': 'mysql',
        'USER': 'root',
        'PASSWORD': 'MyPassword'
    }
}

CELERY_BROKER_URL = 'redis://redis:6379/1'

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis:6379/2',
        'TIMEOUT': 10 * 60,
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

EMAIL_HOST = 'smtp4dev'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 2525

DEBUG_TOOLBAR_CONFIG = {
    'SHOW_TOOLBAR_CALLBACK': lambda request: True
}




docker-compose up --build

docker-compose up -d --build  


docker-compose logs tests 

docker-compose logs -f tests 



docker-compose run web bash 
docker-compose run web python manage.py seed_db 



docker-compose up -d --build 
docker-compose down 





✅ Summary

| Command                             | Purpose                                |
|-------------------------------------|----------------------------------------|
| 'docker-compose up --build'        | Start services and build containers    |
| 'docker-compose up -d --build'     | Run services in the background         |
| 'docker-compose logs [service]'    | View logs for a specific service       |
| 'docker-compose run web bash'      | Interact with the Django container     |
| 'docker-compose down'              | Stop and remove all services           |







