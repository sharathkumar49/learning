

first-class functions:
======================

"A programming language is said to have first class functions if it treats functions as first-class citizens." 


First-class Citizen(Programming):
---------------------------------
"A First class citizen (sometimes called first-class objects) in a programming language is an entity which supports all the operations generally available to other entities. These operations typically include being passed as an argument, returned from a function, and assigned to a variable."


So, that means that we should be able to treat functions just like any other object or variable.


assigning a function to a variable:
------------------------------------
def square(x):
	return x * x
	
	
f = square

print(square)   # <function square at 0x101278950> --->  represents the function 


f(5) # 25


we assigned a function to a variable. But, we can also pass functions as arguments and return functions as the result of other functions. And by the way, if a function accepts other functions as arguments or returns functions as their result, that's what you call a higher order function. (map, reduce, filter)


1. passing a function as an argument to another function: (map function)


def map(func, arg_list):
	result = []
	for i in arg_list:
		result.append(func(i))
	return result 
	
squares = map(square, [1, 2, 3, 4, 5, 6])

print(square) # [1, 4, 9, 16, 25, 36]



2. to return a function from another function: 


def logger(msg):

	def log_message():
		print('log:', msg)
		
	return log_message    
	
	
log_hi = logger('hi')  == log_message 
print(log_hi)  # <function logger.<locals>.log_message at 0x000002AF58FAA0E0>
log_hi() # log: hi


So, one thing important to point out here is that from this step to when we executed the function at this step, that it remembered our initial message that we passed in to this initial logger function. Now this is what we call a closure.


Other use cases of returning a function from another function:


def html_tag(tag):

    def wrap_text(msg):
        print('<{0}>{1}</{0}>'.format(tag, msg))

    return wrap_text



print_h1 = html_tag('h1')
print_h1('Test Headline!')    # <h1>Test Headline!</h1>
print_h1('Another Headline!') # <h1>Another Headline!</h1>

print_p = html_tag('p')
print_p('Test Paragraph!')    # <p>Test Paragraph!</p>



======================================================================================================================================================================================

Closures:
---------


Wikipedia:  “A closure is a record storing a function together with an environment: a mapping associating each free variable of the function with the value or storage location to which the name was bound when the closure was created. A closure, unlike plain functions, allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope.”



def outer_func():
	message = 'Hi'
	
	def inner_func():
		print(message)
	
	return inner_func
	

	
my_func = outer_func()
print(my_func)  # <function outer_func.<locals>.inner_func at 0x000001BCC963A0E0>
print(my_func.__name__)  # inner_func
my_func() #Hi 


The inner_func can access the 'message' variable, this is what we call free variable, because it is not defined inside the inner_func, but still we have access to this 'message' variable

1.
def outer_func(msg):
	message = msg
	
	def inner_func():
		print(message)
	
	return inner_func  # returns the inner_func waiting to be executed, someone needs to trigger it
	
	
hi_func = outer_func("hi")
hello_func = outer_func("hello")


hi_func() # hi 
hello_func() # hello 


a closure closes over the free variables from their environment. 


2.
def html_tag(tag){
  def wrap_text(msg){
    print(f'<{tag}>{msg}</{tag}>')
  }
  return wrap_text
}

print_h1 = html_tag('h1')

print_h1('Test Headline!')  # <h1>Test Headline!</h1>
print_h1('Another Headline!') # <h1>Another Headline!</h1>


print_p = html_tag('p')
print_p('Test Paragraph!')  # <p>Test Paragraph!</p>


The html_tag is a outer function and wrap_text is a inner function. 




3.
# Closures

import logging
logging.basicConfig(filename='example.log', level=logging.INFO)


def logger(func):
    def log_func(*args):
        logging.info(
            'Running "{}" with arguments {}'.format(func.__name__, args))
        print(func(*args))
    return log_func


def add(x, y):
    return x+y


def sub(x, y):
    return x-y

add_logger = logger(add)
sub_logger = logger(sub)

add_logger(3, 3)
add_logger(4, 5)

sub_logger(10, 5)
sub_logger(20, 10)

======================================================================================================================================================================================

Decorators:
-----------

First class Functions: To treat functions like any other object. we can pass functions as arguments to another function, we can return functions, and we can assign functions to variables. 

closures allow us to take advantage of first class functions and return an inner function that remembers and has access to variables local to the scope of the outer function in which they were created.


def outer_function(msg):
	message = msg
	def inner_function():
		print(message)
	return inner_function
	
hi_func = outer_function('hi')
bye_func = outer_function('bye')

hi_func()
bye_func()



def outer_function(msg):
	def inner_function():
		print(msg)
	return inner_function
	
hi_func = outer_function('hi')
bye_func = outer_function('bye')

hi_func()
bye_func()



So, decorators are very similar to what we've already done here. 

Okay, so what is a decorator? A decorator is just a function that takes another function as an argument, adds some kind of functionality, and then returns another function. All of this without altering the source code of the original function that you passed in.


def decorator_function(msg):
	def wrapper_function():
		print(msg)
	return inner_function
	
hi_func = outer_function('hi')
bye_func = outer_function('bye')

hi_func()
bye_func()



Okay, now what if I instead of 'printing a message' that we pass in, 'we execute some function' that we pass in. And that's what a decorator does. 

def decorator_function(original_function):
	def wrapper_function():
		return original_function() # executing the origianl_function and returning the same
	return wrapper_function # returning the wrapper function which is waiting to be executed






	
def display():
	print('display function ran')
	
	
decorated_display = decorator_function(display)
print(decorated_display.__name__) # wrapper_function
decorated_display() # 'display function ran'




Okay, so now that we have a basic decorator example here, why would we want to do something like this? So, decorating our functions allows us to easily add functionality to our existing functions by adding that functionality inside of our wrapper. 


def decorator_function(original_function):
	def wrapper_function():
		print("checking the user login before {}.".format(original_function.__name__))
		return original_function()
	return wrapper_function




Now, how actually the decorators implemented is:	


@decorator_function
def display():
	print('display function ran')


The above syntax is technically equals to, 
display = decorator_function(display)


Now we can simply run,
display()



So even though those syntaces(one by passing the display function in decorator_function normally and other by using decorators) are functionally the same, I think using decorators syntax is little bit easier to read, especially whenever we chain multiple decorators together.


so, if we put the decorator symbol above the function, it's technically equal to,
display = decorator_function(display)


So, instead of using the above statement, we are using the decorator instead. 




What if original_function take some arguments: 
----------------------------------------------

def display_info(name, age):
	print('display _info ran with arguments ({}, {})'.format(name, age))
	
display_info('steve', 27)



if we apply decortor to the display_info and run it, we would get an error saying 
"TypeError: decorator_function.<locals>.wrapper_function() takes 0 positional arguments but 2 were given"

So, what we need is we need to be able to pass any number of positional or keyword arguments to our wrapper and wrapper to have it execute our original function with those arguments. 





def decorator_function(original_function):
	def wrapper_function(*args, **kwargs):
		print("checking the user login before {}.".format(original_function.__name__))
		return original_function(*args, **kwargs)
	return wrapper_function
	
decorated_display = decorator_function(display)
decorated_display()
	
	
Classes as Decorators:
----------------------

greet(

class decorator_class(object):

    def __init__(self, original_function):
        self.original_function = original_function

    def __call__(self, *args, **kwargs):
        print('call method before {}'.format(self.original_function.__name__))
        self.original_function(*args, **kwargs)


@decorator_class
def display():
	print('display function ran')
	
@decorator_class	
def display_info(name, age):
	print('display _info ran with arguments ({}, {})'.format(name, age))
	
display()
display_info()





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

More examples:
--------------

def my_logger(orig_func):
    import logging
    logging.basicConfig(filename='{}.log'.format(orig_func.__name__), level=logging.INFO)

    def wrapper(*args, **kwargs):
        logging.info(
            'Ran with args: {}, and kwargs: {}'.format(args, kwargs))
        return orig_func(*args, **kwargs)

    return wrapper

@my_logger
def display_info(name, age):
    print('display_info ran with arguments ({}, {})'.format(name, age))

display_info('Tom', 22)




So, now you can reuse this decorator anytime you want to add that logging functionality to any new function. So you can imagine how repetitive and error-prone it would be if you wanted to add that functionality to multiple functions and tried to manually add in that logging code within each individual function. The decorator allows us to maintain our added functionality in one location and easily apply it anywhere that we want within our code base.




Another example of assigning timing function as a decorator:
------------------------------------------------------------

def my_timer(orig_func):
    import time
    
    def wrapper(*args, **kwargs):
        t1 = time.time()
        result = orig_func(*args, **kwargs)
        t2 = time.time() - t1
        print('{} ran in: {} sec'.format(orig_func.__name__, t2))
        return result

    return wrapper



@my_timer
def display_info(name, age):
    print('display_info ran with arguments ({}, {})'.format(name, age))

display_info('Tom', 22)








Chaining the decorators:
------------------------

so, the decorator means, for the my_timer say

display_info = my_timer(display_info)

And, for the stacked version means, 

display_info = my_logger(my_timer(display_info))





print the out name of display_info after the my_timer function has been called:

display_info = my_timer(display_info)
print(display_info.__name__)  # wrapper


Now we want to use that returned 'wrapper' function for something else, 
we are passing that returned 'wrapper' function into our logger also.

Also, the orig_func in the my_logger, will not receive the 'display_func' anymore, it will receive the 'wrapper' function instead from my_timer


Okay, so how do we fix something like this? It's always a good idea to preserve the information of our original function whenever we use decorators. And we can preserve that information by using the functools module and the 'wraps' decorator.


All we have to do is decorate all of our wrappers with the wraps decorator.





# Decorators
from functools import wraps


def my_logger(orig_func):
    import logging
    logging.basicConfig(filename='{}.log'.format(orig_func.__name__), level=logging.INFO)

    @wraps(orig_func)
    def wrapper(*args, **kwargs):
        logging.info(
            'Ran with args: {}, and kwargs: {}'.format(args, kwargs))
        return orig_func(*args, **kwargs)

    return wrapper


def my_timer(orig_func):
    import time

    @wraps(orig_func)
    def wrapper(*args, **kwargs):
        t1 = time.time()
        result = orig_func(*args, **kwargs)
        t2 = time.time() - t1
        print('{} ran in: {} sec'.format(orig_func.__name__, t2))
        return result

    return wrapper

import time


@my_logger
@my_timer
def display_info(name, age):
    time.sleep(1)
    print('display_info ran with arguments ({}, {})'.format(name, age))

display_info('Tom', 22)


======================================================================================================================================================================================

Decorators with Arguments: 
---------------------------



def decorator_function(original_function):
    def wrapper_function(*args, **kwargs):
        print('Executed Before', original_function.__name__)
        result = original_function(*args, **kwargs)
        print('Executed After', original_function.__name__, '\n')
        return result
    return wrapper_function


@decorator_function
def display_info(name, age):
    print('display_info ran with arguments ({}, {})'.format(name, age))


display_info('John', 25)
display_info('Travis', 30)









from flask import Flask
app = Flask(__name__)


@app.route("/")
def hello():
    return "Hello World!"


@app.route("/about")
def about():
    return "About Page"

if __name__ == "__main__":
    app.run()









# Decorators


def prefix_decorator(prefix):
    def decorator_function(original_function):
        def wrapper_function(*args, **kwargs):
            print(prefix, 'Executed Before', original_function.__name__)
            result = original_function(*args, **kwargs)
            print(prefix, 'Executed After', original_function.__name__, '\n')
            return result
        return wrapper_function
    return decorator_function


@prefix_decorator('LOG:')
def display_info(name, age):
    print('display_info ran with arguments ({}, {})'.format(name, age))


display_info('John', 25)
display_info('Travis', 30)