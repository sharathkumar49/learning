What is Sql?
 
 
 
 
 
Let's start the course with a quick overview of databases, what they are and how we use them. A database is a collection of data stored in a format that can easily be accessed. In order to manage our databases, we use a software application called Database Management System or DBMS. We connect to a DBMS and give it instructions for querying or modifying data. The DBMS will execute our instructions and send results back. Now, we have several database management systems out there, and these are classified into two categories. Relational and non-relational, also called NoSQL. In relational databases, we store data in tables that are linked to each other using relationships. That's why we call these databases relational databases. Each table stores data about a specific type of object, like customer, product, order, and so on. 
SQL or SQL is the language that we use to work with these relational database management systems. It looks like this. We use SQL to query or modify our data. In this course, you're going to learn everything about this powerful language. Now, there are many different relational database management systems out there. Some of the most popular ones are MySQL, SQL Server by Microsoft, and Oracle. But of course, there are plenty more. Each database management system has a different flavor of SQL, But all these implementations are very similar and are based on the standard SQL specification. So most of the SQL code that you will learn in this course will work with any database management system. In this course, we'll be using MySQL, which is the most popular open source database in the world. 
Alright, now back to this diagram. What about non-relational databases? In non-relational databases, we don't have tables or relationships. These databases are very different from relational databases, but that's a topic for an entirely different course. What you need to know is that non-relational database management systems don't understand SQL. They have their own query language. So we use SQL to work with relational database management systems. Now, before we jump in and install MySQL, let me clarify something quickly. As you talk to different people, you will hear two different pronunciations of SQL, SQL or SQL. What is the correct way? Well, it depends on who you ask. And of course, everybody thinks their way of pronouncing this word is the right way. But here's a little history about this language. 
SQL was originally developed at IBM in the 70s, and back then it was initially called SQL, short for Structured English Query Language. But they changed the acronym to SQL because SQL was the trademark of an airplane company. So to this date, there's been an argument about what is the right way to pronounce this language. Generally speaking, people in non-English speaking countries call it SQL. I'm used to calling it SQL because it's shorter and sweeter than SQL. But if you prefer to call it SQL, that's totally fine with me. I'm not going to get mad at you. So that's the history behind this language. But what about MySQL as a software product? Developers of this product prefer to call it MySQL rather than MySQL, but they don't mind if we call it MySQL. 
In this course, I'll be teaching you SQL with MySQL.




Installing MySql on Mac and Installing MySQL on Windows:

In this tutorial I'm going to show you how to install mysql on your computer now here I'm using a Mac so first I will show you how to install my skills on a Mac computer and then I' will show you how to install it on Windows. So if you're a Windows user, feel free to skip this tutorial now open up your browser and head over to mysql.com. Then go to the downloads page and scroll down to the bottom. Here you should see mysql Community Edition. This is absolutely free and we're going to use that throughout this course so let's go ahead with that. Now on this page click on mysql communi to Server. 
And then on this page you should see available releases for macos. So in this list download the first item which is a DMG archive. All right now. On the next page click on no thanks. Just start my download all right. As you can see we are getting a DMG file which is basically a set of Wizard. All right now the DMG is downloaded, so let's open it and then double click on this package. Let well launch an installation Wizard which is pretty easy to use, so simply click until and again and again. I agree with the license agreement and install my skill. It's going to ask for your password. This is the password that use to log into your computer. So let's put that here alright now. Here we need to set a password for the root or the admin user, so click next and in this box type a complex password. All right now let's finish the installation. 
And into your computer's password one more time and were done. That was super easy and sweet alright. We installed mysql Community Server. Now we need a graphical tool to connect to the server and manage our databases. So back to the downloads page one more time scroll to the bottom and go to mysql Community Edition. And on this page somewhere you should see mysql Workbench. This is a graphical tool that we use to connect to our database server, so let's go ahead and download this as well. Now once again on this page we need to download a DMG archive so download and again we have to say no. We don't want to log in or sign up, so let's just go ahead and download the DMG. 
And then open it all right. You're going to see something like this, so simply drag this my skill Workbench and drop it onto the applications fold there. So let's go ahead with that. Now it's going to copy this into the applications folder Beautiful. So we're done with the installation that was super easy. Now press command and space and search for mysql Workbench there you go, let's open it now the first time we get this message because this is an application that we have downloaded from the Internet. So we need to tell Mac that we trust this. Let's go ahead with that. So this is mysql Workbench. Now by default, you should see a connection here. If you don't see that you need to create it. Let me show you how to do that. So for this demo, I'm going to right. Click this and delete this connection. 
All right now let's create a connection from scratch, so click on this plus icon on this page. Give this connection a name. Let's say local instance. Now the connection method that we're going to use is TCPIP, which is set by default. The host name is 1. 27.1, which is the address of the local machine and the port is 3003 and six. This is the default port for mysql server, that is the username of the admin. Now we need to enter the password. This is the password that we set during the installation, so click on store in keychain and in this box type the password for the MOS skill server right. And finally let's test the connection ok. We successfully connected to MOS skill server on the local machine. Beautiful. Let's click ok and here we have a connection on the homepage of myscul Workbench. Every time we open mycul Workbench, we use this connection to connect to our local server. All right we're done with the installation of macule on a Mac. Next I will talk about installing mysql on a Windows computer so feel free to skip that tutorial. 

In this tutorial I'm going to show you how to install mysql on Windows. Open up your browser and head over to mysql.com. Then go to the downloads page. Now here scroll down to the bottom. We're going to use mysql communityition which is absolutely free. So let's go with this. Now select my SQL Community Server and then scroll down. So here you should see something like this. Mysql Installer for Windows. This is the recommended method for installing mysql on Windows. So click on this al right on the next page. Scroll down and download the first installer here on the next page. Scroll down and click on no thanks. Just start my download. Otherwise you have to create an account and login which is unnecessary for following this course. So let's go with this and save this file to our computer and then run it. 
All right we're going to use this setup wizard to install mysql on our computer. This is very easy. All you have to do is to click next, but there are a couple of places where you need to enter a password. Let me show you so on the first page for the setup type we're going to use the developer default setup. Go to the next page. Now here we're getting a little warning because this installation wizard wants to install the connector for Python 3.7. But I don't have Python on this machine. So that's why I'm getting this warning now on your machine. You might or you might not get this error. It doesn't really matter. Just click next and one more time. So here are the products that are going to get installed. The first one is mysql Server, the second one is mysql workbench. This is the graphical tool that we use to connect to our database server and manage our databases. You're going to see that soon, so click on Execute. Now this is going to take about five to ten minutes, so I'm going to pause the recording. 
All right all the products are installed. Beautiful. Let's go to the next page and again here on the group replication page. Also click on next on the next page, which is about networking. Leave all the default settings, so let's go to the next page. Now we should set a password for the root or the admin user, so click on next. Add in this box. Type A password for the admin user. 
All right and then let's go to the next page once again leave all the default settings and click on next and execute one more time. 
All right and now let's finish the installation once again. We have to click on next and then finish one more time. Theres so many steps now here's the page where you need to enter the admin password, so the page is called Connect to Server. You can see the username is Root, which represents the admin user in this box. Enter the password that you said earlier. Then click on check ok. Connection was successful. Beautiful. Let's go to the next page and click on execute and finally finish there you go. We have one more step next now. Finally after all these steps, the installation is complete. Now this is going to start mysql Workbench, which is the graphical tool we use to manage our databases and run SQL queries. So click on finish. So now we have a command prompt window where we can type instructions to talk to our myscul server. We don't really need this, so close it and here's mysql Workbench. Now the first time you open this page by default, you should see a connection here. If you don't see it, click on this plus icon. 
Indus page give this connection and name. Let's say local instance. Now leave all the settings to their default value. But here for the password click on store ingot. And in this box type the password that you set for the admin user. So I'm going to put that here. Ok. Now click ones. Connection all right. We successfully connected to the myscule server on this computer. All right. Then click on ok. Now we click on this connection to connect to our database server AL right. So here's the interface that you'll be using throughout those courses. On the left side we have the navigator panel, in the middle we have the query editor, which we can resize. This is where we're going to write our SQL queries, and on the right side we have SQL additions. So we're done with the installation of my skill on our computer. Next I'm going to show you how to create the databases for this course. 





Creating the Databases:
In this tutorial I'm going to show you how to create the databases for this course. So here I've got MySQL Workbench open, let me quickly give you an overview of this interface because the first time you open it, it might appear a little bit intimidating, but actually it's not that difficult. So here on the top we've got this toolbar with these buttons for creating a new tab for writing SQL code, as well as opening a SQL file. And next to that we've got a bunch of buttons for creating a database, creating new tables, and so on. On the left side we've got the navigator panel with two tabs, administration and schemas. We use the administration tab to do administrative work such as starting or stopping our server, importing or exporting data, and so on. 
The schemas tab shows the databases that we have in the current database server. So currently we only have one database that is sys, and this is the database that MySQL uses internally to do its work. Now in the middle we've got this query editor window, this is where we write our sql code, so we'll be spending most of our time in this course in this window. And on the right side we've got another panel with two tabs, context help, and snippets. Now chances are this interface might look slightly different on windows, but what I'm showing you here is almost identical with what we have on windows. So don't get hung up if it looks slightly different on your machine, it doesn't really matter. 
Now up here we've got these buttons for showing or hiding these panels, so to clean this interface, I'm going to hide this panel on the right side, as well as the panel on the bottom. That is better. Now to create the databases for this course, download the zip file I've attached below this video. When you extract this zip file, you're going to see a bunch of sql files like this. So the main one that you'll be using in this tutorial is called create databases dot sql. So this file contains all the sql code to create all the databases that we need in this course. Now we also have individual files for creating individual databases, I just added these files in case you need to recreate one of these databases in the future, but for now don't worry about them. 
Now, back to mysql workbench, let's open the main sql file, that is create databases. So this is an example of sql code. Now this may look complex at the beginning, but trust me, as you go through the course, you're going to understand exactly how everything works here. You're going to be able to write SQL code like this. So, you want to execute this to create all the databases for this course. To do that, we click on this icon, this yellow thunder icon that we have on this toolbar here. This will execute either the selection or the entire code if there is nothing selected. For example, if I select this line here, and click on this icon, this will execute only this line. In this case we want to execute the entire code, so we shouldn't select anything, and now let's execute this, beautiful. 
So here down the bottom we have this panel called the output window that shows all the operations performed in our database server. So we can check to see if all the operations completed successfully or something went wrong. As you can see we've got this green text next to each operation. Beautiful. So I'm going to close this panel, that's better, now on the left side in the schema tab currently we don't see the new databases, so we'll have to refresh this view, beautiful, so we've got all these databases that are prefixed with sql or sql, I decided to prefix them with sql so we know that these are the databases for this course, they don't accidentally clash with another database with the same name on your database server. 
Now at the time of recording this video, there are only 4 databases here, But as we go through the course, I'm going to update the script for creating the databases, so when you watch this course, chances are you're going to see more databases here. Don't worry about the difference. Now as an example, let's explore one of these databases. And by the way, we don't need this tab anymore, so let's close it, that's better. Let's expand the SQL store database. Now in every database we have these objects. We have tables, this is where we store our data. We have views, which are kind of like virtual tables, so we can combine data from multiple tables and put them in a view. And this is especially powerful for creating reports. 
You're going to learn about them in the future. You also have stored procedures and functions. And these are little programs that we store inside of our database for querying data. For example, we can have a stored procedure for getting all the customers in a given city. So we call that procedure and say, hey, give me all the customers in San Francisco. and this will return all the customers in San Francisco. Okay? Now, let's expand the tables. So here are the tables in this database. We have customers, we have orders, products, shippers, and so on. Now select this customers table, whenever you hover your mouse over this item, you should see these three icons on the right side. Click on the right most icon that looks like a table with a thunder. 
With this we can see all the data in this table. So this is our customers table, in this table we have these columns like customer id, which we use to uniquely identify customers, we also have first name, last name, birth date, phone address, and so on. So these are the columns in this table, and every row is called a record. So every row represents one customer, and these are the pieces of information we know about each customer. Now let's look at another table, let's open the orders table, in this table we have these columns like order id, customer id, order date, status, and so on. What is this customer id here? We use this column to identify who has placed each order. Now what is interesting here is that you're referring to these customers using their customer id, which uniquely identifies them. 
In other words, if John Smith has placed an order, we don't store John Smith here, you only store John's customer id. Why is that? Here's the reason, it is possible that John Smith might have placed multiple orders in our system. Now every time John places an order, we need to look up his address and phone to ship his order. Now it is possible that some of this information might change in the future. John might move to a new place or change his phone number, he might even change his name. If you repeat all that information next to each order, then we'll have to come back and make changes in multiple places. In contrast, with this design we only store the id of john here, so anytime we want to change any information about john, instead of changing that here, we go back to our customers table, so let's look at the customer with id 6, that is actually called elka. 
So here are all the information about elka, this is her phone number, this is her address, And by the way, this is all dummy data that I created using a tool. So, if any information about Elko changes in the future, this is the only place that we need to modify. So this is how these databases work. We refer to these databases as relational databases. That basically means in this kind of databases we have multiple tables that are related to each other using a relationship. So internally there is a relationship between the customers table and the orders table. So the customer id column in the customers table is related or linked or associated with the customer id column in the orders table. Here's the orders table and here we have the customer id column. 
So this was a brief introduction to relational databases. You learned about databases, tables, columns, rows, and relationships. In the next section I'm going to show you how to retrieve data from a single table in this database. But before going any further, as an exercise, I want you to explore the invoicing database. Look at all the tables, look at all the data, to get an idea of the kind of data we have in this database. We're going to use this database a lot in the future. So we'll spend a couple of minutes to explore this database.





What youâ€™ll be learning:
 
 
 
 














The SELECT Statement:
  
In this tutorial I'm going to show you how to retrieve data from a single table. Now look at the navigator panel. Currently none of our databases is displayed in bold. That means none of these databases is selected for querying. So the first step to write a query to get data from a database is to select a database. The query that we'll write will be executed against that database. In this demo we're going to use the SQL store database. So we type out use SQL on the line store. Now use is a keyword in the sql language, and that's the reason it's displayed in blue. Now sql is not a case sensitive language, and that means we can use uppercase or lowercase characters, it doesn't really matter, but as a best practice, we should capitalize the sql keywords and use lowercase characters for anything else. 
So now let's go ahead and execute this query, alright, look the sql store database is now displayed in bold. Now in mysql workbench you can also select a database by double clicking that, so now I double clicked sql invoicing and it's the current database. Now if we run this query again, the sql store database becomes selected. Alright, now let's write our first query to retrieve all the customers in this database. So after the use statement we're going to use the select statement. Here's the basic syntax or basic structure of the select statement. we type out select, in front of that we specify the columns that we want to retrieve. For example, we can retrieve the customer id column, as well as the first name column, or we can retrieve all columns using an asterisk. 
Now after that we use the from clause, and this is where we specify the table that we want to query. In this case, the customers table. So this is the simplest query to select all the customers in a given table. Now whenever you have multiple SQL statements, you need to terminate each statement using a semicolon. So look we have a red underline here that indicates an error, if you hover your mouse here you can see this tooltip saying select is not valid at this position. Because we didn't terminate the first statement with a semicolon. Okay? Now let's execute this query one more time, once again we can click on this button here, or we can use a shortcut. So look at the query menu on the top, the first item is execute. 
Now here's the shortcut for this command. On mac, it's shift, command, and enter. On windows it's going to be different, honestly I'm not sure. So whatever it is, use that. So I'm going to press shift command and enter, and here are all the customers in this table. So this select statement has two clauses. The select clause, and the from clause. But there are other clauses that we can use to filter and sort data. For example, we can use the where clause to filter the result and get the customer with id 1. So we can write an expression like this, where customer underline id equals 1. Now when we execute this query, we'll only get the customer with id 1. So this is the where clause. 
We can also sort the data, so after where we use the order by clause, and here we specify the columns that we want to sort the result on. Let's say we want to sort these customers by their first name, so we type out first underlined name. That is the name of one of the columns in this table, right? Now if you execute this query, this order byte doesn't really have any impact because we only get one record in the result. So let me temporarily take out the where clause, to do that we can put two hyphens in front of this line. Now this line is treated as a comment, which means the sql engine is not going to execute this. Okay? So let's execute this query one more time, now all the customers that we get are sorted based on their first name. 
So that's the basic idea. Now over the next few tutorials you're going to learn more about each of these clauses in detail. But what you need to take away in this tutorial is that these three clauses from, where, and order by are optional. As you can see in this example I'm not using the where clause, we can also comment out the order by clause, we can also comment out the from clause, so instead of selecting all the columns in a given table, we can select some values like 1 and 2. Now if we execute this query one more time, in the result we get something like this, two columns called 1 and 2, and in these columns we have these values. So all these clauses are optional, but in the real world we quite often use all of them. 
Now what you need to understand here is that the order of these clauses matters. So we always have select first, then we have from, then where, and finally order by. We cannot change the order of these clauses, otherwise we get a syntax error, which basically means the syntax or the grammar or the structure of our SQL statement is incorrect. So it can't be executed. And one last thing before we finish this tutorial. In this example, you can see I've listed all these clauses on a new line, but technically you don't have to do this because line breaks, white spaces and tabs are ignored, when executing SQL statements. So we could come back here and put from in front of select, so select star from customers all in one line, and that's perfectly fine for simple queries, but as your queries get more complex, it's better to put each clause on a new line. 
So that's all for this tutorial, in the next tutorial we'll explore the select clause in detail.












The SELECT clause: 
In this tutorial we're going to look at the select clause in detail. So since our current database is sql store, to clean things up I'm going to remove the first statement, you don't really need it now, also I'm going to delete these two comments, we just want to focus on the select clause. Alright, so what can we do with this select clause? Well, in the last tutorial you learned that if we use an asterisk this will return all the columns. Alternatively, we can specify the columns that we want, and this is helpful in situations where you have a big table with so many columns and perhaps millions of records. If you want to bring back all that data, that's going to put a lot of pressure on the database server, in this case, MySQL, as well as the network. 
So that's when we explicitly specify the columns that we want to get. Let's say we want to get the first name and last name columns. Execute the query, as you can see, we only get these two columns, and they're in the same order as specified here. So if we change the order and put the last name first, and execute the query again, now you can see the last name column comes first. Now let's add a new column to the end, let's get the points for each customer as well, run the query, so these are the points for each customer, which are calculated based on their shopping. Now let's say we want to get these points and put them in a mathematical formula to calculate the discount that we can give to each customer. 
So here we can use an arithmetic expression. Let's say points plus 10. This is an arithmetic expression. So now if you execute this query, for the first record you can see that their points will end up being 2283. Let's run the query one more time. There you go. Now we can put the original points column here for clarity. So points comma points plus Let's run the query one more time, now you can see the original points, and next to that you can see the value that we're going to use to calculate the discount. And here we're using the plus operator, which is for addition, we also have multiplication, division, subtraction, and modular, which is the remainder of the division. So let's change this to something more complex. 
Let's say we want to get the points multiplied by 10, and then add 100 to it. Now you can immediately see that this line 1 is getting too long and it doesn't fit on the screen. In situations like this, you can break up the select clause by placing each column on a new line. So select last name, then first name, points, and finally points times 10 plus 100. So let's execute this query one more time. So this is our new column with the new calculated value, Now one thing you need to understand in this arithmetic expression is the order of operators. And this is based on the order of operators in math. So in math, the multiplication and division operators have higher order or higher precedence than addition and subtraction. 
So in this expression, first points is multiplied by 10, and then the result is added to 100. Now if this is not what you want, you can always change the order by using parenthesis. As an example, let's change this multiplication to addition, and then put that multiplication here. In this expression, first 10 is multiplied by 100, and then the result is added to the points. Now let's say this is not what we want. So we can change the order by using parenthesis here. With this parenthesis, first we get the points, add 10 to them, and then multiply the result by 100. So these parentheses are useful for changing the order of operations as well as adding clarity to our code. So someone else reading this code can easily understand the order of these operations. 
Now let's execute this query one more time. Alright, now look at the name of this column here. It's set to the expression that we have on line 5. That doesn't quite make sense. We want to have a clear descriptive name. So we can give this column an alias using the as keyword. So as and then we give it a name like discount, discount underline factor. Let's run the query again, now the name of this column is changed, so this is the benefit of using an alias. We can give descriptive names to the columns in the result set. Now if you want to have a space in the column name, you need to surround it with quotes, either single or double quotes. So we put quotes here and then we can add a space in between 
two words. Let's execute the query one more time, now we've got discount factor. So let's quickly recap everything you learned about the select clause. We can use an asterisk to return all the columns, or we can explicitly specify the columns that we want to return. We can also use arithmetic expressions here, and optionally we can give an alias to each column in the result set. Now there is one more thing you need to know about the select clause. So let's delete this query, and select the state column from the customers table. Take a look. These are the states in which our customers are located. Now currently in this sample data we don't have any duplicates. In other words, we don't have multiple customers in any of these states. 
But for this demo, I want to change the state of the first customer to Virginia, so we end up with duplicates in the result set. So let's open up the navigator panel, here's our customers table, let's look at all the data, and here's our first customer as you can see, is located in the state of Massachusetts. Now I want to change this to Virginia, so double click VA for Virginia, enter, done. Now on the bottom right corner of the screen you should see two buttons, apply and revert. Unfortunately I cannot show you these buttons because the recording window is a bit smaller than MySQL But look down the bottom, in the bottom right corner, click on apply. You're going to see a dialog box like this asking you to review the changes, so go ahead and click the apply button one more time. 
Alright, beautiful. Now, let's go back to our first query window and execute this query one more time. As you can see, the first two customers are located in Virginia. What if you want to get the unique list of states in the result set? that's when we use the distinct keyword. So select distinct state. With this query, we'll retrieve the unique list of states from the customers table. So with the distinct keyword we can remove the duplicates. Let's execute the query one more time, now you can see Virginia is not duplicated. Alright, here's an exercise for you. I want you to write a sql query to return all the products in our database. In the result set, I want to see three columns, name, unit price, and a new column called new price, which is based on this expression. 
Unit price times 1.1. So let's say we want to increase the price of each product by 10%. With this query we want to get all the products, the original price, and their new price. So pause the video and spend one or two minutes on this exercise, when you're done come back and see my solution. Alright, this is pretty easy, so we start with select, now what columns do we want to select? Name, unit, underline price, and then here we're going to use an arithmetic expression to calculate the new price, so we type out unit price times 1.1, and then give it an alias, so as new underline price, or we could put this in quotes and put a space between new and price. 
Now where do we want to select these columns from? From the products table, so from products. Note that I've used uppercase characters for all the SQL keywords and lowercase characters for everything else. So let's go ahead and execute this query, this is what we get, so these are all the products, you can see the original price as well as the new price which is 10% more expensive.















The WHERE Clause:
In this tutorial we're going to look at the where clause in SQL. So earlier I told you that we use the where clause to filter data. For example, let's say we only want to get the customers with points greater than 3000. So here in the where clause we can type out a condition like this. Points greater than 3000. When we execute this query, the query execution engine in MySQL is going to iterate over all the customers in the customers table. For each customer it's going to evaluate this condition. If this condition is true, it will return that customer in the result set. So, let's go ahead and execute this, and here's the result, as you can see, we have only two customers with points greater than 3000. 
So this is what we call the greater than operator, which is one of the comparison operators in SQL. Let me show you the complete list of comparison operators. So, We have greater than greater than or equal to we have less than less than or equal to here's the equality operator and For not equality. We can use an exclamation followed by an equal sign or Something like this. So both these are not equal operators. Let me show you a few examples of these operators so I'm going to delete all this and bring back the previous query and Let's say we want to get only the customers in the state of Virginia. So we can change our condition to something like this. Where state equals Virginia. 
Note that I've put Virginia in quotes because this is what we call a string. A string is a sequence of characters. So whenever you're dealing with a sequence of characters or basically textual data, you need to enclose your values with either single or double quotes. But quite often by convention we use single quotes. So let's execute this query, and here's the result, you can see we only have these two customers with id 1 and 2, who are located in Virginia. And it doesn't matter if we use uppercase or lowercase characters, so if we type out va in lowercase, and execute the query, we get the exact same result. Now what if we want to get all the customers outside of the state of Virginia? 
We can use the not equal operator. So, can either prefix this with an exclamation, or use this other notation. Either way, we get the same result. So these are the customers that are not located in Virginia. Now we can use this comparison operators with date values as well. For example, let's say we want to get only the customers born after january 1st, 1990. So we change our condition to birth date greater than once again we use quotes for representing date values, even though dates are actually not strings. But in the SQL language we should enclose dates with quotes. So here we type out 1990-01 for January-01 for day. So this is the standard or the default format for representing dates in MySQL. Four digits for the year, two digits for the month, and two digits for the day. 
So let's go ahead and execute this query, I actually made a mistake here, so we don't see the result, instead we see the action output, or the output window. If you scroll to the bottom you can see the details of the error. So here I used the wrong name for the column, we should separate these two words with an underscore, that is the name of our column. So let's execute the query one more time, so we only have three customers born after January 1st, 1990. So these were examples of comparison operators in SQL. In the next tutorial, I'm going to show you how to combine multiple conditions when filtering data. Alright, here's your exercise. I want you to write a query to get the orders that are placed this year. 
So look at the orders table, see what columns do we have there, and based on that, write a query with a where clause. So here's the orders table, in this table we have this column, order date. We can use this column to see the orders that are placed this year. So here's our query, select star from orders, where order underline date is greater than or equal to January 1st 2019, assuming this is the current year. So 2019 0101. Now since currently we are in the year 2019, this query will return all the orders placed this year. But next year this query is not going to give us the right result. But don't worry about it, later in the course I will show you how to write a query to get the orders placed in the current year. 
So for the purpose of this exercise, this is a valid solution. Now let's execute this query and see what we get. So we have only one order, order id 1, that is placed in the current year.






The AND, OR and NOT Operators: 
In this tutorial I'm going to show you how to combine multiple search conditions when filtering data. So let's say we want to get all the customers that are born after January 1st, 1990, who also happen to have more than 1000 points. So this is where we use the and operator. So we type out and, and after we type out another condition, like points greater than 1000. Now when we execute this query, we only get customers who have both these conditions. Let's take a look. So execute, we only have two customers, and if you look, both these people are born after 1990, and they have more than a thousand points. So this is the and operator. When we use this operator, both these conditions should be true. 
In contrast to the and operator, we have the or operator. So with or, if at least one of these conditions is true, that row will be returned in the result set. Let's take a look. Now we execute this query again, instead of two records we have quite a few records. So for example, we have this person who is not born after 1990, but if you look at their points they have more than a thousand points. So any customer records that satisfies at least one of these conditions will be returned. Now let's take this to the next level. Let's say we want to get customers who are either born after 1990, or they should have at least a thousand points and live in Virginia. 
So this is how we do this. We type out and, and then we add another condition, state equals Virginia. Let's execute this query and see what we get. We only get four records, so these are the customers that are born either after 1990, or they have more than a thousand points and live in Virginia. If you look at the first customer here, this person is not born after 1990, But you can see that she lives in Virginia and she has more than a thousand points. So the last two conditions are true for this customer. Now when combining multiple logical operators, you need to be aware of the order of these operators. So earlier I talked about the order of arithmetic operators, I told you that multiplication have a higher order than addition and subtraction. 
And we can use parenthesis to override the default order. We have the same concept in logical operators. So the and operator is always evaluated first. So when this query is executed, the query execution engine first evaluates this condition. Because here we're using an and. It doesn't matter that we typed out this condition after the first condition. Because the and operator has a higher precedence. Now you can always change the order using parenthesis. And this also makes your code cleaner and easier to understand. So here we can put parenthesis around these last two conditions, and also we can put these on a new line for clarity, something like this, so anyone who reads this code can easily understand what is the intent of this query. 
Now we also have another logical operator called not, and we use that to negate a condition. Let me show you. So I'm going to simplify our where clause, let's say, we're searching for customers who were born after 1990, or they have more than a thousand points. If we execute this query, we get these people. Customers with id 1, 3, 5, and so on. Now we can use the not operator to negate this condition. So we apply not here, and preferably we also put parenthesis around this condition. Now when we execute this query, we'll see other customers that are not in the current result set. Let's take a look. So, instead of customers with id's 1, 3, 5, 6, and so on, we get the customers with id's 2, 4, and 10. 
Now technically these customers were born before 1990 and they have less than 1000 points. So if you look here, this first customer was born before 1990 and he has less than 1000 points. How did I know that? Let me show you a trick that I learned in math. Whenever you have a not operator, you can simplify your expression like this. We apply the not operator to the first condition. People who were born after 1990. How can we negate this condition? Well, the greater than operator becomes less than or equal to. That is the inverse of that condition, right? Now we apply the not to or. To negate the or. What do we get? We get and. Finally apply the not operator on the last condition. 
People who have more than 1000 points. When we negate this condition, we get customers with less than or equal to 1000 points. Now, we can remove the not operator to simplify this. We don't need parenthesis anymore because we only have two conditions that are combined with an and. Here's the result. As you can see, this is much easier to read and understand. People who were born before this date and they have less than 1000 points. Alright, here's your exercise, from the order items table, get the items for order number 6, where the total price for that item is greater than 30. Alright, here's the order items table, in this table we have these columns, order id, product id, quantity, and unit price. If we multiply the quantity by unit price, we can get the total cost 
of that item. And then we can compare it with 30. So, let's go ahead and write this query. Select star from order items, where, here we need two conditions. One is for the order, so order underline id should be 6, and the second condition, we want to calculate the total price. So, we get the unit price, multiply it by quantity, and this value should be greater than 30. So as we can see, we can use an arithmetic expression in the where clause, it's not limited to the select clause, okay? Now let's execute this query and see what we get. We should get only one item, that is for product 1, here the quantity is 4, and unit price is just over $8, so the total price for this item is greater than 30.


















The IN Operator:
In this tutorial I'm going to show you how to use the in operator in SQL. So as an example let's say we want to get the customers that are located in Virginia or Florida or Georgia. One way to write this query is like this. So where state equals Virginia or state equals Georgia or state equals Florida. Now people who are new to the SQL language or programming in general find this expression a little bit strange. They ask, mosh, why can't we write this expression like this? Where state equals Virginia or Georgia or Florida. Here's the reason, we use the or operator to combine multiple conditions. So here we have a condition or an expression more accurately, but on the right side of this or operator we have a string. 
In sql we cannot combine a string with a boolean expression that produces a boolean value, which can be true or false. So that is why we have to write our query like this. So we have multiple expressions or multiple conditions, and we're combining them using the or operator. So now if we execute this query, we get these customers here, but there is a shorter and cleaner way to get the same result. Instead of combining multiple conditions using the or operator, we can use the in operator. So where state is in, and then in parenthesis we add the values, like Virginia comma Florida comma Georgia and the order doesn't matter. This query is exactly equivalent to what we had earlier. But as you can see, it's shorter and easier to understand. 
So let's execute it. Look, we get the exact same result. Now here we can also use the not operator. Let's say we want to get the customers outside of these states. So we can use where state not in this list. Now if we execute this query, we get customers who are located in Colorado, Texas, and so on. So use the in operator when you want to compare an attribute with a list of values. Now here's your exercise. I want you to write a query to get the products where their quantity in stock equals to one of these values. 49, 38, and 72. So pause the video, do this exercise, and then come back and continue watching. Alright, this is pretty easy, so we do a select star to get all the columns from the products table where quantity in stock, in, we use the in operator to compare this attribute with these values, 49, 38, and 72, let's execute the query, we get only two records, because we don't have a product with quantity in stock equal to 72.













The BETWEEN Operator: 
In this tutorial we're going to look at the between operator in sql. So let's say we want to get the customers who have more than 1000 and less than 3000 points. What made this query is like this, where points greater than 1000, well more accurately greater than or equal to 1000, and points less than or equal to 3000. When we execute this query we get, how many? We get 4 people that satisfy this criteria. Now whenever you're comparing an attribute with a range of values, you can use the between operator, and this makes your code shorter and cleaner. So we can rewrite this expression like this, where points between 1000 and 3000. This is exactly equivalent to what we had before, so these range values are also inclusive. 
That means points is going to be greater than or equal to 1000 or less than or equal to 3000. Let's execute the query, we get the exact same result. Alright, now as an exercise, I want you to write a query to get the customers that are born between January 1st 1990 and January 1st 2000. Alright, so we start with select star from customers where birth, underline date, between, so what matters here is that we can use the between operator for date values as well, it's not limited to using numbers. So we're birth date between, now we need to supply two date values. So as I told you before, the format for dates is four digits for the year, so 1990, two digits for the month, and two digits for the day. 
So the birth date should be between this value and, here's the second value, 2019, 0, 1, and 0, 1. Let's execute this query, we get only 3 people who match this criteria.











The LIKE Operator:
In this tutorial I'm going to show you how to retrieve rows that match a specific string pattern. For example, let's say we only want to get the customers whose last name start with b. So here in the where clause, we type out where last name, this is where we use the like operator, and right after that we add a string pattern. So we want to get the customers whose last name start with b, and we have any number of characters after b. So use the percent sign to indicate any number of characters. You might have one character after b or no characters or 10 characters, with this pattern, we get all the customers whose last names start with b. And also it doesn't matter if it's an uppercase or a lowercase b. So let's execute this query, there you go. 
So we only have 3 customers whose last names start with b. As another example, let's say we only want to get the customers whose last names start with brush. So we change our pattern to brush percent. Now let's execute the query, we only get this one customer here. Now this percent sign doesn't have to be at the end of the pattern, it can be anywhere. For example, let's say we want to search for customers who have a b in their last name, whether it's at the beginning, in the middle, or at the end. So we change our pattern to percent b percent. This pattern means we can have any number of characters before or after b. let's execute the query, these are the customers who have a b somewhere in their last name. 
It doesn't matter if b is at the beginning or in the middle or at the end. Let's look at another example. I want to get all the customers whose last name end with y. So here's the pattern we use, let's execute this query, and we have 5 customers whose last name ends with a y. So this is how we use the percent sign. Now we also have an underscore, and that matches a single character. So with this pattern, we get customers whose last name is exactly two characters long, we don't care what the first character is, but the second character should be y. Let's execute this query, obviously we don't have any customers whose last name matches this pattern, but if we change this pattern to 5 underscores, so 1, 2, 3, 4, 5, followed by a y, 
we should get these customers. So their last name is exactly 6 characters, we don't care about the first 5 characters, but all of them end with a y. Now as another example, we can replace the first underscore with b, and that means we want to get the customers whose last name starts with b, and after b we have exactly 4 characters followed by a y. let's execute this query so we only have one customer that matches this pattern. So this is how we use the like operator. We use the percent sign to represent any number of characters, and an underscore to represent a single character. Now this like operator in MySQL is an older operator, but we also have a newer one that is more powerful, and it allows us to search for any string patterns. 
And That's what I'm going to show you next. Alright, here I'm going to give you two exercises for the like operator. First, I want you to get the customers whose addresses contain trail or avenue, and next I want you to get the customers whose phone numbers end with 9. Alright, let's get started with the first exercise. So, select from customers where address like, here we want to use a search pattern like this, we want to have trail, but trail can be anywhere in the address, so we put a percent before and after trail. Next we should use the or operator to search for another pattern, or address like, let me put this on a new line, that is better, address like, once again, percent 
avenue, percent, that's it. So, let's execute this query, here is the result, you should get the customers with IDs 2, 9, and 10. If you look at their addresses, all of them have either trail or avenue in their address. Now let's work on the second exercise. We want to get the customers whose phone numbers end with 9. That is pretty easy, so let me change our where clause, where phone, once again we use the like operator, at a percent followed by a 9. That's all you had to do. Let's execute the query, so here's the result, customers with id's 3 and 7, their phone numbers end with 9. So this is how we use the like operator. And by the way, you can always use the not operator here, let's say if you want to get the customers whose phone numbers don't end with 9. 
So we simply prefix like with not. Now if we execute this query one more time, we get all the other customers and the database.










The REGEXP Operator: 
In the last tutorial you learned about the like operator in SQL. So as another example, let's say we want to search for the customers who have the word field in their last name. So we type out a where clause like this, where last name, like percent field percent. So the word field can be anywhere in the last name. Let's execute this query, we get only one customer, beautiful. Now we also have another operator in MySQL, that is reg exp, which is short for regular expression, and regular expressions are extremely powerful when it comes to searching for strings. So they allow us to search for more complex patterns. Here's an example, if I want to rewrite this last where clause, using a regular expression, it looks like this. 
Where, last name, reg exp, now here in our string pattern, we don't have to type out the percent signs, we only type out filled. So what we have on line 4 is exactly identical to what we have on line 3. Let's execute this query, we get the same result, beautiful. Now here in regular expressions we have additional characters that we don't have when we use the like operator. For example, we can use the caret sign to indicate the beginning of a string. So, if I put a caret just before the word filled, that means our last name must start with filled. Obviously if we execute this query we don't get anyone that matches this criteria, so we use the caret sign to represent the beginning of a string. 
We also have a dollar sign to represent the end of a string. So this pattern means the last name must end with filled. Let's execute this query, we get the same result as before. Now we can also search for multiple words here, for example, let's say we want to find the customers who have the words filled or mac in their last name. So we use a pipe, a vertical bar, and type out another pattern. Let's execute this query. So here we have two customers, one of them has the word mac, the other has the word field in their last name. Now we can take this to the next level. Let's say we want to find the customers who have the words field, or mac, or rows in their last name. 
Let's execute the query, we get three customers, beautiful. So we use a pipe or a vertical bar to represent multiple search patterns. Now as another example, we can change our first search pattern to something like this. Now this pattern means the last name should either start with the word field, or it should have the word mac in it, or it should have the word rows. Let's execute the query, now we get only two customers, because our customer with the last name brushfield doesn't match this pattern. However, if we change our first pattern to field dollar sign, and execute the query we get three people here, three customers. So this is how we can combine multiple special characters when building a complex pattern. Now let's look at another example, let's say we want to search for customers who have an e in their last name. 
So these are all the people, alright, now let's say we want to make sure that before the letter e we should either have a g or an i. So this is where we use square brackets, and inside the brackets we add multiple characters like g, i, m, and that matches any customers who have ge, or ie, or me in their last name. So any of these characters can come before e. Now let's execute this query, there you go, we only get two customers, and the first example, before e we have which is one of the characters inside the brackets, in the second example, before e we have a g, which is also another valid character before e. Now once again, the square brackets don't have to be before e, we could add them after e, so any customers who have e followed by an f, or an m, or a q in their last name, can be returned with this pattern, obviously we don't have anyone in the database, so this is how we use 
square brackets. Now we can also supply a range of characters. For example, we can have e, and just before e, we want to have any characters from a to h. We don't have to type them out explicitly, like a, b, c, d, e, f, g, that's very verbose. So we can type out a to h, and now if you execute this query, we get these three people. So, let's quickly recap everything you learned about regular expressions in this tutorial. We use a caret to represent the beginning of a string, so beginning, we use a dollar sign to represent the end of a string, we use a vertical bar or a pipe to represent a logical or, so we can supply multiple search patterns, we use square brackets to match any single characters listed in the brackets, and finally, we use square brackets with a hyphen to represent a range, so any characters from a to let's say f. 
Now technically MySQL supports more special characters, but quite honestly the ones that I have listed in this tutorial are the ones that you'll be using 90% of the time. So just memorize these and you're good to go. Quite honestly a lot of beginners find the syntax for regular expressions confusing, so in this video I'm going to give you four exercises that I have carefully designed to help you quickly learn about the syntax. Here's the first exercise. get the customers whose first names are elka or amber. And note that this is amber with a u. Now for the second exercise, return the customers whose last names end with ey or on. Here's the third exercise, get the customers whose last names start with my, or it contains se, and finally as the last exercise, return the customers whose last names contain b, followed by 
r or u. So, go ahead and spend 2-3 minutes on this exercise, when you're done come back and continue watching. Alright, let's knock out the first exercise. So we want to get all, oops, there's a c here, select store from customers, where, first name, regular expression, and here's our pattern. you want to search for two words, either elka or amber, simple as that. Let's execute this query, we should get two customers, there you go, amber and elka. Alright, now let's knock out the second exercise. So I'm going to delete this, we don't need it anymore, so we want to get the customers, select start from customers, where last name should end with either ey or on. So in the search pattern we type out ey followed by a dollar sign to indicate the end of a string, then we add a vertical bar to supply the second search pattern, so on and once again a dollar sign. 
Let's execute this query, oops, actually I forgot to type out regular expression, there you go. So let's execute this query, and we should get these four customers with id's 1, 3, 5, and 7, the first three, their last names end with ey, and the last customer, his or her last name ends with on. Alright, now, let's work on the third exercise, so I'm just going to change the regular expression here, we want to get the customers whose last name starts with my, or contains se. So we use a character to indicate the beginning of a string, so it should start with my, or it should contain se, again very easy, let's execute this query, and we get the customers with ids 4, 8, and 10, and finally, we want to get the customers whose last names contain b, so let's change the search pattern, we should have a b, followed by r, or u. Now there are two ways to write this regular expression, we can use square brackets, 
So we have b followed by r or u. That's one way. The other way is to use a vertical bar. So br or bu. These are both valid solutions. So I hope you knocked out these exercises. In the next tutorial I'm going to show you how to get the records with missing values.






















The IS NULL Operator:
In this tutorial I'm going to show you how to look for records that miss an attribute. For example, if we select all the customers in our database, we can see that the customer with id 5 doesn't have a phone number. So if you look closely here, you can see the value null. Null means the absence of a value. Now let's say we want to search for all the customers who don't have a phone. Perhaps we want to send them an email and say, hey, your phone is missing in our system. So how can we get these customers? That is very easy. we use the is null operator. So, in the where clause, we type out where phone is null. Now let's execute this query, we only get one customer who doesn't have a phone, now here we can also use the not operator to get the customers who do have a phone. 
So we change the condition to is not null. Let's execute the query, now in the query results, every customer does have a phone number. For this exercise, I want you to write a query to get the orders that are not shipped yet. This is a very useful query that is used in a lot of real applications. For example, let's say you're an admin for an online shop, you want to see the orders that are not shipped yet, so you can follow them up. So write a query to get these orders. So here we have the orders table, let's have a quick look at the data in this table. Alright. So if you pay close attention, you see some of these orders don't have a shipped date. 
And these orders also don't have a shipper id, which is a unique number for identifying the shippers. So any order that misses a value for the ship date or shipper id is considered an order that is not shipped. So let's go ahead and write a query to get these orders. So back to our query editor, select star from orders where shipped underline date is null. You could also write shipper id is null, they're both equally correct. So let's execute this query and we should get 5 orders. Orders 1, 3, 4, 6, and 8.









The ORDER BY Clause:
In this tutorial I'm going to show you how to sort data in your SQL queries. So here we have a query to select all the customers from the customers table, if you look at the query result, you can see that our customers are sorted by their id. So we have customers 1, 2, 3, 4, and so on. This is the default sort column. But we can always change this using the order by clause. But first, let me explain why the customer id column is the default sort column. So first I'm going to open up the navigator panel, on the left side here is the customers table, now let's click on this middle icon here that looks like a tool. This opens up our customers table in the design mode, so here we can change our columns, we can add new columns, or remove existing ones, or change their name or order and so on. 
Now if you pay close attention, you can see a yellow key just before customer id. This means that this column is the primary key column for this table. So in relational databases, every table should have a primary key column, and the values in that column should uniquely identify the records in that table. So back to our query window, you can see that the values in this column uniquely identify each customer. So the customer id column is the primary key column in this table, and that is why when we write a query against this table, our customers are sorted by their id by default. Now, let me show you how to sort customers by a different column. So, here in the order by clause, we type out the name of another column, like first name. 
Let's execute the query, now we can see our customers are no longer sorted by their id, instead, they're sorted by their first name in ascending order. Now if you want to reverse the sort order, simply type out desc, which is short for descending. Now, you're sorting these customers in descending order. Okay? We can also sort data by multiple columns, for example, let's say first we want to sort our customers based on their state, and then within each state we want to sort them by their first name. So, we type out multiple columns here, state, and first name. Let's execute the query, now you can see that the first state we have here is California, followed by Colorado, and now here in Florida we have two customers 
and these customers are sorted by their first name. Let's have a close look here, so first we have amber, and then we have this other customer here. Now we can also use the descending argument anywhere here. For example, we can sort these customers by their state in descending order, and then sort them by their first name in ascending order, or once again, in descending order. So there are various ways we can sort data. Now one of the differences between MySQL and other database management systems is that in MySQL we can sort data by any columns, whether that column is in the select clause or not. For example, let's say we only want to select the first and last name for each customer. Now we can sort the result by any columns in this table. 
They don't have to be first name and last name. For example, we can sort them by their birth date, take a look, so this is a valid query in MySQL, but other database management systems sometimes yell at you when you write a query like this. Now we can also sort data by an alias, for example, here in our select clause, let's add the number 10, and give it an alias as let's say points. So points is not a valid column in this table, it's simply an alias for an expression, in this case, a simple number. Now here we could have a complex mathematical expression, it doesn't really matter, we can still sort data by an alias. So we can order by points, and then first name. 
Once again, this is a valid query from mysql's point of view. Now one last thing before we finish this tutorial, I've seen some tutorials that teach you how to sort data by column positions, for example, here we can order by 1 and 2, and that basically means sort the data by the first name, and then the last name. So these are the order of these columns. If you execute this query, You can see that our customers are sorted by their first name and then the last name. While this approach works, it's something that you should avoid. Because if in the future you come back here and add a new column in front of the first name column, let's say burst date. Now our customers are no longer sorted in the previous order. 
So sorting data by column positions produces unexpected results and it's something that you should avoid. Instead, always sort by column names, like first name. Alright, here's your exercise for this tutorial. In this database we have this table called order items, where we can find the items for each order. Now, I've written a query that you cannot see here, because that's the solution to the exercise I'm going to give you. That query produces this result. So we only have the items for the order with id 2, and we have sorted these items based on the total price for each item. So the total price for each item equals quantity times unit price. In this case the total price for product 1 is just over $18. 
So go ahead and write a query to select all the items for order with id 2, and sort them by their total price in descending order. Alright, let's select everything from order items, where order id equals 2, That returns all the items for this order. Now we want to make sure to sort them by their total price, so here in order by clause we write an expression, quantity times unit price, this returns the total price for each item, and then we add the descending argument here. So once again, the expression that we use in the order by clause doesn't have to be a column name, it can be an alias or an arithmetic expression like this. Let's go ahead and execute this query. 
this is what we get, now for clarity I would like to add another column in the result, so let's say quantity times unit underline price, we give it an alias like total price, let's execute the query, we can clearly see that this data is sorted by the total price in descending order, however, there is a bit of duplication in our query, we have repeated this expression in two places, So now we can simplify our order by clause by using an alias, that is total price. And we get the exact same result. Next I'm going to show you how to limit the number of records returned from your queries.











The LIMIT Clause:
In this tutorial I'm going to show you how to limit the number of records returned from your query. For example, when we execute this query, we get all the customers in the customer table. So we have 10 customers here. Now, what if you only want to get the first 3 customers? That's where we use the limit clause. Let me show you. So, after from, we type out limit 3, and this will return only the first 3 customers. Now if the argument that we pass here is greater than the number of records that our query produces, we'll get all the records in the query result. For example, if I pass 300 here, obviously we don't have 300 customers in this table. So when we execute this query, we'll get all the 10 customers in this table. 
So this is how the limit clause works. Now here we can optionally supply an offset, and this is very useful in situations where we want to paginate the data. For example, let's say we have a website, and on this website we have a webpage for the user to see all the customers in the database. Now for simplicity let's imagine we want to show only 3 customers per page. So, what are the customers that we're going to have on page 1? We're going to have customers 1, 2, 3. Now, let's say we want to write a query to retrieve the customers on page 3. How can we do that? Well, we want to skip the first 6 records and then pick 3 records, right? 
So we change our limit clause to something like this. Limit 6 and 3. So 6 is what we call an offset, and that basically tells mysql to skip the first 6 records and then pick 3 records. Let's execute this query, Alright, now we get customers seven eight and nine Now for your exercise I want you to get the top three loyal customers. These are the customers that have more points than everyone else All right first we select everything from the customers table Now we need to order customers by their points in descending order. So, if you look at the query result, you can see that customers are sorted by their loyalty. So the most loyal customers come first. Now we want to pick only the first three customers. 
And that's where we use the limit clause. So limit 3. Let's execute this query, and these are the most loyal customers. Customers with IDs 5, 6 and 3. Now, here's one thing I want you to remember, and that is the order of the limit clause. The limit clause should always come at the end. So first we have the select clause, then we have from, optionally we can have where, followed by order by, and finally limit. The order of these clauses matters. If you change the order, MySQL is going to yell at you. So pay attention to the order when writing your queries.











Inner Joins:
So far we have only selected columns from a single table. But in the real world, we quite often select columns from multiple tables, and that's what I'm going to show you over the next few tutorials. So, on the left side, if you look at our orders table, let's select all the data here, in this table we're using the customer ID column to identify the customer that has placed each order. Now as I told you before, we don't store customers information here, like their phone number, their email, their address, because this information can change in the future. And if a given customer has placed multiple orders, then we'll have to come back and change multiple records. We don't want to do that. That's why we have separate tables for customers and orders. 
Now in this tutorial, I'm going to show you how to select the orders in the orders table, but instead of showing the customer id, show the full name for each customer. So let's go back to our query window. Alright, so, you want to select everything from the orders table, Now we should combine the columns in this table with the columns in the customers table. That is where we use the join keyword. Now here we can optionally type inner join, because in SQL we have two types of join, inner join and outer join. We'll look at outer joins later in this section. So for now we're only using an inner join, and this inner keyword is actually optional, so we don't have to type it. 
So, we want to join the orders table with the customers table. Now, on what basis do we want to join these tables? Well, here in the customers table we have this customer id column. So if we put these two tables next to each other, we want to line up the records such that the customer ids are equal. That is where we use the on phrase. So after on we type out a condition. Here's the condition we need to type out. Orders.customer underline id should be equal to customers.customer customer id, now this is getting outside of the screen, so let me break up this line, that's better, so with this query we're telling mysql that hey, whenever you're joining the orders table with the customers table, make sure that the customer id column in the orders table equals the customer id column in the customers table. 
Now let's execute this query, look at the result. Since we are selecting everything here, the first few columns are from the orders table because we have listed that first. Now after all the columns in the orders table, we have the columns in the customer table. So customer id, first name, last name, and so on. Now let's simplify the result set and select only order id, first name, and last name. So back to our query, we select order id, first name, and last name. Now let's execute the query, that is better, so next to each order id we can see the name of the customer that placed that order. Now what if we want to display the customer id here as well? Well, let's put that here and see what happens. 
Customer id. Execute the query, we get an error. So if you look at the output window, down the bottom, you should see an error saying column customer id in the filled list is ambiguous. Now unfortunately I cannot show you this error, because the size of my recording window is smaller than mysql workbench. But that aside, let me explain why we're getting this error. Because we have this customer id column in both the orders and customers tables. So mysql is not sure which table do we want to select this column from. That is why it's saying this column is ambiguous. So we need to qualify this column by prefixing it with a table name. We can either pick it from the orders table or 
the customers table, it doesn't really matter, because the values are equal, right? So, in situations where you have the same column in multiple tables, you need to qualify them by prefixing them with the name of their table, okay? Now let's execute the query one more time, so there you go, we have order id, customer id, and the full name, beautiful. Now one more thing before we finish this tutorial, if you pay close attention, we have repeated the word orders multiple places. We have it here, as well as in the join condition. The same is true about the customers table. We have repeated that here. We can get rid of this repetition and make our code simpler by using an alias. So right after each table, we can give it an alias, o as in short for orders. 
So by convention, we abbreviate the table's name. Now, wherever we have orders, we should replace that with o. So here in the join condition, we replace orders with o, and also one more time, and the select clause. There you go. We can also apply an alias for the customers table, call it c, and then we simplify our join condition like this. So this is how we can join columns from multiple tables. Now, for your exercise, I want you to look at the order items table. So, In this table we have these columns, order id, product id, quantity and unit price. Now, I want you to write a query and join this table with the products table, so for each order, return both the product id as well as its name. 
Followed by the quantity and the unit price from the order items table. And by the way, make sure to use an alias to simplify your code. Alright, first, let's select everything from the order items table, and then join it with the products table. How are we going to join these tables? On order underline items dot, well actually let's just give this an alias right away. So we use oi as an abbreviation for order items. And p as in short for products. So oi dot product id should be equal to p or products dot product id. id. And by the way, remember that when you give an alias to a table, you have to use that alias everywhere else. So here I cannot type out products, my SQL is going to yell at me. 
So let's use the abbreviation, alright, this is how we join these tables, let's execute this query up to this point, alright, so we see all the items from the order items table, followed by the columns from the products table. Now, we want to explicitly select a few columns here. So from the order items table we want to select order underline id, well technically we don't have to prefix this with the table name, because this column is not repeated in multiple places, so it's not ambiguous. So let's make the code shorter, that's better, now we want to select the product id column, but because this column exists in both tables, we have to prefix it with a table name, either oi or p, it doesn't really matter. 
Next we want to select quantity, and finally unit price. Now actually here we have this unit price column in both tables, so this is the unit price in order items table, and this is the unit price in the products table. Now you might be curious why we have this column in two places, the reason for this is that the price of products can change. So for each order item, we want to have the price at the time the user or the customer placed the order. So this is a snapshot of the price at a given point in time. The unit price that we have in the products table is the current price right now. This is very important for reporting, otherwise we cannot calculate the sales properly. 
So because we have the unit price column in two places, in this case we should pick it from the order items table because this is the price at the time of placing the order. Now let's execute the query, so here's the final result.







Joining Across Databases: 
In the real world when you work as a developer or a database administrator, quite often you'll have to work with multiple databases. In this tutorial, I'm going to show you how to combine columns from tables across multiple databases. That's pretty easy. So in the SQL store database, we have these tables that you're fairly familiar with. Now, imagine this products table was not here. Now, if you look at the SQL inventory database, you can see here we have another products table, This products table is exactly the same as the products table that we have in the SQL store database. So it has the same columns and the same data. But technically this is not a good design. You don't want to have the same table repeated in multiple places. 
But for this demo, let's just imagine that we don't have the products table here, so we want to join the order items table with the products table in the SQL inventory database. Let's get started. So, select everything from order items table, let's give it an alias straight away. We want to join this with the products table. This products table is part of the SQL inventory database. So we'll have to prefix this with the name of its database. So we type out SQL inventory dot. Now once again we can give this an alias like p, then type out our join condition, so oi dot product id should be the same as p dot product id. Let's run the query, there you go. So we successfully joined tables across multiple databases. 
Now, note that we're prefixing the products table with the name of its database, because the current database that we're writing this query against is the SQL store database. Take a look, in the navigator panel, the SQL store database is displayed in bold. Because earlier, we wrote the use statement to select a database, that was SQL store. Now, what if we select the sql inventory database? Let's see what happens. So, SQL inventory. Now, because we have multiple statements, we have to terminate this with a semicolon. Now, we want to select everything from the order items table, but we don't have this table inside of this database. So now we'll have to prefix this table with the name of its database. That is sql underline store. 
Let's execute the query. Okay, everything works beautifully. So here's the lesson, you only have to prefix the tables that are not part of the current database. In other words, your query will be different depending on the current database.




















Self Joins:
SQL we can also join a table with itself. Let me show you an example Take a look at this database sequel HR In this database we have these two tables employees and offices. Let's take a look at the data in the employees table There you go, so here we have these columns employee ID first name last name their job title salary and reports to This is the idea of the manager for this person or this employee. Now once again, we don't want to repeat the manager's information here, like their phone number, their address, because this information can change in the future. So we are only using their identifier or their id to refer to them in this table. Now where can we find the information about this manager? 
Well, this manager is actually an employee of the same organization. So, look at this example, the manager id is 37270. Now if you look on the left side, here's the idea of that manager, which is another employee. Now who's the manager for this employee? Let's take a look. We don't have any values here, so the value for this cell is null. So this employee doesn't have a manager, and that means they are the CEO. So now let's go ahead and write a query to join this table with itself, so we can select the name of each employee and their manager. Back to our query window, first we need to select the sql database. Next we select everything from the employees table, we give it an alias like e, now we need to join this table with itself. 
So once again we type out employees, but we need a different alias. What should we call this alias? Well, we want to join this table with itself so we can find the managers, right? So we can use m as a short for managers. Now let's type out our join condition, So from the employees table, we need to join the reports underline 2 column to the managers table, which is basically the employees table itself, and what column? That is employee underline id. Now let's execute this query and see what we get. So, we see all the columns from the employees table repeated, the first set of columns represent information about the employees, and then after that we have information about the manager. In this case, we have only one manager in this table. 
But with this technique, we can easily create an organization chart. We can have a hierarchy of managers. Now let's simplify our query and select only the name of the employee and their manager. So, back here, since every column in the employees table is repeated twice, we need to prefix each column with a table name. For example, from the employees table, you want to get employee id, as well as the first name, and then from the managers table, you want to select the first name as well. So every column should be prefixed with the table name, or more accurately the alias, because all these columns exist in two tables. Right? Let's go ahead and execute this query. So, this is what we get, employee id, first name, and here's the manager's first name. 
We can improve this query by giving an alias to this column, because it doesn't make sense to have two first name columns. So, let's give an alias to the third column, manager. Now, let's execute it one more time, and here's the end result. So we have the employee id, first name, and manager. So joining a table with itself is pretty much the same as joining a table with another table. The only difference is that we have to use different aliases, and we have to prefix each column with an alias. This is what we call a self join. Next I'm going to show you how to join more than two tables.









Joining Multiple Tables:  
In this tutorial I'm going to show you how to join more than two tables when writing a query. For example, back to our SQL store database, look at the orders table. Now you know how to write a query to join this table with the customers table to return information about the customer who placed each order. But here we also have another column, status, which is similar to the customer id column. So the name of the statuses are not stored in this table, they're somewhere else in the order statuses table. let's have a quick look here, so our orders can be either processed, shipped, or delivered. And these are the identifiers for each of these statuses. Now back to our orders table, in the status column we store the order status id. 
So now we should write a query to join the orders table with two tables, the customers table and order statuses table. The result of this query is going to look like this. So for each order we see the order id, the date, the first and last name of the customer, and finally the status of the order. This is a beautiful report we can create for our users. So let me show you how to write this query. Back to our query editor, first we need to select the sql store database, now we need to select everything from the orders table, let's give it an alias, next we need to join this with the customers table. On o.customerId should be equal to to see that customer id. 
Nothing new so far, exactly like before. Now here we can write another join keyword, to join the orders table with order statuses table. So we type out order statuses, and also we give it an alias like os, what is our join condition? Well, back in the orders table, here we have this status column. So the value in this column should be equal to to the order status id column in order status table. Right? So back to the query, so order table dot status should be equal to order statuses dot order status id. Make sure to get the name right, don't have a typo, otherwise you're going to get an error. So this is how we can join three tables. Now in the real world, as you work on more complex problems, you will end up joining even ten tables. 
So this is not uncommon in the SQL world. Now let's go ahead and execute this query, first we get the columns from the orders table, followed by the columns from the customers table and so on. This result is so complex and hard to extract information from. So, let's explicitly select a few columns here. From the orders table, we want to select the order id column, as well as the order date, then from the customers table we want to select the first name, and the last name, and finally from the order status table, we want to select the name column. Now we can give this an alias, like status, that's better, let's execute the query one more time, so, here's the end result, we have order id, order date, the name of the customer, followed by the status of the order. 
Alright, for your exercise, take a look at this SQL Invoicing database. here. We have this table, payments, and these are the payments that each client has made towards a given invoice. Let's take a look at the data. So, we have these columns, like client ID, that identifies the client, So we can join this table with the clients table to see the name of the clients. Next we have invoice ID. You also have date, amount, and payment method. So similarly we can join this table with the payment methods table here. Let's have a look. and the data in this table, these are the payment methods, credit card, cash, paypal and wire transfer. So back to the payments table, I want you to write a query and join this table with the payment methods table as well as the clients table. 
Produce a report that shows the payments with more details such as the name of the client and the payment method. Alright, first we need to use the sql invoicing database. Now we can select everything from the payments table which we call p, next we need to join this with the client table which we call c, on p.clientId should be equal to c.clientId. Let me double check the column name to make sure I got it right. So back to the payments table, the column is called clientId. You also have a column called payment method that we should join to the payment method id column of the payment methods table. So back to the query, once again we use a join statement here, join with payment methods, we give it an alias pm on p.payment underline method should be equal to pm.payment method id. 
Make sure to type it out correctly, otherwise you're going to get an error. So let's go ahead and execute the query up to this point, there you go, Finally, let's handpick the columns that make the most sense so From the payments table, let's select a date followed by invoice ID What else do we have here? So we have client ID invoice ID date amount and payment method I'm gonna pick the amount column from here as well. So back to the query P dot amount now we need to add information about the client and let's take a look at this table, clients, so here we have columns like name, address, city, and so on. All we need here is the name column. So back to the query, from the clients table, let's select the name column, and finally from the payment method table, let's select, what is that column called? 
It's called name. So back to the query, pm.name. So here's the end result, Now we can put these columns in any order that we want, it doesn't really matter, let's execute the query and make sure everything works. So, on this date, for this invoice, we have a payment for this amount by this client using a credit card.






Compound Join Conditions:
all the examples you have seen so far, we use a single column to uniquely identify the rows in a given table. For example, in the customers table, we have this customer id column which uniquely identifies the rows in this table. But there are times that we cannot use a single column to uniquely identify records in a given table. For example, look at the order items table. In this table we have columns like order id, product id, and so on. Now if you look at the data, you can see that the values in the order id column are repeated, they're duplicated. You have 2, 2, 2, 6, 6, and so on. So we cannot use this column on its own to uniquely identify each record. 
The same is true for the product id. The values in this column are also duplicated. So in this table, we use the combination of the values in both these columns to uniquely identify each order item. As an example, in this order we have three items for products 1, 4, and 6, and for each product we have the quantity and unit price. So if we use the combination of the values in both these columns, we can uniquely identify each order item. In other words, we don't have two records for order id 2 and product id 1. We only have a single record for that item. Right? Now let's open this table in the design mode. So over here, click on this middle icon that looks like a tool, 
Note that this yellow key that represents the primary key exists on both these columns. This is what we call a composite primary key. A composite primary key contains more than one column. Now, why does this matter? Well, when you have a table with a composite primary key, you need to learn how to join that table with other tables. For example, here we have this table order item notes that we use to keep notes for each order item. Let's take a look at the data here. So we have this column note id, which uniquely identifies the records in this table, next to that we have order id and product id, you learn that the combination of these two columns uniquely represent an order item. 
So here for order number 2, for product number 1, we have two notes. Now let me show you how to join this table with the order items table. So back to our query, you can see that I have already selected the sql store database, So I'm not going to type out a use statement. Alright, let's select everything from the order items table, give it an alias, now we need to join this with order item notes, also we give it an alias, how are we going to join these tables? Based on two columns. Back to the order items table, these are the columns that we need to use in our join condition. So, in the order items table, we have this order id column, this should be equal to the same column in order item notes table. 
So, oin.order id. But this is not enough, we should also join these tables based on the product id column. So, we type out and, and then we type out our second condition. So, order items. product id should be equal to order item notes. product id. This is what we call a compound join condition. So we have multiple conditions to join these two tables.




Implicit Join Syntax:

In this tutorial I'm going to talk about the implicit join syntax in MySQL. So here we have a basic inner join, we're selecting everything from the orders table, joining it with customers table on orders.customerId equal to customers.customerId. Pretty basic. There is another way to write this query using implicit join syntax. Let me show you how that works. So, we select everything from Now here we can type out multiple table names. So, orders, customers. And we can also give them an alias, so c and o. And then we move this join condition to the where clause. So I'm going to copy this from here, type out a where clause, and paste the condition. These two queries are equivalent. What we have here is called implicit join syntax. 
Now even though mysql supports this syntax, it's something that I suggest you not to use, because if you accidentally forget to type out the where clause, you will get a cross join. Let me show you what I mean. So first I'm going to delete the first query, and execute this, so we get 10 records because we have 10 orders in this database. So far so good. But what happens if we accidentally forget to type out the where clause. Instead of 10 records, we're going to get probably 100 records. Because every record in the order table is now joined with every record in the customers table. This is what we call a cross join. Now later in this section I'm going to talk about cross joins in more detail, but what I want to point out in this tutorial is that it's better to use the explicit join syntax, so we use join, because this syntax 
you to type out the join condition. If you simply join orders with customers without typing the join condition, you're going to get a syntax error. So to recap, be aware of the implicit join syntax, but write all your joins using the explicit syntax.




Outer Joins:
Earlier in this section I told you that in SQL we have two types of joins, inner joins and outer joins. Now so far you have only seen examples of inner joins. And I also told you that this inner keyword is optional. So whenever you type out a join, you're using an inner join. In this tutorial we're going to look at outer joins and the problems they solve. So, let's start by writing a query that uses an inner join, and then we'll convert that inner join to an outer join. So, select everything from the customers table, join it with the orders table, on c.customerId should be equal to o.customerId. Pretty basic, right? Now for clarity, let's pick a few columns from these two tables. 
So from the customers table, I want to pick customerId, and first name, and from the orders table, I want to pick order Now finally, let's sort the result so we can clearly see what we get. So order by c.customer id. Let's execute this query and see what we get. So, here's the result. For customer number 2 called ines or ines, whatever, we have two orders, order 4 and order 7. Similarly for customer number 5, we have two orders and so on. Now there's something missing in this result. We only see customers who have an order in our system. These are customers 2, 5, 6, 7, 8, and 10. But if you look at the customers table, you can see that we have other customers like customer number 1, customer number 3, and so on. 
Now currently we don't have any orders for these customers, and that's the reason we don't see them in this result set. But what if you want to see all the customers whether they have an order or not? That's when we use an outer join. Let me show you how that works. So back to our query. The reason we only saw customers who have an order was because of this join condition. When joining these two tables, we are only returning records that match this condition. So for a given customer, if we do have an order, that record is returned. But as you saw a second ago, some of our customers don't have an order. So for those customers, this condition is not valid. And that is the reason they are not returned in the result set. 
To solve this problem we use an outer join. Now in sql we have two types of outer joins. We have left joins and right joins. When we use a left join, all the records from the left table, in this case customers, are returned whether this condition is true or not. So we get all the customers, and if they do have an order, we'll see the order idea as well. Let's execute this query and see what we get. So, There you go. Customer number 1 doesn't have an order and that's why we get null in this cell. Customer number 2 has 2 orders, 4 and 7, customer number 3 also doesn't have an order, so we have null for order id. This is the result of a left join. 
So back to our query, when we use a left join, all the records from the left table are returned whether this condition is true or not. Now what if we use a right join? In this case, all the records from the orders table are returned, whether this condition is true or not. Let's execute this query and see what we get. So, we get the same result as before, when we use an inner join. Because we are selecting all the records from the right table, which is the orders table. So we don't see all the customers, we see all the orders, right? Now if you want to use a right join, and still see all the customers, you need to swap the order of these tables. 
So, we put the orders table first, that's going to be our left table, and then we put the customers on the right side, so now with this query we'll return all the records from the right table, which is the customers table. And we execute this, we get all the customers, whether they have an order or not. Beautiful. Now one last thing before we finish this tutorial, I've seen developers use the outer keyword here, so either right outer join or left outer join. but technically the outer keyword is optional, just like the inner keyword, so you don't have to type it out. So I'm going to remove this to make my code shorter and easier to understand. So to recap, if you use the join keyword, you're doing an inner join, and if you do a left or right join, you're doing an outer join. 
Here's your exercise for this tutorial. I want you to write a query that produces this result. So we have three columns here, product id, name, and quantity that I picked from the order items table. So here we need to join the products table with order items table. So we can see how many times each product is ordered. However, if we do an inner join, we'll only see the products that have been ordered, but here I'm doing an outer join, so product number 7 has never been ordered, but still exists in the result. We see null for the quantity. So go ahead and write an outer join to produce this result. Alright, first we select everything from the products table, and then do a left join with the order items table. 
Our join condition is p.product id equals oi.product id. So because we're using a left join, we'll get all the products in the products table, whether this condition is true or not. If they have never been ordered, we'll still see them in the result. Now, let's pick a few columns for clarity, so p dot product id, p dot name, and oi dot quantity. That's it, let's execute the query, we get the same result as before, so all the products are here, and product number 7 has never been ordered, so we see null for the quantity.





Outer Joins Between Multiple Tables: 
Similar to inner joins, we can use outer joins between multiple tables. Let me show you. So here's the query that we wrote in the last tutorial. We're doing a left join between customers and orders tables. So when we execute this query, we get all the customers whether they have an order or not. If they have an order, we see the order id. Beautiful. Now if you look at the orders table, you can see that some of our orders have a shipper id. these are the orders that have been shipped. So now let's join the orders table with the shippers table to display the name of the shipper in the result. So back to our query, after this left join, let's write another join, here I'm doing an inner join. 
So let's inner join the orders table with the shippers table, join shippers, we call it sh, on, what is the join condition? Well, o.shipper id, should be equal to sh.shipper id. Alright? So in this query we have a left outer join and an inner join. Let's see what we get. Alright, we only see 5 records, but we have more orders. So here we have the same problem we had before. Some of our orders don't have a shipper and that is why they are not returned here. In other words, this join condition is not true for some of our orders. So back to the orders table, as an example, this first order doesn't have a shipper, shipper id is null, and that is why it's not returned in the query result. 
So to solve this problem, we should use a left join. We want to make sure that all orders are returned, whether they have a shipper or not. So back to the query, we need to replace this inner join with the left join. So let's execute the query and see what happens. Now we should have quite a few more orders, there you go. Now to make this example more interesting, I'm going to add the shipper name here. So, back to our select clause, let's add a new column, so shipper.name. And we can give it an alias like shipper. Let's execute the query and here's the result. So we get all the customers whether they have an order or not, and for those who do have an order, we get all the orders whether they have a shipper or not. 
This is the power of outer joins. Now in the last tutorial you learned that you can get the same result with both a left join or a right join, you just have to swap the order of the tables. However, as a best practice, avoid using right joins, because when you're joining multiple tables and you have left and right and inner join, things get really complex. Someone else reading your code will have difficulty visualizing how you're joining these tables. As an example, if you had a right join here, and then a left join after, it would be harder to visualize how these tables are getting joined. So as a best practice, avoid right joins and use left joins instead. And here is your exercise for this tutorial. 
I want you to write a query that produces this result. So here we have these columns, order date, order id, the first name of the customer, the shipper, and you can see that some of our orders are not shipped yet, so here we have null. And finally, the status. So go ahead and spend 2-3 minutes on this exercise, when you're done come back and continue watching. Alright, let's select everything from the orders table, now we should join this with customers on o.customer id should be equal to c.customer id. here I'm using an inner join, because every order does have a customer, so this condition is always valid, it doesn't matter if you use a left join or an inner join here, okay? Now, before going any further, let's pick our columns, so from the orders table, I want to pick order id, followed by order date, and then customer.first name, which we can optionally rename to customer. 
Alright, Alright, next we need to select the shipper. So, we join the result with the shippers table on order.shipper id equal to shipper.shipper id. However, if we use an inner join here, because some of our orders don't have a shipper, we're only going to see the orders that have been shipped. Let me show you. So for clarity, I'm going to add the shippers name here, so shipper.name as shipper. Let's execute the query, there you go. We only see the orders that have been shipped. But we want to see all the orders, right? So, we need to change the second join to a left join. So all orders are returned whether they have a shipper or not. Let's execute the query one more time. 
There you go. Now we see all the orders from number 1 to number 10. Beautiful. Finally we need to add the status column here. So we need to do another join here, join with order statuses which we abbreviate as os on o.status equal to os.order status id. You can see that I have designed this database such that sometimes our column names are exactly identical, but in other cases they don't match. So in the order table we call this column status as opposed to order status. status id, and this is deliberate, because a lot of real databases are like that all right now let's add the status name here, so order status the name as status execute the query and we can see all the orders here, for each order we have to date the customer the shipper and the status.














Self Outer Joins:
Earlier we talked about self joins in SQL. So here in the SQL HR database, we have this employees table, we wrote a query to get all the employees and their manager. So here we have this column, reports 2, that specifies the manager for each employee. So let's go back and rewrite this query to get all the employees and their manager. Back to our query editor window, first let's use a SQL HR database, then select everything, from the employees table, we give it an alias, and then join it with itself, so this is what we call a self join, now we're going to use a different alias like m for managers, now, what is the join condition? e.reports2 should be equal to m.employee id, right? 
Now for clarity, let's pick only three columns, so e.employee id, e.reports2 first name, and m.first name, which we rename to manager. Alright, let's execute this query and see what we get. So, here is the result, as we can see all these employees have the same manager. However, there is something missing here. We don't have a record for this person, this manager himself. So what is missing is a record where we can see the employee id for this person, their name, and their manager which should be null, because this person is the CEO or the head of the company. But why is this happening? The reason is our inner join. Because this condition we have here will only return people who have a manager. 
We can solve this problem by using a left join. So, we do a left join because we want to get every employee in this table, whether they have a manager or not. Okay, now let's execute the query one more time. There you go. now we have a record for this person, the manager, as you can see this person does not have a manager, that's why we have null here.
















The USING Clause: 
In our database, here we have a simple query that joins the orders table with the customers table. And here's our join condition. You have seen several examples of this before. Now as our queries get more complex, these join conditions get in the way. They make our queries hard to read. But the good news is that in MySQL we have a powerful feature for simplifying these queries. If the column name is exactly the same across these two tables, we can replace the on clause a using clause which is simpler and shorter. Let me show you. So I'm going to comment out this line and instead type out using in parenthesis we type out the column name, that is customer id. What we have on line 7 is exactly identical to what we have on line 6, but it's shorter and easier to read. 
So let me delete this line, we can add another join statement here to join the orders with the shippers, so join with shippers using shipper id. In both these tables we have a column with the exact same name. Alright, now let's execute this query, this is what we get, we have the order id followed by the first name of the customer. Let's add a new column here, so I'm going to add sh.name, that is the name of the shipper, so shipper, now obviously because some of our orders are not shipped, we need to replace this inner join with a left join. So we can use the using keyword with both inner and outer joins. Let's execute the query one more time, there you go, now we have the name of the shipper next to each order, beautiful. 
However, we cannot use this technique to join the result with the order status table. Because in the order table we have this column called status, but in order status table this column has a different name. it's order status id, let me show you, so order status columns, there you go, order status id. So the using keyword only works if the column name is exactly the same across different tables. Now what if we have multiple columns in our joint condition? For example, earlier we talked about this order items table, I told you that in this table we have a composite primary key, which basically means a primary key that consists of multiple columns. So the combination of these two columns uniquely identify each record in this table. 
Now if you want to join this table with order item notes table, in our join condition, we should compare both these columns with their corresponding columns in the order item notes table. So let's quickly write that query and then simplify it with the using keyword. So select everything from order items, now join it with order item notes, on, so here we need to compare oi.order id with oin.order id, and oi.product id equal to oin.product id. This join condition is kind of messy, it's hard to read this query. Now we can simplify this query with the using keyword. So we type out using, in parenthesis, we add both columns and separate them using a comma. So order id and product id. Isn't that better? 
Now for exercise, back to our SQL invoicing database, write a query to select the payments from the payments table and produce something like this. So in this table we have the date, the client, the amount, and the payment method. We can see on what date who has paid how much using what payment method. Alright, I'm going to use the SQL invoicing database, and then select everything, from the payments table, join it with the clients table, using client ID, because in both these tables, we have the client ID column. Next we need to join this with payment methods, however, the column name between these two tables is different. So, in the payments table we have a column called payment method, but in payment methods table, our column is called payment method id. 
So here we cannot use the using keyword. And we'll have to use the on clause, so on p.payment underline method equals pm.payment method id. Now let's pick our columns, so payment method client.name, and we rename this as client, next we pick the amount, and finally the payment method, so let's rename that to payment, underline method, and execute the query, there you go, this is what we get, the date, the client, the amount, and the payment method.





















Natural Joins:
In my skill we also have another simpler way to join two tables, it's called a natural join and it's easier to code, but it's not something that I recommend because sometimes it produces unexpected results. But let me quickly show you how it works in case you see it somewhere, so at least you're familiar with it. So back to the previous example, let's select everything from the orders table, now we should do a natural join with the customers table. Now with this natural joins, we don't explicitly specify the column names. So the database engine will look at these two tables and it will join them based on the common columns. The columns that have the same name. And that is the reason this query is shorted right. 
So for clarity, let's pick a couple of columns here, o.order id and c. let's say first name. Let's execute the query, there you go. So we see all the orders and the customers who placed them. So natural joins are really easy to code, but they can be a little bit dangerous because we're letting the database engine figure out or guess the join. We don't have control over it. For this very reason, natural joins can produce unexpected results and that's why I discourage you to use them.








Cross Joins: 
In this tutorial we're going to look at cross joins in sql. We use cross joins to combine or join every record from the first table with every record in the second table. Here's an example, let's select everything from the customers table, now here we do a cross join with the products table, so every record in the customers table will be combined with every record in the products table. And that is why we don't have a condition here, okay? So, this is what we call a cross join, now for clarity, let's pick a couple of columns, like c.first name, we rename it as customer, and then product.name, which we rename to product. Also, let's sort the result by customer.first name. Now let's execute the query, here's the result of a cross join. 
So first we have Amber as the customer and here are all the combinations of ember with different products next we have Barbara or whatever it is and again we have the combination of this customer with all the products now in this particular example it doesn't really make sense to use a cross join a real example for using cross joins is where you have a table of sizes like small medium large and a table of colors like red blue green whatever and then you want to combine all all the sizes with all the colors. That is when you use a cross join. Now what we have here is called the explicit syntax for a cross join. We also have the implicit syntax which looks like this. 
Instead of typing out the cross join, we type out multiple tables in the from clause. So customers and orders. Both these queries produce the same result. But I personally prefer to use the explicit syntax because it's more clear. And here's a simple exercise for you. Do a cross join between shippers and products. First do it using the implicit syntax and then using the explicit syntax. It's pretty straightforward, I just want you to get your hands dirty in the code and get used to this syntax. Alright, first I'm going to use the implicit syntax and then I'll show you the explicit syntax. So let's start by selecting everything from shippers, and products, now for clarity let's pick two columns, shipper.name which we rename to shipper, and product.name which we rename to product, and finally let's order everything by shipper.name, let's execute the query, this is what we get, so the combination of all shippers and all products, beautiful, now let's use the explicit syntax, 
So we select everything from the base table, in this case shippers, and then do a cross join with products. That produces exactly the same result.





















Unions:
We covered everything about joints, you learned that with joints we can combine columns from multiple tables, but in sql we can also combine rows from multiple tables. And this is extremely powerful, let me show you how that works. First let's have a quick look at our orders table, so select everything from the orders table. Now if you look at the data, we can see that the first order was placed in the current year, 2019. All the other orders were placed in previous years. Now let's say we want to create a report, get all the orders, and next to each order add a label. If the order is placed in the current year, the label is going to be active, and if the order was placed in previous years, we want to label it as archived. 
So, let's change our query and add a condition here. First we want to get all the orders in the current year. So where order date is greater than or equal to 2019 0101. I just want to highlight that this is not the ideal way to get the orders in the current year. Because here we have hard coded 2019. So if you execute this query next year, we're not going to get the right result. But don't worry about this for now. Later in the course I will show you how to get the orders in the current year without hard coding a date here. So, let's execute this query. Now we get only one order. Let's handpick a couple of columns here. So, order id, 
and order date. And also I want to add a string literal here, like active. Right? Let's execute this query, this is what we get. We have three columns, order id, order date, and active, and in this column currently we have the string value, active. Now let's rename this column to status. And execute the query, that is better. Now we want to write another query similar to this, that will return the orders in the previous years, but with a different label, archive. So, to save time, I'm going to copy these few lines, and paste them right after our first select statement. Now note that here we have a syntax error because we didn't terminate the first select statement with a semicolon, but don't worry about it, we're going to get back to this in a second. 
So for the second query, we want to return a different label, archive, and we want to change our condition to less than 2019. Now, select only these few lines, and execute this query either by clicking on this icon here, or using the keyboard shortcut that you learned earlier in the course. So, there you go, here are all the orders from the previous years with the label archived. This query returns 9 records, the previous query returned 1 record. Now using the union operator, we can combine data from these two queries. So, in between our select statements, we type out union, now let's execute the query one more time. So here's our first order in the current year that is active, and below that we have all the orders in the previous years. 
So using the union operator, we can combine records from multiple queries. Now in this example, both our queries are against the same table, but we can also have queries against different tables, and then combine the result into one result set. Let me show you another example. So I'm going to delete everything here, let's select the first name from the customers table, and then we can union that with select the name from the shippers table. Let's execute the query, so in one result set, we can see all the customers and all the shippers. As far as I know there is no real world use case for this particular query, but what I want to point out is that with union you can combine results from multiple queries. 
These queries can be against the same table or different tables. In your database you could have a table like archived orders and another table like orders, and then you could combine all the archived and active orders into one result set. Just remember that the number of columns that each query returns should be equal, otherwise you're going to get an error. For example, let's select the first name and last name from customers, and then union that with the name of shippers. When we execute this query we'll get an error, because the first part of this query returns two columns, but the second part returns one column. So MySQL doesn't know how to combine these records. And one last thing before we finish this tutorial. 
If you look at the result here, the name of this column is based on the first query. So the first query returns first name, and that's why this column is called first name. If we change the order of these queries, and move this union up here, now let's run this query, as you can see our column is called name. So whatever we have in the first query is used to determine the name of these columns. Here we can also rename the column to let's say full name. There you go. Alright, here's your exercise for this tutorial. Write a query to produce this report. So here we have four columns, customer id, first name, points, and type. As you know, we don't have this column in the customers table, so we have calculated the values in this column based on the points each customer has. 
If they have less than 2,000 points, their type is bronze, if they have between 2,000 to 3,000 points, they are silver customers, And if they have more than 3000 points, there are gold customers. Also note that here we have sorted the result by the first name. So go ahead and spend 2 minutes to write this query. Alright, first let's get the bronze customers, so select everything from customers, where points is less than 2000. Now here we want to pick 3 columns, customer id, first name, and points. And finally we add a new column with a string literal, bronze. Let's run this query and see what we get, so these are all the bronze customers, but the name of this column is bronze, we don't want that. 
So let's rename this to type. Now this is off the screen, so I'm going to break this up into multiple lines, that makes our query cleaner and easier to read. So, there you go, let's run the query one more time, Now the column is called type, beautiful. Now we should do a union, and repeat this query, but extract the silver customers. So I'm going to paste this query here, and then make a couple of changes here. I'm going to replace bronze with silver, and change the condition to between 2000 and 3000. Let's run our query and see what we get. So, we have all the bronze customers first, followed all the silver customers. So the order of these records are based on our queries. 
In our first query we got the bronze customers, that's why they are listed first. But this is not what we want. We want to order the result by the first name of our customers. So, let's apply an order by at the end, so order by first name. Now there is one more piece remaining. We should do a union one more time, and write a query to get the gold customers. so I'm going to select these few lines, and paste them here, now let's change silver to gold, and the condition to points greater than 3000. And finally we do an order by. Let's run the query one more time, and here's the end result, our customers are sorted by their first name, we see all the bronze, silver, and gold customers.




Inserting, Updating and Deleting Data:


Column Attributes:
In this section I'm going to teach you how to insert, update, and delete data. Before we get started, let's have a closer look at our customers table. So click on this middle icon to open this table in the design mode. What you see here might look a little bit intimidating at first, but trust me this is actually so easy, and in this tutorial I'm going to explain exactly what we have in these columns. So, on the left side you can see the column name, next to that you can see the data type for each column, So our customer id column can only accept integer values, integers are whole numbers, like 1, 2, 3, 4, and so on. They don't have decimal points. First name is a varchar, which is short for variable character. 
Now here in parenthesis you can see 50, that basically means in this column we can have a maximum of 50 characters. Now if the name of a customer is only 5 characters long, we only store those 5 characters. So even though the maximum length for this column is 50, we're not going to waste space if the customer's name is less than 50 characters. That is why here we have varchar, which is short for variable. In contrast we have another data type that is character. If you had character 50 here, and the name of the customer was only 5 characters long, my skill would insert additional 45 spaces to fill this column. So this is a waste of space. So as a best practice, 
most of the time we use varchar to store string or textual values. Now here on the right side we have this column pk, which is short for primary key. So customer id is marked as the primary key and that is why we have this yellow key here. So the values in this column uniquely identify each customer. Next to that we have nn, which is short for not null, and that determines if this column can accept null values or not. In this case, every customer record must have the customer id, first name, last name, as well as these other attributes, but birth date and phone are optional, so in these columns we can have null values. Now we have another column here, ai, which is short for auto increment, and this is often used with primary key columns, so every time we insert a new record in this table, we let mysql or our database engine insert a value in this column. 
So essentially it gets the customer id for the last row, and it will increment it by 1 at the time we insert a new record. So if you look at the data, you can see that currently we have only 10 customers here, so if you have a new customer here, mysql will assign 11 to the new customer. Okay? And finally here we have another column that specifies the default value for each column. For example, for our birth date and phone columns, the default values are null. So if you don't supply a value, mysql will use the null values for these columns. Similarly we have another default value for the points column, so if you don't supply the points for a customer, mysql will use 0. 
Now we have a few other columns here which are not important at this stage, you will learn about them later in the course. So now that you understand the attributes of each column in this table, let's go ahead and insert data into this table.















Inserting a Row:
In this tutorial you're going to learn how to insert a row into a table. For that we're going to use the insert into statement. Where are we going to insert this row? Into the customers table. So we type out the name of the table here, followed by the values clause. And here in parenthesis we supply the values for every column in this table. So back to our table definition, these are all the columns, first we need to supply a value for the customer id column. However, in this column, the auto increment attribute is enabled. And as I told you before, if we don't supply a value, mysql will generate a unique value for us. So we can go back to our statement and either assign an explicit value, or use default to let mysql take care of generating this value. 
This is the preferred approach. Because if you use an explicit value like 200, it is possible that you might have another customer with the same id, So when you execute this statement, you're going to get an error. Because you cannot have duplicate values in this column. Every value should be unique. So here we're going to use the default keyword to let mysql generate a unique value for the customer id. After that, we need to supply a value for the first name and last name columns. So, let's say John Smith. Note that I have enclosed these values with quotes, because as I told you before, in SQL, we should always enclose and date values with quotes. Either single or double quotes. Okay? Now, what else? 
Back to our customers table, after the last name we have the birth date. However, as you can see this column is optional because this checkbox is not checked. So here we can use null or an explicit value. Null means the absence of a value. So back to our statement, we can type out the birth date, like 1990 January 1st, or we could use the null keyword to leave out this value. Now in this demo I'm going to use a valid date, now to make this code cleaner and more readable I'm going to break it up into multiple lines, that's better, now back to our table, next we have phone, and phone is also optional because this checkbox is not checked, and null is the default value for this column. 
So here we can explicitly pass null, or use the default keyword and let mysql put null into this column. It's exactly the same. So, back to our statement, we can pass null or default. Both these keywords will have the same result. In this case I'm going to use the null keyword. Alright, let's have one more look at our table. Next we have four more columns that are required, so address, city, state, and points. And note that points has the default value of 0, So we can either use an explicit value like 200, or use the default keyboard and let mysql generate 0. So, back to our statement, let's type out an address, it doesn't really matter, followed by a city, and a state, let's say California, and finally points. 
Again, we can use an explicit value, or default. So this is how we can insert a row into a table. However, in this example, we are only supplying values for first name, last name, birth date, and these address fields. So we are leaving out the phone number, the customer id, and the points. So there is another way to write this statement. Let me show you. So, after the table name, we can optionally supply the list of columns that we want to insert values into. In this case, first name, last name, birth date, Now once again, I'm going to break up this statement into multiple lines. So, three more columns, address, city, and state. So these are the six columns that we're going to supply values for. 
With this change, we don't have to use this default or null values, we only supply values for these columns. So I'm going to remove default from here, then null, and finally this last default keyword. So these six values that we supplied here are used for these six columns. Now with this change, we can also reorder the columns. We don't have to list them in the same order that they are defined in the customers table. For example, we can put the last name first, and then obviously we should also swap the order of these values, so we can list them in any orders. Now let's execute this statement, Now if you look at the output window, down the bottom you should see the statement followed by one rows affected. 
Unfortunately I cannot resize this window to show you this message, but if you look down below you can see that one record was affected, which basically means one record was inserted into this table. Now let's look at the data in the customers table, so the last row is the one that we inserted, you can see that mysql automatically generated the value 11, this is the effect of auto increment attribute. So it takes the value of the last row and increments it by 1. So here we have the first name, last name, the birth date, we didn't supply a value for the phone attribute, so that's why we have null here, we also have address, city, state, and the default value of 0 for the points.












Inserting Multiple Rows:
In this tutorial you're going to learn how to insert multiple rows in one go. For this demo we're going to use this shippers table, let's have a quick look at the table definition. So here we have two columns, shipper id and name, shipper id is a primary key, it's not nullable, and it's an auto incremented column. So we're going to let mysql generate values for this column. Easy. We only need to supply a value for the name column. So back to our query editor window, we type out insert, into shippers, in parenthesis we specify the name of the columns we want to insert values into, in this case name, followed by the values clause, here we add a pair of parenthesis with a value like shipper 1, now to insert multiple rows, all you have to do is to add a comma followed by another pair of parenthesis, so shipper 2, and one more time, comma, parenthesis, shipper 3. 
This is how you can insert multiple rows in one go. Now let's execute this statement, alright, and then inspect the data in the shippers table. There you go. So initially we had only 5 shippers, and here are the 3 new shippers that we inserted. Note that MySQL automatically generated the values for the shipper id column. So we have 6, 7, and 8. Alright, here's your exercise for this tutorial. Write a statement to insert three rows in the products table. That's pretty easy, you can knock it out in a minute. So here's our products table, we only have four columns, we're going to leave out the first column because it's an auto incremented column, so we only have to supply values for name, quantity, and unit price. 
Back to our query editor window, let's insert into products, the columns are name, quantity in stock, and unit price. And the values are going to be, let's say product 1, stock is going to be 10, and the unit price is going to be 1.95, now I'm going to select these values, copy, comma, paste it like this, change the values accordingly, and finally the last row, product 3, there you go, let's execute the statement, alright, and then verify the result, so in the products table, now we should have three new records, now the IDs you see here are 15, 16, and 17, because before recording this video, I actually inserted a few records in this table, and then deleted them. So I had product IDs 11, 12, 16, 
13 and 14. Now even though they're actually deleted from this table, mysql remembers their ids, so instead of incrementing 10 by 11, it incremented 14 which was the last record from before, and that's why it generated 15. On your computer, the ids are going to be 11, 12, and 13.











Inserting Hierarchial Rows:
So far you have only learned how to insert data into a single table. In this tutorial I'm going to show you how to insert data into multiple tables. Here's a really good example. Look at the orders table. What columns do we have here? We have the order ID, we have the customer ID, so we know who has placed this order, we know the date of the order, we know the status, comments, as well as shipping information. But the actual items for this order are not in this table. They are in the order items table. So in this table we have four columns, we have the order id, so we know what order this item is for, we have the product id, so we know what product has been ordered, at what quantity and what price. 
So an actual order can have one or more order items. This is what we call a parent child relationship. So in this relationship the orders table is the parent, and the order items table is a child. So one row in the orders table can have one or more children inside the order items table. Now in this tutorial I'm going to show you how to insert an order and all its items. So you will learn how to insert data into multiple tables. Alright, back to our query editor window. First we need to insert the order, so insert into, let me close the navigator panel, alright, we want to insert a record into the orders table, now what columns do we have here? So we have these columns, but only the first four are required. 
And actually the first one, we don't want to worry about that because that's an auto increment column. So we only want to supply values for customer id, order date, and status. So back to our query, we specify those columns here, customer id, order date, and status. Now let's supply the values. In the customer id column, we need to add a valid customer id. So let's have a quick look at our customers table, there you go. In this table we have 11 records, so these are the valid customer IDs. Now back to our query, let's use one for customer ID, and then 2019 January the 2nd for the order date, and one for the order status. Once again, in this column we need to insert a valid order status ID. 
If we don't supply a valid ID, MySQL is going to yell at us. So, we insert an order here, now we need to insert the items. Now back to our order items table, in this table we have this order id column. So here's the tricky part, as soon as we insert an order, MySQL is going to generate an id for our new order. Now we need to be able to access that id in order to insert the items in this table. How can we do that? Well, back to our query editor window, In mysql we have a bunch of built in functions, and a function is basically a piece of code that we can reuse. Just like the functions or features in your tv. 
Every tv comes with a bunch of built in functions like power on, power off, change the volume, change the channel, and so on. So mysql and other database engines come with a bunch of built in functions that we can use in our programs. One of these functions is last insert id. we can call or execute this function by adding parenthesis here, and this will return the id that mysql generates when we insert a new row. So, before going any further, let's just select this and make sure we get the right result. Now we have a syntax error here because we didn't terminate the first statement with a semicolon, alright, now let's execute this query, alright, so the id of the new order is 12. 
Let's verify that. So back to the orders table, let's look at the data, on my machine I have 12 records here, I actually created one just before recording this video, so on your machine you're going to have 11 orders. Now back to our query window, now that we know how to get the ID of the newly inserted record, we can use that ID to insert the child records. So, we're going to write another insert statement, insert into order items, let's have another look at the columns in this table. So we have four columns and all of them are required, so there is really no need to specify the column names in our insert statement, we simply supply values for order id, product id, quantity and unit price. 
So, here, in the values clause, we add parenthesis, what is our order id? That is the value returned from calling this function. So I'm going to cut this from here and put it here, next we need to supply a valid product id, let's say product 1, quantity, let's say 1, and the unit price 2.95 dollars. Now let's delete this select, we don't really need it anymore, and let's add another set of values, so once again we're going to call last insert id, to get the id of the new order, we're going to change the product to product number 2, and at a different price. That's it. Now let's execute these statements and see what we get. Alright, So, back to our orders table, let's refresh the records here, alright, so we have a new order, order number 13, beautiful, now let's look at the order items table, here's the order items, let's open the table, so we should have two items for order number 13. 
Beautiful, so this is how you insert hierarchical data in MySQL.














Creating a Copy of a Table: 
In this tutorial I'm going to show you how to copy data from one table to another. For example, in our orders table, currently we have about a dozen records. Now let's say we want to create a copy of this table called orders archive, and we want to insert every row that we have in this table into that new table. If we have 10 orders, we don't want to code an insert statement with 10 set of values. That is very time consuming. So I'm going to show you a powerful technique to quickly copy data from one table to another. First we need to create this new table, orders archived. For that we're going to use the create table as statement. So create table orders archived as. 
Now right after that we write a select statement to get everything from the orders table. Now let's see what happens when we execute this query. There you go, so back in the navigator panel, we have to refresh this view by clicking on this icon over here, now we have a new table, orders archive, let's look at the data, so you can see all the orders are here, and we have the exact same columns as the orders table. However, if you open this table in the design mode, you can see that in this table we don't have a primary key. So the order id column is not marked as a primary key. And also it's not marked as an auto increment column, So when we create a table using this technique, mysql will ignore these attributes. 
And that means, if you want to explicitly insert a record into this new table, we have to supply a value for order id, because this column is no longer an auto increment column. Okay? So, using create table as statement, you can quickly create a copy of a table. Now, we refer to this select statement as a subquery. So a subquery is a select statement that is part of another sql statement. Now we can also use a sub query in an insert statement, and that's a very powerful technique. It allows us to do really cool things. Let me show you. So first, let's right click the orders archive table, and click on truncate table, because we want to delete all the data in this table. 
Alright, it's asking for confirmation, let's truncate the table, so now back to this table, let's refresh the table, we don't have any records here, okay? Now back to our query editor, let's say we want to copy only a subset of records from the orders table into this table, like all the orders placed before 2019. So first let's select everything from the orders table where order date is less than 2019 January 1st. So, these are all the orders, orders number 2 to 10, beautiful. Now we want to copy these orders into the orders archive table. So, we can use this select statement as a subquery in an insert statement. We write insert into orders archive. Now we don't need to supply the column names, because we're going to supply values for every column that we have in this query. 
So, we delete that, and This is an example of using a select statement as a sub query and an insert statement. Let's execute this, alright, now back to the table, let's refresh the records, we only have the orders placed before 2019. Alright, here's a really really really cool exercise for you. Back to our sql invoicing database, look at the invoices table. So in this table we have these columns, invoice id, number, client id which is associated or related to the client id column in the clients table, followed by a few other columns. Now let's say we want to create a copy of the records in this table, and put them in a new table called invoices archive. However, in that table, instead of the client id column, we want to have the client name column. 
So you need to join this table with the clients table and then use that query as a sub query in a create table statement. Also, to make the exercise more interesting, I want you to copy only the invoices that do have a payment. So if you look over here, this payment date column determines if a payment has been made towards this invoice or not. So select only the invoices that do have a payment date. It's a really really good exercise, spend 2-3 minutes on this and then come back and continue watching. Alright, first I'm going to use the SQL invoicing database, now let's select everything from the invoices table, and join it with the clients table, here I'm going to use the using statement to simplify my join. 
What column are we going to use for joining? The client id column. Let's execute this query up to this point, alright, so first we see the client id column that is used for joining these tables, after that we have the columns from the invoices table, like invoice id, number, and so on, followed by the columns from the clients table, like name, address, and so on. Obviously we don't want all of these columns, we only need the columns from the invoices table, but we should replace the client id column with the client name column. So, let's have a quick look at the design of the invoices table, here we have invoices id, number, client id, we want to replace this column with the client name. 
So, back to our query, I'm going to pick invoice id, number, and then client.name, let's rename it to client, what other columns do we have here? We have invoice total and payment total, so let's add those as well, invoice as well as payment total, we also have three columns for dates. Invoice date, due date, and payment date. So, let me close the navigator panel, invoice date, payment date, and due date. Now technically because these columns only exist in the invoices table, we don't have to prefix them with a table alias. So we could simplify the code by like this. However, I personally prefer to prefix them because that gives me a more clear picture of how I'm joining these tables. It's just a personal preference, another developer might disagree, and that's perfectly fine. 
So whatever you prefer, that's perfectly fine. Let's execute the query and make sure we get the right result. So we have the invoice id, number, client, beautiful, followed by these other columns. Now we want to filter the result, return only the invoices that do have a payment. So we can either return records that have a payment date, or the records that have a payment total of greater than 0. Those are perfectly fine. So, back to our query, down the bottom, let's add a where clause, where payment date is not null. That's better. Let's execute the query one more time. Now we get only this handful of invoices, beautiful, finally let's use our query as a subquery in a create table as statement. So right before select we type create table invoices archived as, there you go, let's execute the query, beautiful, now back to the navigator panel, let's refresh the view, 
So here's our new table, invoices archived, let's look at the data, there you go. We only have the invoices paid, and here's the name of the client for each invoice, beautiful. Now just note that if you execute this query one more time, you're going to get an error because we already have a table called invoices archived. Later in the course I'll show you how to drop tables, that's pretty easy, but for now you can just right click and go to drop table, and then confirm, alright, and then you can run the query one more time.



Updating a Single Row:
In this tutorial, I'm going to show you how to update data in sql. So back to our invoices table, look at the first record here. The payment total for this record is 0, and obviously there is no payment date. Now let's imagine that there was a problem in the system that recorded this information. Let's say the client paid $10 for this invoice. So we should update this record in this table. That is very easy. Back to our query editor window, We use the update statement to update one or more records in a table. What table? In this case, invoices. Next we add the set clause, and this is where we specify the new value for one or more columns. In this case we want to update payment total, let's set it to $10, we should also update payment date, so we use a comma to add more columns. 
We set this to a date value, let's say 2019 March 1st, and then we type out a condition. With this condition we identified the record or the records that need to be updated. In this case we want to update the invoice number 1. So back to our query, we type out invoice id equal to 1. Let's execute this, beautiful. Now back to our table, let's refresh the data by clicking on this icon. Alright, you can see payment total is updated to 10, and we also have a payment date, beautiful. Now let's say we actually updated the wrong record, maybe we should have updated invoice number 3. So we should update this table one more time and restore the original values in these columns. 
Back to our query, we can set the payment total to 0, and the payment date to null. So we can use the null keyword to insert the null value in a column that accepts null values. Now back to the navigator panel, let's open this table in the design mode, you can see that the payment total column has a default value of 0, and the payment date column has the default value of null. So back in our query, we can also set payment total to default, and mysql will use the default value for this column, which is in this case 0. So let's execute this statement one more time, beautiful. Now back to the table, let's refresh the data, So payment total is set to 0 and payment date is null. 
Beautiful. Now let's go ahead and update the third payment. Look at the invoice total, that is $147. For this example, let's imagine that the client made 50% of the total amount on the due date. So, back to our query editor window, instead of using a literal value here like $70, we can write an expression. We want to calculate 50% of invoice total. So invoice total times 0.5. Now let me break this code into multiple lines so we can see clearly. Now we should set the payment date. As I told you, this client made the payment on the due date. So we can set this to due date. Whatever value we have in this column will be used to set the payment date. And obviously we need to update the invoice id, number 3, now back in the table, 
let's refresh the data, alright look, payment total is updated, and it's set to almost 50% of the invoice total. However, this number is truncated, so we don't have the digits after the decimal point, don't worry about it for now, we'll come back to this when we talk about data types later in the course. Also you can see that payment date is set to the same value we have in the due date column.






Updating Multiple Rows:
In the last tutorial you learned how to update a single record using the update statement. Now if you want to update multiple records, the syntax is exactly the same, but the condition that you type out here has to be more general. For example, back to the invoices table, you can see that we have multiple invoices for client number 3. We can write a statement to update all the invoices for this client. So back to our query editor window, we change our condition to where client id equals to 3. However, if you execute this statement with mysql workbench, which is the software we've been using in this course, you're going to get an error, because by default, mysql workbench runs in the safe update mode. 
So it allows you to update only a single record. You're not going to have this problem if you use another client for mysql, or if you write this statement in your application code. This is only specific to mysql workbench. Now let me show you how to get around this. So on the top, we go to mysql workbench menu, and then preferences. On this dialog box, on the left side, click on sql editor, and then down the bottom, untick this checkbox, save updates. So this prevents you from accidentally updating or deleting a bunch of records in a table. So, let's go ahead with this, now we need to reconnect to this instance of mysql. So, let's copy all the code here, and close this local instance window. 
Alright? Now on the homepage, double click this connection to reconnect, there you go, and then paste all that sql code. Now, let's execute this, beautiful, all the invoices for client number 3 were updated. Here we can also use the in operator, let's say we want to update all the invoices for client number 3 and number 4. So all the operators you learned to use in the where clause also apply here. But technically this where clause is optional, so if you want to update all the records in a table, you simply leave it out. Alright, here's your exercise for this tutorial. Back to our SQL store database, write a SQL statement to give any customers born before 1990 50 extra points. Alright, first I'm going to use sql store, then write an update statement, to update the customers table, set the points to points plus 50, so here we are using an expression to update the points column for anyone born before 1990. 
So where birth date is less than 1990, January 1st. Alright, let's execute this query, alright, now, let's open up the customers table one more time so anyone who was born before 1990 now has an extra 50 points.





















Using Subqueries in Updates:
In this tutorial you're going to learn how to use sub queries in an update statement, that's extremely powerful. So we're going to continue with the example from the last tutorial, but we're going to make it more interesting. Here we're updating all the invoices for client number 3, but what if we don't have the id of a client, we only have the name. For example, imagine you have an application, and in that application the user types in the name of the client. So first we should find the id for that client, and then use that id to update all their invoices. How do we do that? Well, let's have a quick look at our clients table. So here we have this client, my works, let's say we have the name, we want to find the id. 
So back to our query editor window, after this update statement, I'm going to write a select statement to select the client id column from the clients table, where name equals my works. Now here we have a syntax error because we didn't terminate the last statement with a semicolon, but don't worry about that, we're going to get back to that in a second. Let's just select these few lines and execute this query. The idea of this client is 2, beautiful. Now, we can use this select statement as a subquery in an update statement. So as I told you before, a subquery is a select statement that is within another SQL statement. So, instead of hard coding 3 here, we're going to use this select statement as a subquery, but we need to put it in parenthesis, so mysql will execute this query first, it will return the client id, and then use it in this condition. 
So for clarity, let's remove the line break and indent these few lines. So this is the end result. Now, we execute this query, and this updated all the invoices for this client. Now, what if this query returns multiple clients. For example, back to the clients table, let's imagine we want to update the invoices for all clients located in New York or California. So, we need to update our subquery like this, where state in California and New York. Now before executing the entire statement, let's just select our subquery and execute it to see what we get. So we get two client ids, one and three, beautiful. Now, because this query, this sub query returns multiple records, we cannot use an equal sign here anymore, so we need to replace this with the in operator. 
And now this statement updates the invoices for all clients located in these two states. Let's execute it, beautiful, everything worked. So as a best practice, before executing your update statement, run your query to see what records you're going to update. So you don't accidentally update the records that shouldn't be updated. Now here we have a subquery, but even if it didn't have a subquery, we could still query the records that we're going to update. Let me show you. So let's imagine we're going to update all the invoices where payment date is null. Before executing this entire update statement, I would run a query like this. Select star from invoices where payment date is null. Now let's execute this query, these are the two records that don't have a payment date. 
So once we're confident that we're updating the right records, then we come back here, and get rid of this select statement, and just attach the where clause to our update statement. Alright, here's your exercise for this tutorial. Back to our SQL store database, look at the orders table, As you can see, some of our orders don't have a comment. I want you to write a SQL statement to update the comments for orders for customers who have more than 3000 points. So customers who have more than 3000 points, regard them as gold customers. Find their orders, if they have placed an order, update the comments column and set it to gold customer. That's a really good exercise. Alright, first we need to find the gold customers. 
So, select everything from the customers table where points is greater than 3000. And by the way, because the current database is SQL invoicing, we either have to type out a use statement on the top or double click this database before executing this query. So, there you go. We have three gold customers, now we need to get the idea of these customers to use them in an update statement. So, we only select customer id here, and then use this select statement as a subquery and an update statement. So, update orders, set comments to gold customer, where customer id, because we're dealing with multiple customer ids, we need to use the in operator, and then to use this as a sub query we need to enclose it in parenthesis, that's it, let's indent the code, that's better, so here's the final solution.














Deleting Rows:
So you have learned how to insert and update data, in this lecture we're going to finish this section by learning how to delete data. That is very easy. We use the delete from statement to delete records from a table. Let's say the invoices table. Now optionally we can add a search condition to identify the records we want to delete. If you don't write this where clause with this statement, we'll delete all the records in this table. And obviously that's very dangerous, so be very careful when executing this statement. Now here, let's say we want to delete the invoice with the ID 1 so where invoice ID equals to 1 Now here we can also use sub queries. Let's say we want to delete all the invoices for the client called my works First let's find this client. 
So select everything from the clients table where name equals to my works Let's execute the second query so Here's our client Now we can get this client id and use it in our search condition. So where client id equals to, this is where we add our subquery, there you go, just like before, beautiful. So this is how we can delete data in sql.









Restoring the Databases:
we're done with this section, but before going to the next section, I want you to restore all these databases to their original state. Because in this section we added some data, we updated some data, we deleted some records, so if you don't restore these databases, you might see different results going forward. So, restoring these databases is pretty easy. Here in mysql workbench, on the top, go to the file menu and open sql script. Then navigate to the directory where you stored the sql script for this course. In case you lost that directory, go back to the first section, we have a lecture for downloading the supplementary materials. So, in this directory open, create databases.sql, now execute this script to recreate all of our databases. 
Alright, beautiful, now let's open up the navigator panel, you can see the databases disappeared from here, simply click on this refresh icon, beautiful. Alright, we're done with this section, I will see you in the next section.
















Summarizing Data:

Aggregate Functions:
In this section you're going to learn how to write queries that summarize data. For example, you will learn how to write queries that report sales by clients or state. So we can see how much we have sold in each different state. These are the answers to some common questions that businesses ask. So the stuff that I'm going to show you in this section are extremely useful, especially if you work in a large organization with lots of data. Every single day you'll have to write queries to summarize data. So let's get started. The first thing you need to understand is how to use aggregate functions in SQL. So a function as I told you before is a piece of code that we can reuse. 
MySQL comes with a bunch of built-in functions, some of these functions are called aggregate functions, because they take a series of values and aggregate them to produce a single value. For example, we have the max function for calculating the maximum in a series of values. We also have min, average, sum, calculating the total as well as count now with all these functions as you can see we'll have to use parentheses to call or execute them now let me show you a few examples of these functions so in this demo I'm going to use our sequel invoicing database let's select the maximum of invoice total column from the invoices table there you go So our highest invoice total is $189. Now look at the name of this column. 
It's set to the same expression we used here. So let's rename it to something more meaningful like highest. Now in the same query we can also calculate the minimum. So min of invoice total as lowest. We can also add the average of invoice total as average. Let's execute the query and So here's our lowest invoice total, and the average of all our invoices is about $150. Now in this example, I'm applying these functions on a column that has numeric values, but you can also apply them on dates and strings. For example, we can change invoice total to payment date, now, the value that we have here is the latest date when we received a payment. Okay? So let me revert this back to invoice total. 
We can also calculate the total of values in this column using the sum function. So sum of invoice total as total. And finally count to count the records. So invoice total one more time as number of invoices. Let's execute the query. So in this table we have 17 invoices and our total sales is just over $2500. Now one thing you need to know about these aggregate functions is that they only operate on non-null values. So if you have a null value in this column, it's not going to be included in these functions. Let me show you where that matters. So as another example, I'm going to calculate the count of payment date. So let's rename it to count of payments. So as you know, this column accepts null values, so when we execute this query, 
we get 15, because not all of our invoices have been paid. So the count function returns the count of records with non-null payment dates. Now if you want to get the total number of records in a table, irrespective of null values, you would have to use count of star. So as total records, let's execute it, there you go. So in this table we have a total of 17 records. Now let me delete lines 6 and 7, we don't need them anymore. Another thing you need to understand here is that most of the time we use column names here, but we can also write an expression. For example, here we can write an expression like invoice total times 1.1. When mysql tries to execute this query, first it will get the values in this column, it will multiply each value by 1.1, and then it will apply the sum function on those values. 
Okay? Also, if you have a filter here, these functions calculate the summary values for records that match your search criteria. For example, let's say where invoice date is greater than 2019 July 1st. So we only want to get the invoices for the second half of the year. Now when we re-execute this query, we're going to see different values here, let me show you. So we only have 7 records that match this criteria. and our total is also changed. So here we have the total sales for all the invoices issued in the second half of the year. And here's one last thing you need to know. By default, all these functions take duplicate values, if you want to exclude duplicates you will have to use the distinct keyword. 
Let me show you an example. So instead of calculating the total number of records, let's calculate the records that have a client id. So, we get 7, but if you look at the data in this table, you will see that many of these clients are duplicated. Let's have a quick look here. So here's the invoices table, there you go. So we have client 5 duplicated in a few places. Same is true for client 3. So our count function is returning the count of records that have a client id. It doesn't care if we have duplicates or not. If you want to count only the unique values, you will have to use the distinct keyword. So back to our query, here in our count function, 
we use the distinct keyword, and now when we execute this query, instead of 7 we get 3, because we have 3 unique clients that have an invoice after this date. Alright, here's a fantastic exercise for you to practice what you have learned so far. Write a query against the invoices table to generate this report. So here we have 4 columns, date range, total sales, total payments, and what we expect, which is the difference between these two columns. Now in this table we have three records, first we see all the amounts for the first half of 2019, then we see all the amounts for the second half of 2019, followed by the total. So go ahead and spend 2-3 minutes on this exercise, when you're done come back and continue watching. 
Alright, first calculate all the values for the first half of 2019. So we select a string literal or a label first half of 2019, and we give it an alias as date range, otherwise the name of our column is going to be first half of 2019. That's not what we want, right? Next we calculate the sum of invoice total, and rename it to total sales, then we calculate the total payments, so payment total as total payments, and finally, sum of invoice total minus payment total. And we call this what we expect. We're going to select all these values from the invoices table, where invoice date is between 2019 January 1st and 2019, June the 30th. So I'm going to put this on a new line so you can see clearly, there you go, this is our date range, this is our date range for the first half of the year, right? 
Let's execute this query, alright, this is what we get, beautiful, now we need to calculate the same values for the second half of the year. So, to split things up, I'm going to copy this entire query, then after our select statement, I'm going to write a union, and then paste our select statement. Now we change this label to second half of 2019, as well as our search criteria. So we only want to select the invoices where invoice date is between July 1st and December 31st. Let's execute our query one more time, alright, beautiful. finally we need to calculate the total for all invoices in 2019. So one more time we're going to use the union operator and paste our query, then we're going to change the label to total, and finally our search criteria is going to be from January 1st to December 21st. 
Let's execute the query one more time, and here's the end result.


















The GROUP BY Clause:
In the last lecture you learned how to summarize data using aggregate functions. So here we have a simple query that calculates the total sales using the sum function. And here's the result. Our total sales is just over $2500. But what if we want to see the total sales per client? That is when we need to group data by one or more columns. So here's how it works. Right after the from clause, we use the group by clause, and here we type out one more columns for grouping data. For example, we can group data by client id, and now when we execute this query, instead of one value, we see four values. These are the total sales for each client. But we don't see the client id here, so let's add it to our select clause, client id, and now next to each client, we can see the total sales value. 
Now here by default, data is sorted by the column specified in our group by clause, but we can change the sort order using an order by clause, so order by, let's say total sales in descending order. Now let's execute the query again, and here's the result, that is better, we can also apply a filter before grouping our data, let's say we want to calculate the total sales for each client, but for the second half of the year. So, here we use our where clause, where invoice date is greater than 2019 July 1st. Technically here we need greater than or equal to operator. So, let's execute the query, now we get a different result. So this is how we can group data using a single column. 
Now before I show you how to group data by multiple columns, I want you to remember the order of these clauses. So, just like always, first we have the select clause, followed by from, optionally we can have a where clause, followed by group by, and order by. So the group by clause is always after the from and where clauses, and before the order by clause. So if you put the order by first, and execute the query, we're going to get a syntax error, take a look, because the group by clause is not valid at this position. So, let's fix the issue, alright, Now let me show you how to group by multiple columns. So, I'm going to join our invoices table with our clients table. 
Let's give it an alias, then join it with clients using what column? Client ID. Now let's have a quick look at our clients table. In this table we have these columns like name, address, city, state, and phone. So let's say we want to group our data and see the total sales per state and city. So back to our query, we're going to change our group by clause, and replace client id with state and city. Now let's also change our select clause, so we're going to select the state and the city, and finally the sum of invoice total for each state and city combination. So, to make things simple, I'm going to delete our where clause, that is better, Let's also remove the order by clause, we don't really need it at this point. 
Now look at what we get. Now that we're grouping by multiple columns, we see the total sales for each state and city combination. So when we use multiple columns in the group by clause, we get one record for each state and city combination. Now in this example in our data set, we don't have multiple cities per state, but you're going to see an example of that as part of your exercise for this tutorial. Alright, here's your second exercise for this section, it's a fantastic exercise. So we have a query that generates this report. We have three columns, date, payment method, and total payments. So we can see the total payments for each date and payment method combination. For example, on January 8th, we received a total amount of $32 using credit card, and $10 using cash. 
So here we're grouping by multiple columns. Each group is a unique combination of these two values, date and payment method. Write this query against the payments table in this database. You will see my solution next. Alright, here's the solution. Whenever I want to solve a complex problem, I start by dividing that problem into smaller and easier to solve problems. In this example, instead of grouping by multiple columns, let's start by grouping by date only. So we want to see the total payments for each date. That is easier. So, let's select the date column, as well as the sum of amount from the payments table. Now, let's give this an alias, like total payments, and finally group our data by the date column. Let's execute the query, this is what we get, 
So we have solved almost half of the problem. Now as you can see our data is not sorted by the date column, so the next thing I want to do is to sort the data by the date column. So that is pretty easy. After our group by we add order by date. Let's execute the query one more time. Alright, here's the result, that is better. Now we're ready to add the second column, payment method. So If you look at the payments table, you can see that in this table we only have payment method id. So we need to join this table with the payment methods table to get the name for each payment method. That is pretty easy, we have done it before, so we're going to call our payments table p, and then join it with the payment methods table, and we're going to call this pm. 
Now here we cannot use the using clause, because our join columns are named differently. In the payments table it's called payment method, in the payment methods table it's called payment method id. So here we'll have to use the on keyword on p.payment method equals to pm.payment method id. Now that we have joined our tables, we go back to our select clause and pick pm.name and rename it to payment method. And then we add payment method to our group by clause. So group by date, and then payment method. Let's execute the query. Alright. So here's the final result. For each date and payment method combination, we can see the total payments.
















The HAVING Clause:
Here's the example from the last tutorial where we calculate the total sales for each client. So we select the client id column, and the sum of invoice total from the invoices table, and group our data by client id. And here's the result, beautiful. Now, what if you want to include only the clients that have a total sales of more than let's say $500. So we don't want to include client number 2. How can we do this? Well, we cannot use our where clause in this situation, so we cannot write where total sales is greater than 500, because at this point we have not grouped our data, we group our data after, so on line 5 we don't know the total sales for each client, that is why we cannot use our where clause to solve this problem. 
If you execute this query, mysql is going to yell at you saying unknown column total sales. So how can we solve this problem? That is where we use the having clause. We use the having clause to filter data after we group our rows. So here we can write a filter like total sales is greater than 500. Let's execute the query. Now client number 2 is excluded from the result. Beautiful. So, with the where clause, we can filter data before our rows are grouped, and with the having clause, we can filter data after our rows are grouped. That is the difference. Now let me remove this where clause, and make this example more interesting. For each client, we want to calculate the total sales, as well as the number of invoices. 
So we can do account of invoice total, or we could do account of everything, and label it as number of invoices. Let's execute this query one more time. There you go. So now for each client we see the total sales as well as the number of invoices. Now let's say we want to filter this result and only return the records that have a total sales of $500 or more and more than 5 invoices. So we want to exclude the first two records because they don't have more than 5 invoices. So here in the having clause we can write a compound search condition. So we want to get the records where total sales is more than 500 and number of invoices is greater than 5. 
Let's execute the query, and here's the end result. So to recap, we use the where clause to filter data before grouping our rows, and we use the having clause to filter data after we group our rows. And here just like our where clause, we can type out one or more conditions. But the columns that we use here have to be part of our select clause. In other words, here, We cannot reference the payment date column because it is not included in our select clause Okay, in contrast when writing a word clause we can reference any columns whether we're selecting them or not These are the two differences between where and having clauses All right, here's a more challenging exercise for you for this exercise we're going to use our sequel store database so write a query and 
to get the customers who are located in Virginia and have spent more than $100. It's a fantastic exercise and helps you get job ready. So spend 3-5 minutes on this exercise and then come back and continue watching. Alright, once again, when solving a complex problem, we should always break that problem into smaller and easier to solve problems. So first, let's only get the customers who are located in Virginia. We write a query like this, select everything from customers where state equals Virginia. And by the way, we should use the SQL store database, so on the top we have use SQL underline store followed by a semicolon. Let's execute the query, there you go. So here are the two customers located in Virginia. Now if you look at the columns return here, nowhere in this result set we have sales information. 
We don't know how much each of these people have paid us. Where can we find that information? Well, in the order items table, we know how much we have sold in each order. So for each order, for each product, we know the quantity and the unit price. However, we don't have the customer information here. So we don't know who has bought these products. Those pieces of information are in the orders table. So in the orders table we know who has placed what order. So what we need to do now is to join the customers table with the orders table so we can find the orders for each customer and then we'll have to join the orders table with order items so we can calculate the total sales by each customer. 
So back to our query, we have selected everything from the customers table, let's give it an alias and then join it with the orders table. using the customer id column. And then once again, let's join it with the order items table, we call it oi, using the order id table. Now let's execute this query and see what we get. First we see our join columns, which are order id and customer id, then we have information about each customer, followed by information about each order, so we have order date, status, comments, ship date, and so on, and then we have information about each order item. So we have the product id, quantity, and unit price. So now from this table we can calculate the total amount each customer has spent. 
Back to our query, instead of selecting everything, let's select customer id, as well as first name, and last name. Now to calculate the total amount each customer has spent, we need to use the sum aggregate function, and here we should write an expression. We go in the order items table and get the quantity column. Then we multiply it by order item dot unit price. So for each order item we calculate the total cost, and then we pass all these values to the sum function. So this will return the total amount each customer has spent. Let's call that total sales. So here we have used an aggregate function, now we need to group our data. So after the where clause we type out group by, here we should group our data by three columns, customer id, first name, and last name. 
With this we can see the total sales for each group, which is the combination of customer id, first name, and last name. As a rule of thumb, whenever you have aggregate function in a select statement, and you're grouping your data, you should group by all the columns in the select clause. So, I'm going to copy these three lines, and then paste them here, now we should remove the trailing comma, alright, let's execute the query and see what we get. So we see the total sales for each customer, right? We're almost done. The last part is to apply a filter here, and only return the customers who have spent a minimum of $100. So we want to exclude the first customer here and return only the second customer. 
Back to our query. Earlier I told you that we use the where clause to filter data before grouping it, and we use the having clause to filter data after grouping our rows. So, after group by, we add having total sales greater than 100. let's execute the query one more time, now we only see one record, that is customer with id 2 who has spent a total of $157. So here's the end result, I hope you completed this exercise, because a lot of problems you work on in the real world are very similar to what you saw in this video. Now, if you couldn't complete this exercise, don't worry, we're going to have more exercises like this later in the course.












The ROLLUP Operator:
again we're using the same example where we calculate the total sales for each client. Now in my skill we have a powerful operator for summarizing data called with rollup. So, here in our group by clause, after we list our columns, we type out with rollup. Now when we execute this query, we get one extra row that summarizes our entire result set. So 2590 is the sum of total sales all clients. Note that the client id in this row is null because it doesn't make sense to add these values together. So the role of operator only applies to columns that aggregate values. Now what if we group by multiple columns? Let me show you. So once again we're going to join our invoices table with the clients table using the client id column. 
Now instead of grouping by client id, let's group by state and city, and also include these columns in our select clause. So state, city, and the sum of invoice total. Let's execute this query and see what we get. Alright, here's what we get. First we see the total sales for the city of San Francisco in California, and below that we see the total sales for all cities in California. So the rule of operator calculates the summary for each group. Similarly you can see the total sales for all cities in New York, as well as all cities in Oregon, and finally all cities in all states. So when you group by multiple columns and use the rollup operator you see the summary values for each group as well as the entire result set. 
So the rollup operator is very useful and it has a lot of applications in the real world. However, it's only available in MySQL, it's not part of the standard SQL language. So you're not going to be able to execute this query in sql server or oracle. But I'm pretty sure that those database engines have similar operators to summarize data. And here's your exercise for this tutorial. Write a query to produce this report. Here we have two columns, payment method and total. So we can see the total for each payment method as well as the total amounts we have received. You need to write this query against the payments table. So go ahead and do this exercise, when you're done come back and continue watching. 
Alright, just like always we start by simplifying our problem. So first, let's select everything from the payments table. So we get all these columns, but we're only interested in payment method and the total amount for each payment method. Now our payment methods here are numeric values, So later we need to join this table with the payment methods table to get the actual name for each payment method. But let's not worry about that yet, because we want to solve this problem step by step. So, from this table, we want to pick the payment method column, and the sum of amount. We're going to rename this to total. Now we need to group our data, so group by payment method. Let's execute the query, here's what we get, beautiful, we can add with rollup, and this adds the summary row at the end, beautiful, now finally we need to join this table with the payment methods table to get the actual names. 
We give our table an alias, and then join it with payment methods, pm, as I told you before, we cannot join these two tables using the using clause, because the column names are not the same. So we use the on clause where p.payment method equals pm.payment method id. Let's execute the query one more time, beautiful, we still see the same result, now we should replace this payment method id with the actual name of the payment method. So pm.name as payment method. Now if we execute this query, we get and error in the output window, because when we use the rollup operator, we cannot use a column alias in the group by clause. So here we need to type the actual name of the column, that is pm.name. 
That was a little detail that I probably forgot to tell you earlier, so sorry about that in case you couldn't solve this problem, that is totally fine, let's execute the query one more time, alright, and here is the total result, so we see the total amount we have received, for each payment method, as well as the total amount across all payment methods. And here's the final solution.





















Writing Complex Query:
Introduction:
 

 

In this section we're going to learn how to write complex queries in sql. Mostly we're going to revisit sub queries that you learned about earlier in the course, a sub query is a select statement that is within another sql statement. In this section we're going to take a closer look at these sub queries, we're going to work on lots of examples that help you master writing complex queries. Now before getting started, I want you to restore all of our databases to their original state, because earlier in the course we added some new records we updated existing ones, I want to make sure that going forward we both have the exact same data set. So what I show you in these videos look exactly the same on your computer. 
So here in mysql workbench, on the top go to the file menu, and then open sql script. Then browse to the folder where you stored all the scripts for creating these databases, in case you lost that folder, simply go back to the first section there is a lecture for downloading this script. Now in this list, open create databases, this will recreate all of our databases. So we'll have the exact same data set. Now to execute this either click on this icon here or use your shortcut. There you go, all of my databases are restored to their original state, beautiful. Now let's jump in and get started.
















Subqueries:
Alright, let's start this section by writing a simple subquery. So in our sql store database, we want to write a query to find all the products that are more expensive than lettuce. And here the idea of lettuce is 3. So we need to write a query like this. Select everything from the products table, where unit price is greater than, now here we need to get the unit price for lettuce. So this is where we write a subquery in parenthesis. Let me close the navigator panel. That's better. So here inside the parentheses we select the unit price column from the products table where product ID equals 3. When mysql tries to execute this query, first it will evaluate our inner query or subquery. So it will get the unit price for letters and then it will pass the result to our outer query over here. 
So, let's execute the query and see what we get. These are the two products that are more expensive than lettuce. So here's one way to write a subquery. In this example, we have coded this subquery inside the where clause. But we can also write a subquery in the from clause or in the select clause. As I will show you later in this section. But before we get there, I have an exercise for you. In our SQL HR database, write a query to find all the employees who earn more than average. It's a really good exercise to get your hands dirty with sub queries. Alright, so first we're going to use our SQL HR database, then from the employees table, you want to select everything, where salary is greater than 
Now here we need to calculate the average salary of all employees. So that's where we need a sub query, we add parenthesis and inside this parenthesis we select the average of salary from the employees table. Now, let's execute this query. So these are the employees who earn more than average.















The IN Operator:
you're going to learn how to write a subquery using the in operator. So in our sql store database, let's say we want to find the products that have never been ordered. How can we solve this problem? Well, let's take a look at our tables. You know that in the order items table, we know how many times each product has been ordered. So to solve this problem, first we need to find all the products in this table, and then we'll write another query to return products that are not in this table. So, back to our query window, first let's select the product id column from the order items table. So these are all the products that have been ordered. But as you can see here we have duplicates, so we can simplify the result by using the distinct keyword. 
So back to our select clause, we add the distinct keyword here, let's execute the query one more time, Now we have the unique list of products that have been ordered. Beautiful. Now we need to use this query as a subquery inside another query. So we want to go to the products table and select everything where product id not in this list. So we're going to wrap this query with parenthesis to convert it to a subquery. Let's indent it, that's better. add parenthesis here, let me close this window, and here. So our subquery returns the unique list of products that have been ordered, now we get this list and pass it to our where clause. Let's execute the query, and product number 7 is the only product that has never been ordered. 
So in this example, our subquery is returning a list of values, in contrast in the last lecture, The subquery that we wrote returned a single value. For example, we calculated the average salary of all employees, and then returned employees who earned more. In that case, our subquery returned a single value and we used that with a comparison operator in the where clause. In this example, our subquery is returning a list of values, but we can also write a subquery that returns a table. A table with multiple columns. You will see that later in this section. Now for your exercise, in our SQL invoicing database, I want you to write a query to find the clients without invoices. It's pretty straightforward, you can knock it out in a couple of minutes. 
Alright, in our SQL invoicing database, we have this invoices table, and in this table we have the ID of each client. So first we need to get the unique list of clients, And then we'll use that list to find clients who don't exist in this list. So back to our query, let's select distinct of client id from the invoices table. Execute. These are the clients with invoices. Now we need to select everything from the client table where client id not in, and then we'll use our subquery. Like this. Pretty easy. Let's execute the query. So we only have one client who doesn't have an invoice.









Subqueries vs Joins:
often we can rewrite a subquery using a join and vice versa. For example, here is the query that we wrote as part of the exercise in the last lecture. So here we are selecting the client without invoices. Now we're going to rewrite this, but instead of using a subquery we're going to use a join. So we want to select all the clients, and then we want to join these clients with the invoices table. Now earlier you learned that we have two types of joins, inner joins and outer joins. If we do an inner join we'll only get the clients who have an invoice. If we do an outer join or a left join more accurately, we'll get all the clients whether they have an invoice or not. 
So as you can see we can rewrite a subquery using a join and vice versa. So which approach should you use? Well, that depends on a couple of things. One is performance and the other is readability. Later in the course we talk about execution plans, so you will learn how to write a query that gets executed faster. But assuming that both these queries have the same execution time, you should go for the query that is most readable. In this particular example, the first query is more intuitive because it better aligns with the problem you're trying to solve. Find clients without invoices. So you're finding clients who don't have an invoice. Understanding this query is easier. So left join here is a little bit of distraction from our problem. 
But this is not always the case. Sometimes you will see that using a subquery can make your query too complex, and in those cases it's better to use a join. So always pay great attention to the readability of your code. Alright, here's a great exercise for you to practice what you learned in this tutorial. In our SQL store database, write a query to find the customers who have ordered lettuce. And as you remember, the ID of lettuce is 3. In your select statement, select customer ID, first name, and last name. Now we can solve this problem using both a subquery and a join. So as part of this exercise, I want you to come up with both solutions and pick the one that is more readable. 
You will see my solution next. Alright, first I'm going to solve this problem using a subquery. So I'm going to select everything from the customers table, where, customer id, in, now here in the subquery, we need to return the id of customers who have ordered lettuce. So we need to go to our order items table, select everything from order items, where product id equals to 3. Now in this table we don't have the customer id, so we need to join this table with the orders table to get the customer id. Let's give it an alias, and then join it with the orders table using the order id column, and then instead of selecting everything, we select o.customer id. So this is how we solve this problem using a subquery. 
Now, let's execute our query, we should get these three customers, number 8, 2, and 10. Beautiful. Now I'm going to solve this problem using a join. So I'm going to join the customers table with the orders table and then order items. Then we'll filter and get only the records where product id equals to 3. So I'm going to open up a new query window, here we're going to select everything from the customers table, do a join with the orders table using customer id, and one more join with the order items table using the order id column. Now we want to apply a filter, so where order item dot product id equals to 3, let's execute our query, see what we get. Note that because customer number two has ordered let us twice this record is duplicated here. 
We don't want duplication, right? So, here instead of selecting everything, we do a distinct of customer ID, and then we'll pick the first name and last name columns. Let's execute the query one more time all right now we have the same result as before. Now actually I made a mistake in my first query, so instead of selecting everything here we should select customer id, first name, and last name. That doesn't really matter. Now compare this query with this other query. In my opinion the second query is more readable, it's more meaningful because there is a natural relationship between customers, orders, and order items. So in situations like that quite often we use joins, and here our filter clearly explains what customers we are looking for. 
Customers who have bought product number three, so I personally pick the second solution over the first one.

















The ALL Keyword:
Alright, now let's select invoices that are larger than all invoices of client 3. Once again, we want to simplify this problem. So first, let's get all the invoices of client 3. So in our SQL invoicing database, first I'm going to select everything from the invoices table where client ID equals to 3. Let's execute this query and make sure we get the right result. Alright, so here are the invoices of client 3. As you can see, each invoice has a total amount. Now look at invoice number 15. The total amount is hundred and sixty seven dollars so this is the largest invoice of client 3. Now we want to change our query to get all invoices that have a total amount greater than hundred and sixty seven dollars so first we want to change this query to select max of invoice total. 
let's execute the query one more time, alright, now we get $167, beautiful. So now we can use this query as a subquery to select all invoices with total amount greater than $167. So, we want to select everything from the invoices table, where invoice total is greater than, and this is where we use our subquery. So let me indent these three lines, that's better. Let's execute the query one more time. There you go. So these are the invoices that are larger than all invoices of client 3. Now there's another way to solve this problem using the all keyword. Let me show you. So I'm going to open up a new query window. So once again, we want to select invoices that are larger than all invoices of client 3. 
So we can convert the sentence to a query like this. Select everything from the invoices table where invoice total is greater than, then we write our subquery, here we want to select the total amount for all invoices of client 3. So select invoice total from invoices where client id equals to 3. However, when we run this query, Instead of getting one value, we're going to get multiple values. Because client 3 has multiple invoices. Let's take a look. So, there you go, these are the total amounts for all invoices of client 3. Now in this query we want to select invoices that have a total amount greater than all these values. So we prefix our subquery with the keyword all. When we give this query to mysql, first it will execute this subquery. 
This sub query returns a list of values like this. Let me just temporarily delete this and show you the amounts. Like $150, $130, $167, and so on. Right? Then mysql is going to look at the invoices table, for each row it will compare the invoice total with these values. If the invoice total is greater than all these values, that row will be returned in the final result set. So this is how the all keyword works. Now I'm going to revert this back to what we had earlier. So here's what you need to take away, sometimes your sub queries return a single value, sometimes they return a list, sometimes they return a table. In our first implementation, our sub query returned a single value, that was the max of invoice total for client number 3. 
When we execute this query we get $167. So in our main query we can compare invoice total with $167. In contrast, in the second implementation, our subquery returns a list of values. In this case, if we don't add the all keyword here, MySQL will not be able to compare invoice total with all these values. So that is why we'll have to prefix this subquery with the all keyword. So, these two implementations are interchangeable, wherever you have the all keyword, you can rewrite that query using the max aggregate function. In my opinion, both these queries are readable, some developers prefer to use the max function, the others prefer to use the all keyword, in this particular case, I personally think this second implementation better aligns with the problem at hand, so I prefer this second implementation, but they're both equally good.







The ANY Keyword:
In the last lecture you learned about the all keyword. In this example, you're only getting rows where invoice total is greater than all the values returned by this subquery. Okay? Now in my skill we also have the any or some keywords that are equivalent, and with this we'll get rows where invoice total is greater than any of these values returned by this subquery. Let me show you an example of this. So, Let's say we want to select the clients with at least 2 invoices, how can we solve this problem? Well, first we need to know the count of invoices for each client. So we can write a query like this, select client id, and count of everything from the invoices table, group by client id. 
Let's execute this query, there you go, so next to each client we know the count of their invoices. Now we're only interested in clients that have at least two invoices. So here we want to apply a filter using the having clause, because we want to filter after grouping our data. Okay? So having count of star greater than or equal to 2. So with this we get clients 1, 3, and 5. Beautiful. Now here we don't really need this column, the count column, we only want to know the client id's. so we can remove this from our select clause, let's execute the query one more time, so we only have the client ids here, beautiful, now we want to select the clients with these ids, that is very easy, right? 
So, we go to the clients table, and select everything, where client id is in any of the values returned by this subquery. Like this, we've already done this before, right? So these are our clients 1, 3, and 5. Beautiful. Now there is another way to write this query. Instead of using the in operator, we can use the equality operator and prefix the subquery with any. So if client id equals to any of the values returned by this subquery, that client will be returned in the final result. So equal any is equivalent to the in operator. Which approach you choose is entirely up to you. They're both equal.









Correlated Subqueries:
here's another interesting query we're going to work on. We want to select employees whose salary is above the average in their office. For this demo we're going to use our SQL HR database. So let's have a quick look at the employees table. There you go. So in this table we have the salary for each employee, as well as the office in which they're located. So in office 1 we have 4 employees, we need to find the average salary of these employees, and then return only the employees who earn more than average. Similarly, we're going to find the average salary of employees in office number 2, and return the employees who earn more than average. So we're not dealing with a constant average across the entire organization. 
You want to calculate the average salary for each employee. In other words, if I write a pseudo code for this problem, my pseudo code is going to look like this. For each employee, calculate the average salary for employee.office, and then return the employee if salary is greater than the average. This is what we call a pseudocode. It looks a little bit like a code, but it's not code, it's just plain English. Now we should convert this to a query. So we want to select everything from the employees table, where salary is greater than, and this is where we need to write our subquery. In our subquery, we need to calculate the average salary for employee.office. So, we select average salary from employees, but we don't want to calculate the average salary for all employees, we want to apply a filter here. 
We only want to get the employees in the same office. How can we find these employees? Well, we can give this table an alias, like e, and then write a where clause like this. where office id equals e.office id. So here's the tricky part here, in both the outer and the inner queries, we are using the employees table. So to get the employees in the same office, I've qualified this office id column by prefixing it with the table alias. So this is what's going to happen when mysql executes this query. It's going to go in the employees table, for each employee it's going to execute this sub query. It will calculate the average salary for employees in the same office. Then, if the salary of this employee is greater than the average, it will return that employee in the final result. 
Then it will move on to the second record. Once again, for the second record, it's going to calculate the average salary for all employees in the same office. This is what we call a correlated sub query. Because in this sub query, we have a correlation with our outer query. You're referencing the alias from the outer query, that is e here. In contrast, all the sub queries that we wrote earlier were uncorrelated sub queries. So, for example, in the last lecture, we wrote this query to find the clients with at least two invoices. In this sub query, we don't have a reference or a correlation with the outer query. So mysql will execute this sub query only once. In this case, this sub query returns a list of client ids, 
So that list will be passed to our where clause in the outer or main query. In contrast, when we use a correlated sub query, this sub query gets executed for each row in the main query. So for this reason, correlated sub queries can sometimes be slow. The more data you have, the more overhead your query is going to have, and the slower you're going to get your result. Having said that, correlated sub queries are very powerful and they have a lot of applications in the real world. For your exercise we're going to go to our SQL invoicing database and get the invoices that are larger than the client's average invoice amount. Let me explain what I mean. So, let's have a quick look at the invoices table here. 
As you can see, each client can have multiple invoices. So client number 5 has these invoices. For each client, we need to find the average invoice amount. That is the average of invoice total column. And then we only want to return the invoices that have a larger total amount. Now we want to repeat this for each client. So this is where we need to use a correlated subquery. Because we're not dealing with a single average across the entire table. So go ahead and do this exercise and come back and continue watching. Alright, we're going to start by selecting everything from the invoices table where invoice total is greater than, and here's our subquery, we select the average invoice total from the same table, where now we only want to get the invoices for the current client. 
So we give this invoices table an alias, like i, and then use that in our filter. So where client id equals i.client id. Pretty straightforward. let's execute this query, so we should get invoices 2, 4, 5, 8, 9, 15, 16, and 18.








The EXISTS Operator:
In this lecture we're going to write a query to get the clients that have an invoice. You should already know two ways to solve this problem. We can use the in operator or a join. Let me show you. So, we select everything from the clients table where client id is in, and now we write our subquery, we select the client id from the invoices table. Now we could also apply the distinct keyword here, So we're only getting the clients that have an invoice in the invoices table. Okay? The other approach is to use a join, so if we do an inner join between the clients table and the invoices table, we only get the clients that have an invoice. Now let me show you a third way to solve this problem using the exists operator. 
So in a new query window, I'm going to write the same query, but in a slightly different format. So select everything from the clients table, where exists and here in our sub query we write, select client id, from invoices table, where the client id column in the invoices table equals to, now we should give an alias to this clients table, so, c.client id. So once again here we have a correlated sub query, because we're correlating this inner query with this outer query. We're referencing the clients table in our subquery. However, in our where clause we are not referencing a column, we are using the exists operator to see if there is a row in the invoices table that matches this criteria. So when mysql tries to execute this query for each client in the clients table, it will check to see if there exists a record that matches this criteria. 
Now here is the difference between this query and the query that we wrote earlier. When we use the in operator, mysql will execute this subquery and it will return the result to our where clause. Now in this particular case, that result is a list of four client ids. Right? So when mysql executes our subquery our main query will look like this. 1, 2, 3, 5. These are the client ids that have an invoice. Now, what if in this table we have of thousands or millions of client IDs that have an invoice. We're going to end up with a very very large list. And this will have a negative impact on the performance. In situations like this, it is more efficient to use the exists operator. 
When we use the exists operator, the subquery doesn't actually return a result to the outer query. Instead, it will return an indication of whether any rows in the subquery matches this search condition. Do we have a client by this id in the invoices table or not? So as soon as it finds a record in this table that matches this criteria, it will return true to the exist operator, and this exist operator will include the current record, the current client, and the final result. So here's what you need to take away. Back to the in operator, if the sub query that we wrote after the in operator produces a large result set, it is more efficient to use the exists operator. Because when we use the exists operator, the subquery doesn't actually return a result set to the outer query. 
Here's your exercise for this tutorial. In our SQL store database, find the products that have never been ordered. This is a good case for using the exists operator. Imagine you have a website like Amazon. On Amazon we have perhaps hundreds of thousands of products and millions of orders. If you want to use the in operator here, our subquery is going to return a large result set. In this case, it's more efficient to use the exists operator. So go ahead and write this query, you will see my solution next. Alright, so first we're going to select everything from the products table, where, if you want to use the in operator, our where clause would look like this. Where product id not in and then in our subquery we select product id, oops, product id from the order items table. 
Let's execute the query, so product number 7 is the only product that has never been ordered. Now, we want to rewrite this query using the exists operator. So we're going to change our where clause like this, where not exists, so I'm using the not operator in addition to the exists operator, Now here we need to write a correlated subquery. So we give this table an alias like p, and then check to see if we have a product by this id in the order items table. So where product id, that is the product id column in the order items table, equals p.product id. So when mysql tries to execute this query, for each product it checks to see if this condition is true. if you have a product by this id in the order items table, this subquery will return true, now because we have the not operator here, true will end up becoming false. 
So that record will not be included in the final result set.















Subqueries in the SELECT Clause:
So far you have only used sub queries in the where clause of a select statement. But we can also use sub queries in the select clause. Let me show you. Let's say we want to generate a report like this. So here we have four columns, invoice id, invoice total, invoice average, which is the average of all invoices in our invoices table, and the difference between the invoice total and invoice average. Let me show you how to write a query to produce this result. So, we're going to start by selecting the invoice id and invoice total columns from the invoices table. Next we need to calculate the average of all invoices in this table. So this is where we write a subquery. We start with our parenthesis, and inside this parenthesis we write a subquery. 
So select average of invoice total from the invoices table. and then we give it an alias like invoice average. Let's execute the query, so this is what we get, we have the invoice id, invoice total, and invoice average, beautiful. Finally we need to add the last column to calculate the difference between the total and the average. So, here we can write an expression like this, invoice total minus, now here we cannot add invoice average, In other words, we cannot use a column alias in an expression. One solution is to copy this entire subquery and put it here, but that looks a little bit too long, and I don't like this repetition of our query. So, here's a better way. We can convert this invoice average to a subquery. 
So we put it in parenthesis, and then simply select it here. Now, let's execute the query one more time, There you go. So we can see the difference, but look at the name of the column. It's set to the exact expression we have used here. So let's rename that to difference. That is better. So sub queries are not limited to where clauses, you can also use them in the select clause as well as the from clause which I will show you in the next lecture. Alright, here's your exercise for this tutorial. Write a query to produce this result. Here we have these columns, name, total sales for each client, which is basically the sum of all the invoices issued for each client. You also have the average sales, so this is the average of all invoice totals, and finally the difference between these two columns. 
Note that for client number 4, we don't have any invoices, that's why we have null in these two columns. Alright, I'm going to start by selecting the client id, and name columns from the clients table. Next we need to get the total sales for each client. So here we write a subquery, select sum of invoice total, from the invoices table, where the client of this invoice equals the current client. So here we have to write a correlated subquery. So we need to assign this table an alias, like c, and then write our search condition like this, where client id equals c.client id. So this sub query returns the total sales for each client. Let's give it an alias, total sales, next we need to calculate the average sales across all invoices. 
That is pretty easy, so we select average of invoice total from the invoices table. and give it an alias like average. And finally we need to calculate the difference between these two columns. Earlier I told you that you cannot use these column aliases in your expressions, so here we can write a subquery like this, select total sales minus average. Now let's give it an alias like difference. That's it, let's execute the query, so here's the end result, beautiful.























Subqueries in the FROM Clause:
In the last lecture you learned that we can use a subquery in the select clause of a select statement. So this is a query that we wrote in the last lecture as part of our exercise. When we execute this query, we get this table. So we have the client id, client name, total sales, average, and difference. Now currently we don't have a table like this in our database, but the data that we have in this, let's say virtual table is very valuable, because it summarizes a lot of data. Now we can get this table in memory, treat it like a real table in our database. We can join it with another table using the client id column, we can filter the data here, we can group the data, we can do all sort of things, just like how we use real tables in our database. 
So, we can take this query and use it in the from clause of another query. Let me show you. So, I'm gonna write a very basic query, select everything from, now instead of referencing a table here, we can use the result of this query. So we can convert this query to a subquery. So let's remove dot dot dot, here we add parenthesis, and then indent our subquery, this is not required, but it makes our code more readable. And let's close the parenthesis, beautiful. So this is an example of using a subquery in the from clause of a select statement. Now whenever we use a subquery in the from clause, we need to give the subquery an alias. This is required, whether we use that alias or not. 
So, let's call this sales summary. Okay? Now let's execute this query. So we get the same result as before. So we haven't really achieved anything at this point. But we can filter this data. For example, we can write a where clause to return only the clients that we have an invoice for. So we don't want to return client number 4, because the total sales here is null. So, back to our main query, here we write a where clause where total sales is not null. Let's execute the query, now client number 4 is gone, beautiful, we can also take this table and join it with another table. The possibilities are endless. Having said that, as you can see, writing a sub query in the from clause of a select statement can make our main query more complex. 
There is actually a better way to solve this problem using views. So we can take this query and store it in our database as a view. And then we can call that view sales summary. This will greatly simplify our queries. We'll look at views later in the course. So this is what I want you to take away in this lecture. Yes, you can write sub queries in the from clause of a select statement, but reserve it only for simple queries.









Essential MySQL Functions:
Numeric Functions:
In this section we're going to look at some of the most useful built in functions in MySQL for working with numeric, date time, and string values. So let's start by looking at the functions for working with numeric data. We have the round function for rounding a number, for example, we can call this function and pass 5.73 and then select the result. Let's take a look, so we get 6, now this function has an optional second argument that we can use specify the precision for rounding. For example, if I pass 1 here, we'll get 5.7, so we keep 1 digit after the decimal point and then round the number. As another example, let's add a couple more digits here, let's say 4 and 5, now let's round this number with 2 digits after the decimal point. 
So we get 5.73, okay? We also have the truncate function for truncating a number. So in this example, we're keeping the two digits after the decimal point and removing the other digits. Another useful function is ceiling, so ceiling of 5.7, and this will return the smallest integer that is greater than or equal to this number. Let's take a look. So we get 6, if we pass 5.2 here, we still get 6. So this is different from the round function, because if we round 5.2 we get 5. But the ceiling function will return the smallest integer that is greater than or equal to this number. Another similar function is floor, and this will return the largest integer that is less than or equal to this number, so in this case we get 5, we also have 
abs function for calculating the absolute value of a number, so if we give it 5.2 we get 5.2, if we give it negative 5.2 we get 5.2 again. So it always returns a positive value. And finally the last useful function we're going to look at is the round function for generating a random floating point number between 0 and 1. So every time we call this function we get a new random value between 0 and 1. Now there are actually a few more functions for working with numeric data in MySQL, but the ones that I've shown you in this tutorial are the ones that you'll be using most of the time. If you want to see the complete list of these functions, open up your browser and search for MySQL numeric functions. 
Here on this page, you can see all the numeric functions supported in MySQL.










String Functions:
In this tutorial we're going to look at some of the most useful functions to work with string values. Here are a few examples. We can call the length function to get the number of characters in a string. For example, if you pass sky here and then select the result, we get 3 because we have 3 characters in sky. We also have the upper and lower functions for converting a string to uppercase or lowercase characters. So if we call upper of sky, we get sky in uppercase, and you also have the lower function, so if you pass sky with a capital s, it returns sky in lower case. Pretty straightforward. We also have three useful functions for removing unnecessary spaces in a string. These functions are pretty useful when we deal with data entered by the user. 
Sometimes people type an unnecessary space before or after a value, so we can clean or trim these values using these three functions. The first one is ltrim, which is short for left trim, so if you pass sky and add a few spaces at the beginning, look, we get sky without those leading spaces. The other function is r trim, which is short for right trim, so if you pass sky with a few spaces after, this function removes all these extra unnecessary spaces. Alternatively, we can call the trim function, trim, and this will remove any leading or trailing spaces. Again, pretty straight forward. We also have the left function for returning a few characters from the left side of a string, so we can call this function and pass two arguments. 
Let's say kindergarten, that is our string, and let's say we want to get the first four characters. So, we get kind, another similar function is right, which does the opposite of the left function. So, let me change 4 to 6, and now this will return 6 characters from the right side of the string. We also have the substring function, and with this we can get a few characters from anywhere in a string. So, here's our string, the second argument is the start position, and the third argument is the length. So, when we call this function mysql will go to position 3, that is 1, 2, 3, it starts at n, and then it will pick 5 characters, so 1, 2, 3, 4, 5. 
That is why we get nderg here in the result. Now this third argument is actually optional, so if you leave it out, this will return all the characters from the start position to the end of the string. Take a look. There you go. Another useful function is locate, which returns the position of the first occurrence of a character or a sequence of characters. For example, we can call locate with these values. The first argument is our search string, so let's say we want to search for n in kindergarten. When we call this we get 3, because the position of the first n in this string is 3. So 1, 2, and 3. Now it doesn't matter if we use lowercase or uppercase characters, we get the same result because the searching is not case sensitive. 
Now what if we search for a character that doesn't exist in our string? Let's say q, we get 0. So this is different from a lot of programming languages, in most programming languages if we search for a character that doesn't exist in a string we get negative 1. In mysql we get 0. We can also search for a sequence of characters like garden, and this will return the first occurrence of the word garden in our string. Take a look, that is 7. So garden starts from 1, 2, 3, 4, 5, 6, and 7. Okay? We can also replace a character or a sequence of characters, so we call the replace function and give it 3 arguments. The first argument is our string, kindergarten. 
Then, what we want to replace let's say garden with a t, we want to replace this with garden with a d. Let's run this query, so we get kindergarten with a d. And finally the last function we're going to look at in this lecture is concat, which we use for concatenating two strings. So if we have a first name and a last name, we can combine them into one string. Like this. Here's a better example. So we can go to our SQL store database, select all the records from the customers table, as you know here we have two separate columns for the first and last name. Now we can combine these two using the concat function. So concat, first name, then we add a space, and finally the last name. 
Now let's give it an alias, full name, and here's the full name for each customer. So these are the most useful functions to work with strings in mysql, once again you can find the complete list of these functions by searching for mysql string functions. Here's the mysql reference manual, and on this page you can see all the string functions that we have in mysql.















Date Functions in MySQL:
In this lecture we're going to look at the useful functions to work with dates and times. We can call the now function to get the current date and time. Let's select it. So here's the current date and time on my machine. We also have curDate which is short for current date. And this returns the current date without the time component. And similarly we have current time which returns the current time. Let's take a look. So here's the result. Pretty straightforward. Now we have a bunch of functions for extracting certain components in a date or time. For example, you can get the current date time and then extract the year by calling the year function. So here we call the now function, this function returns a date time object, and then we pass that as an argument to the year function. 
Take a look, so the current year is 2019, we can also get the current month, which is or the current day, or we can call the hour function to get the current hour, or the minute, or the second, pretty useful functions. Now all these functions return integer values, but we have two useful functions that return strings. For example, we can call day name to get the day of the week as a string. Or we can call month name to get the month as a string. Now apart from these functions we also have the extract function, the good thing about this function is that it is part of the standard SQL language, so if you want to be able to port your code to other database management systems, it's better to use the extract function. 
Here's how it works, when we call it, first we need to specify a unit, like year, month, day, second, and so on. So let's get the day from the current date. this returns 11, or we can extract the year from this date, that returns 2019, so when we call this function, we type out a unit, then the from keyword, and then a date time value. So these are the essential functions to work with dates and times. In the next lecture we'll look at formatting dates and times. Here's your exercise for this tutorial. Earlier in the course, we wrote this query to get the orders placed this year. There we assume that the current year is 2019, and we wrote our query with a where clause like this. 
As I told you before, this is an unreliable way of returning the orders placed in the current year. Because next year, in year 2020, this query will return any orders placed after January 1st, 2019. So it will return the orders placed in both 2019 and 2020. Now, in this lecture you learned how to get the current date and extract various components like year, month, day, and so on. So now go ahead and modify this query to reliably return the orders placed in the current year. Alright, the solution is pretty easy, instead of hard coding a date value here, we should call the now function to get the current date time. Now we pass the current date time to the year function to extract the current year. 
and then similarly we pass this order date to the year function, to get the year of the order, and then check to see if both these years are equal. This query will return all the orders placed in the current year. Let's take a look. So, since we're currently in 2019, this query returns only one order that is placed in the current year. In the future when you watch this course, this query is not going to return anything, because in our sample data set we don't have any orders after 2019. So if you want to test this query, you'll have to manually update the data of one of the orders.







Formatting Dates and Times:
we learned that in mysql we represent dates as a string with four digits for the year, followed by hyphen, two digits for the month, another hyphen, and then two digits for the day. Now this format is useful for us developers, but when presenting dates to our users, this format might not be ideal. So we have a couple of functions for formatting dates and times in a more user friendly way the first one is date format, which takes two arguments. A date value and and then a format string which contains special codes for formatting the various parts of a date. For example, here we can use a %y to display a 2 digit year. Let's select the result, so we get 19, but if we use a capital Y here, we'll get a 4 digit year. 
2019, there you go. Similarly, we have %m for displaying a 2 digit month, and we can change this to a capital M to get the month name. So this is a more user friendly date. Now we can also add the date part, so %d and with this format string we get March 11, 2019. Now don't worry about memorizing any of these, you can simply search for mysql date format string and here on mysql reference manual on this page, if you scroll down, somewhere you should see a table, let's scroll down more, where is it? Right here. So in this table we have all these format specifiers and the description. So here's the date format function, we also have the time format function, very similar, but here we use other format specifiers. 
For example, we can use %h for the hour, then colon, followed by %i the minutes. We can also add %p for the pm or am. There you go. So we use the date format and time format functions to format our dates and times.








Calculating Dates and Times:
often we need to perform calculations on dates and times. For example, we want to add a day or an hour to a date, or calculate the difference between two dates. In this lecture we're going to look at the most useful functions for performing calculations on dates and times. We can use the date add function to add a date part to a date time value. Let's say we want to add one day to the current date time. So as the first argument we pass the current date time, and then for the second argument We write an expression like this, interval 1 day. Let's select the result. So this returns tomorrow's date with the same time. Now we can also add 1 year to the current date time by simply changing the unit from day to year. 
So this returns next year, same day, same hour. What if you want to go back in time? We can either pass a negative value here, so this returns last year's date, or we can use the date sub function to subtract a date part from a date time value. So instead of passing a negative number, we pass a positive number and we get the exact same result. So this is how we can add or remove a date part to a date time value. We can also calculate the difference between two dates, so we call the date diff function, and give it two dates, let's say 2019, January 5th, and 2019, January 1st. So this returns 4, note that this function only returns the difference in days, not the hours or minutes, even if we include a time value here. 
For example, let's say January 5th, 9am, and January 1st, 5pm. We still get 4 irrespective of the difference in timing here. Also, note that because I put the later date first, we get a positive number here, if we swap the order of these dates, we get a negative value. So, there you go, we get negative 4, so this is how we calculate the difference between two dates. Now, how can we calculate the difference between two times? Well, for that we use the time to sec function, and this returns the number of seconds elapsed since midnight. Let's say 9am, So this returns 32,400, and these are the number of seconds elapsed since midnight. Now, we can call the time to sec function for the second time value, and then subtract it from the first value. 
So, minus time to sec, let's say 902. So we get minus 120, obviously because we put the earlier time first. If we swap the order of these values, we get a positive value.





















The IFNULL and COALESCE Functions:
covered all the essential functions to work with numbers, strings, and date time values. In this lecture we're going to look at a couple more useful functions in mysql. So let's go to our sql store database and select all the orders. As you can see, some of these orders don't have a shipper, so their shipper id is null. Let's say for these orders, instead of displaying null to the user, you want to display the label not assigned. So I'm going to simplify this query by picking only two columns, order id and shipper id. Now here we can call the if null function to substitute null values for shipper id with something else. In this case, not assigned. So as a second argument, we pass a string, if shipper id is null, then this function is going to return not assigned. 
Now let's give it an alias, like shipper, and execute the query, there you go. So these orders don't have a shipper, in contrast, these other orders do have a shipper, so we see their shipper id. Now we also have another similar function that is more flexible, and that is the coalesce function. Let's say if shipper id is null, we want to return the value in the comments column, and if comments is also null, then we want to return not assigned. So, we call the coalesce function, and here we supply a list of values. First we want to return the value in the shipper id column. If this is null, we want to return the value in the comments column. If this is null too, then we want to return not assigned. 
So, let's execute this query. In this example, if you look at order number 8, instead of not assigned, we see the value in the comments column. So here's the difference. With the if null function, we can substitute a null value with something else. With koalas function, we supply a list of values, and this function will return the first non null value in the list. Alright, here's your exercise for this tutorial. In the same database, write a query to produce this result. Here we have two columns, customer and phone. In the customer column, we display the customer's full name, and in the phone column, we display their phone number and if we don't have their phone number, we display unknown. Pretty easy, you can knock it out in a minute. 
Alright, first we're going to select customer's full name. So this is where we use the concat function, we get the first name, then we add a space, and next we add the last name. Let's rename this to customer, now we should display the phone, but if we don't have the phone, we want to display unknown, so we call the if null function, and here we can substitute phone with unknown, we could also use qualis, they're both valid solutions. And finally from the customers table, actually we need to assign an alias here as well, phone. Let's execute the query, there you go, this customer doesn't have a phone, so we see the word unknown.
















The IF Function:
There are times that you want to test the condition and return different values depending on if the condition is true or not. For example, let's take a look at our orders table. Let's say we want to classify our orders into two categories, active and archived. If the order is placed in the current year, we want to put it in the active category, otherwise we want to put it in the archived category. Earlier in the course, you learned how to do this using the union operator. You wrote two select statements, one to get the active orders and another to get the archive orders. And then you combine the results using the union operator. We can achieve the same result using the if function but with less code. 
Here's how it works. We call the if function and give it an expression to test. If this expression, a value is too true, this function will return this value, let's call it the first value, otherwise it will return the second value. whatever this value is. It can be a string, it can be null, it can be a number, it can be a date, it can be anything. So let's see this function in action. I'm going to select a couple of columns from the orders table. Order id, and order date. From the orders table. Now here we want to add another column, and this is where we use the if function. So, here we pass a test expression. We want to check to see if the order is placed 
in the current year. You learned how to do this earlier in the section. So we get the year of order date, and compare it with the year of current date time. If this expression evaluates to true, we want to return active, so we pass another argument to the if function that is active, otherwise we want to return archive, so we pass another argument, archive. Now this is getting out of the screen, so let me break this up into multiple lines, that is better, so now we can clearly see the three arguments of the if function, the first argument is a test expression, the second is the value that is returned if the test expression is true, and the third argument is the value that is returned if the test expression is false. 
Here I missed to add a quote, alright, now let's execute this query, there you go, So as you can see, the first order is placed in the current year, which is 2019, and that is why we have the active label here. Now look at the name of the third column. It is if with an open parenthesis. So let's rename this to something more meaningful like category. And here's the final result. Now here's your exercise for this tutorial. Write a query to produce this result. So here we have four columns, product id, name, the number of times each product has been ordered, and this frequency column which is based on what we have in the orders column. If a product has been ordered more than once, in the frequency column we have many times, otherwise we have once. 
Spend a couple minutes on this exercise and then come back and continue watching. Alright, just like always, we simplify a problem by breaking it down into smaller and easier to solve problems. So first, let's get the product id and name from the products table. Products. Okay, our query is working up to this point, beautiful. Next we need to add a column to display how many times each product has been ordered. We can get that information by joining the products table with the order items table. So here we join this with the order items table using the product id column. Now to get the count, here we call the count aggregate function, and rename the column to orders. Now because we have used an aggregate function here, we need to group by these two columns. 
So, group by product id and name. Let's execute the query one more time, beautiful. Now we know how many times each product has been ordered. Finally let's add the last column. And this is where we're going to use our if function. So if, now what is our test expression? If count of everything is greater than 1, we want to return many times, otherwise we want to return once. And now let's give it an alias frequency. That is the final result. Let's run the query again, there you go.




The CASE Operator:
In the last tutorial you learned about the if function. You learned that with this function, we can test an expression and return different values depending on the result of this expression. Now, what if we have multiple expressions to test? So in our orders example, let's say if the order is placed in the current year, we want to return active, if it was placed last year, we want to return last year, and if it was placed earlier, we want to return archived. So here we have three test expressions, and our if function only allows a single test expression. In situations like this, we use the case operator. Let me show you how it works. So I'm going to delete this if function, we type out case, followed by one or more when clauses. 
Each when clause includes a test expression, let's say year of order date equals to year of now. So here's our test expression. Next we add, then, if this expression, a value is too true, the value that we put here will be returned. In this case, active. So here's our first when clause. Now we can add another when clause with a different test expression. If the year of order date equals to year of now, minus 1, that is last year, then we want to return last year, we can write another when clause, if year of order date is less than year of now minus 1, that means this order was placed 2 years ago or earlier, then we want to return archive. Now here we can optionally add an else clause, and if none of these conditions, if value is true, then the value that we add here will be returned. 
In this particular case, it means an order that is placed in the future. So let's say future here. Now finally we need to close our case block with the end keyword. And then give it an alias like category. Now, let's execute this query. The first order was placed this year, so that's why we have the active label here. The second order was placed last year, and these other orders were placed two years ago or earlier. So use the case operator in situations where you have multiple test expressions and you want to return different values for each test expression. Earlier in the course, you wrote a query to classify customers based on their points. So if a customer has more than 3000 points, we classify them as gold customers. 
If they have between 2000 and 3000 points, inclusive of these values, we regard them as silver customers, otherwise if they have less than 2000 points we refer to them as bronze customers. Now the query that we wrote earlier in the course was fairly large because it had 3 parts, 3 select statements that were combined using the union operator. Now we can simplify this query using the case operator and get the same result. So go ahead and write a query using the case operator to produce this result. Alright, so here we have three columns, customer, where we display the full name for each customer, we have points, and category. So, just like always, let's simplify this problem by breaking it down into smaller and easier to solve problems. 
First, we just want to display the customer's full name. So select, here we're going to use the concat function, concat, and give it three values. First name, a space, and last name. and then we want to give it an alias like customer. Let's select these from the customers table. So, our query is working up to this point, beautiful, next we need to add the points, that is pretty easy, and finally we need to add the category column. So here we use the case operator, we have one test expression for customers who have more than 3000 points. So, if points is greater than 3000, then we want to return gold. Here's the second test expression, if the customer has greater than or equal to 2000 points, then we want to return silver, so if the first test expression is false, that means the customer has 3000 points or less. 
So we fall in the second test condition, here we are checking to see if the customer has between 2000 and 3000 points. of these values. If that's the case, we return silver, otherwise that means the customer has less than 2,000 points. Here we return bronze. Now finally we need to end this block and give it an alias called category. So here's the end result, let's execute our query and make sure it works. There you go.












Views:
Creating Views:
You have learned a lot about writing queries. You have seen that these queries can sometimes get complex, especially when we use multiple joints and sub queries. This is where views come to the rescue. We can save these queries or sub queries in a view, and this will greatly simplify our select statements. And then we can reuse this view so we don't have to code those queries again. Let me show you. So in our sql invoicing database, I'm going to write a query to get the total sales for each client. So let's select everything from the clients table, and join it with the invoices table using the client id column. Now I'm going to pick a few columns, so c.client id, and c.name, and then finally let's calculate the sum of invoice total for each client, and call it total sales. 
And then we need to group by client id and name. Let's execute this query, there you go, so we see the total sales for each client, beautiful. So this is a very useful query, in the future we might have a lot of queries that will be based on this query. For example, we might want to get the list of our top clients, or the clients with the least sales. Now, instead of writing this select statement every time, and changing it slightly for each query, we can save this query in a view and reuse that view in many places. Let me show you. So, before this select statement i'm going to write create view, let's give our view a name, like sales by client. 
And then we type as. So right after as we have our select statement. Now let's execute this statement. Now we don't see the result because here we are executing the create view statement. So this statement doesn't return result like the select statement, right? Instead it creates a view object. Let me show you. So, here in the navigator panel, in our sql invoicing database, we need to expand the views folder, but first let's refresh this view, alright, now let's take a look inside the views folder, there you go, this is our new view, sales by client, now just like a table, we can select the data from this view, so here's the result of our view, but we can also use this view just like a table, for example, we can select everything from 
sales by client, now we get the same result, we can order the result by total sales in descending order, now we can see the top client, that is client number 5, there's so many different things we can do with this view. We can apply a filter here, so where total sales is greater than let's say $500. Now one of our clients disappeared, we can also join this with any tables that has the client id column. For example, we can join this with the clients table using the client id column, now we see all these attributes about each client, their id, their name, their total sales, their address, their city, and so on. So views are extremely powerful and they can greatly simplify our future queries. 
Anytime we need to deal with sales by clients, we can reuse our view. We don't have to write this query, this select statement from scratch. So a view behaves like a virtual table, but remember, views don't store data. Our data is actually stored in our tables. A view just provides a view to the underlying tables, that is why we call them views. Alright, now for your exercise, I want you to create a view to see the balance for each client. Call this view client balance, and in this view we should have these columns, client id, name, and balance. We calculate balance by subtracting the payment total from the invoice total in invoices table. So the balance is the difference between what we charge each client and how much they have paid us. 
Alright, I'm going to select everything from the clients table and join it with the invoices table using the client id column. Now, I want to pick a few columns c.clientid and c.name and then we need to calculate the balance. That is the difference between invoice total and payment total. Let's call this balance, now let's execute this query, alright, this is what we get, so for each invoice we see the client id, as well as the balance. Now we need to group this data by clients. So, technically here we need to calculate the sum of invoice total minus payment total, and then we need to group our data by client id and name. Let's execute the query again, there you go, so we see the balance for each client. 
Now let's put this query in a view. So on the top, we write create view clients underline balance as, there you go, let's execute it one more time, now back to the navigator panel, I'm going to refresh this view, Here we have this new view, clients balance, we can see all the data in this view, beautiful.
















Altering or Dropping Views:
once you create a view, you may realize that your query had a problem, so you need to go back and change your view. In this tutorial, I'm going to show you two ways to do this. One way is to drop the view and then recreate it. So, we can type drop view sales by client, we could also write this in the same query window, it doesn't matter, let's execute this, now our view is gone, we can go back to our first query window, and execute this statement one more time. So this is one way to recreate the view. The other way is to use the replace keyword. So we can change this create view statement like this, create or replace view, and this is the preferred way because you don't have to explicitly drop a view first. 
Now we can execute this statement as many times as you want. Now, what if this query window is gone and you don't have access to the query behind this view? Well, a lot of people save their views in sql files and put these files under source control. It's a very common practice to check these files into a git repository, and then share that repository with other people, so everyone can recreate this database on their machine. That's a really good practice. So here we can save this file in a folder called views, and in this folder we're going to have a file with the same name as the view. That is sales by client. Then we can put that folder under source control. So this is one way. 
But in case you don't use this in your organization, you can always come back here, and click this middle icon, this opens the view in the edit mode, but you can see a bunch of other stuff here that we didn't explicitly code, mysql added these. But quite honestly, I'm not sure why mysql does this, but one thing you need to know is that mysql surrounds your table and column names with this back tech character, and this is to prevent a name clash, so if you use certain keywords that have special meanings in SQL, mysql would treat those just as table or column view or column names. Obviously this makes your code a little bit convoluted, but that's something you have to deal with. 
So let's make a small change here, I'm going to add an order by clause, an order by total sales in descending order. When we're done we need to click the apply button, it's on the bottom right corner of the screen, but unfortunately it's not visible in my recording window, it's right here. So click apply, and then MySQL generates a SQL statement like this, create or replace blah blah blah, and here we can see the change that we applied. So once again we apply, done. But obviously this is not the ideal way to update views. As I told you before, as a best practice you should save your views in SQL files and put them under source control.
















Updatable Views:
So far you have seen that we can use our views in select statements, just like our views, but we can also use them in insert, update, and delete statements, but only under certain circumstances. If the view doesn't have the distinct keyword, and any aggregate functions like min, max, sum, whatever, group by, or having clauses, and these basically go together because most of the time when we use an aggregate function, we often have a group by clause as well. and finally the union operator. So if we don't have any of this stuff in our view, then we refer to that view as an updatable view, which means we can update data through it. So we can use that view in insert, update, or delete statements. 
Let me show you. First, let's have a quick look at our invoices table. Here we have these two columns, invoice total and payment total, but we don't have a column for the balance. So every time we need to work with the balance, we have to calculate it. we have to subtract the payment total from the invoice total. Now we can create a view for our invoices table that includes the balance for each invoice. So, let's create or replace a view called invoices with balance. And here we need to write select, what columns do we have in the invoices table? Invoice ID, number, client, let's add these. Invoice ID, number client id next we have invoice total and payment total we need to add these as well, so invoice total and payment total, and finally three more columns invoice date, due date, and payment date, let's add these as well invoice date, due date, and finally payment date, we select these 
From the invoices table, so we have selected all the columns in this table. Now we want to add an extra column here That is invoice total minus payment total and We call it balance Now let's also apply a filter here and only return the invoices that do have a balance. So balance should be greater than 0 where invoice total minus payment total is greater than 0, unfortunately here we cannot use the balance alias, if we do this, mysql is going to say there is no column called balance, so we'll have to rewrite this expression here, okay? Now let's execute this statement, beautiful, so we should have a new view, first let's refresh this view, alright, now under views we have invoices with balance, so in this view we have the invoice total, payment total, 
and the balance for each invoice. Beautiful. So here's the code for this view. Here we're not using the distinct keyword, we're not using any aggregate functions or group by, neither are we using the union operator. So this is an updatable view and we can use it to modify our data. So I can open up a new query editor and delete from invoices with balance where invoice id equals to 1. So we can delete records from this view just like a regular table. Let's go ahead, our invoice is deleted, now back to this view, let's refresh the result, we no longer have the invoice with id 1. We can also update an invoice, so let's push the due date for invoice number 2 to 2 days after. 
Here we use update, we want to set the due date to 2 days after. How do we do this? In the last section you learned that we can use the date add function to add a date part to a date time value. So here we pass the current due date, and then as the second argument we write this expression, interval to day. Now with this we can update the due date for invoice number 2, beautiful, so back to our view, currently the due date for this invoice is July 1st, when we refresh this view it's going to be July 3rd. There you go, it's July 3rd. We can also insert a new invoice through this view, but this one is a little bit tricky, because this will only work if the view has all the required columns in the underlying table. 
For example, if we didn't have this invoice date column in our view, we couldn't insert any rows through this view, because our table cannot accept null values for the insert date column. So to recap, most of the time we update data through our tables, but there are times that you may not have direct permission to a table for security reasons, so your only option is to modify data through a view. In those cases you can use your views to insert, update, or delete data assuming that your views are updatable. We'll look at security and permissions later in the course.















The WITH OPTION CHECK Clause:
In the last lecture you learned about the updatable views. Now following the same example from the last lecture, let's see what happens when we update the payment total for one of these invoices. So here we have invoice 2, the payment total is less than the invoice total, we have a balance, and that is the reason we have this invoice in this view. Now I'm going to update this invoice through this view, and set the payment total to the exact same amount as invoice total. So the balance is going to be 0. What do you think will happen? Let's take a look. So, back to our query window, I'm going to update the invoices with balance view and set the payment total to the invoice total for invoice number 2. 
Let's execute this statement. Alright, now back to our view, let's refresh the view and see what happens. Invoice number 2 disappeared. So this is the default behavior of views. So when you update or delete data through a view, some of the rows may disappear. Now there are times that you want to prevent this. You don't want an update or delete statement to exclude a row from the view. Let me show you how to do this. Back to the code for this view. At the very end, after our select statement, we type with check option. When we apply this clause, this view will prevent update or delete statements from excluding rows from the view. Let me show you. so I'm going to recreate this view by executing the statement, alright, now let's go back to our view, let's update another invoice, invoice number 3, here we don't have a payment, so back to our query window, let's set payment total to invoice total for invoice number 3, now when we execute this statement, we get an error. 
If you look at the output window, you will see an error like check option failed. So by default when you update data through a view, the modified rows may no longer be included in the view. You can use the with check option clause to prevent this. So if you try to modify a row in such a way that it would no longer be included in the view, you will get an error.
















Other Benefits Of Views:
As you have seen, views can help us simplify our queries. But there are a couple more benefits to using views that I want to briefly talk about. The second benefit is that views can reduce the impact of changes to your database design. What do I mean by that? Well, imagine you have ten queries written on top of the invoices table. Tomorrow, you decide to make a change in this table. You may decide to rename the table or one of its columns. Or you may even decide to move one of the columns in this table to a different table. What will happen to your queries? You'll have to come back and fix all those queries that reference this table. Now, what if I told you that you are not allowed to write any queries against this table? 
Instead, you should always use this view that we created earlier. Invoices with balance. This view looks almost exactly like our invoices table, but it has one extra column, the balance, which is also very useful. Now, if we decide to make any changes to the underlying table, that is the invoices table, we can simply modify our view code and use an alias for the changed columns to bring back their old name. Or if we move one of these columns to a different table, we can join the invoices table with that table and bring back that column. With this design, the only place we need to change is the view. If all our queries are based on this view, they will not be affected by a change in the underlying table, the invoices table. 
So, views provide an abstraction over our database tables, And this abstraction reduces the impact of changes. There is also another benefit to using views. We can use views to restrict access to the data in the underlying table. For example, in your view, you may use a where clause to filter the records or you may exclude some of the columns in the underlying table. If you remove direct access to the table, users can only update data through your views and they won't be able to modify the value of a certain column or modify the rows that are not returned by your view. of course, this is not always that easy and it requires a lot of planning. Otherwise, you will end up with a big mess. 
So be aware of these benefits, but don't apply them blindly to every situation. Just remember that views can help you simplify your queries. So that's a great winner. But also remember that you can use them to put an abstraction layer over your tables and reduce the impact of changes. And finally, you can use them for data security. All right, we have reached the end of this section. In the next section I'm going to talk about stored procedures and functions.













Stored Procedures:
What are Stored Procedures?
At this point, you know how to write complex queries, you know how to simplify these queries by saving them in views, and you also know how to insert, update, and delete data using SQL statements. Now, let's say you're building an application that has a database. Where are you going to write these SQL statements? You're not going to write them in your application code for a couple of reasons. One reason is that it will make your application code messy and hard to maintain. For example, if you're building an application with C sharp or Java or Python, You don't want to mix your Java code with SQL because the SQL code gets in the way and it makes your application code look messy and hard to maintain. 
Also, some programming languages like C Sharp or Java require a compilation step. So if you write your SQL queries in your application code and then find out that you need to change one of your queries, you'll have to recompile your application code for these changes to take effect. So every time you make a change in your SQL code, you will have to recompile and potentially redeploy your application code. For these reasons, you should take your SQL code out of your application code and store it in a database where it belongs. But where? Inside a stored procedure or function. So a stored procedure is a database object that contains a block of SQL code. In our application code, we simply call these procedures to get or save the data. 
So we use stored procedures to store and organize our SQL code. But stored procedures have other benefits. Most database management systems perform some kind of optimization to the code in stored procedures. So the SQL code in stored procedures can sometimes be executed faster. Also, just like views, stored procedures allow us to enforce data security. For example, we can remove direct access to all the tables and allow various operations like inserting, updating, and deleting data to be performed via stored procedures. Then we can decide who can execute which stored procedures. and this will limit what the user can do with our data. For example, we can prevent certain users from deleting our data. So, stored procedures are very powerful, and in this section you're going to learn how to create and use them. 
So, let's get started.









Creating a Stored Procedure:
In this lecture you're going to learn how to create a stored procedure in MySQL. For this demo we're going to write a simple query, like select everything, oops, select everything from the clients table. We want to sort this query in a stored procedure. We can create a stored procedure using the create procedure statement. Then we give our stored procedure a name, like get underline clients. Note that here I'm only using the lowercase letters, and I'm separating multiple words using an underscore. This is a common convention amongst mysql developers. Now after the name we add a pair of parentheses, later I will show you how to add parameters here to pass a value to our store procedure. Then we type begin, here's our query and then we terminate the store procedure using the end statement. 
What we have in between the begin and end keywords is called the body of the store procedure. Now here we only have single statement, but quite often the store procedures that we create in the real world have multiple statements. So we'll have to terminate each statement using a semicolon, even if we have a single statement here. This is a mysql requirement, and you may not have to worry about this if you use other database management systems like sequel Server. Now here we have a couple of syntax errors, don't worry about it, we're gonna fix it in a second. Now here's the tricky part. We want to give all these statements to mysql as a single unit, rather than individual statements separated using a semicolon. 
So we want MySQL to take this entire unit and create a procedure for us called get clients. We don't want it to execute individual statements that we have here. How do we do this? Well, we'll have to change this default delimiter that is a semicolon to something else. So, just before creating our procedure, we use the delimiter statement to change the default delimiter. By convention, a lot of developers use $2 signs, but you can literally use anything you could use two slashes or any sequence of characters that you don't use in your sequel code But let's stick to the convention. So yeah $2 signs here to change the default delimiter Then we repeat this after the end keyword So with this we're telling mysql. 
Hey, this is the new delimiter Take all these statements as one unit now Finally we need to change the default delimiter back to a semicolon So with these changes, you can see those syntax errors are gone. This is how we create store procedures in MySQL. In other database management systems like SQL Server, you don't have to change the default delimiter. Now let's execute this, alright, now let's open up the navigator panel, refresh the view, now we have a new store procedure, beautiful, get clients, we can call or execute this procedure by clicking on this icon, This returns all the clients in our database. We can also call a stored procedure using the call statement. So call get clients, then we add the parenthesis, and this executes our get clients stored procedure. 
Now most of the time calling a stored procedure is something that we do in our application code like in C sharp, Java, Python, whatever. But there are times that you want to call a stored procedure in your SQL code, and this is how you do it. Now for your exercise, create a store procedure called get invoices with balance to return all the invoices with a balance greater than 0 All right before creating the store procedure, Let's first write this query to make sure our query returns the right result. So select everything from the invoices table where invoice total minus payment total is greater than zero so these are the invoices now here we could also use our view so i can select everything from invoices with balance where balance is greater than zero okay this is better because we can see the balance column here so all these invoices have a balance greater than zero beautiful now let's put this inside of a store procedure so first we need to change the default 
delimiter to $2 signs, then we create a procedure called get invoices with balance, we add a pair of parenthesis, then we add begin, it's better to indent our code so we know where our store procedure begins and where it ends. Now here we need to type the new delimiter $2 signs, and then we need to change the default delimiter back to a semicolon. Here we have a syntax error because I forgot to put a semicolon here. So as I told you before, you should always terminate every single statement in a stored procedure with a semicolon. And this is the reason we changed the default delimiter so we can use this semicolon in our stored procedure. Okay? Now let's execute these statements. Alright, back in the navigator panel, let's refresh, here's our new stored procedure, let's call it, and here's the result. 
Beautiful.












Creating Procedures Using MySQLWorkbench:
you might think that creating stored procedures is very tedious in MySQL, because we have to change this default delimiter every time we want to create a stored procedure. So let me show you an easier way. Here in the navigator panel, we can right click on the stored procedures folder, and create a stored procedure. Now in this window we don't have to worry about changing the delimiter, we just focus on our SQL statements. So let's give this new procedure a name, like get payments, as I told you before, MySQL by default adds this back tick character, and this is to prevent a name clash with SQL keywords. So, here we simply select everything from the payments table, and we should terminate this statement with a semicolon. 
Now, here in the bottom right corner, you should see two buttons, apply and revert, as I told you before, unfortunately, they are not visible in my recording window, just click on apply, and then MySQL generates these SQL statements. So it will take care of changing the default delimiter, we don't have to do it. Then go ahead and click apply, alright, now we have a new store procedure here, get payments, when we call this, it returns all the payments, beautiful.




















Dropping Stored Procedures:
In this lecture you're going to learn how to drop a stored procedure. This is particularly useful if you made a mistake and you want to recreate your stored procedure. So we use the drop procedure statement, followed by the name of our procedure, like get clients. Let's execute this, alright, our procedure is gone, so it's not here anymore, now if we execute this statement one more time, we get an error, because mysql will raise an error if we try to drop a procedure that doesn't exist. To prevent the error we can use the if exists keywords. So we change the statement to drop procedure if exists. This is a better and safer way to drop procedures. Also, just like views, it's a good practice to store the code for dropping and creating each stored procedure in a separate sql file, and then put that file under source control like git. 
this way you can share your git repository with other team members, and everyone can recreate this database with all its views and stored procedures on their machine. So typically we have the drop statement first, followed by a semicolon, and then create procedure, get clients, begin, and of course we need to add the delimiter statement here, and also change that to the default delimiter. And then here we can write select everything from the clients table. So this is a basic template for creating stored procedures. Now we save this in a file called get clients. So save, earlier we created the views folder for our views, now we can create another folder for our stored procedures, and here we add get unaligned clients.sql. When you put all these scripts under source control, you can always go back in time and see what changes you made to your database objects at any given point in time.















Parameters:
You have learned how to create and drop stored procedures. In this tutorial I'm going to show you how to add a parameter to your stored procedures. We typically use a parameter to pass a value to your stored procedure, but we can also use parameters to send values to the calling program. We'll look at that later. So here we're using the code for creating a stored procedure called get clients. Now let's create a new procedure called get clients by state. So underline by, underline state. also let's change the name here, by state. We want this stored procedure to receive the name of a state and return the clients in that state. So here in between the parentheses, we need to add a parameter, we call it state, and set its type to char of 2 in parentheses. 
Now this looks a little bit unreadable, so we can break this down into multiple lines like this. So after the create procedure statement, we add a pair of parentheses, and in between parentheses we list all our parameters. If you have multiple parameters, we need to separate them using a comma. Okay? Now, what is this char to here? This represents a string of two characters, like ca for California or ny for New York. We also have varchar, which represents a variable length string, and this is useful for storing names, phone numbers, messages, these are variable length strings. most of the time we use varchar, unless we know that our strings always have a fixed length. In this case, state. Okay? Let me delete this comment. 
Now we look at data types in more detail when we talk about database design. Alright, we added this parameter here, now we need to add a where clause to filter the clients. Actually I realize I made a mistake, this select statement should be after the begin keyword. I hope you caught my mistake, so let's go ahead and add a where clause, where state is equal to state. Now this looks weird, and our filter is not going to work because we're comparing the value in a column with itself. And of course, this condition is always true. So here we need to separate the state column from the state parameter we defined here. There are a few different ways to do this. Some people prefer to prefix or post fix their parameters with something like p underline state as in short for parameter, 
or just pstate with a capital s, other people prefer to add a post fix like state underline param, I personally don't like this, I think this is a little bit verbose, so I prefer to use clean names for my parameters, and then instead, here I'm going to give an alias to our table, c, and then we qualify this column with this table alias, so c.state, and it's quite clear that we're comparing the value in the state column with the state parameter we defined here. Now let's execute these statements, alright, our procedure is created, let's take a look, I'm going to refresh the view, here's get clients by state, so let's go ahead and call this procedure, call get clients by state, I'm going to pass ca, as in short for California, and this returns the clients in California. 
Now, what if we don't supply a value? We get an error here because all parameters are required in MySQL. Here's your exercise for this tutorial. Write a stored procedure to return invoices for a given client. Call it get invoices by client and give it the client id parameter. Now for the type of this parameter, look at the type of client id column and in the invoices table. Alright, here I'm going to create a stored procedure in mysql workbench, let's call this get invoices by client, here we need to add the client id parameter, what is the type of this parameter? Well, let's have a quick look at the type of client id column in the invoices table. So, that is an integer. An integer, as I told you before, represents a whole number. 
So back to our procedure, the type of this parameter should be int, and I'll be right, our statement, select everything from the invoices table, where client id equals to, well, let's give this table an alias, and then qualify our column, and complete the where clause. Alright, and here's our semicolon, Now let's click on apply, there you go, so mysql generated all this stuff, apply, beautiful. We should have this procedure here, get invoices by client, let's call this procedure, now we get this pop up, we can pass client id 1, and this returns the invoices for this client.

















Parameters with Default Value:
In this tutorial I'm going to show you how to assign a default value to a parameter. So here we're using the procedure we created earlier, get clients by state. Now let's make up a rule. If the color of the store procedure doesn't specify the state, we want to return the clients in California by default. So here before executing this query, we can write an if statement like this. If state is null, then We want to give it a default value, and for that we use the set statement. Set state to California. And obviously we need to terminate this statement with a semicolon. So if this condition is true, we assign a default value to this parameter. Now, whenever we use the if statement, we should always Terminate it with and if. 
Because if this condition is true, we might have multiple statements here, so we need to tell mysql what is the end of the if block, okay? Now let's go ahead and recreate this procedure. Alright, our procedure is created, beautiful. Now let's go ahead and call this procedure with null. So I'm going to open a new query window, and here we're going to call get clients by state, and we pass null as the parameter. So this returns the clients in California. Note that here we have to specify a value, even null, because if you leave it out, mysql is going to complain. Alright? So let's add null here. Now let me show you a really powerful trick. Back to our procedure, let's change the rule. 
What if instead of returning the clients in California, we want to return all clients. How can we do that? Here's one way, instead of giving our parameter a default value, we can write a separate query like this. Select everything from the client table. Then, we add an l statement, so if this condition is not true, then we want to return the clients in a given state. So we can move this query up here. Let's fix the indentation, that's better. So we have an if statement, followed by an l statement, and finally end if. Let's recreate this procedure, alright, now back to our query window, if we don't supply the state, we get all the clients If we pass a state like California, we only get the clients in California. 
Beautiful. However, this approach is a little bit verbose and it looks amateurish. We can combine these two queries into a single query. Let me show you how. So, I'm going to delete all these if and else statements, as well as end if, so we have the same query we had before, now I'm going to change the where clause like this. If null, state comma c dot state. What's going on here? You learned about the if null function in the last section, right? If the first value is null, this function returns the second value. So here if we set the parameter to null, this function will return c dot state, and our where clause will essentially look like this. Where c dot state equals c dot state. 
This condition is always true because a value is always equal to itself. It's like writing 1 equals to 1. We're comparing the value in a column with itself, right? So, let's revert this. With this technique, we can optionally filter data. Alright, here's a fantastic exercise for you to practice what you have learned so far. Write a stored procedure called get payments with two parameters. Client id, which is an integer, and payment method id, which is a tiny integer. So both these data types are used for storing whole numbers, a tiny integer takes 1 byte of memory, and with this we can store numbers from 0 to 255. Integer takes 4 bytes, and with this we can store larger numbers. Once again, we'll look at data types later in the course when we talk about database design. 
But if you're curious, you can simply search for mysql int size, in this table you can see various data types for storing whole numbers, We have small int that takes 2 bytes of memory, and this is the maximum value we can store in 2 bytes. We also have medium int, int, which we have seen so far, big int, and so on. So back to our procedure. Both these parameters should be optional. So if we pass null for both of them, our procedure should return all the payments in the database. If it's applied the client id, it should only return the payments for this client. If we set both these parameters, it should return all the payments for the given client using the given payment method. 
It's a fantastic exercise, and it helps you get ready for a job. Alright, here's a solution. Let's create a new procedure. We're going to call this get payment. This procedure needs two parameters. The first one is client id, which is an integer, and the second is payment method id, which is a tiny integer. Now here we write a select statement to select everything from the payments table, where, here we need to type two conditions, because we have two ways to filter data. The first one is for the client, so p.clientid is equal to, once again we use the if null function, if the client id parameter is null, we want to use the same value in the client id column, right? Let me zoom out, 
Alright, this is our first condition, then we need to apply the and operator, followed by our second condition, p.payment method is equal to, so note that the name of this column in this table is payment method, not payment method id, as I told you before, this is one of the real world scenarios, when you work with an existing database, a lot of times you see that the name of the columns are not consistent. Alright? So you'll have to deal with that. Once again, we use the if null function, if the method id parameter is null, you want to use p.payment method. Once again, it's not fitting on the screen, let me break this down, alright, better, so this is the final solution, now let's test it. 
Click apply, and then create the procedure, beautiful. I'm going to open a new query window, and call the get payments procedure with two values, null and null. Now technically the values that we pass here are called arguments, a lot of developers don't know the difference between arguments and parameters. Parameters are the placeholders or the little holes that we define in our procedures or functions. So in our procedure, we define these two parameters, client id and payment method id. The values that we supply for these parameters are called arguments. So anyway, back here, let's execute this procedure. So this returns all the payments in the database, beautiful, what if we pass 1 for the client id, now we only see the payments for this client, what if we pass 5? 
Now it returns all the payments for client number 5, note that the last payment has a different payment method, so let's filter that too. I'm going to pass 2 for the payment method, and now we only see this record, what if we pass 3? We don't see anything because this client doesn't have a payment using this payment method. Alright? And also, as one last test, let's pass null for the client id, and 2 for the payment method. We want to see all the payments using this method. So we only have a single record.





















Parameter Validation: 
you have only seen procedures that select data. But we can also use procedures to insert, update, and delete data. In this lecture we're going to create a procedure to update an invoice and as part of this we'll be looking at parameter validation to ensure that our procedure doesn't accidentally store bad data in our database. So let's start by creating a new procedure, we're going to call this make payment, Here we need three parameters, first is the invoice that we want to make a payment for, so invoice id, and the type of this is integer. The second parameter is the payment amount, and the type of this parameter is decimal of 9 and 2. What is this? Decimal represents a number with a decimal point. 
Here we have two arguments, the first argument represents the total number of digits, and the second argument represents the number of digits after the decimal point. Okay? And finally the last parameter, that is payment date of type date. Alright, now let's write a SQL statement to update the invoice with the given ID. So update, invoices, let's give it an alias, here we set i.payment total to this payment amount parameter, and we also set payment date, so this payment date parameter. And then we write a where clause, where i.invoice id equals this invoice id parameter. Here we only want to update two columns, because when the client makes a payment, we don't want to accidentally update the invoice number or total amount or the invoice date, we only want to update the payment total and payment date columns. 
Alright, let's go ahead and create this procedure. Here's the generated code, beautiful. Let's go ahead, done. Now let's call this procedure. So I'm gonna call it right here. Let's set the parameters, to for the invoice id, 100 for the payment amount, and let's say 2019 January 1st for the payment date. Let's execute this. So this generates a call statement like what you see here. Now, let's go back to our invoices table, and Verify that our invoice was updated properly. Here's invoice number 2, and as you can see the payment total is set to $100, beautiful. But what if we pass a negative value when calling this procedure? Let's execute the statement and see what happens. Back to the invoices table, I'm going to refresh, you can see we have stored minus $100 in the payment total column. 
And that is not good. we shouldn't store invalid data in our database. So let me show you how to validate the arguments that we pass to this store procedure. Back to our procedure, before our update statement, we're going to use an if statement to validate the payment amount parameter. So if payment amount is less than or equal to 0, then here we should use the signal statement to signal or raise an error. This is like throwing an exception in other programming languages. So we type the signal keyword, followed by the sql state keyword, and then a string literal that contains an error code. Where do we find the error code? If you search for sql state errors, you can find the complete list of these errors. 
Now here we have different pages for viewing the complete list, I personally don't like the one on oracle.com, it's poorly formatted, the one on ibm.com is better, let's have a look here. The first two letters specify the class of the error. For example, double 2 represents a data exception. Most of the time in stored procedures we want to deal with out of range values. And there is a standard code for that, that is 22003. Let me show you. So I'm going to search for 22003, these are all the errors in the category of data validation. So 22003 is the standard code for a numeric value that is out of range. And that's exactly what we want. So back to our procedure, let's set the error to 22003. 
Note that this is a string, not a number. So this is how we can signal or raise an error. Now we need to terminate this statement with a semicolon, here we can optionally set an error message, and this helps the color of the procedure identify why something failed. So it's a good practice to set a descriptive message here. So after the code and before the semicolon we type set message underline text equal to let me break this down to multiple lines, that's better. So let's type a meaningful error message here like invalid payment amount. Okay? Then we terminate this statement with a semicolon. And finally, because we have used the if statement here, we need to terminate this block using end if. So this is how we can validate the parameters of our stored procedures. 
Now let's test this. First, let's apply the changes, alright, beautiful, now back to this other query window, if we call this procedure with an invalid payment amount, we get an error in the output window. So it's a good practice to check the parameters of a stored procedure before making any changes to the data. But of course, too much of a good thing is a bad thing. If you write too much validation logic here, your restore procedure will end up looking very bloated and it will become hard to maintain. For example, here I'm not going to check to see if this parameter is null. Because the payment total column doesn't accept null values. So if you pass null to this procedure, MySQL will automatically signal this error. 
We don't have to do it. So keep your validation logic to the bare minimum. The absolute essentials. You should do a more comprehensive validation in your application at the time you receive input from the user. It's much faster to detect and report these errors in the application before hitting the database. Do parameter validation as the last resort in case someone directly calls your store procedure without using the application.





















Output Parameters:
Let's learn how to use parameters to pass values to restore procedures. But as I told you earlier, we can also use parameters to return values to the calling program. So, in this demo let's create a new procedure, get unpaid invoices for client. Here we need a parameter called client id of type integer. Now our query is going to be pretty simple. select, let's say we only want to get the count, and the sum of all these unpaid invoices. So sum of invoice total from the invoices table, i, where i.client id equals to client id, and payment total equals to 0. Let me put this on a new line, that's better. Let's go ahead and create this procedure. Alright, done, now, let's quickly test it before going any further. 
So here it is, get unpaid invoices for client. In this popup I'm going to pass 2 for the client id, we don't have any unpaid invoices for this client, so let's try client number 3. Alright, that's better. So we have a total of 2 unpaid invoices and the total amount is $286. Now, we can also receive these values through parameters. So back to our procedure, we need to add a couple more parameters here. Invoices count, we can use tiny int or int, depending on the possible number of unpaid invoices. For simplicity, let's just go with int. We also need invoices total, that is going to be decimal of 9 and 2. Now, by default, all these parameters in a store procedure are input parameters, which means we can only use them to pass values to our procedures. 
So here we need to prefix these two parameters with the out keyword, and this marks these parameters as output parameters. So we can use them to get values out of this procedure. Okay? Now we need to make a slight change to our select statement. We need to select these two values into invoices underline count and invoices underline total. So we're reading these values and copying them into these output parameters, okay? Now let's apply the changes, good, and then call this procedure again. Now we get three parameters here, the first parameter client id is an input parameter, the other two are output parameters. So let's pass three for the client id and execute, we get the same result as before, But look at the code that is generated here. 
First we have to define two variables, invoices count and invoices total. These are what we call user defined variables. A variable is basically an object that we can use to store a single value in memory. Now to define a variable, we need to prefix it with an add sign. So here using the set statement, we're defining two variables and initializing them to 0. Then, when calling this procedure, we need to pass these variables. So our first argument 3 is the client id, and the other arguments here are the variables that we defined earlier. Now after we call this procedure, we need to use the select statement to read these values and display them here. So as you can see, using output parameters requires a little bit more effort to read data, and I would suggest you avoid them unless you have a valid reason for using them.














Variables:
In the last lecture you learned how to define user variables. These are the variables that we define using the set statement and we prefix them using an at sign. Quite often we use these variables when we call stored procedures that have output parameters. So just like what we did in the last lecture, we pass these variables to get the value of output parameters. Now, these variables will be in memory during the entire client's session. When the client disconnects from MySQL, these variables are freed up. So we refer to this as user or session variables. We define them using the set statement and we prefix them using an at sign. Now in mysql we also have another type of variable called local variable. And these are the variables that we define inside of a stored procedure or function. 
We'll look at functions soon, so for now don't worry about them. Now these local variables don't stay in memory for the entire user session. As soon as our stored procedures finish execution, these variables are freed up. Quite often we use this type of variables to perform calculations in our stored procedures. Let me show you. So I'm going to define a new stored procedure, let's call this get risk factor. Now let's make up a business rule. Let's say risk factor equals to invoices total divided by invoices count multiplied by 5. This is where we use local variables. So we can define these local variables in our procedure, and with this we can easily implement this formula. Let me show you. First we need to declare our variables on the top right after the begin statement. 
So we use the declare statement to declare a variable, let's say risk factor, next we need to specify its type. Let's say decimal of 9 and 2. So as I told you before, that means a number with a decimal point, here we can have a maximum of 9 digits, and 2 digits after the decimal point. Now here we can optionally give this variable a default value, otherwise it's going to be null. Now we need two more variables, invoices total, this is also going to be decimal of 9 and 2, here we have syntax error because I forgot to add a semicolon here, right? Now, I'm not going to give the second variable a default value because we're going to set it using our select statement. 
You will see that in a second. Finally, let's declare another variable, invoices count, and this is going to be an integer, right? Now let's write a select statement to set these two variables. That is very easy. So select count of everything and some of of invoice total from the invoices table, now we need to read these values and put them into these variables. So that's where we use the into statement, into invoices count and invoices total. So here we have two variables which correspond to these two values that we select here. Pretty straight forward. Now let's terminate the statement with a semicolon, next we need to calculate the risk factor. So, we use the set statement to set the value of a variable. 
Set risk factor, invoices total divided by invoices count, let me zoom out a little bit, that's better, and multiply this by 5. Once again, let's terminate this with a semicolon, finally we're going to select this risk factor. So this is how we declare and use local variables in stored procedures. As I told you before, these local variables are only meaningful in our stored procedures, so as soon as we declare them, they become available, and as soon as we finish executing the stored procedure, they go out of memory. Okay? Now let's create this procedure and test it. So, apply, good, and finally, here in the navigator panel let's execute this store procedure, and this returns 777.75.







Functions:
So far you have seen many of the built in functions in mysql. You have seen the aggregate functions like min, max, and so on. You've also seen the functions for working with numbers, dates, strings, and so on. In this tutorial I'm going to show you how to create your own functions. Functions are very similar to stored procedures, but the main difference is that a function can only return a single value. So unlike stored procedures, they cannot return result sets with multiple rows and columns. So in situations where you want to return a single value, you can create a function. A good example of this is the calculation of risk factor that we did in the last lecture. So in this lecture we're going to create a function for calculating the risk factor per client. 
So let's close the stored procedures folder, right click on functions, and create a new function. The syntax for creating functions is very similar to the syntax for creating stored procedures. So here we have create function, we give it a name, like get risk factor for client. Here in parenthesis we define our parameters, like client id of type integer. Next we have this return statement, this is one of the main differences between functions and stored procedures, and this specifies the type of value that this function returns. So we can have int or integer or any other data types that we have in MySQL. Now, right after the return statement, we need to set the attributes of a function. Every mysql function should have at least one attribute. 
These are the attributes. One is deterministic, deterministic, which means if we give this function the same set of values, it always returns the same value. This is useful in situations where you're not going to return a value based on the data in your database, because the data can change. A real world use case is a function that calculates the shipping or tax for an order. You might have a formula based on your business rules. Let's say the tax should be 10% of the orders total. So the function receives the order total and returns the tax amount. It's deterministic, which means it always returns the same output for the same inputs. So here's one attribute. Another attribute is reads SQL data. And this means that you're going to have a select statement in your function to read some data. 
We also have modifies SQL data, and that means you're going to have an insert, update, or delete statement in your function. Now, you can have multiple attributes here. For example, if your function both reads and modifies data, you can have both these attributes here. Now, back to our example. In this example, our function is not going to be deterministic, because if you give it the same client id, it may return different values. One second later, the client may pay some of their invoices, so the risk factor can change in a second. So, we remove this attribute, we're going to read data using a select statement, so I'm going to keep this attribute, but we're not going to modify anything, so I'm going to delete this attribute. 
Next we have the begin statement, here we write our select statements, and finally we should always return a value. So to save time, I'm going to copy some code from our get risk factor procedure that we created in the last lecture. So let's go back there, we're going to bring all these variables, we're going to bring our select statement, as well as the formula for calculating the risk factor. So copy, back to the new function, let's paste them here, now we need to change the select statement, and add a where clause here. So where here we should give this table an alias like i, where i.client id equal to the client id parameter of this function. Next, we calculate the risk factor, and finally using the return statement, we return it. 
So risk factor. That's how we create functions. Let's go ahead and click on apply. Alright, now let's apply the changes, beautiful. Now we have a new function, we can use this function in our select statements just like the built-in functions in MySQL. So we can select the client id and name columns from the clients table. This returns these two columns here. Beautiful. Now we can add a third column and here we can call our new function. Get risk factor for client. And as the argument we pass the client ID. There you go. Now we can see the risk factor for all these clients, some of them don't have a risk factor, we see null here, because these clients don't have any invoices. So back to our function, where we calculate risk factor, we get the invoices total, which is the count of everything, this is always 0 or greater. 
Now the second value here is invoices count, which is the sum of invoice total column. Now if this client doesn't have any invoices, sum is going to return null. So 0 divided by null produces null. Here we can use the if null function, so if risk factor is null we can return 0. Okay, let's apply the changes, beautiful, now, back to our query, let's execute this one more time, now instead of null we have 0. Also, note that the name of this column is based on this function call, you want to rename this to something meaningful like risk factor. That is better. So this is how we create and use our functions. Also, similar to views and stored procedures, it's a good practice to save your functions in SQL files and put them under source control. 
I already covered that before so I'm not going to repeat it. And finally, we can use the drop function statement to drop a function. So we type drop function, optionally and preferably we can type if exists, and then we type the name of the function. Get risk factor for client.








Other Conventions:
you work in different organizations, you will realize that different people adopt different conventions, and quite frankly, everybody likes their own conventions. Some people like to prefix their functions with fn, or their store procedures with proc, with, or without an underline. Some people like to use camel case when naming their functions and store procedures. For example, proc, get, risk, factor. So with camel case, we capitalize the first letter of of every word except the first word. There are other people who think this proc or any other prefix is unnecessary, so they prefer to call this procedure get risk factor. In this course I told you to use an underscore, so we call this procedure get underline risk underline factor. Again, some people love this, some people hate it, don't waste your time arguing about these things, there is no such thing as the very best naming convention, you can never make everybody happy. 
By the same token, there are different conventions for changing the default delimiter, some people like to use double dollar signs, other people like to use double slashes. My advice to you is, wherever you work, adopt the convention that is already there, don't try to reinvent the wheel, because most of the time you'll be working on applications that are already built, they might be a few months or a few years old, if you want to argue with your teammates about the naming conventions that they have used, and say, hey, I'm using this because Mosh told me to do so. This is not going to work my friend, I'm telling you. So stick to the conventions that are already there, and if you're building a new project from scratch, then you can adopt the conventions that I've shown you in this course, assuming that you like them. 
If you don't like them, that's perfectly fine. The bottom line is, whatever convention is there, stick to it.










Triggers and Events:

In this lecture we're going to look at triggers in MySQL. A trigger is a block of SQL code that automatically gets executed before or after an insert, update, or delete statement. Quite often we use triggers to enforce data consistency. For example, in our SQL store database, we can have multiple payments towards a given invoice. Now in this table we have this payment total column, and the value that we have in this column should be equal to the sum of all the payments for this invoice. So whenever we insert a new record in the payments table, we should make sure that the payment total column in the invoices table gets updated. And this is where we use a trigger. Let me show you how to do this. 
So, first we need to change the default delimiter, then we use the create trigger statement, we give our trigger a name, like payments after insert. and this basically means that this trigger is associated with the payments table and is fired after we insert a record. This is a convention that a lot of people use to name their triggers. So first we specify the table name, then we type after or before, and this indicates whether the trigger is fired after or before a SQL statement. And finally we have the type of the SQL statement that will fire this trigger. Okay? Now this is just a name, it has no impact, so we should explicitly tell mysql that we want this trigger to be fired after an insert statement on the payments table. 
So here we type after insert on payments. Here we could also use before, in this example we're going to go with after, we could also use update or delete here, depending on what we're trying to implement. So let's go with insert, Next we need to type for each row. And this means that this trigger gets fired for each row that is affected. So if we insert 5 rows, it will get triggered for each row. Now some database management systems also support table level triggers that get fired only once. So if we insert 1 row or 5 rows, the trigger gets fired only once. Unfortunately at the time of recording this, mysql doesn't support this. Now we type begin and end to indicate the body of this trigger and obviously here we need to type our new delimiter and then change it back to a semicolon. 
Now here in the body of this trigger we can write any sql code to modify our data for consistency. We can write raw sql here or call a store procedure. Now in this example we're going to update the invoices table and increase the payment total amount. So we set payment underline total to payment total plus, now we need to get the new value, the new payment amount. So here we use the new keyword and this returns the row that was just inserted. We also have the old keyword, and this is useful when we're updating or deleting a row, so the old keyword will return the old row with the old values. Now here we're going to use the new keyword and using a dot we can access individual attributes. 
In this case, amount. So just to clarify this, take a look at the payments table, in this table we have the amount column, so whenever we insert a new record in this table, then using new.amount we can access the amount of this new payment. Okay? Next we need to add a where clause, you want to update a particular invoice, right? So where invoice id equals, once again we use the new keyword to get the invoice id. And finally we terminate this with a semicolon. Now just one thing before we test our new trigger. In this trigger we can modify data in any tables except the table that this trigger is for. Otherwise we'll end up with an infinite loop because this trigger will fire itself. 
So we can modify data in any tables except this table here. Alright, now let's create our new trigger, beautiful, so back to our invoices table, look at invoice with the id 3, on my machine, the payment total is 0, I'm going to make a $10 payment towards this invoice, and then I'm going to come back here, I expect the payment total to be updated automatically. So, let's open a new query window, and insert into the payments table what values do we need here? Let's look at the columns. First we need the payment id, for this I'm going to use default, so mysql will generate an id for us, for the client id I'm going to use 5, for invoice id I'm going to use 3, then I'm going to use 2019 January 1st for the date, I'm going to use 10 for the amount, and finally 1 for the payment method. 
Alright, let's execute this, beautiful, back to the invoices table, I'm going to refresh the result, now you can see the payment total for this invoice was automatically updated. This is where our trigger kicked in. Now for exercise, create a trigger that gets fired when we delete a payment. This trigger does the opposite of the trigger that we just created. So it should reduce the total payment amount. Alright, first we need to change the default delimiter, then we create a trigger called payments after delete, here we type after delete on payments, for each row, this is what we're going to do, begin and end, here we use the new delimiter and then change it back to semicolon. Now in the body of this trigger, we want to update the invoices table, and set the payment 
total amount, total, to payment total minus, here we use the old keyword to get the values in the row that was deleted. So old.amount, where invoice id equals old.invoice id. As simple as that. Let's create this trigger, alright, now I'm going to create the payment that we just created, so this invoice, invoice number 3, its payment total should be updated to 0. Back to the navigator panel, let's look at the payments table, scroll to the bottom, so here's the new payment that we created, on my machine that's payment number 10, where I contributed $10 for invoice number 3. So in this window I'm going to delete from payments, where payment id equals 10. Let's execute this statement, beautiful. Now back to the invoices table, I'm going to refresh the result, you can see the payment total for this invoice is updated to 0.














Viewing Triggers:
We have created a couple of triggers so far, but unfortunately in mysql workbench there is no way to visually see the triggers we have created. Here we can only see the tables, views, store procedures, and functions. But don't worry, we can use the show triggers statement to view all triggers in the current database. Take a look. So here we can see various attributes about each trigger, we can see the trigger name, the event, which can be insert, update, or delete, the table, code for the trigger, and we also have the timing which can be before or after, as well as the creation date time for each trigger. Here we can also filter the result, for example, if you only want to see the triggers associated with the payments table, we can use the like operator like this. 
Like payments percent. So this will return triggers that have a name with this pattern. So if you follow the convention that I told you about earlier, this technique you can easily find the triggers associated with a given table. Here's the convention for your reference. First we add the table name, then before or after, and finally the type of the SQL statement which can be insert, update, or delete.




Dropping Triggers:
dropping triggers is very easy. It's very similar to dropping stored procedures. So we use the drop trigger statement, optionally and ideally we use the if exists keywords, and then we type the name of our trigger. Payments after insert. So as a best practice, we should have our drop and create statements in one script file that is also checked into a source code repository So not only can everyone on the team create the same database on their machine, but over time we can view the history of changes to our database. So I'm going to grab this statement and put it over here like this. So first we have the drop statement and then we create the trigger.








Using Triggers for Auditing:
You have seen how we can use triggers for enforcing data consistency. Another common use case for triggers is logging changes to the data for auditing. For example, whenever someone inserts or deletes a record, we can log that somewhere so later we can come back and see who made what changes when. So, I've attached a SQL script to this lecture, you can download it right below this video. When you open that script you're going to see something like this. Here we're using the create table statement to create a new table. We look at creating tables later in the course. For now, just execute the script. Alright, now, we should have a new table in this database. Let's refresh this view. There you go. Payments, audit. 
In this table we have these columns, client id, date, amount, action type, which can be insert, update, or delete, as well as action date that specifies this action was performed. Now this is a very simplified approach to auditing, but it should give you an idea of how we can use triggers for logging changes. Now, back to our triggers. Here we have this trigger payments after insert, after we update the invoices table, we can insert a new record in our audit table. So, it looks like this. Insert into payments values, what values do we need to supply here? Client id, date, amount, let's pass these, so I'm going to get these from the new row, new.client id, new.date, and new.amount. Then we need to supply the type of the action, for this I'm going to pass a string like this, insert, and finally, for the action date, 
we call the now function to get the current date time. Finally, let's terminate this with a semicolon, and now let's recreate this trigger, beautiful. I'm going to make a similar change to the other trigger. So let's copy these two lines for inserting record in the payments audit table, then we go to our other trigger called payments after delete, and note that in this script we have the drop trigger statement before the create trigger statement. so we can recreate it, okay? Now, let me zoom out, so after we update the invoices table, then we insert a new record in our audit table, now in this trigger we're dealing with a row that was deleted, so we need to replace the new keyword with the old keyword, like this, and instead of insert we're going to use delete. 
So this indicates that a row was deleted, and Here we have the values of the row that was deleted, so we can recover it later. Alright, now let's recreate this trigger as well. Beautiful. Now I'm going to create a new payment, insert into payments with these values. Default, 5 for the client, 3 for the invoice, 2019 January 1st for the date, 10 for the amount, and 1 for the payment method. Execute, now let's take a look at our audit table. So now we know that at this date time a new record was inserted into this table, and here are the original values. Now we can create another trigger that will get fired after updating a payment, now let me delete this new payment, so back to the payments table, what is the idea of this payment? 
That is payment number 11. So let's delete from the payments table, where payment id equals 11. Alright, now back to our audit table, let's refresh the result, we have another record here that tells us at this date time, a record was deleted and here are the values for this record. So this is very powerful. Now once again, I've simplified this audit table so you better understand how we can use triggers to log changes. In a real world application, you may want to log changes in many tables, so in that case, you shouldn't create a separate audit table for each table in your database, that's very repetitive. Instead, you need a general structure for logging changes, but let's not worry about it yet, later in the course, when we talk about database design, you will learn how to design general audit tables. 
So this concludes our discussion about triggers, next we'll look at events.








Events:
In this lecture we're going to look at events in MySQL. An event is a task or a block of SQL code that gets executed according to your schedule. It can get executed once or on a regular basis like every day at 10 am or once a month and so on. So with events we can automate database maintenance tasks such as deleting stale data or copying data from one table into an archive table or aggregating data to generate reports. So events are very powerful. Now, before we can schedule an event, we need to turn on mysql event scheduler. That's basically a process that runs in the background, and it constantly looks for events to execute. Let me show you. So here we type show variables, and here we can see all the system variables in mysql. 
As you can see, we have quite a few variables here, we only want to see the event scheduler variable. So here we use the like operator, like event So we want to see only the variables whose names start with event. Right? Take a look, here we have event scheduler which is set to on by default. At your organization, this might be turned off to save system resources, if that's the case you can turn it on using the set statement. So, we type set global event scheduler, we set this to on. Or, if you don't want to use events, you can turn this off to save system resources. So you're not going to have that background process that is constantly checking for events to execute. 
Now let me show you how to create an event. First we need to change the default delimiter, then we use the create event statement, we give our event a name, like yearly delete stale audit rows. So it's a good practice to start our event's name with this interval, like hourly daily, monthly, or once if this event is going to get triggered only once. With this convention we can easily find all the events that get triggered every month or every year or once. So, after the event name, we type on schedule. And here we're going to provide a schedule for this event. How often do we want to execute this task? Once or on a regular basis. If you want to execute it only once, here we use the at keyword followed by a date time value. 
like 2019, may 1st. That's one way. If you want to execute this on a regular basis, instead of the add keyword, we use the every keyword with an interval. Like every one hour, or every two days, or every one year, depending on what we want to implement. Every one year. Now here we can optionally give it a start time, start, let's say, 2019, January 1st, We can also optionally specify an end time, so end, let's say 2029 January 1st. So both these parts are optional, okay? Then we type do followed by begin and end. And obviously here we need to type our new delimiter and then change the default delimiter back to a semicolon. Now in the body of this event, we can write code like this. 
Delete from payments underline audit, where action underline date is less than, we get the current date time, and then subtract one year from it, so interval one year. Earlier you learned about the date add and date sub functions, this expression that we have here is exactly equivalent to using the date add or date sub functions. For example, here we could call date add, pass the current date time, and then interval one year, well here we should pass a negative value to go back one year, or we could use the date sub function and pass a positive value here. Like this. We can also calculate the date like this. That's easier, right? So, with this event, we're going to delete all the audit records that are older than one year. 
Okay? Let's go ahead and create this event. Beautiful.























Viewing, Dropping and Altering Events:
In this lecture I'm going to show you how to view, drop, or alter your events. To view the events in the current database, we use the show events statement. Take a look. Here we can see all the events and their characteristics, for example, in sql invoicing database we have this event, as you can see it's a recurring event, here we have the interval for this event, so it's going to get executed every one year, and you also have the start and end time for this event. Now earlier I told you that it's a good practice to start your event's name with their interval, like hourly, monthly, yearly, or once for one time events. With this convention, we can easily filter events using the like operator. 
For example, to view the events that get triggered every year, we can write like yearly percent. Pretty useful. Now to drop an event, we use the drop event statement, so drop event, if exists, and then specify the name, like yearly, delete, stale, audit rows. We also have the alter event statement to make changes to an event without the need to drop and recreate it. And the syntax is exactly the same as the create event statement. So, instead of create event we can use alter event, then we can change the schedule for this event, we can also change the SQL statements that will be executed when this event is triggered, pretty straightforward. but we can also use the alter event statement to temporarily enable or disable an event. 
Let me show you. So here we can type alter event yearly delete stale audit rows, then we type disable. Or later on we can come back here and enable this event like this. So that concludes our discussion about events. As you have seen, we use events to automate database maintenance tasks. In the next section we're going to look at transactions.

























Transactions and Concurrency:
Transactions:
In this lecture we're going to look at transactions in MySQL. A transaction is a group of SQL statements that represent a single unit of work. So all these statements should be completed successfully or the transaction will fail. For example, think of a bank transaction. When you transfer $10 from your account to your friend's account, $10 should be taken out of your account and deposited into your friend's account, right? So here we have two operations, and these two operations together represent a single unit of work. Either both these operations should complete successfully or if the first operation succeeds but the second operation fails, we need to roll back or revert the changes by the first operation. A database transaction is exactly the same. We use transactions in situations where we want to make multiple changes to the database and we want all these changes to succeed or fail together as a single unit. 
Let's say we want to store an order with an item in our database. We need two SQL statements to store this order, right? What if we insert the order record, but our server crashes at the time we're going to insert the order item? We'll end up with an incomplete order, and our database will not be in a consistent state. We don't want that. That's where we use transactions. Now, these transactions have a few properties that you need to know. The first one is atomicity, and this means our transactions are like atoms. They're unbreakable. Each transaction is a single unit of work no matter how many statements it contains. Either all these statements get executed successfully and the transaction is committed, or the transaction is rolled back and all the changes are undone. 
The second property of transactions is consistency. And that means with these transactions, our database will always remain in a consistent state. We won't end up with an order without an item. the third property of transactions is isolation. And that means these transactions are isolated or protected from each other if they try to modify the same data. So they cannot interfere with each other. If multiple transactions try to update the same data, the rows that are being affected get locked, so only one transaction at a time can update those rows. Other transactions have to wait for that transaction to complete. And the last property of transactions is durability. And that means once a transaction is committed, the changes made by the transaction are permanent. 
So if you have a power failure or a system crash, you're not going to lose the changes. We refer to these properties as asset. In the next lecture I'm going to show you how to create a transaction.








Creating Transactions:
you have learned that a transaction is a group of sql statements that represent a single unit of work. In this lecture, we're going to create a transaction to store an order with an item. Now, before getting started, let's restore our databases so we work with the same data set and there are no surprises later in this section. So here is the script for recreating our databases. I'm going to execute this script. Beautiful. Now, back to our query window, let's use our sql database to create a transaction, we use the start transaction statement. Now in this transaction, first minute to insert an order into the orders table. So, insert into orders. In this table we have a few required columns. Customer ID, order date, and status. 
Now let's set the values. I'm going to use one for the customer ID. 2019 January first for the order date, and one for the status. The values don't really matter. We just want to focus on this transaction next minute to insert the order item. So, insert into order items. All the columns in this table are required, so let's just pass all the values. For the order id i'm going to use the last insert id function. As I told you before, this returns the idea of the newly inserted order. then I'm going to pass one for the product id, one for the quantity, and one for the price. Again, the values don't really matter. Now here we have a syntax error because I forgot to put a semicolon here. 
Let's also terminate this line with a semicolon, beautiful. Now finally, we need to close this transaction using the commit statement. When mysql sees this command, it will write all the changes to the database. If one of the changes fails, it will automatically undo the previous changes, and we say the transaction is rolled back. Let me show you. So, I'm going to execute this transaction, alright, now, let's take a look at the orders table, first we need to refresh this view, alright, here's the SQL store database, and here's the orders table. So here's the new order that we created, order number 11, also let's take a look at the order items table, and this is the item for this order. Alright, now let me simulate the scenario where this second statement is going to fail. 
So our transaction is going to get rolled back, and the change made by the first statement is going to get undone automatically. Let me show you. So on the top, under the query menu, we have this command, execute current statement. With this command we can execute our script line by line. Now look at the shortcut, on the back it's command and enter. So, I'm going to put the cursor on line 3, and press command and enter. Now this line is executed so we have a new transaction, then put the cursor on line 5 and execute this line as well, beautiful. Now we're not going to execute line 8, instead we're going to disconnect from the server. So, I'm going to close this, this simulates the scenario where the client disconnects from the server. 
This can happen for a number of reasons, maybe the client crashes or the network goes offline or the server crashes, it doesn't matter. Now, let's reconnect to the server and look at the data in the orders table. See what we have here. The last order is order number 11 that we successfully inserted earlier. So when we try to insert order number 12, our transaction didn't complete, it was rolled back, that is why we don't have that order here. So most of the time, this is how we code a transaction. We have a start transaction statement on the top, and a commit statement down the bottom. But there are situations that we may want to do some error checking and manually roll back a transaction. 
In those cases, instead of the commit statement, we use the rollback statement. Rollback. So this will roll back the transaction and undo all the changes. Now one more thing before we finish this lecture. MySQL wraps every single statement that we write inside a transaction, and then it will do a if that statement didn't return an error. So whenever we have an insert, update, or delete statement, mysql wraps this inside a transaction and then it will do a commit automatically. This is controlled using a system variable called auto commit. Let me show you. So, let's show variables like auto commit. There you go, we have this variable, auto commit, which is set to on by default. So whenever we execute a single statement, MySQL puts that statement in a transaction and commits it if the statement doesn't raise an error.




Concurrency and Locking:
So far we've been the only user of our database. But in the real world it's quite possible that two or more users will try to access the same data at the same time. This is what we call concurrency. Now concurrency can become a problem when one user modifies the data that other users are trying to retrieve or modify. In this lecture you're going to learn how MySQL handles concurrency by default, and then over the next few lectures you're going to learn how to minimize concurrency problems. So we're going to simulate two users trying to update the points for a given customer at the same time. Let's go to the home page of mysql workbench and open a new connection to our server. Now we have two separate connections or sessions. 
In our first session, let's start a transaction. And By the way, we should make sure that we're using our sequel store database. Okay, so we start a transaction and and give customer number 1 10 extra points. So update customers, set points to points plus 10, where customer id equals 1. And then we commit. Now don't execute this yet. Let's copy this entire code and paste it into our new session. Let me zoom in. Alright, beautiful. Now before executing this script, let's look at the customers table and see how many points customer number 1 has. So, here's the customers table, customer number 1 has currently 2273 points. Now back to our first session, we're going to execute this script line by line. So using the shortcut that you learned earlier under the query menu, execute current statement, right? 
So, let's execute the first line, and then start a transaction, and then update the points. But we're not going to commit. Now we go to our second session, let me close the navigator panel, alright, here's the second session. In this session we should also use our SQL store database, start a transaction, and then try to update the customer. Now look at this spinner here, this update is running, because when we executed the first update, MySQL put a lock on the customer row that we updated. So if another transaction tries to update the same row, it has to wait until the first transaction is complete. Either committed or rolled back. That is why we had this spinner here. Now, this operation timed out, that's why the spinner disappeared. 
So I'm going to repeat this step one more time. In our second session, I'm going to start a new transaction, update the customer, okay, it's waiting, beautiful. Now back to our first session, let's commit the changes. Alright, now let's go to the second session, update is no longer running, so it affected one row, but the changes are not committed yet. Let's commit the changes. Alright, now back to our customers table, let's refresh the result, I look at the points for customer number 1. We have 20 extra points here. because each transaction increased the points by 10. So if a transaction tries to modify a row or multiple rows, it puts a lock on these rows, and this lock prevents other transactions from modifying these rows until the first transaction is done. 
Either it's committed or rolled back. So with the default locking behavior in MySQL you don't have to worry about concurrency problems most of the time. But there are special cases where the default behavior is not sufficient for scenarios in your applications, in those situations you can overwrite the default behavior as I will show you shortly. Next we're going to look at the common concurrency problems and how to solve them.










Concurrency Problems:
Now that you know what concurrency is, let's look at the common problems it brings. The first problem is lost updates. This happens when two transactions try to update the same data and we don't use locks. In this situation, the transaction that commits later will override the changes made by the previous transaction. For example, let's say that we have two transactions that try to update the same customer. One tries to increase the points, the other tries to update the state for this customer. Here's our customer record. John in New York with 10 points. Now we have two transactions, transaction A that tries to update the state of this customer, and transaction B that tries to update the points for this customer. These two transactions occur at the same time. 
This is the customer record that both these transactions see. Now, let's say transaction A updates the state, but it hasn't committed yet. At the same time, transaction B updates the points. Now, the transaction that commits last will overwrite the changes made earlier. In this case, if transaction b commits last, we will lose the update made by transaction a. How can we prevent this from happening? We use locks. So as you saw in the last lecture, by default, mysql uses a lock in mechanism to prevent two transactions from updating the same data at the same time. They will run in sequence one after another, and will have both updates. Let's look at the next common concurrency problem, dirty reads. A dirty read happens when a transaction reads data that hasn't been committed yet. 
For example, transaction A changes the points for a customer from 10 to 20, but before it commits the change, transaction B reads this customer and based on the customer's points makes a decision. Let's say for every one point, it gives a $1 discount to the customer. So it's going to give this customer a $20 discount. Now, what if transaction A rolls back before transaction B completes. Transaction B would have data that had never existed. In other words, this customer never had 20 points, this was never committed to the database, and transaction B gave this customer a $20 discount. So in this scenario, we have read uncommitted data in transaction B. Our data was dirty. Now to solve this problem, we need to provide a level of isolation around our transactions. 
So data modified by transaction it's not immediately visible to other transactions, unless it's committed. The standard SQL defines four transaction isolation levels, which you're going to learn about soon. One of these is read committed. When we use this isolation level for a transaction, that transaction can only read committed data. With this, we won't have dirty reads. Now, what if the data gets changed after our transaction completes? It doesn't really matter. What matters is that any data that we read is committed at the moment it is read. If we make a business decision in a transaction, we base our decision on valid committed data. The data can change later after the transaction and our transaction shouldn't worry about that. So when we set the isolation level for a transaction to read committed, that transaction will only read committed data. 
In the next lecture I'll show you how to set the isolation level. Now let's look at another concurrency problem, non-repeatable reads. So by adding more isolation to our transaction, we can guarantee that our transaction can only read committed data. But what if during the course of a transaction, we read something twice and get different results. For example, transaction A reads our customer's points, it sees that this customer has 10 points, so it will make a business decision based on this value. Now, before transaction A completes, another transaction, like transaction B, updates the points for this customer to 0. Now back to transaction A, we read the points for this customer one more time, perhaps as part of a subquery. Now in this transaction, we have read the points twice, and each time we have seen a different value. 
This is a non-repeatable or inconsistent read. How should we handle this situation? Well, we can argue that at any point in time, we should make decisions based on what is the most up to date. If that's the case for a business scenario, we don't really have to worry about anything here. But we can also argue that at the time our transaction started, this customer had 10 points, so we should have given them a $10 discount. If the points change during this transaction, we shouldn't see the changes. We should see the initial snapshot. If that's what we want, then we need to increase the isolation level of our transaction. We need to isolate it from other transactions such that changes to the data aren't visible to our transaction. 
The SQL standard defines another isolation level called repeatable reads. With this level, our reads are repeatable and consistent, even if the data gets changed by other transactions. We'll see the snapshot that was established by the first read. And the last common concurrency problem is phantom reads. Imagine in transaction A, we're querying all the customers who have more than 10 points. Perhaps we want to send them a special discount code. Now at the same time, transaction B updates the points for another customer that was not returned by our query. So this customer is now eligible for this discount code, but at the time we queried the customers table, we didn't see this customer. So after transaction A completes, there is still one eligible customer that didn't receive this discount code. 
This is what we call a phantom read. Phantom means ghost. So we have data that suddenly appears like a ghost, and we miss them in our query because they get added, updated, or removed after we execute our query. How can we solve this problem? it depends on the business problem we're trying to solve and how important it is to include this customer in our transaction. We can always re-execute transaction A at a later time, and this customer will also get a discount code. Not a big deal. But if it's absolutely critical to include all eligible customers in our transaction, we'll have to make sure that no other transactions are running that can impact our query to find the eligible customers. For this, we have another isolation level called 
serializable, and this will guarantee that our transaction will be aware of changes currently being made by other transactions to the data. If there are other transactions modifying the data that can impact our query result, our transaction has to wait for them to complete. So transactions will be executed sequentially. This is the highest level of isolation that we can apply to a transaction, and it gives us the most certainty in our operations. But it comes with a cost. the more users and concurrent transactions we have, the more rates we're going to experience and our system is going to slow down. So this isolation level can hurt performance and scalability. For this reason, we should reserve this only in scenarios where it's absolutely critical and necessary to prevent phantom reads. 
Now, if all this sounds overwhelming, don't worry. We're going to review all these concurrency problems on how to solve them again. Later in this section, will show you each concurrency problem and how to solve it using a transaction isolation level.















Transaction Isolation Levels:
In the last lecture you learned about common concurrency problems and how we can prevent them using standard transaction isolation levels. In this lecture we're going to review these isolation levels one more time and I will summarize everything for you in a way that you can easily remember. Let's start by reviewing the concurrency problems. We have lost updates which happens when two transactions update the same row and the one that commits last overwrites the changes made earlier. We have dirty reads that happen if you read uncommitted data. Another problem is non-repeating reads, which happen if you read the same data twice in a transaction, but get different results. And phantom reads which happen when we miss one or more rows in our query, because another transaction is changing the data and we are not aware of the changes in our transaction, we are dealing with phantoms or ghosts. 
Now to solve these four problems we have four standard transaction isolation levels. Read uncommitted doesn't really protect us from any of these problems because our transactions are not isolated from each other and they can read uncommitted changes by each other. Next we have read committed which gives our transactions a bit of isolation so we can only read committed data and this prevents dirty reads. But at this level it is possible that during a transaction we read something twice and we get different results because another transaction updates the data in between the two reads. So it doesn't really protect us from non-repeatable reads. That brings us to the repeatable reads level. At this level we can be confident that multiple reads return the same result, even if the data gets changed in the meantime. 
And finally we have serializable, which prevents all these common problems. With this level we can prevent phantom reads, so if data is getting changed in the meantime, our transaction will wait to get the most recent data. Obviously this puts an overhead on the server because it needs extra resources in terms of memory and CPU to manage the transactions that have to wait. So the more we increase the isolation level, the more performance and scalability problems we're going to experience because more locks will be involved to isolate transactions. So to recap, a lower isolation level gives us more concurrency, so more users can access the same data at the same time. But more concurrency means more concurrency problems. On the flip side, we achieve a 
performance because we need fewer locks to isolate transactions from each other. A higher isolation level restricts concurrency and that means fewer concurrency problems. But at the cost of decreased performance and scalability because we need more locks and resources. So the fastest isolation level is read uncommitted because it doesn't set any locks and it ignores the locks set by other transactions. For this reason, you may experience all concurrency problems. As we go down this list, we get better protection from the concurrency problems, but that also means we're going to use more locks, and this requires more resources which can hurt performance and scalability. In MySQL, the default transaction isolation level is repeatable reads, which works well for most scenarios. It's faster than sterilizable and prevents most concurrency problems except phantom reads. 
So, stick to this unless you absolutely have to prevent phantom reads for a specific transaction. In that case, you can use the serializable level for that particular transaction. As for the other two isolation levels, read committed and read uncommitted, you can use this in situations such as bulk reporting where you don't need precise consistency or when you deal with data that is rarely updated and you want to achieve a better performance. Again, I would say stick to the default for most scenarios and only change the isolation level if you really have to. Now let me show you how to set the transaction isolation level. First, let's view the current isolation level. We're going to use the show variables statement to view the system variables used by MySQL, and then we're going to filter the list to only see a variable called transaction underline isolation. 
There you go. So, the current transaction isolation level is repeatable read. This is the default in MySQL. now to change the transaction isolation level, we use the set transaction isolation level statement and then we type the name of the new isolation level such as serializable. This will set the isolation level for the next transaction. We can also set the isolation level for all future transactions in the current session or connection. So we add the session keyword here. So as long as we have this session or connection open, all the future transactions will have this isolation level. We can also set the isolation level globally for all new transactions in all sessions. And for that we use the global keyword. Now if you're an application developer, you have a function or method somewhere in your application that connects to your database to execute a given transaction. 
You may use an object relational mapper or directly connect to MySQL. Either way, just before executing your transaction, you change the isolation level only for that session or connection, and then run your transaction. So you connect to MySQL, change the isolation level, execute your transaction and disconnect. This way other transactions in the database will not be affected. Alright, that brings us to the end of this lecture, we're going to see each of these isolation levels in action.





















READ UNCOMMITED Isolation Level:
this picture you're going to see the read uncommitted transaction isolation level in action. If you want to follow along with me, do it exactly like what i'm going to show you so there are no surprises later on. First I'm going to close both these sessions because i want to start from a blank canvas. So let's open a new connection, this simulates one client, now let's open another connection, and here's our second client. Now in the first session, first let's use database, then we're going to set the transaction isolation level to read uncommitted. With this isolation level, we'll be able to read uncommitted data. So we're going to have dirty reads. Then let's select points from the customers table where customer id equals 1. 
Now let's go to the second session, Here, once again, we're going to use the sql store database. We're going to start a transaction, and in this transaction we're going to update the points for this customer. So, update customers, set points to 20, where customer id equals 1. And finally we're going to commit. Now before executing any of these scripts, let's look at our customers table and see how many points this customer has. So here's our customers table, our first customer has 2293 points. Beautiful. Now let's go to the first session, we're going to execute line 1, then we're going to set the transaction isolation level, so the next transaction is going to have this isolation level. But here we don't have a start transaction statement, 
because as I told you before, every single statement that we execute, mysql wraps that statement inside of a transaction and automatically commits that. So here we're not modifying any data, but this select statement is still executed inside of a transaction. Okay? Now, we're not going to execute this line, instead we're going to go to the second session, first we're going to use our sql store, then we're going to start a new transaction, and update the point for this customer. Now we haven't committed the changes at this point, but if we go back to the first session, because we set the isolation level to read uncommitted, this select statement will read uncommitted data. Take a look. So, execute, now we have 20 points but as you saw earlier, this customer should have 2293 points. 
Now here's the problem, in this transaction we are reading the points as 20, we might make a decision based on this value but what if in the first transaction this commit never happens, for whatever reason, maybe the server crashes or the transaction explicitly rolls back. So let's roll back. Now in our first transaction we're dealing with a value that never existed in the database. This is the problem with dirty reads. So to recap, read uncommitted is the lowest isolation level, and with this level we may experience all concurrency problems.
















READ COMMITTED Isolation Level:
In this lecture you're going to see the read committed isolation level in action. So you saw the problem with dirty reads in the last lecture, now we're going to change this isolation level to read committed. So read committed. With this isolation level we can only read committed data. So we're not going to have dirty reads. Now before executing any of these scripts, let's double check what we have in the customers table. So I'm going to refresh the result, customer number 1 has 2000 points. alright, now back to the first session, let's execute line 2 to set the isolation level alright, now back to the second session once again we're going to start a new transaction, we're going to update the customer's points to 20, but we haven't committed anything yet, so if we go back to the first session and read the points, we should not see that uncommitted data, take a look, select points, we have 
2293. Now back to the second session, if this transaction is committed, let's commit it, now our customer has 20 points, so we go to the first session, read the points again, and now we have 20 points. Beautiful. So at this isolation level, we don't have data reads, but we have another problem. We have unrepeatable reads. So it is possible that during a transaction read something twice, but we get different values each time. Let me show you. So, here we're going to start a transaction because we're going to have two select statements. So, start transaction, here's our first select statement, I'm going to copy paste this one more time, and then commit. Now for clarity, I'm going to compress this select statement into one line. 
Like this. So we have two select statements, that's better. Alright, now once again we need to execute line 2 to set the isolation level, because this only applies to the next transaction. We already had a transaction with this isolation level, so this new transaction is not going to have the same isolation level, it's going to have the default isolation level, which is repeatable read. So let's execute line 2, alright, now we start the transaction, we read the points, there you go, we have 20 points, now before we execute the next line, we're going to go to the second session and update the points to let's say 30. So here we're going to start a new transaction, update the points and then commit. Now if you go back to the first session and read the points again, we get a different value. 
So at this isolation level, we have non-repeatable or inconsistent reads. To solve this problem, we need to increase the isolation level for this transaction and That's what I'm going to show you next.








REPEATABLE READ Isolation Level:
you're going to see the repeatable read isolation level in action. With this isolation level, our reads are going to be consistent and repeatable. Let me show you. And the first thing we want to do here is to commit the transaction from the last lecture. So we can come back and change the isolation level for the next transaction. So commit this, nothing happens, that's perfectly fine. Now let's change the isolation level to repeatable read. Alright, now let's execute line 2, then let's start a new transaction, we're going to read the points, so currently we have 30 points, now before we execute the next line, let's go to the second session, and change the points for this customer to 40. So we're going to start the transaction, update the points, and commit. 
Now back to the first session, when we execute the next line, we're going to see the same value, take a look. We got 30, so our reads are repeatable and consistent. So this is the benefit of this isolation level. And by the way, as I told you before, this is the default isolation level in MySQL that solves most of the concurrency problems. But at this level, we have one problem and that is phantom reads. So let's change our query to get the customers located in Virginia. Perhaps you want to give these customers a special discount. So, we're going to select everything from the customers table, where state equals virginia. Now we don't really need to repeat this query, so let's delete line 5, so if we execute line 4, we see customer number 2 as the only customer who is located in virginia. 
Now to start a new demo, let's commit this current transaction, alright done, alright now we're going to start another transaction, but before selecting the customers, let's go to the second session, and set the state for customer number 1 to Virginia. This customer is not currently located in Virginia, so the scenario that we're simulating here is that one client tries to read the customers that are located in Virginia, and at the same time another client is updating the data such that this customer, customer number 1 should be included in this query that client number 1 is executing. So here in the second session, let's start a transaction, update the customers, now we're not going to commit anything yet, this is just a pending transaction in memory. 
So technically this is not written to the database. So if you go back to the first session and read the customers, obviously we're only going to see customer number 2. Now at this point, the second session is going to commit the changes. So now we have two customers located in Virginia, but we missed one of them, customer number 1. If you read this customer again one more time in this transaction, we're going to see the same result, because with repeatable read, our reads are going to be consistent. So we'll have to commit this transaction, now if you read this customer one more time, we can see we have two customers in Virginia, but we missed one of them. This is what we call a phantom read. 
In the next lecture I'm going to show you how to use the serializable isolation level to solve this problem.









SERIALIZABLE Isolation Level:
In this lecture we're going to look at the serializable isolation level, which provides the highest level of isolation and solves all concurrency problems. So at this level our transactions are executed in sequence, one after another. So you really don't have concurrency. The experience we get is like a single user system. One user executing different commands against the database. These commands are executed sequentially. Now following the example from the last lecture, let's execute line 4, So currently we have only two customers in Virginia. Now we're going to change the transaction isolation level to serializable. Let's execute line 2, alright. Now, we start a new transaction, but before we read the customers in Virginia, let's go to the second session and add another customer in Virginia. 
So, customer number 3. So we start a transaction, we update the customers we haven't committed anything yet. So while the first client is trying to read the customers in Virginia, another client is updating customer number 3, so this customer should be included in our query, otherwise we're going to have phantom reads. So, I'm not going to commit this transaction yet, instead, we're going to execute line 4, now, look at this spinner here. This transaction is waiting for this other transaction to finish. this is the result of serializable isolation level. So once we commit this, then our transaction will execute, and now we have three customers in Virginia. So with the serializable isolation level, we solve all concurrency problems, we don't have phantom reads, we don't have lost updates or dirty reads, all concurrency problems get resolved because our transactions are executed sequentially, one after another. 
The more users and the more concurrent requests we have, the more weights we're going to experience. So as I told you before, use this isolation level only for situations where you want to prevent phantom reads. But not for every transaction in your system. The default isolation level that is repeatable read works for most scenarios. So stick to that, unless you know what you're doing.














Deadlocks:
Now let's look at a classic problem in databases, deadlocks. What is a deadlock? A deadlock happens when different transactions cannot complete because each transaction holds a lock that the other needs. So both transactions keep waiting for each other and never release their lock. Let me show you. So here in MySQL workbench, I'm going to close both these sessions and start over. I want to make sure there are no surprises, we start from a clean canvas. So let's open a new connection, and one more time, in our first session, we're going to use our sql store database, then we're going to start a transaction, in this transaction we're going to update two records. First we're going to update the customers table, and set this date to virginia for customer number 1. 
So where customer id equals 1. let me zoom out a little bit, that's better, then we're going to update the orders table and set the status of an order to 1 where order id equals 1. Now don't worry about these values I've used here, it doesn't really matter. What matters is that first we're updating one record in the customers table, and then we're updating one record in the orders table. Okay? And finally we're going to commit here. Now, Before executing the script, let's copy this entire code and paste it into the second session. Like this. But here in the second session, we should change the order of these update statements. So we update the orders table first and then the customers table. I will explain why this matters shortly. 
Now back to the first session. In this transaction, when we execute line 3, we're going to update customer number 1. This transaction will put a lock on this record, so other transactions will not be able to update this record, right? They'll have to wait. And this doesn't matter what isolation level we use. Earlier in this section, you learned that whenever we try to update a record, MySQL puts a lock on that record, so other transactions have to wait. So here we try to update this customer, but let's imagine, before line 4 is executed, another user starts a new transaction at the same time. This user is going to update one order in this table, order number 1. So this transaction is going to put a lock on this record. 
Then, this line is about to get executed, so we try to update the same customer that the other transaction updated. So transaction number 1 already put a lock on this record, so we cannot complete this transaction, we'll have to wait for that transaction to complete. Okay? Now we go back to the first transaction, and execute line 4. At this point we try to update order number 1, but transaction number 2 already put a lock on this record, so we'll have to wait for that transaction to complete. Here's the problem, both these transactions are waiting for each other and they will never be able to complete. This is what we call a dead lock. So let's see this in action. Here in the first session, let's execute the first statement, then we're going to start a transaction, we update the customer, now we go to the second session, 
and once again, use our sql store database, we start a new transaction, we update the order, so far so good, now we update the customer, this transaction is waiting, take a look here, so we go back to the first transaction, and execute line 4. Now we get a deadlock. So if you look at the output window, you can see an error here, error 1, 2, 1, 3, deadlock found. In this situation, MySQL treats this transaction as the victim and rolls it back. So this is how a deadlock happens. Generally speaking, deadlocks are not a big issue unless they happen so frequently. If you're an application developer, you should write your application in a way that it can reissue a transaction if it gets rolled back because of a deadlock. 
Or you may just tell the user, hey, this operation failed, please try again. But there are a few things that you can do to minimize deadlocks. You can never completely get rid of them, you can just minimize their likelihood. Here are a few things. If you frequently detect deadlocks in two transactions, look at their code. These transactions could be part of two store procedures. Now look at the order of the statements in your transactions. If these transactions update records in the reverse order, it's likely you're going to have a deadlock. That is the reason we swapped the order of these statements in the second session earlier. So to reduce deadlocks, you can follow the same order when updating multiple records. That's one solution. 
The other thing you can do is to keep your transactions small and short in duration, so they're not likely to collide with other transactions. If you have transactions that operate on really large tables, these transactions may take a long time to run. And then you're at risk for collision. If that's the case, see if you can schedule those transactions to run during the non-peak hours when there are not a lot of active users. So that's pretty much what you can do. And that brings us to the end of this section. If you found this section a little bit overwhelming, I totally understand. Quite honestly, concurrency is a fairly advanced topic and it's okay if you're confused the first time you're learning about it. 
I personally had the same experience myself and I had to look at several different sources to really understand concurrency. Trust me, you're not going to find any books or videos that simplifies this concept for you the way I've done in this section. I've worked really hard on this section to make it super simple for you. So if you're confused, just take a break and watch this section again from the beginning. I promise you're going to digest everything I've explained. Alright, that's it for now, I will see you in the next section.









Data types:
 
You have seen some of the data types supported by MySQL. It's really important for you to understand these data types and when to use which, because in the next section we're going to talk about designing databases, and that's where you're going to use these data types. So in this section, we're going to explore all these data types. In MySQL we have several categories of data types. We have string types, numeric types, date and time types, blob types for storing binary data, and spatial types storing geometric or geographical values. Over the next few lectures, we're going to explore various data types in each category. So, let's get started.







String Types:
the string category, we have a bunch of data types. The most common ones are char and varchar. As I told you before, we use chars for storing fixed length strings, like the abbreviation of states, and varchar for storing variable length strings, like usernames, passwords, emails, addresses, and so on. Now, even though these are string types, we can also use them to store numeric values like zip codes and phone numbers, because we don't use these values in mathematical operations. Also, sometimes these values may contain a hyphen or parenthesis to group a few digits, and that's another reason that we should store these values as a string of characters. I personally like to use a standard length for most of my varchar columns, for example, I use 50 for short strings like usernames and passwords, and 255 for longer strings like addresses. 
This consistency simplifies the maintenance of your databases. You don't have to constantly check the lengths of each color. Now, the maximum length for varchar is just over 65,000, so if you store something that is longer, it will get truncated. To prevent that, you can use medium text, which allows you to store up to roughly 16 million characters. And this is good for storing JSON objects, CSV strings, and short to medium length books. You also have long text, which can store up to 4GB of textual data. And this is good for storing textbooks or years of log files. These are the main string data types that you'll be using most of the time. You also have tiny text, which can store up to 255 characters, and text which can store up to 65,000 characters, just like varchar. 
But for this range of characters, it's better to use the varchar type because it can be indexed. We'll talk about indexes later in the course, but basically we use indexes to speed up our queries. Also, all these types support international characters, English letters use 1 byte, European and Middle Eastern languages use 2 bytes, and Asian languages like Chinese and Japanese use 3 bytes. So if the type of a column is char of 10, MySQL will reserve 30 bytes for the values in that column. Next we'll look at integer types.






















Integer Types:
We use integers to store whole numbers that don't have a decimal point, like 1, 2, 3, 4. In mysql we have 5 integer types, and these are different in terms of the number of bytes they use and the range of values they can store. Obviously the more bytes we have, the larger the numbers we can store. So we have tiny int, which takes only 1 byte, and with this we can store the numbers minus 128 to 127. Now, if you mark a numeric column as unsigned, it can only store positive numbers. So with an unsigned tiny int we'll be able to store the numbers 0 to 255. This is particularly useful when storing positive values like people's age. If you mark this column as unsigned, we can prevent a negative value from being accidentally stored in our database. 
Next we have small int which takes 2 bytes and gives us a bigger range. We also have medium int which takes 3 bytes, int integer which takes 4 bytes, and big int which takes 8 bytes. Now don't worry about memorizing any of these ranges, you can always google mysql integer types and you will see this table that clearly shows the number of bytes for each type, as well as the range of values they can store. Now if we try to store a value outside the range of a columns data type, mysql throws an error saying the value is out of range, so our insert and update operations will fail. Also, apart from unsigned, Numeric types have another attribute and that is called zero fill. 
This is useful in situations where you want to zero pad the values so they always have the same number of digits. When defining a numeric column, we can specify the display size in parenthesis. For example, with int of 4, our numbers will always have 4 digits, so the number 1 will be padded with 3 zeros. Note that this will only affect how MySQL displays these values, not how it stores them. Now as a best practice, try to use the smallest data type that suits your needs. With this your database will be smaller in size, and your queries will execute faster. For example, if you want to store the age of people, you can use an unsigned tiny int. No one is going to age more than 255 years, at least not anytime soon. 
So one byte is sufficient to store people's age. You may think that saving a byte or two doesn't really matter these days because disk space is cheap, that is true, but if you're dealing with large amounts of data, your queries will perform better if you use every byte consciously. Because these bytes of data will have to be transferred between the disk and the memory. So the less data you have in memory, the faster your queries are going to be. So keep things smaller and more compact.






Fixed-point and Floating-point Types:
we have three types for storing numbers with a decimal point. We have the decimal type, and this is useful for storing fixed point numbers. These are the numbers that have a fixed number of digits after the decimal point, like monetary values. When using the decimal type, we need to supply two arguments, precision and scale. The precision specifies the maximum number of digits, and this can be between 1 and 65. The scale determines the number of digits after the decimal point. For example, with decimal of 9 and 2, we can store a number with a maximum of 9 digits, we have 2 digits after and 7 digits before the decimal point. Also, this decimal type has a few synonyms, they are des, numeric, and fixed. 
These are exactly the same. So just stick to decimal and keep things consistent. I mention these synonyms in case you see them in databases designed by others. We also have the double and float types, And these are used in scientific calculations. If you want to perform calculations with very large or very small numbers, you should use these types. Just remember, these types don't store the exact value, they use an approximation. That's the reason they allow us to store really large or really small numbers. Flow takes 4 bytes, double takes 8 bytes, so obviously with double we can store larger numbers. So if you want to work with exact values like monetary values, you should use the decimal type. If you want to work with really large or small numbers in scientific calculations, and the precision is not important, you should use float or double.



Boolean Types: 
are times that we need to store a yes or no kind of value. For example, is this blog post published or not? That's when we use boolean values which are true and false. In MySQL we have a data type called bull or boolean and this data type is actually a synonym for tiny int. So with a boolean column we can write code like this. Now this true keyword you see here is internally represented as a one and false is represented as a zero so we could rewrite this code like this. In my opinion, true and false keywords are more descriptive, but I leave it up to you to choose the style that you like. What you need to understand is that true and false are synonyms for 1 and 0.









Enum and Set Types:
There are times that we want to restrict the values for a column to a limited list of strings. For example, you might have a column called size, and in this column, we only want to allow the values small, medium, and large. This is where we use the enum type. Let me show you. Here in our SQL store database, I'm going to open the products table in the design mode, and add a new column here called size. Now let's set the type of this column to enum, and here we need to pass three string values. small, medium, large. Let's close the parenthesis and press tab, one more time, and then click on apply, so here are the changes, we're going to add a new column called size, and the type of this column is enum of these three values. 
Let's apply the changes, now let's open the table, and set the size of one of these products here. So, The only values we can set here are small, medium, or large. If you use anything else MySQL is going to give us an error. So here we can type small in lower case or upper case, it doesn't matter. Now let's apply the changes. Beautiful. I'm going to close this tab and reopen the products table. Now look at the size of the first product. It's small. So this is how enums work. Now, while this may look appealing to you, in my opinion, enums are generally bad and you should avoid them. The first reason is that changing the members of an enum can be expensive. 
For example, let's say tomorrow we decide to come back to our products table and add a new member here. Or maybe rename one of these members. MySQL is going to rebuild this entire table, and this can be expensive if we have millions of records in this table. Also with this approach, we can add additional attributes to each member. For example, what if we want to include the actual measurements for each size? we can do that. Also, if you want to get the list of all possible sizes and display them in a drop down list in our application, you have to do a bit more work, it's not that easy. Plus, these enums are not reusable. So if you have another table and you want to reuse these values there, in that table we need to redefine this enum with these members. 
And that duplication means if we decide to make a change in one of these members, we'll have to apply that change in multiple places. So these are some of the reasons that I believe enums are bad and you should avoid them. A better approach is to have a separate table called sizes. In this table, we can store all the sizes and any additional attributes they have like their measurement. We can reuse this table in multiple places and if you want to get all the sizes, we write a single select statement. That's really easy. We refer to this kind of table as a lookup table. In our sequel invoicing database, this payment methods table is also another lookup table. Quite often we use these tables to feed our drop down lists. 
So, back to enums, just because mysql supports them doesn't mean you should use them. I only explain them here so you're aware of them and know why they're bad. We also have another similar type called a set, but a set can store multiple values. So similar to enums, we specify the list of allowable values, and then we can store multiple values in a column. Again, this is really bad because It causes all sorts of issues. In the next section, when we talk about normalization, you will learn a better approach to deal with these scenarios.










Date and Time Types:

In MySQL we have four data types for storing date and time values. We have date for storing a date without a time component, time for storing a time value, date time, time stamp, and year for storing a four digit year. We often use time stamps for keeping track of when a row was inserted or last updated. We can also use the date time for that, the difference is that time stamp is four bytes, and it can only store dates up to the year 2038. This is called the year 2038 problem. Date time uses 8 bytes, so if you want to store dates that go beyond the year 2038, you should use the date time type.








Blob Types:
We use blob types to store large amounts of binary data like images, videos, PDFs, word files, pretty much any binary data. In MySQL we have four blob types, and they differ based on the maximum amount of data they can store. We have tiny blob for storing binary data up to 255 bytes, blob for storing binary data up to 65 kilobytes, medium blob for storing binary data up to 16 megabytes, and block for storing binary data up to 4 gigabytes. Generally speaking, it's better to keep your files out of your databases because relational databases are designed for working with structured relational data, not binary data. If you store your files in a database, your database size is going to increase pretty quickly and that will slow down your backups. 
You will also experience performance problems because pulling images out of your database is always slower than reading them from the file system. plus you will have to write additional code to read or store images in a database. If you have valid reasons for storing your files in a database, first take all this into account and make sure these reasons don't apply to your scenario.





















JSON Type:
In mysql we can also store json documents. In case you're not familiar with json or javascript object Notation, it's basically a lightweight format for storing and transferring data over the internet. It's used heavily in web and mobile applications, so most of the time your mobile apps send your data to the back end using JSON. In JSON we use curly braces to define an object. Inside these braces we can have one or more key value pairs, keys are always strings, so we need to surround them with quotes. Values can be anything, they can be strings, numbers, booleans, arrays, or other objects. So in our SQL store database, let's open up the products table, and add a new column here. We're going to call that properties, to store additional properties about each product. 
For example, clothes can have a size and color, but things like a TV have other specs like weight, dimension, and so on. So it's not a good idea to add several columns in this table where only a subset of these columns apply to each product. This is where we can use JSON to easily store multiple key value pairs about each product. So we call this column properties and set its type to JSON. Alright, now let's apply the changes, beautiful. Now in case you get an error at this point, you need to go to mysql workbench menu on the top, go to preferences, here under modeling, select mysql, make sure your target mysql version is at least 8. So here I'm using 8.0.15. If you have an earlier version number here, you're going to get an error. 
Alright, now we have this json column here, let me show you how to use this. So in this query window, I'm going to update the products table, and set the properties of our first product. So this equals here we add single quotes, and in between these quotes we define a json object. So earlier I told you that we use curly braces to define an object, in between the braces we add one or more key value pairs. Our keys are always strings so we surround them with double quotes, let's say dimensions, then we add a colon, and here we set the value. In this case I'm going to pass an array which is a list of values, let's say 1, 2, and 3. Next we add a comma to add another key value pair, let's say weight, we set this to 10, and finally let's say manufacturer, we can set this to a string like sony, but let's make this example more interesting. 
I'm going to set this to an object. So here we're dealing with a nested json object. In this object I'm going to add a property or a key called name, and the value for this key is going to be sony. Now finally let's apply our where clause, where product id equals 1. Alright, let's execute this, beautiful, now I'm going to open another query window, let's select everything from the products table, so here's the first product, look at the properties column, this is our json object. Now we can query this object and extract individual key value pairs, I'm going to show you that in a second. But before we get there, Let me show you another way to create a JSON object in SQL. 
So here we're using single quotes, and in between the quotes we're using the standard JSON format. Curly braces and key value pairs. But in MySQL we have a few functions for creating JSON objects. So I'm going to delete this string here, and instead call the JSON object function. In this function we can pass multiple key value pairs. For example, we can set weight to 10, and dimensions, let me zoom out a little bit, alright, we can set the dimensions to an array, for that we need to call the json array function. Let me break this up into multiple lines, that's easier to read, so we set the weight to 10, dimensions to an array, in this array we pass multiple values, let's say 1, 2, and 3, we need one more key value pair, 
that was our manufacturer, manufacturer, we set this to a json object, so json object, in this object we're going to have a key called name, and the value for this key is going to be sony. And then we need one more parenthesis to close the call to the json object function. So what we have here is exactly identical to what we wrote earlier. But here we're using the internal functions in MySQL. Let's execute this one more time, beautiful. Now back to our other query window. We can extract individual key value pairs from this json object. And this is the benefit of defining this column as a json column as opposed to a varchar, because with strings it's very difficult to extract individual key value pairs in a json object. 
So, here I'm going to select the product id, and let's say from the properties column we only want to extract the weight, so we call json underline extract, the first argument to this function is a json object, in this case, what we have in the properties column. The second argument is a path, so here we add a string, in this string we add a dollar sign, and this represents the current json document. Then we use a period to access individual properties or keys, in this case, weight. Now let's apply a where clause as well, product id equals 1. So, as you can see we could successfully extract the weight for this product. We could also give it an alias like weight, that is better. 
But there is a shorter way to write this code. Instead of calling the JSON extract function, we can use a special operator to access individual properties in a JSON object. Let me show you. So, we start with our properties column, Then we add this operator, hyphen, greater than. This is called the column pass operator. And then we add our pass. So dollar sign, that is the current document, dot, wait. This returns exactly the same result as before. Now what if you're dealing with a key whose value is an array? Like the dimensions. We get that array here, but we can also access individual items in this array. So here we add square brackets, and inside these brackets we specify the index of the item we want to retrieve. 
To get the first item, in this case 1, we pass 0. Now, we get the first item in this array. What about working with nested objects? Like the manufacturer property. So, we type manufacturer, as you know this returns a JSON object, once again we can use the period operator to access individual properties in this object. So manufacturer.name returns sony. But because sony is a string, we see double quotes here, sometimes this is not desirable. For example, we might have this expression in a where clause, and let's say we only want to get products whose manufacturer is sony. We don't want to get rid of this quote. That is where we use another greater than sign. Now, take a look, we get Sony without any quotes. 
So we can change our where clause to something like this. I'm going to copy this entire expression and put it here, now we get this and compare it with Sony. There you go. So this is how we can extract various pieces of a JSON object. Now we also have a few functions for updating JSON objects in our database. For example, back to our first query window, let's say we want to change the weight of this product. We don't want to reset this entire object, we only want to update the weight property. How can we do this? That is when we use the json set function. Let me remove these arguments, alright. The first argument to this function is the json object that we're going to update. 
In this case, what we have in the properties column. Now we add one or more key value pairs to this object. For example, we can update the value of the weight property, so we pass a path here, dollar sign dot weight, and then we add the new value for this property, let's say 20. Now we can add a new property here as well, let's say age, currently this object doesn't have a property called age, so we can set it here. Let's set it to 10. Now, let's execute this statement, beautiful, back to our other query window, let's select the product id and the properties column. Alright, so take a look, now we have the age property that is set to 10, and the weight is updated to 20. 
So we can use the JSON set function to update existing properties or add new ones. We also have JSON remove for removing one or more properties. Let's say we made a mistake, age doesn't really apply to a product, so in this function first we pass a JSON object, then we list one or more keys that should be removed. in this case, h. So both these functions, json remove and json set, take a json object, modify it and return a new json object, and that is the reason we can use them in our set clause like this. So we're setting these properties to a new json object that is returned from this function, right? Now let's execute this, and make sure it's removed. So, 
execute this one more time, we no longer have the age property. So as you can see, it's really easy to work with JSON objects in MySQL.














Designing Databases:

Introduction:
 

So far we've been writing our queries against existing databases. But as a software engineer or database administrator, there are times when you will need to design a new database from scratch or add new tables to an existing database. And that's what you're going to learn in this section. I'm going to walk you through a simple step-by-step process to design well-structured databases. Remember, a well-designed database requires a bit of planning at the beginning and it may take a bit of time, but it plays a critical role in the success of your applications. If your database is designed properly, you can easily extend it to support new business requirements, you can easily query to extract useful information and your queries will execute quickly. A poorly designed database requires a lot of maintenance and the cost of maintaining it increases over time to the extent that it will eventually prevent you from supporting new business requirements. 
In one of the companies that I worked at, we had a poorly designed database and believe it or not, some of our stored procedures were almost a thousand lines of code because the structure of the database was overly complex. So extracting data was really difficult. Also, some of our queries took several minutes to execute. So in this section, I'm going to walk you through a systematic approach to design well-structured databases. Are you ready? Let's get started.




Data Modelling:
In this lecture we're going to talk about data modeling, which is the process of creating a model for the data that we want to store in a database. It involves four steps. The first step is to understand and analyze the business requirements. Unfortunately, so many developers skip this step and jump into creating tables in a database. But this step, in my opinion, is the most important step in the data modeling process. Yes, it's a bit slow and takes a bit of time, but the better you understand the business problem you're trying to solve, the better you can come up with a solution, in this case, a database. So before you think about your tables and columns, you need to fully understand the business requirements. 
You need to talk to the business stakeholders, domain experts, and even end users. Look at the existing forms, documents, applications, spreadsheets, databases, pretty much anything that is relevant to the problem domain you're working on. Once you collect all this information, your next step is to build a conceptual model of the business. And this involves identifying the entities or things or concepts in the business and their relationships with each other. A conceptual model is just a visual representation of these concepts that you use to communicate with the stakeholders so you know you're both on the same page. Once you have a conceptual model, you refine it to come up with a data model or data structure for storing data. This is what we call a logical model. 
A logical model is an abstract data model that is independent of database technology. It just shows you the tables and columns you need. Next, you refine this logical model to build a physical model for a specific database management system. So a physical model is the implementation of a logical model for a particular database technology. In this model, you should have the exact data types supported by your database technology, the default values for your columns, whether they're nullable or not, the primary keys for tables, as well as other objects like views, stored procedures, triggers, and so on. So physical data model is very specific to a database technology like MySQL. So this is the process of data modeling. Now don't worry if all this sounds a little bit ambiguous, over the next few lectures I'm going to walk you through all these steps using a real world example. 
Next we're going to look at conceptual models.


















Conceptual Models: 
In the last lecture you learned about the three types of data models, conceptual, logical, and physical. In this lecture we'll be looking at conceptual models. So let's say we want to build a website for selling online courses so people can sign up and enroll in one or more courses. These are the video courses that online instructors like me upload to this website. A course can have one or more tags like frontend or backend. Now to create a database for this website first we need to create a conceptual model that represents the entities or things or concepts in this business and the relationships with each other. Quite often these entities are things like people, events, locations, and so on. So what concepts or entities do we have here? 
Well, at first glance, I can quickly pick a couple of entities. Student and course. These are the concepts that we need to know about in this domain. Now, we need a way to visually see these entities and their relationships. There are basically two ways to do this. We can use entity relationship or UML diagrams. These are both ways for visually expressing concepts. Entity relationship diagrams are often used for data modeling. UML is short for unified modeling language, and its scope goes way beyond data modeling. Some people are more comfortable with UML diagrams, others prefer entity relationship diagrams. They're both equally good when it comes to building conceptual and logical data models. In this course, I'll be using entity relationship diagrams. Now, there are various tools out there for creating entity relationship diagrams. 
If you're on Windows, you can use Microsoft Visio. There are also a couple of popular online tools like Draw.io or Lucidcharts. So here on Draw.io, on the left side we have various kinds of visual languages like UML, entity relationship, flowchart, and so on. Now, under entity relationship, here we have this entity object, we can add this to our diagram, let's double click and rename this to student. Now, inside this box, we list all the attributes that we need to know about each student. Things like their name, their email address, the date they registered, and so on. So, let's double click here, and list these attributes. Name, email, date, register. And note that here I'm using camel notation, So we capitalize the first letter of every word except the first word. 
This is purely my personal preference, you don't have to follow this convention. This is just a conceptual model that we use to communicate with stakeholders. You can use any naming conventions that you prefer, but keep it consistent. Now, one thing you need to know is that data modeling is an iterative process. You can't come up with the perfect design in your first attempt. So you need to constantly go back and forth between the requirements and your models and keep refining them. So these are the attributes that we currently know about students, but they may change later. We may add new attributes or rename or remove some of these attributes. Now let's add another entity here, course, what attributes do we need to know about the course? 
We need to know it's title, we need to know it's price, the instructor, and tags. Next we need to define the relationship between these two entities. So here we have various kinds of relationships as you can see here, now don't worry too much about the difference between these types, you're going to learn about them soon. So here I'm going to select a many to many relationship, let's drag and drop this here, and attach the left side to the student box and the right side to the course box. There you go. Now let's give this relationship a label, so we double click it and type enrolls. So we read this relationship from left to right saying student enrolls in course. So this is a conceptual model that gives us a very high level overview of the business domain and the things involved in this domain. 
At this point we don't have any details about the type of each attribute, neither do we know or care what database management system we're going to use to implement this model. It's just a conceptual model. And we use this to communicate with the business stakeholders so we know we're both on the same page and we talk the same language. These are the benefits of conceptual models. Next, we're going to use this conceptual model to build a logical model.


















Logical Models:
So we're going to continue with the conceptual model that we built in the last lecture. Now we're going to refine this model to come up with a data model or a data structure for storing our data. This logical model is independent of database technologies, that's why we call it a logical data model. It's just an abstract data model that clearly shows our entities and their relationships, but it's a bit more detailed than this conceptual model. Later when we pick a database management system like MySQL, we'll refine this logical model to implement it for this particular database management system. Okay? So, what are we going to have in this logical model? Well, first we need to specify the type of each attribute, like string, integer, float, date, and so on. 
For example, the student's name is a string, so here in parenthesis we type string. Note that here we have a string, not varchar, because varchar is an implementation detail. It's a data type in MySQL. but this logical model is independent of database technologies, okay? Now similarly, email is a string, so let's add that here as well, and date registered is a date time. Now it's often a good practice to split an attribute like name into multiple attributes like first name and last name, with this we can easily query or sort students by their first or last name. In contrast, if you have a single attribute to store the full name then we'll have to deal with extracting the first or last name, and this will make our queries complex and slow. 
The same is true when you have an address attribute. You should break it into smaller pieces like street, city, zip code, country and so on. This way you can query on these individual pieces. Okay? So let's split the name attribute into first and last names. That is better. Next we need to specify the type of the relationship between our entities. we have three main types of relationships, one to one, one to many, and many to many. The other types are variations of these three types. In this case we have a many to many relationship between the student and the course, because the student can enroll in multiple courses, and the course can have multiple students. Now if you want to change the type of this relationship, we can select it, and here on the right side, we have this panel, from this drop down list, we can select the type of the relationship. 
you see a lot of different shapes here, because draw.io supports a lot of different visual languages, some of these icons are part of UML. So down the bottom you can see the icons for entity relationship diagrams. If this is confusing for you, you can also hover your mouse over each of these relationships, so this is a one to one relationship, here's a one to many relationship and so on. So in this logical model, we should clearly specify the type of relationship between our entities. At the conceptual level, this doesn't matter. All we need is a straight line between entities. The type doesn't matter. Now, there is something missing here. What if we need to know the date a student enrolled in a course? 
Where should we put that date attribute? We can put it here on the student, because a student may enroll in several courses. Then we need a separate attribute for each course. And we want to know ahead of time how many courses each student is going to enroll in. That doesn't make sense. What if we put it on the course entity? That doesn't make sense either. Because the enrollment date would be different for each student. So the enrollment date is not an attribute of the course. It's an attribute of the enrollment, right? So it's an attribute of the relationship between the student and the course. This is a common scenario in the real world that a lot of data modelers don't get right. So here we need to introduce a new entity that represents the relationship between the student and the course. 
Let me add that here. and rename it to enrollment. Now in this entity we're going to have an attribute called date. And the type of this attribute is date time. Now we need to delete this relationship between these two entities and recreate it through this new entity. So select this, delete, now a student can have many enrollments, but each enrollment is for a particular student. So here we have a one to many relationship between the student and the enrollment. So I'm going to pick this relationship on the left side, add it here, now let's drag and drop it on the student and the enrollment. So a student can have multiple enrollments, and that is why we have this fork icon on this side. 
This represents many, right? Similarly a course can have multiple enrollments, but each enrollment is for a particular course. So once again we need to add another one to many relationship here, let's move this around, so I'm going to attach this end to the course entity and this other end to the enrollment. So one to many. Okay? So previously we had a many to many relationship between these two entities, now we have two one to many relationships. You see that a lot in modeling relational databases. Alright, so now we have a new entity that clearly represents an enrollment for a student in a particular course. In this entity currently we only have one attribute, that's the date, but let's say we talk to our domain expert, and we realize that courses are priced differently over time. 
So each student may buy a course at a different price. Where should we put that price? In the enrollment entity. That is the price a student pays at the time of enrolling in a course. So, let's add another attribute here, price, And the type of this should be float, because we can have digits after decimal points. Like $49.50. Once again, at this level, we don't care what is the name of the corresponding data type in MySQL or any other database management systems. That's why we use float. Now in MySQL, we're going to use decimal. In another database management system, we might have a different type. Our logical model doesn't care. This is just an abstract data structure. So compare our conceptual model with our logical model. 
Our conceptual model doesn't really give us a structure for storing data, it only represents the business entities and their relationship. And we use it to understand the problem domain and communicate with the domain experts. Our logical model adds more details to our conceptual model, so now we almost know what structure or what tables we need to store our data. The entities that we have here eventually end up as tables in our database. Alright, now let's add the type for these attributes as well, so title is going to be a string, price is going to be a float, instructor is going to be also a string, and tags, we can keep things simple, so we can use a string, and if a course has multiple tags, we can separate them using a comma. 
Now, you might say, Mosh, this is not a good idea, I know, we're going to talk about it later when we get to normalization. So for now, let's keep things simple. Next we're going to take this logical model and implement it in MySQL.







Physical Models:
As I told you earlier, a physical model is the implementation of a logical model for a specific database technology. So in this lecture we're going to take our logical data model and create a physical data model for MySQL. So here in MySQL workbench, on the top, let's go to the file menu and select new model. Now this EER that you see here is short for enhanced entity relationship. So here we can also create entity relationship diagrams. Now, by default, this model assumes a database called mydb, we can right click this and go to edit schema to rename it. So, let's change the name of this database to school. We haven't created the database yet, this is just a model or a physical model for that database. 
Now, on the top, let's add a new diagram. In this diagram we can add tables and views. So here's the icon for adding a new table, let's click this and add it here. Now let's double click this and rename it to something meaningful. In this case, students. Now when it comes to naming tables, I personally prefer to use plural names, because a table is a container for several entities like students. Some people prefer to use singular names for their tables, and they have their own valid reasons. Whatever you prefer, go for it, but stick with that convention. If there is already a convention in place, follow that. Don't break the rules. It's much better to stick to the existing convention, even if it's not ideal, otherwise your development and maintenance cost is going to increase pretty quickly. 
You have to constantly remember if a table name is singular or plural. So in my logical models, I use singular names for my entities, and in my physical models, I use plural names for my tables. Now let's add columns to this table. First, let me zoom in a little bit so you can see clearly, that is better, now I'm going to close the navigator panel, so here's our table designer, here we can add the columns in this table. Now back to our logical model, here are the columns that we need to add, first name, last name, email, and date registered. So, first I'm going to add the first name, first underlined name, so here I'm following a different convention, that is a MySQL convention. 
separate multiple words using an underscore. Now the type of this column is going to be varchar of let's say 50. So as I told you before, I use standard length for my strings, so for shorter strings like username, password, first name, I use 50, and for medium length strings I use 255. This is just my personal preference. Now you can see by default, mysql marks this column as a primary key, we don't want this to happen. we're going to talk about primary keys later. So for now, let's uncheck this box, now here this column is marked as not null, so we cannot accept null values in this column. That's good. Now let's add a second column, last name, also varchar of 50, we want to mark this column as not null as well, now let's add the email, also varchar of, maybe 50 is not enough here, because 
perhaps some people's email is longer, so I'm going to go with 255, and also we want to mark this as not null, and finally we're going to add date, underline registered. And for this we're going to use a date time, so we can store both the date and the time the student registered. Also we want to mark this as not null. So at this level, in this physical model, we have the exact types in MySQL, we also know if columns are nullable or not, we can also set the default values, this is the difference between a physical model and a logical model that is independent of database technologies, okay? So, here's the end result, this is our students table, now it's your turn, add the other entities that we defined in our logical model to this physical model, for now don't worry about their relationships, just add the tables and their columns, you'll see my solution next. 
Alright, here's my solution. So we have two new tables, courses and enrollments. In the courses table we have title of type varchar of 255. For the price I have used decimal of 5 and 2, and that means we can have a maximum of 5 digits with 2 digits after the decimal point. So the maximum price that we can allow here is $999. Now how did I come up with this? Let's say I talk to the business stakeholders, So they told me that the maximum price they want to allow on their website is $999. Now if this rule changes in the future, we can always come back and fix this. So I didn't go for a decimal of 9 and 2 right from the get go, because that would waste our disk space. 
As I told you before, keep things small. Next we have instructor, for the instructor I have used bar chart of 255, it could go less, like 50 characters, but I just want it to be on the safe side. So that's why I used 255 characters here. And also for tags I have used varchar of 255 characters. Now all these columns are required, so we do not accept null values. Here we have the enrollments table with two columns, date and price. Note that I have called this column date, not enrollment date, because this is a little bit repetitive and redundant. I've seen a lot of data modelers prefixing their column names with a table name, like enrollment date, and enrollment price, this is really unnecessary and makes your code ugly. 
Date is an attribute of enrollment, not enrollment date, okay? So, just a little side note, now the type of this column is date time, so we can store both the date and the time someone enrolled in a course. And the price column in this table is also a decimal of 5 and 2, so look at the consistency between these tables. Alright, we're not done yet, next we need to add a primary key to each table and define the relationships between these tables.





Primary Keys:
now we need to add a primary key to each table. As you know, a primary key is a column that uniquely identifies each record in a given table. So what column can we use here to uniquely identify each student? We cannot use the first name because many people can have the same first name. The same is true for the last name. What about the combination of the first and last names? This is what we call a composite primary key. A composite primary key is one that has multiple columns. Again, here we cannot rely on the combination of the first and last names, because two people can have the same full name. John Smith and John Smith. What about the email? Well, email certainly uniquely identifies each student, but the problem with the email is that it can be several characters long. 
So as you will see shortly, when we add a relationship between these two tables, this primary key in this table, in this case email, is going to be repeated in the enrollments table. So every time a student enrolls in a course, his primary key, in this case email, is going to get repeated in the enrollments table. And that is not a good idea because we're repeating several characters. Also, ideally a primary key should not change. So its value should stay the same forever. So this email column is not a good candidate for a primary key, because a student can change their email later on. So in situations like this, we introduce a new column, which we call an id column, and we use that as the primary key. 
So, double click the table, here I'm going to add a new column, student underline id, by default we use the int or integer type, which allows us up to 2 billion records. And that is pretty sufficient for most scenarios. But don't take this as a hard and fast rule. Always think about the context. Alright, now, press tab, let's mark this as a primary key, Now you can see that whenever we check this box, not null gets checked by default, because the primary key must have a value to identify each record uniquely. Now, by convention we should always put the primary key first, this makes it easier for us to understand our design. So here on Mac unfortunately we don't have drag and drop, but we can right click this and click move up, let's do it again and again and again. 
Alright, now we need to add a primary key to the courses table. So, once again, we cannot rely on any of these attributes or columns, so we need to add a new column called course id. So course id of type integer, and this is going to be a primary key. And by the way, I forgot to check this primary key as an auto increment column, because we want mysql to automatically generate values for this column. this just makes it easier for us to insert records in this table, we don't have to worry about the uniqueness of values, okay? Now, let's move this up, so back to the students table, here's our student id column, let's also check this as an auto increment column. 
Beautiful. Now what about the enrollments table? We're going to look at that next.














Foreign Keys:
Before we add a primary key to the enrollments table, let's talk about the relationship between the students and enrollments. Because here we have two options for adding a primary key in the enrollments table, and you will see that in a second. So, here we need a one to many relationship between these two tables, so your student can have multiple enrollments. Here on the left side you can see the icon for one to many relationship. Now, whenever we add a relationship between two tables, one end of the relationship is called the parent or the primary key table, and the other end is called the child or the foreign key table. In this case, the student's table is the parent or the primary key table, because we cannot have an enrollment without having a student first. 
So the student is the parent, right? Now when adding a relationship, here we need to select the foreign key table first. If you forget that you can simply look at the status bar. The status bar says select the table to receive the foreign key. So, here I'm going to select the enrollments table first, and then I'm going to select the students table. Now as you see we have a one to many relationship between these two tables, beautiful. Now the moment I added this relationship, mysql workbench added a new column here, students underline student underline id. This is basically telling us that this column is referencing the student id column in the students table. So this is how we know who this enrollment is for. 
Anytime we insert a record in this table, we store the id of that student in this column. Now personally, I don't like this naming convention, I don't like to prefix this column with the reference table. Of course, there are situations where this clarifies the design, but in this case, I think it's unnecessary. So let's double click this table, and rename this column to student id. Now you can see that this column is marked with this red diamond, because this is a foreign key in the enrollments table. So a foreign key is a column in one table that references the primary key of another table. Okay? Now let's close this window, we need to repeat this step one more time to add a relationship between these two other tables. 
So one more time, one to many, we select the foreign key table first and then the primary key table. so you can see we have another column here, courses, underline course, underline id, let's rename this as well okay, that is better, once again you can see in our physical model we have more details than a logical model at that level we didn't have to worry about primary keys, foreign keys, because these are implementation details, now we are ready to add a primary key in the enrollments table, and here we have two choices One way is to use the combination of student id and course id to uniquely identify each enrollment. So we can use a composite primary key here. The other approach is to introduce a new column called enrollment id, just like student id and course id. 
We can set it to auto increment. Which approach is better? It really depends, there is no hard and fast rule. The benefit of this composite primary key is that it prevents us from accidentally Enrolling the same student in the same course twice. Because the primary keys of a table cannot be repeated. They have to be unique. Each primary key uniquely identifies each record in a given table. So if we use a composite primary key here, we can prevent bad data from being inserted into this table. That's the benefit. What's the problem? the problem is that if we have another table in the future and there's going to be a relationship between the enrollments and that new table and these two keys need to be repeated in that table as the foreign key. 
Just like the student id in this table. So when we added a relationship between the student's table and enrollment's table, mysql automatically added the student id column here as the foreign key. So if we add another table here in the future, and establish a parent to child relationship between these two tables, these two keys will have to be repeated in that table. Now, depending on the context, this is not always a bad thing, depends on the amount of data that you have, and whether that table also has another child table. Now, on the other side, if we introduce a new column here, like enrollment ID, we're not going to have that problem, so if you have another table here in the future, and there's a parent to child relationship between enrollments on that table, we only have to repeat the enrollment ID. 
So you're repeating one value, one integer instead of two integers. Okay? However, currently, we don't have such a table in our design. So there is no need to design for what if scenarios that may never happen in the future. So in this case, I personally prefer to use a composite primary key here, because we get this immediate benefit, we can protect this table from bad data, and honestly, we don't really have that child table here, so we don't have to worry about these two keys being repeated somewhere else. If that happens in the future, we can always come back and revisit this design. We can write a change script to update the design of our tables. that's not a big deal. So, let's double click this table, and move these two columns on the top, so move up, I know this is really painful, so, alright, now, we tick the primary key checkbox for each of these columns. 
And this gives us a composite primary key.
















Foreign Key Constraints:
whenever you have a foreign key in a table, you need to set the constraints on that foreign key. And that basically protects your data from getting corrupted. So here I've got the enrollments table open, how many foreign keys do we have here? We have two foreign keys. One is the student ID that references the student ID in the students table, and the other is the course ID that references the course ID in the courses table. Now the combination of these two columns forms the primary key in this table. Now if you look down below, we have this tab, foreign keys, here you can see we have two foreign keys in this table, each foreign key has a name, by convention we use fk, underline foreign key table, underline primary key table. 
So the first foreign key is for the relationship between the enrollments and the students table. So you can see this foreign key is referencing the students table. The second foreign key is enrollments to courses 1, that sometimes MySQL automatically adds a 1 or a 2 at the end to prevent this name from clashing with another foreign key in this database, because all foreign keys have this name, and this name has to be unique in your database. Now currently we haven't really generated anything and we're dealing with only 3 simple tables. I know that we don't have another foreign key with this name. So I'm going to rename this and remove 1 from the end. That is better. Now look at the first foreign key. 
This foreign key is on the student id column in this table, now look at the right side, here we have two drop down lists for what should happen when the corresponding record in our parent table gets updated or deleted. For example, what should happen when the id of a student changes from 1 to 2? Well, earlier I told you that we should not change primary keys, that's considered a bad practice. But in the unlikely event that the primary key of a table changes, we want to make sure that the foreign key table is updated. So if the id of a student changes from 1 to 2, you want to make sure that all the enrollments for that student also get updated, so they reference student id 2. 
So in this drop down list, we select cascade. And with this, mysql will automatically update the records in the child table if the primary key changes. And here we have a few other options, one is restrict, and this will reject the update from happening. The other option is to set null, So if the idea of a student changes, this will set this foreign key to null. And with this we'll end up with a child record, in this case the enrollment, that doesn't have a parent. We call this an orphan record. We don't want to have any orphan records in our database. Because orphan records are bad data. We don't know who this enrollment is for. So most of the time, you never use this option. 
Unless in very specific scenarios. And the last one is no action, and this is exactly the same as restrict. It prevents or rejects the update operation. Now, what about the delete scenario? What should happen when we delete a student? Well, we can set this to cascade, and this means the enrollments for the student will automatically get deleted by MySQL. Shall we do it? It depends, depends on the context. In this case, we are storing financial information in the enrollments table. So we're storing the price each student paid to enroll in a course. If we delete the enrollments of our students, we're not going to be able to answer questions like how much we have sold over time or what courses were popular. So in this case, we want to prevent this delete from happening. 
In other words, if a student has at least one enrollment in this database, and we try to delete that student, we want mysql to prevent or reject the delete operation. So back to our foreign key constraints panel, I'm going to set the value for undelete to restrict or no action. Both these will reject the delete operation. So whenever you have a foreign key, you need to set these two constraints and tell mysql what should happen when the primary key gets updated or deleted. As a rule of thumb, we should always cascade on update, and for delete, it really depends. Most of the time you want to reject the delete operation, because you don't want to lose data. But in some cases, it doesn't really matter, it's okay to cascade delete. 
For example, let's say we have an application for people to set reminders for themselves. So they sign up, create an account, and set reminders. If someone deletes their account, we probably don't care about their reminders. You want to delete them. But don't take this as a hard and fast rule. You should always check with the business. That's why I told you it's really important to understand the business requirements. Maybe the business says, no, we don't want to delete any reminders, because we want to use them to create reports on historical data. So always check with the business. Now we need to apply the constraints for the other foreign key. Course id. So I'm going to set update to cascade and delete to no action. 
So if a course has at least one enrollment record, we should not be able to delete that course unless we delete the enrollment first.









Normalization:
So far we have done a lot of work on this physical data model. But before we go ahead and generate our database tables, we need to make sure that our design is optimal and doesn't allow redundant or duplicated data. Because redundancy increases the size of our database and complicates the insert, update, and delete operations. For example, if the name of someone is repeated in many different places, and they decide to change their name, we'll have to update several different places. Otherwise we'll have inconsistent data, and this is bad because it gives us invalid reports. So that's where normalization comes to the rescue. Normalization is the process of reviewing our design and ensuring that it follows a few predefined rules that prevent data duplication. 
There are basically seven rules, also called seven normal forms, and each rule assumes that you have applied the previous rules. Now, for almost 99% of the applications, you only need to apply the first three normal forms, and that's what you're going to learn in this section. You really don't have to worry about the other normal forms. So, over the next few lectures, I'm going to explain each normal form, and then I will give you a simple pragmatic advice that helps you easily create normalized databases without having to remember any of these rules. So next, let's take a look at the first normal form.







1NF â€“ First Normal Form:
first normal form says that each cell in a row should have a single value and we cannot have repeated columns. Now look at the tags column in the courses table. Here we're violating this role because we're going to store multiple tags in this column and separate them using a comma. So we're going to have multiple values in this cell or attribute. What if we have multiple columns like tag 1, tag 2, tag 3? Well, the problem with this approach is that we don't know ahead of time how many tags each course is going to have. What if in the future we want to add the fourth tag to a course? Then we'll have to come back here and modify our design. Plus there is no guarantee that this will not happen again. 
So this approach is not scalable. And this is why the first normalization form says that we cannot have repeated columns. To solve this problem, we need to take this tags column out of this table and model it as a separate table called tags. and then we'll add a many to many relationship between tags and courses. So, let me add a new table here, let's rename this to tags, now we need to add a primary key to this table, we're going to call that tag id, now, what should be the type of this column? Well, it depends how many tags we're going to have in this database. And that's a question we need to ask the business. Are these tags going to be created by end users? 
or the admins. If they're going to be created by end users, it's likely that they're going to grow pretty quickly. But in this case, let's assume that these tags are going to be created by our admins, and we're going to have only a maximum of 50 to 60 tags. So, we can use a tiny int for this column. Now, let me try to add another column, mysql workbench automatically changes this back to integer, this is because I think there is a bug in mysql workbench It acts a little bit flaky at times. So, to fix this, you need to set the data type over here. So back to the first column, make sure to select that, then type tiny int here. And remove the parenthesis. 
Enter, okay, now it's updated here. Next we need to add the name column, and we set its type to varchar of 50 to be consistent. And obviously, we need to mark this as not null. Beautiful. So here's our tags table, now we need to add a many to many relationship between the courses and the tags tables. And that's the topic for the next lecture.









Link Tables:
So now we need to add a many to many relationship between the courses and tags tables. However, in relational databases we don't have many to many relationships. We only have one to one and one to many relationships. So, to implement a many to many relationship between these two tables, we need to introduce a new table which we call a link table, and we're going to have two one to many relationships with that table. Exactly like the enrollments table here. So before we introduce the enrollments table, logically we have a many to many relationship between the students and the courses. Then we introduce this link table, and as you can see here we have two one to many relationships with this link table. We need to follow the same approach to implement a many to many relationship between these two tables. 
So I'm going to add a new table here, and call it course tags. so course underline tags, this table determines the tags for each course, so in the courses table we only have the courses, in the tags table we only have our tags, and in this new table we know the tags for each course, okay? So enter, here's our new table, now we need to add our relationships, so I'm going to select this one to many relationship, first we need to select the child or the foreign key table, and then we need to select the parent or the primary key table. There you go. Now we have a one to many relationship with our link table. Let me scroll to the right, that's better. 
Now one more time, I'm going to add another one to many relationship here. First the child table, and then the parent table. Now you can see in this link table, we have two new columns, courses underline course id, and tags underline tag id. Let's simplify the column names. So, I'm going to rename the first column to course id, and the second column to tag id. Now in this table once again we're going to have a composite primary key, because the combination of the course and tag id should be unique. So I'm going to mark both of these as primary key. So link tables are very common in relational databases, sometimes they only have these two columns, but in other cases they have additional columns, like our enrollments table. 
Now let's review our design one more time. So, we introduce this new table here, and now we can remove the tags column from the courses table. Alright, here are the columns, let's right click this column and delete it. With these changes, our database is now in the first normal form. Because first of all, we don't have repeating columns like tag1, tag2, and tag3, and we also don't have multiple values in a column. So all our tags are stored here in one place. If we need to rename a tag, this is the only place that we need to update. Only one record in the tags table. In contrast, in the previous design, because we repeated tags as strings in the courses table, we had several occurrences of each tag. 
We could have frontend repeated in so many different places. then if we wanted to rename frontend to something else, like let's say we wanted to add a hyphen in the middle, we would have to update several courses records. And as you know, every time we have an update or delete operation, mysql locks one or more rows. So with the previous design, our rows had to be locked unnecessarily. Why should we lock a course if you want to rename a tag? That doesn't make sense. If you want to rename a tag, the tag row should be the only row that should be locked. Next we're going to look at the second normal form.


























2NF â€“ Second Normal Form:
Alright, now let's look at the second normal form. Here is the academic definition on Wikipedia. To qualify for second normal form, a relation must be in the first normal form, and it should not have any non-prime attribute that is dependent on any proper subset of any candidate key of the relation. What is this supposed to mean? Let me make it super simple for you. The second normal form says that each table should have a single purpose, in other words, it should represent one and only only one type of entity, and every column in that table should describe that entity. Here's an example, our courses table has these columns, course id, title, and price. So it has a single purpose, it stores course records. 
Every column in this table is an attribute of a course, so these columns describe a course, right? Now, what if we had a column here called enrollment date? We talked about this earlier, this is not really an attribute or property of a course, because the course can have several students, and each student will probably have a different enrollment date. So this column doesn't really belong to this table. It's not an attribute of a course. It's an attribute of the enrollment. That's why earlier we introduced the enrollment entity and added the date attribute there. So the second normal form says that every column in a table should describe the entity that the table represents. If you have a column here that describes something else, 
We should take that column out and put it in a separate table, as simple as that. Let's look at another example. We have this orders table with these columns, order id, date, and customer name. This table is not in the second normal form. Why? The purpose of this table is to store our orders, right? So order id and date are attributes of the order and they belong to this table. Because they describe an order. But the customer name column describes a customer, not an order. With this design, if a customer places multiple orders, their name will be repeated and this will create two problems. The first problem is that we're going to waste space. The second problem is that our updates are going to be painful. 
Because if you want to update, the name of a customer will have to change it in several places. So this column doesn't really belong to this table. We should take it out and put it in the customers table. Now, this customer's name is stored in a single place. We have not wasted space, And if we need to change this name in the future, there is only a single record that we should update. Okay? This is our second normal form. Now, sometimes this is not very obvious at first. For example, what if the column was called customer instead of customer name? You would say, well, every order has a customer, so this is an attribute of an order. So this column should belong to this table. 
But with this design, the name of our customers is going to get duplicated. Whenever you see that, that means your design is not normalized. So that's when you should ask yourself where is that single place that we need to store the customer name so it's not duplicated. It's in the customers table. So we need a separate table to store all our customers. Then we reference our customers by their id in the orders table. And that's why earlier I told you that primary keys should not be updated. So yes, we have duplicated the customer id in this table, but that's a minimum duplication. We are duplicating integers that are 4 bytes long, not customer names that can be 50 or 100 characters long. Now take a look at the current design of our database. 
This design is violating the second normal form. In one of our tables, we have a column that shouldn't be there. So pause the video and think about this for a few seconds, but don't make any changes yet. When you're done, come back and let me show you how to put this database in the second normal form. Alright, so our courses table is violating the second normal form, because this instructor column here doesn't really belong to this table. If the same instructor teaches multiple courses, their name is going to get duplicated in this table. So we'll have to change it in multiple places. That's when we ask ourselves, where is that single place where we need to store the name of our instructors? It's the instructors table. 
So, I'm going to add a new table here, Let's call it instructors, here we're going to add two columns, the first one is instructor id, what data type do we need here? Again, we need to ask the business. I don't think we're going to have 2 billion instructors, so the int data type is a little bit too big for this column. So I'm going to go with small int, which allows us to store up to 30,000 instructors. But again, I'm just making assumptions here, you should always ask the business. Now, let's also mark this as an auto increment column, next we add the name column of type varchar of 50, and this is not going to accept null values, beautiful. So we're done with this table, now we need to delete the instructor column in the courses table, and add a one to many relationship between the instructors and the courses. 
Take a look. So, in the courses table, I'm going to right click the instructor column and delete it, then I'm going to apply a one to many relationship here. So here's our one to many relationship, first we select the child table or the foreign key table, and then the parent table. Now our model is getting a little bit convoluted, so we can go to the arrange menu on the top and select auto layout. That is a little bit better, so we have the instructors table over here, and here's our courses table. Now we can see that the moment that we added this relationship, mysql added our foreign key column, let's rename this column to something shorter and easier to work with. So we're going to call this instructor id, now because we have a new foreign key here, we need to go to the foreign keys tab, and set the foreign key constraints. 
For updates I'm going to cascade, for deletes I'm not going to take any action. So, if an instructor has a course, we're not going to be able to delete that instructor.








3NF â€“ Third Normal Form:
now let's talk about the third normal form. Here's the classic definition on Wikipedia. So our entity or table should be in the second normal form to start with. And all the attributes in the table are determined only by the candidate keys of that relation and not by any non-prime attributes. Jesus, that's a mouthful. Let me explain it using a simple example. Look at this invoices table. Here we have three columns. Invoice total, payment total, and balance. Do you agree that we can calculate the balance by subtracting the payment total from the invoice total? So balance can be derived from these two columns. We say it's dependent on these two columns, which means if the value of these columns changes, the balance has to be recalculated, right? 
Now, what if we change one of these values but forget to update the balance? Our data will not be consistent. If we look at this record, we won't know what the actual balance is. Should we rely on the value in the balance column or subtract the payment total from the invoice total? We won't know. So the third normal form says that a column in the table should not be derived from other columns. So in this example, we should drop the balance column. We don't really need it. Here's another example. Look at this table. We have first name, last name, and full name. The full name column should not be here because it's violating the third normal form. We can always calculate it combining the first and last names. 
So the third normal form just like the other normal forms helps us reduce duplication and increase data integrity.



















My Pragmatic Advice:
Here's my pragmatic advice for you. Don't worry about memorizing this normalization rules like what is the first rule or the second rule and how they're different unless you're preparing for your college exam and you have to answer stupid questions like these. These questions have no applications in the real world. When working on real projects with other people, just focus on removing redundancy, not applying normalization rules one by one to each table and each column. Nobody is going to debate with you whether given table is in the second or the third normal form. So whenever you see duplicated values and these values are not foreign keys like one two three four that means your design is not normalized. What normalization form it violates doesn't really matter. 
Nobody cares about this stuff. Just think about how you can eliminate the duplication. Here's an example. We have this customers table with three columns. Customer ID, name, and shipping address. If there is a requirement to support Multiple shipping addresses, we're going to have a problem with this design. For a given customer, We have to repeat their name to add multiple shipping addresses. Now this is a simplified table, But what if we had two other columns here like email and birthday to store multiple shipping addresses for this customer? You'll have to repeat all these other values as well. That's bad. How can we solve this? Well, first minute to think about the logical entities and the relationships here. We have two entities and Customer and address. 
And there is a one-to-many relationship between these two entities. The customer can have many shipping addresses, but a shipping address is for one and only one customer. Now we convert this logical model to a physical model. We end up with two tables, customers and addresses. The customer table has columns like customer ID, name, and email. So the shipping address column no longer exists here. Now. We have a separate table for it. See what I did here. I didn't think about any normalization rules and how to apply them by moving columns around. I only thought about the logical entities and the relationship. So if you follow the same process, you really don't need to worry about normalization rules. Start with the logical or conceptual model first. 
Don't jump into creating tables. You will almost always end up with a bad and messy design. Also, once again, I want to emphasize the importance of the requirements. In this example I I assume that there is a requirement to support multiple shipping addresses. With this requirement, the original design violated the third normal form. But what if we didn't have this requirement? This design would be perfectly valid. So don't apply normalization rules blindly. Always take the requirements into account. And that brings me to my next point. Don't model the universe. We'll talk about that next.









Donâ€™t Model the Universe:
One of the mistakes that a lot of data modelers make is they try to generalize their models so they can support future requirements. Most of the time, these future requirements that these people think of are just in their head. They may never happen. So they end up creating a model that is overly complex and, in my opinion, useless. In one of the companies that I worked at before, we had one of these people. He tried to model the entire universe. He forgot about the scope of our project. He forgot about the context, he forgot about the requirements. So he gave us a data model that was spread over 20 pages or more. And quite honestly, nobody really understood this data model except himself. 
Everything was super generalized and his argument was that this model could handle all future requirements without any changes. He also designed another database for us that took abstraction and generalization to the next level. So we had three tables called entities, attributes, and values. And again, his argument was that this model was so flexible, so general that we wouldn't need to change it in the future. Because with these three tables, we could model any concepts. Because everything is an entity. So we could store it in the entities table. And everything has attributes. So we could store its attributes and values in the attributes and values tables. Now the actual model had a few more tables like relationships, relationship types, and so on. So he essentially built a relational database on top of a relational database. 
This design is referred to as the sixth normal form. And while it may promise some benefits on the paper, in reality, it creates a big mess that nobody can clean up. That is the reason I told you that we had stored procedures that were a thousand lines long. Because if I wanted to select a student record, I couldn't just write a query like this. There was no such a thing as the students table. One record in the entities table represented our students table. So I had to join this with entity instances table to get a specific student. But then I had to join that with the attributes and values tables and then do a group by God, it was so painful. The simplest query was 10 lines long and it was super slow. 
Some queries took a minute to execute, sometimes even longer. So here's what I want you to take away. Develop the best solution for today's problems, not future problems that may never happen. In the real world, people may change their legal name. Don't add a previous name column in your customer's table unless it's really important to your problem domain. People move houses. Don't worry about supporting multiple addresses if all you need to know is the customer's current address. So don't build a model for the universe or the real life. Build a model for your problem domain based on the current requirements, not what happens in the real life. Don't make these kind of assumptions like, what if this happens? What if that happens? What if none of this happened? 
You will end up with a design that has a lot of baggage that you have to carry for a long time. And this will prevent you from going faster. It will make it harder to add new features to your applications. That's why I told you that you're going to end up in a big mess that nobody's going to be able to clean up. So as I always say, keep it simple. Simplicity is the ultimate sophistication. Don't be proud for designing a complex model. That is not something to be proud of. You can be proud only if you take a complex model simplify it, and simplify it, and simplify it like no one else. And then you have a beautiful model that supports today's requirements in an optimal fashion. 
Your code will be beautiful, it won't be complex, your queries will execute quickly, everybody will understand your design, and you can easily extend your model to support future requirements. Don't be afraid of changes. Changes will happen whether you predict them or not. And trust me, no matter how much experience you have, you're never going to be able to predict all future requirements. Because they depend on the business, what the CEO thinks, not what programmers think. So once again, don't try to predict all future changes. Whenever there is a change in the future, you can always write a script to change your database model and migrate the data if necessary. And trust me, you will do that no matter what. Even if you predict all the future requirements, there is still one day that your prediction will fail.
















Forward Engineering a Model:

 

 

 

 

 

 

 

 

 

 

 

 

So we have created this physical model, but this is just a model, it's not a database. In this lecture I'm going to show you how to convert this model to a real physical database. So, with the physical model open, on the top let's go to the database menu and select forward engineer. In this dialog box we have to select our connection, by default you should have the connection that you have on MySQL workbench homepage, if not you can select it from here. Leave all the default settings as they are, You may have to enter your password in case it's not stored here. Again, that's pretty straight forward. Now let's continue to the next step. On this page we can set the options for the script that this wizard is going to generate. 
Most of the time you want to leave these settings as they are unless you know what you're doing. So let's go to the next step. Now here we can select the kind of objects that we want to be scripted. So far we have only created tables in our physical model, but we can also create views stored routines like stored procedures and functions as well as triggers and user objects. For now, we don't have to worry about these other objects. Also, here we can select show filter to exclude one or more tables from being scripted. By default, all tables are selected, but we can exclude one or more of these tables by selecting them here and moving them to the list of excluded objects. 
I'm going to take this back to the list of objects to process. Let's continue to the next step. So this is the script that this wizard has generated for creating our database, our school database with all its tables. For example, on line 14 we have this create schema statement for creating a database called school. Below that we have a create table statement for creating the students table. And here are all the columns in this table. For now don't worry about the details of these statements, you're going to learn about them later in this section. Now here we also have two buttons below this script one is save to file, so you can save this as a script file and check it into your source control repository, you can also copy it to clipboard, and then go back to mysql workbench and paste it into a query window. 
In this demo I'm going to click on the continue button, so this wizard will generate this database for us. Continue, alright, now it's ready. So, back to our local instance, here I'm going to refresh the navigator panel, there you go, we have the school database, and Here are all the tables that we designed earlier in this section.








Synchronizing a Model with a Database:

 

 

 

 

 

 

 

 

 

 

 

So we have created this database, now what if you want to make any changes here? What if you want to add a new table or modify one of the existing ones? Well, you can always come here and open these tables in the design mode and make any necessary changes. We can add a new column or rename one of these columns or drop them. That totally works. But it only works if you are the only person using this database. In other words, you can use this approach if you're working with a database on your machine and no one else is going to use it. you're using this database for your personal reasons. But in medium to large organizations, we often have multiple servers that simulate the production environment. 
The production environment is where our users access our applications or databases. So in addition to the production environment, we also have staging environment, which is very close to the production environment. We also have the testing environment that is used purely for testing. And we also have the development environment each environment one or more servers. So anytime we developers want to make any changes to these databases, we should be able to replicate the same changes on other databases. So all these databases that we have in various environments are consistent. How do we do that? Well, back to our model. We start here. We make our changes and then synchronize this model with a database. Let me show you. So here in the enrollments table, I'm going to add a new column. 
So I've selected this, and here I'm going to add a column called coupon. Let's say this is the coupon that the student is going to use at the time of the enrollment. I'm going to use a varchar of 50 for consistency, and leave this column as nullable, because not everybody has access to a coupon at the time of enrollment. So, this is the change I've made in this model. Now we go to the database menu on the top, And instead of selecting forward engineer, we select synchronize model. We use forward engineering when we don't have a database. So we take a model and we generate a new database. Now that we have a database, we want to synchronize this database with our model. 
So we select synchronize model, and on this page once again we select our connection. So here I'm connecting to a database on my local machine. If I'm a developer in an organization, I have access to to the testing environment, to the staging environment, and maybe the production environment. So here, instead of selecting this local instance connection, we can select a connection to a database in the testing environment. Okay? Now, let's continue to the next step, we leave all the default settings as they are, so, here MySQL workbench detected that we are working with this database, school. Alright, so we select this, in the next step, it detects the tables that need to be updated. So because I updated the enrollments table, here we have this green arrow, but because the enrollments table is associated or related to the courses table, this table might be affected as well. 
So as you will see in a second, MySQL workbench has to temporarily drop the relationship between these two tables to apply the necessary changes in the enrollments table. Now we have the same story between the courses and course tags tables. So because these two tables are related, my skill workbench has to temporarily drop the relationship between these two and then enable it again. So let's continue to the next step. In this script you can see a bunch of alter table drop foreign key statements. These are used for dropping the relationships between our tables. Down below you can see we have an alter table statement, below that we have add column coupon of type varchar50. So first, these relationships are disabled, then we add a new column to the enrollments table, and finally we enable these relationships. 
Alright, now once again we can immediately execute this script to see our changes, but a better approach is to save this script in our file system, and then check this into a source control repository like git. With this we know exactly what changes we have made to our database, and we can replicate the same change to other databases. All we have to do is to execute that script on those database servers, okay? Now in this demo we don't want to worry about that, so I'm going to execute this script to synchronize my database with my model. Done, now back to our navigator panel, let's refresh and take a look at the enrollments table. Now we have a new column called coupon.

























Reverse Engineering a Database:

 

 

 

 

 

 

What if you want to change a database that doesn't have a model? Like our SQL store database. This database doesn't have a model like our school database. How can we change this database? That's really easy. The first time we need to do this, we need to reverse engineer this database to create a model. We'll use that model for any future changes. So, first I'm going to close this model that we created earlier in this section. This is really important because when we reverse engineer this database, if a model is already open here, mysql workbench will add this database to that model. Now this is not a big deal, but it's better to have a separate model for each database. You can include multiple databases in one model, but that's something you want to do if these databases are highly related and you want to work with them in the same model. 
So, our model is closed, now on the top you go to the database menu and select reverse engineer. So you can see mysql workbench automatically created a new model. this model we don't have any diagrams, so here on this window we're going to select our connection and then we select the database that we want to reverse engineer. So I'm going to select the sequel store database. As you can see we can select multiple databases, but once again, do that if these databases are highly related and you want to work with them in the same model. Now let's continue to the next step all right so here it's asking us if you want to import all the 7 tables in this database. Just like before we can select show filter to exclude one or more tables. 
We don't want to do that because we want to add all our tables to our model. So let's execute this, alright, now here we have a new diagram that is added to our new model, it's right here. Now back to the diagram, you can see all our tables and their relationships, this is really helpful in understanding our database design, for example, here we have a one to many relationship between the products and order items. We can also use these diagrams to identify the problems in our design. For example, somewhere over here we have this table order item notes. As you can see this table is not related to any other tables. What is the problem here? The problem is that we can insert any values in the order id column 
and mysql workbench will not validate that. So we won't have data integrity. When we add a relationship between our tables, mysql workbench will enforce the integrity of our data. So in our child tables, we can only add values that correspond with the values in our parent tables. So currently we don't have any relationships here, and that means we can insert invalid values in the order id and product id columns. So these diagrams are really helpful, they help us better understand the design, they help us identify the problems, and they allow us to make any changes to this design and then script those changes to execute on other MySQL databases.




Project: Flight Booking System
 

Alright, here's a project for you. I want you to design a database for a flight booking system. Download the PDF I've attached to this lecture. In this PDF, you can see an example of a ticket that this system should generate. Based on the information you see here, design a database for this system. You will see my solution next.











Solution â€“ Conceptual Model:

 

 

 

 

this lecture is going to be very informal, I haven't done any prep work, because I just want to walk you through my thought process and show you how I approach a data modeling problem. So here on draw.io, I'm going to create a conceptual model using entity relationship diagrams. So what entities or concepts do we have in this domain? We have the concept of flight, passenger or traveler, aircraft, airline, airport, and so on. These are the concepts that I immediately see in this domain. So, let's add an entity for each, here's the first one I'm going to call this passenger, you could also call it traveler, it doesn't really matter, here's another entity, we're going to call this flight, so a passenger books a flight. 
Now let's add a relationship between these two entities, here we have a bunch of relationship options, like one to many, one to one, at this point we don't really care about the type of these relationships, we just want to add a relationship between our entities. We'll clarify each relationship, when we build our logical model. So for simplicity, I'm going to use a many to many relationship or all relationships in this demo. Here's one, I'm going to add this between passenger and flight, and then I'm going to add a label to this relationship, books. So passenger, books, flights. Now let's add a few attributes to these entities. What do we need to know about each passenger? Well, based on the requirements, we need to know their name. 
That's the only thing we need to know about each passenger. Now in the real world, we also need to know their email, their address, their date of birth, and maybe other attributes. But none of those attributes exist in the requirements I have given you. So we want to stick to the requirements. We don't want to model the universe or the real world, we want to do enough modeling to solve a business problem. So, name is sufficient for now. What do we need to know about our flights? Flight has a number. So let's add that here We need to know when a flight is going to happen. So here we need a date time attribute Well more accurately we need to have two date times. 
One is the departure date time. The other is the arrival date time. So Let's rename this to departure date time and arrival date time Also, let me zoom in a little bit more Okay, that is better Alright, what else do we need to know about a flight? We need to know its duration. So, let's add that here, we also need to know the distance. So in the example I've given you, the flight between Los Angeles and San Francisco is just over 200 miles. That is the distance. We also need to know the airline that operates a flight. Now we can add the airline as an attribute here, or we can model airline as a separate entity and then add a relationship between flight 
an airline. That is more of a normalization thing, because we don't want to repeat the airline's name in the flight. But at this level, we're still doing our conceptual modeling, so we don't have to worry about normalization, we can always come back to it later. So let's get the basics right. What else do we need to know about each flight? We need to know the departing and arriving airports. Now each airport has a bunch of attributes, one of them is IATA code, and that is the three letter code that you see in this example. For example, LAX, is short for Los Angeles International Airport. So airport is really a separate entity because it has its own attributes. So I'm going to add another entity here, let's call that airport, now this airport has a yata code, it also has a descriptive name, like Los Angeles International Airport, it's located in a city and state, 
and country. But technically we don't have country in our example, so this is actually out of scope, we only want to focus on city and state. If you want to support international flights, we can always come back and modify this model. So this is the airport, now we need to add a relationship between flight and airport as well. Once again, I'm going to add a many to many relationship, this is purely for simplicity, we'll refine the top of these relationships later when we build a logical model. So, let's add this here, and attach it to the flight as well. Alright, now let's give this relationship a label, departs slash arrives at. Now here on page 1 we see the ticket number for each passenger. 
Where should we put that attribute? It doesn't belong to a passenger, neither does it belong to the flight, it's actually an attribute of the relationship between these two entities. So it's part of the booking. So I'm going to add a new entity here, let me move this around and put it on the top, that is a little bit better, unfortunately we have a limitation of space here, please bear with me, so I'm going to call this booking, this booking is going to have a ticket number, it also has a price that you can see on page 3, that is the amount each passenger pays for a given flight. Now in the real world we also need to keep track of when this person made this booking, so the booking entity should also have a daytime attribute, but again, we don't see it in the requirements at this point, so I don't want to complicate this model by adding things that we don't need yet. 
So here's the price attribute. Now on page 2 you can see that both these tickets are in economy class, so that is another attribute of this booking, let's call that flight class. Now we could also call this booking ticket, So we could say a passenger purchases or books a ticket for the flight. That is more of a naming issue. Conceptually we have an entity like ticket or booking that has these attributes. Ticket number, the price the passenger paid, and the flight class which can be economy, premium economy, first class, and so on. So now let's delete this relationship and recreate it through the ticket entity. So once again I'm going to add a many to many relationship, this looks a little bit funky, sorry about that, alright, here's our relationship, let's attach one end to the ticket, the other end to the passenger, that looks good. 
So we can add a label here, like purchases or books, in my opinion they both work, but sometimes these words have different meanings in the heads of domain experts, so you should always check with them. The whole point of this conceptual model is to make sure that we developers or data modelers and domain experts are on the same page. We use the same language, the same words. So for now I'm just going to call this purchases. Now let me refine this relationship, it doesn't look properly attached here, ok, that's better. So here's our ticket entity, now let's add another relationship from ticket to the flight. So, one more time. Alright, so here's the relationship between the ticket and the flight, let's give it a label, so a ticket is issued for a given flight. 
Now there's one more attribute that we need to add to the ticket, and that is the confirmation number, so let's add that here as well, confirmation number. Alright, so here's our conceptual model with these four entities based on what we know about this problem right now. Next we're going to build a logical model based on this conceptual model.



















Solution: Logical Model

 

Alright, now we want to refine a few things to build a logical model. The first one is the relationships between these entities. So, let's talk about the relationship between passengers and tickets. A passenger can buy many tickets, but each ticket is issued for only a single passenger. So here we have a one to many relationship between the passenger and the ticket. So I'm going to open up the right panel select this relationship, and change one end from many to one. There you go. So we have one to many. Now what about ticket and flight? Again, here we have a one to many relationship because each ticket is issued for a particular flight, but a flight can have many different tickets. So I'm going to select this relationship and change this second end to one. 
So we have a one to many relationship between flight and ticket. Next one, what about the flight and airport? Well, each airport can host many different flights, but each flight works with two and only two airports. Now in any relationship diagrams we don't have two, we only have one and many. So we can still treat this relationship as a many to many relationship because a flight deals with multiple airports and an airport hosts multiple flights. Now let's set the type for each attribute. So yata code is going to be a string, let's type that here, name is also going to be a string, also city and state. What about flight number? Well, in this example we're dealing with a 4 digit number. But sometimes airlines use a combination of letters and numbers, so number is technically a string. 
Departure date time is going to be a date time, We need both the date and the time. Same is true for arrival. What about duration? Well, we can measure duration in seconds, minutes, hours, or even days. In the case of flight, it's better to measure the duration in minutes, because we might have a flight that is, let's say, 35 minutes long. We don't care about the seconds, we only care about the minutes. So I would prefer to rename this attribute to duration in minutes. This is more descriptive, nobody is going to guess what this number represents. is it the seconds, is it the hours, is it the days, it's very clear. So duration in minutes, and this is going to be an integer. 
What about the distance? This is also going to be an integer, but here I want to rename this attribute to distance in miles, so again there is no guess work, and we can also convert this number and display the distance in kilometers if we want to. Next we have airline, we can set the type of this attribute to a string, but with this structure we're going to end up duplicating the name of the airline. So it's better to represent airline as a separate entity that has a code or a number as well as a name. So let me bring back our design panel and add a new editor here. We're going to call this airline. Airline. All we need to know about each airline right now is their name. 
This is going to be a string. Now we should add a relationship between the flight and the airline, each airline has many flights, but each flight is operated by a single airline, so we have a one to many relationship, where is that here, it's over here, alright, now let me move this around, so we have a one to many relationship between the airline and the flight, and with this we can remove the airline attribute from here, that is better, alright, the name of each passenger is also a string, here we want to split this into the first name and the last name. So first name is going to be a string, last name is going to be a string as well. What else do we have here? 
Finally the ticket. So the ticket number right now is a 10 digit number. We're not going to perform any calculations on this number, this is just a label. So I'm going to use a string for this. Price is going to be float because we have a decimal point. Flight class again here we can use a string, but we'll end up duplicating the flight class, so it's better to model this as a separate entity. So I'm going to add a new entity here, move it on the top, let's call this flight class, now I'm not entirely sure if this is called flight class in this domain, this is one of those cases that you need to talk to the domain experts to see what they call it. 
So for now let's just add the name attribute here, and then we need to add a relationship between these two entities. Now a ticket is issued for a particular flight class but a flight class can have several tickets. So here we have a one to many relationship. So here's the one to many relationship between the flight class and ticket. Finally we need to set the type for confirmation number, again this is going to be a string. Now back to our airport entity, with this design we'll end up duplicating the city and state and potentially the country. So shouldn't we take out these attributes and model them as separate entities like countries, states, and cities? So a country can have multiple states and a state can have multiple cities. 
That is the proper normalized form. So in theory, yes, this is better, we reduce data duplication, but the problem with this is that our data will end up being so fragmented. Quite often, if not always, we need to join these 3 or 4 tables together to look up airports in a given city. These joins can hurt the performance of our applications. So in situations where we want to improve the performance, we should denormalize our tables. So tables that are frequently joined together, we combine them into a single table. This is one of those examples. With this design, we don't have to constantly join these tables together. And take into account that we're not going to have a million airports in the world. we have a limited number of airports, not every city has an airport, so the duplication we're dealing with here is not a big deal. 
So in this particular case, I prefer to denormalize our design and add the city and state attributes here. And one last thing before I finish this lecture, here we have a many to many relationship between the airport and the flight entities, but as I told you before in relational databases, we don't have many to many relationships, we only have one to one and one to many. Whenever you have a many to many relationship, you need to break it down into two one to many relationships. And we do that through a link table, a table that represents the relationship between two entities or two tables. Now here we can add a link table, but the problem with that link table is that it allows a flight to have an association with more than two airports. 
Because with a link table we can have a many to many relationship. But as I told you before, each flight only deals with exactly two airports. So in this particular case, I prefer not to use a link table, and instead I prefer to add two attributes here, departure airport, arrival airport, just like departure date time and arrival date time. So let's add those here as well, departure airport, let's say id, this is going to be the id of the departure airport, so an integer, and also arrival airport id also and integer, integer. So when we build a physical model based on this logical model, we'll need to add foreign keys on these two columns. So here's our final model, you can download this as a PDF right below this video. 
This is just based on what we know about this problem right now. So don't take this as the best or as the only solution for this kind of problem. There is no such a thing. Every solution has pros and cons. This is what I have come up with during this modeling session. Tomorrow if I look at the same problem, I will come up with a different solution. Now chances are, my solutions are going to be very similar or even identical. But the point here is that as we learn more about the problem, about the business domain, our model changes. Just one last thing, I noticed that here in the ticket entity, I forgot to remove the flight class attribute after I added the flight class entity. 
So, let's delete this from here. Okay, we're done with this model, I hope you learned a lot. I leave it up to you to build a physical model for this because that's very repetitive and I already showed you the steps earlier in the section.















Project â€“ Video Rental Application

 







Solution: Conceptual Model:

 

 

I'm going to take a very informal approach and take you through my thought process. So let's look at the requirements document and figure out the entities we have in this domain to build our conceptual model. So we need different levels of permissions for different users. So that tells us we probably have two entities here, permission and user. So let's go back to draw.io and add a couple of entities here. User and permission. So user can have multiple permissions. Let's add a relationship between the two, once again for simplicity I'm going to go with a many to many relationship, we don't care about the type of the relationship at this stage, we'll refine this when we get to our logical model. So a user has permissions. 
Now back to the document. So the store manager should be able to add, update, and delete the list of movies, so these are our permissions. They'll be in charge of setting the stock for each movie as well as the daily rental rate. So this will happen at the time of adding or updating a movie. Cashiers should have a read only view of the list of movies, they should be able to manage the list of customers and the movies they rent. Alright, let's move on. Now at checkout a customer brings one or more movies. So here I see two entities, customer and movie. These are the entities that we need to know about in this domain. So let's add them to our diagram as well, customer and movie. 
So, what is the relationship between these two entities? A customer rents one or more movies, right? So let me add this here, so customer rents movies. Now, back to the document. The cashier should look up a customer by their phone number, So phone number is one of the attributes of a customer. If the customer is a first time customer, the cashier asks their full name, email, and phone number. So these are the attributes of each customer that we need to know. Let's add them over here, so name, email, and phone. Now here we can use Pascal convention by capitalizing the first letter of every word, or we can use camel notation. Earlier I used camel, then I changed it to Pascal, it doesn't really matter, this is just for 
brainstorming, this is for communication. Alright, back to the document. The cashier then scans the movies the customer has brought to check out and records them in a system. Each movie has a 10 digit barcode printed on the cover. So barcode is an attribute of the movie. Let's add that here, barcode, now back to the requirements, when the customer returns to the store they will bring the movies they rented. If a movie is lost, the customer should be charged 5 times the daily rental rate of the movie. So for each movie we need to know the daily rental rate. Let's add that to our movie entity, daily rental rate. Now, the cashier should mark the movie as lost, and this will reduce the stock. 
So stock is another attribute of the movie, for each movie we need to know how many of them we have in the store. Let's add that to our model, we can call it stock or number in stock. Now, back here, there is no need to keep track of lost movies, all we need to know is the number of movies in stock, and how much the customer was charged. For other movies the customer should be charged based on the number of days and the daily rental rate. So for each movie that a customer rents, we need to know how many days the customer has rented this movie, and then multiply it by the daily rental rate. Now, this number of days, what entity this attribute belongs to. 
Back to our model, we can put that on the customer because the customer might rent several different movies. By the same token we can add it here because each customer might rent a movie for a different period. So that attribute is an attribute of the relationship between these two entities. So now we need to introduce a new entity, and call it rental, this represents the relationship between between these two entities. And that means we need to delete this relationship and recreate it through this new entity. So let me add a couple more relationships here. Alright, so we've got the rental entity here, for this we need to know the number of days. Now to calculate the rental fee, we get this number and multiply it by daily rental rate. 
If a movie is lost, we assume 5 as the number of days and multiplied by the daily rental rate. Okay. Back to the requirements. We issue discount coupons from time to time. The customer can bring a coupon when returning the movies. So coupon is another entity, perhaps each coupon has a code, like ABCD, and a discount value. So somewhere in our system we need to register the coupons that we have created. Perhaps the store manager or the cashier can do that. Unfortunately here the requirement doesn't tell us who's going to do that. So for now let's not worry about that, but what matters is that we're going to introduce a new entity here, let's call it coupon, this coupon is going to have perhaps a code, maybe some description, and a discount. 
And this coupon can be applied to a rental. So there's a relationship between the coupon and the rental. There you go, like this. So let's rename this relationship to applied to. Alright, now back to the requirements. It is possible that the customer returns the movies they have rented in multiple visits. That basically means I might rent 5 movies, tomorrow I will return 2 of them, the day after I will return the other 3. And finally we need to be able to track the top movies, top customers, and revenue per day, month, and year. So this is just a rough conceptual model that helps us understand the problem. Now one thing that we didn't add here and it was not reflected in the requirements was the attributes of the user. 
What do we need to know about each user? Well, at a minimum we need to know their user name and password, so they can login into the system. What about permission? Each permission should have a description, like add movie, update movie, and so on. So we've got these two entities on the top, and below this we've got these four entities customer movie rental and coupon. Next we're going to refine this model and build our logical model.
Solution: Logical Model:

 

Now we need to think about storage. Is this model a good model for storing the data in this application? Let's find out. So let's talk about the users and permissions. First we're going to specify the type of the relationship between these two entities. Here we have a many to many relationship because a user can have multiple permissions and the same permission can be applied to different users. Many to many. But there's a problem in this model. The problem is that every time we register a user, we have to explicitly assign those permissions to that user. For example, today we have one cashier, let's call it cashier number 1, we need to give this cashier 10 permissions. Tomorrow we hire a new cashier, we have to come back and give this new cashier these exact 10 permissions. 
The problem here is that we may give one cashier an extra permission or we may forget to give them one permission that they really need. So the issue is that our cashiers or store managers are not going to have a consistent set of permissions. Each user has different set of permissions. So we have to make sure that our users have consistent permissions. Now back to our requirements document. Nowhere in this document we were asked for the flexibility to assign specific permissions to each user. So this model is too fine grained for this application. It's suitable for an application where we want to have full control over the permissions of each user. So we need to change this model and introduce a new entity called role. 
We want to put our users in roles or groups, like store manager or cashier, and then assign permissions to those groups. Next time we register a new user, We simply add that user to a specific group or role, and that user will automatically inherit all the permissions in that role. With this change, our users will have a consistent set of permissions. So, let's add a new entity here should have a name, now we need to assign a user to a role, so let me move this relationship to here, a user belongs to one role, we don't want to add users in multiple roles, because nowhere in the requirements we were asked to do so. So, let's change this end of the relationship to 1, that is probably the drop down list on the right side, let's take a look, that was right, so 
A role can have multiple users, but a user belongs to one and only one role. Beautiful. Now, we need to add a many to many relationship between roles and permissions. A role can have multiple permissions, and a permission can belong to multiple roles. But before we do this, let's go back to the requirements document and have a closer look at the kind of permissions we need here. Basically we have the store manager that can do everything, and we have cashier that can do everything except managing the list of movies. So the cacher can only view the list of movies. They cannot add, update, or delete a movie. That is the only difference. So in my opinion, this model is a little bit too fine grained and too specific for this kind of requirement. 
We don't really need a table like permissions with records like add movie, update movie, delete movie, add customer, update customer, delete customer. This is very fine grained. we don't want that level of control. For example, we don't want to have a role where a user can add a movie, but not update a movie. See where I'm going with this? We don't need that level of control here. So in my opinion, we really don't need this entity, all we need to know is the role of the user, and in our application we can write a simple if statement, if the user is a store manager, we will enable all features, otherwise if there are a cashier, perhaps we're going to hide certain features or disable them. 
Like adding a movie, updating a movie, and deleting a movie. That's all we need, nothing more. So let me give you a metaphor. Imagine you're traveling and you need one room to stay for one night, and your budget is $100. Let's say you're a single person, all you need is a simple room with a single bed. Now you come to me and I say, hey, I have a room, it's actually sweet, it's huge, it has a king size bed, it has the view of the ocean, it has a balcony, it has jacuzzi, it has wifi and video games But it costs you $500 a night. Would you pay for that room? You probably wouldn't. All you need is a simple room to stay for one night and your budget is $100. 
You're not going to spend extra $400 for the features you don't need. Building software is the same. All these additional features that you predict that may happen in the future, somebody is going to pay for it. That is the company. So don't over engineer. Don't ruin people's money because of the features that you think are necessary. Now this is not all about money, it's about managing complexity. In this design, I don't want to bring extra complexity because this complexity is going to stay there for the lifetime of this application. Every time we need to fix a bug or introduce a new feature, we'll have to deal with unnecessary complexity that inexperienced people have brought into the design of this application. So, let's delete the permission entity here, we don't really need it. 
All we need is a simple role table. Now, let's set the data types. both the username and password are going to be a string, the name of the role should also be a string, beautiful, now for the customer, these are all strings, so I'm not going to waste your time typing them, barcode is going to be a string, because we're dealing with a 10 digit number, daily rental rate is going to be a float, because it might have a number after decimal point, so let's set that here, number in stock is going to be an integer, now when it comes to building a physical model, We're not going to use the integer data type in mysql because that would allow us to store up to 2 billion. 
We're not going to have 2 billion copies of a movie in a store. So the maximum number we need here is probably 50 or 100. We can use a tiny int for that. Now let's look at the rental. We need to know the number of days. Here I'm going to remove this attribute and replace it with two date time attributes. The date somebody rented a movie and the date they returned it. With this we can calculate the revenue per months per day and per year, that was one of our requirements. With this design, we cannot calculate the rent for a given time period. So, let's break this into two attributes, let's say rent date and return date, both are either date time or date. 
I don't think in this domain we care about the time, perhaps the date is sufficient. Now we can subtract these two values and calculate the number of days. each rental can have a maximum of one coupon, so this end of the relationship should be 0 or 1. So I'm going to select this relationship, and then change the right end to 0 to 1. So, here's the icon, that is 0 to 1, now in physical terms, in a physical model, that means we're going to have a table called rentals, in that table we're going to have a column called coupon, and this column is going to be nullable. Okay? So a rental can have a maximum of one coupon, but a coupon can be applied to many different rentals. 
Beautiful. Now what about the relationship between the rental and the movie? Each rental is for one and only one movie, but the movie can be part of many different rentals. So this end of the relationship should be one. Let's set that here, I'm not entirely sure if it's the left one or the right one, it depends on how I inserted the relationship. Alright, that worked, so we have a one relationship between the movie and the rental. By the same token a rental is for a specific customer, but a customer can have multiple rentals. So, this end of the relationship should be 1. Let's set that here as well. There you go. So 1 to many. Also, here in the customer entity, I'm going to break the name attribute to first and last names, that is better. 
So we're done with our logical model, I leave it up to you to build a physical model for this in MySQL.










Creating and Dropping Databases:

 

 

 

So you have learned how to use the wizards in mysql workbench to create and modify databases. These tools are really helpful and they increase our productivity. But if you want to become a database administrator, you need to understand the script that these tools generate. So every time they generate a script for you, you need to review it and make sure it doesn't have any bad impacts on your database. So over the next few lectures, we're going to look at a few more SQL statements like create database, create table, and so on. once you learn this you'll be able to create databases or modify them by hand without relying on these visual tools. So in this lecture we're going to look at two statements, one is create database for creating a new database and this will be an empty database without any tables. 
Now let's give this database a name like sql underline store 2, let's execute this now here we have this new database If we execute this statement one more time, we're going to get an error, so a better approach is to include if not exists keywords here. So create database if not exists. And now we can execute this multiple times without getting an error. We also have drop database for deleting a database, but here we remove the not keyword, so drop database if it exists. And now our database is gone. I'm going to recreate it one more time because we're going to use it over the next few lectures. So create database if not exists. Next we're going to look at the create table statement.












Creating Tables:

 

 

 

this lecture you're going to learn how to create a table. For this demo we're going to recreate this customers table that we have in our sql store database, we're going to recreate it in our sql store 2 database. So the first step is to use this new database, sql store 2, then we type create table we give our table a name, customers, and then we add parenthesis and inside this parenthesis we list all the columns. So what columns do we have here? We have customer id, let's type that here, next we add the data type for each column, this one is going to be an integer, we want to make this a primary key, so we type that here as well, and also, we want to apply the auto increment attribute, so MySQL automatically generates a new value every time we insert a new record here. 
So we add the column name, followed by its data type, and any attributes that apply here. let's add another column, first name, this one is going to be a varchar of 50, and here we want to apply the not null attribute, so every customer will have a first name. Now I'm not going to add all these columns here because that would be a waste of time, so let me add the key ones that help you understand how this statement works. I'm going to add another column, let's say points, this one is going to be, what is the data type for this? We can select that here, and right below the schemas panel, we have this object info panel, unfortunately it's not visible here, but in this panel we can see the data type for this column, that is an integer, so let me add that here, now I want to apply the not null attribute here as well, but I also want to give it a default value of 0, so we type default 0, now let's add one more column here, email, this one is going to be varchar of 255, it's not going to be nullable, and 
we want to make sure that every customer has a unique email. So here we can apply the unique attribute. So here are the attributes that we can apply to each column. Primary key, auto increment, not null, default, and unique. Now, let's terminate this with a semicolon, now let's execute the script, beautiful, so if we refresh the navigator panel, we should see this new table. So sql store 2, we have our customers table. However, we are not able to re-execute this script because we already have this customers table in our database and when we try to recreate it, mysql will yell at us. So just before this we can write drop table if exists customers and then we can create this table. There is also another approach, so instead of dropping the table, we can say create table if not exists and 
customers. Now let's execute this script one more time, we can execute it as many times as we want without getting an error, beautiful. Next I'm going to show you how to modify a table.

















Altering Tables:
 

 

 

 

 

lecture you're going to learn how to modify an existing table. So let's say we created this customers table, but we realized that we forgot to add the last name column here. Or maybe we chose the wrong data type for a given column. This is where we use the alter table statement. So I'm going to open up a new query window here, and in this window we're going to alter the customers table. So we type alter table customers, now here we can add a new column, so we type add, give our column a name, last name, data type, just like before, bar chart of 50, here we can apply any attributes like not null, unique, default, and so on. Now if we execute this, mysql will add this column at the end of this list of columns. 
But that's not what we want, we want to add this after the first name. So here we type after first name. Like this. Now if you have a space in your column name, which you shouldn't have to start with, you need to wrap your column name with back tick, like this. So if you have a space here, we'll have to use back ticks to indicate the column name. But once again, you really shouldn't have a space in your column names, that's just an ugly naming convention. Alright, so I'm going to revert this back to what we had, now let's execute this statement, back to the navigator panel, refresh, so here's our new column, beautiful. Now when writing an alter table statement, we can make multiple changes in one go. 
For example, we can add a new column, remove an existing one, and also change the data type or the attributes of one or more columns. So before terminating this statement, we can add a comma and add another clause. Like add let's say city of type varchar of 50, and this is not going to be nullable, Now we can modify an existing column, for example, modify column, now this column keyword here is optional, you don't have to type it, but some people prefer to be more explicit, so they type add column, modify column, and drop column, but again, it's optional. So modify column, first name, we can change its data type to bar chart of 55, we can also give it a default value of an empty string, and finally we can drop an existing column. 
So drop, let's say points. So this is how we can alter or modify a table. But remember, do not ever alter a table in a production environment, because that can have really bad consequences. Always try your changes on a test database, make sure they work, make sure they don't have any bad impacts, and then execute them on a production database. Next I'm going to show you how to create relationships.













Creating Relationships:

 

 

Now let's create the orders table and add a relationship between the customers and orders. So I'm going to collapse the customers table so we have more space here. First we're going to drop the orders table if it exists, so drop table if exists orders, and then we create the orders table with these columns. First we need the order id, this is going to be an integer and it's going to be the primary key for this table. Next we have the customer id, this is also going to be an integer, and it's not going to be nullable, so here I apply the not null attribute. Now let's clean up this code by aligning these attributes, that's better. Now note that here I did not apply the not null attribute on the order id column, because when we apply the primary key attribute on a column, mysql will assume that that column does not accept null values, because it doesn't make sense to have null 
in a primary key column. Now, to define a relationship between these two tables, after we list all our columns, we type foreign key, so we want to apply a foreign key constraint on the customer id column. First we need to give our foreign key a name, here's a convention that a lot of people use, fk, underline, here we add the name of our child or foreign key table, that is orders, and then we add the name of the parent or primary key column. customers. Next, in parenthesis, we list the columns that we want to add this foreign key on, in this case the customer id column. Now here we need to tell mysql that this column references the customer id column in the customers table. 
So we type references, customers table, and in parenthesis we type customer id. So that's the customer id column in the customers table. Next minute to specify the update and delete behavior. Should we cascade them or reject them? What should we do? So we type on update here. We can type cascade or Set null or no action. These are the options that you saw earlier in the foreign key panel. Let me show you. So here in our sequel store database, Let's take a look at the orders table. And by the way, I'm looking at the original sequel store database. So, I open this table, down the bottom we have a bunch of tabs, open the foreign keys tab, and here you can see all the foreign keys, the columns they're applied on, and the update and delete behavior. 
So, back to our query window. If the idea of a customer changes, I want to cascade the update, so the corresponding customer records in the orders table get updated automatically. So here we type cascade. What about deletion? Undelete. I don't want to cascade the deletes because I don't want to accidentally lose our orders. So here I'm going to use no action and this will prevent or reject the deletion. If you try to delete a customer and that customer has an order, MySQL will say hey you cannot delete this because there is an order for this customer. Now some people argue that we should not cascade updates because the primary key should not change. While I agree with that in theory, in practice things are different, we don't live in a perfect world, 
sometimes the primary key can change. This can be someone's accident, it can be a bug in your application, it can happen for a number of reasons. So I personally prefer to cascade my update, but if you disagree with this, that's totally fine. Now, let's terminate this statement with a semicolon and execute our script. Alright, beautiful, let's refresh the navigator panel, and look at our sql store 2 database, Here's the orders table that we created, beautiful. Now if you re-execute this script, we're going to get an error on line 3. MySQL will not be able to drop the customers table because now it's part of a relationship. So, to delete the customers table, first we need to delete the orders table, because this table depends on the customers table. 
If we delete the orders table, customers table will not be part of a relationship and we can easily delete it. So I'm going to move this drop table statement before dropping the customers table. We can separate these statements by line break, that's better. Now let's execute the script one more time. Beautiful, our database is regenerated from scratch.


















Altering Primary and Foreign Key Constraints:

 

 

In this lecture you're going to learn how to drop or create relationships between tables that already exist. For example, let's say in our current script, we forgot to add the foreign key constraint to the orders table. So we forgot to create the relationship. Now I'm going to show you how to add this relationship after creating the table. So, back to our other query window, earlier you learned about the alter table statement. You learned how to add, modify, or drop columns creating a table. We can use the same statement to add or drop the foreign keys in a given table. So, alter table orders. Here we can drop the existing foreign key. So drop foreign key. What is it called? FK, underline orders, underline customers. 
Now at the same time we can drop or add another foreign key. So let's add a foreign key called FK underline orders, underline customers. We're going to add this on the customer id column, so here we're following the exact same syntax that you saw in the last lecture. So we type foreign key, give it a name, we specify the column and all the other attributes. So we say this foreign key references the customers table, and here we need to add the primary key in that table, and finally we specify the update and delete behavior. So on update cascade and on delete, no action. Now here we have a red underline because I forgot to add a comma here. Now here we can also add or drop primary keys, let me show you. 
So we type add primary key, in parenthesis we type the name of the columns that are part of this primary key. In this case, order id. Now if you have multiple columns, you can separate them using a comma. And finally we can drop a primary key like this. So when dropping the primary key you don't specify the name of the columns.












Character Sets and Collations:

 

 

 

 

 

 

 

 

 

 

 

In this lecture we're going to talk about character sets and collations. What is a character set? Well, when we store a string like abc, mysql will convert each character to its numeric representation using a character set. So a character set is a table that maps each character to a number. Now there are various different character sets out there, some of them only support latin languages, the others support asian languages, and we also have character sets that support all international languages. Let me show you. So here we can execute show char set, and in this table we can see all character sets supported in the current version of MySQL. So, for example, we have this character set that is used for Armenian language, here we have another character set for traditional Chinese language, now down below we have this UTF-8 character set, and with this we can store characters in 
pretty much all international languages, and this is the default character set used by mysql version 5 or higher. So with the current version of mysql, when we create a database, our database supports international languages. Now here we have this column, default collation, a collation is basically a bunch of rules that determines how the characters in a given language are sorted. For example, the default collation for utf-8 character set is utf-8 underline general underlined ci. This ci that you see here is short for case insensitive and that means mysql treats lowercase and uppercase characters the same when it comes to sorting. And that's what we want most of the time. So if multiple users type their name in lowercase or uppercase characters, we want to sort them alphabetically irrespective of the uppercase and lowercase characters. 
So for 99.9% of the time we really don't have to worry about changing the collation. Now next to the collation we have is column max length, the max length for the UTF-8 character set is 3, and that means MySQL reserves a maximum of 3 bytes for storing each character. So earlier I told you that for English language MySQL reserves 1 byte, for Western European and Middle Eastern languages it uses 2 bytes, and for Asian languages it uses 3 bytes. Now here's the thing, Most of the time you don't have to worry about changing the character set, you can stick to the default. But there are cases where you may want to change the character set to reduce your database size. Here's an example. 
Let's say we have a table, and in that table we have a column, the type of this column is char of 10. As you know, we use chars for fixed length strings. So with a char column, whether we have 1 character or 10 characters, MySQL will reserve space for 10 characters. Now here's the thing, with the utf-8 character set, the maximum number of bytes mysql reserves for each character is 3 bytes. So if the type of our column is char of 10, mysql will reserve 10 times 3 for each cell in this column, that is 30 bytes. Now if we have a million records in this table, mysql is going to allocate 30 million bytes for this table. Now what if you don't want to support international languages? 
Let's say you only want to support Latin languages. Here we have another character set that is Latin 1, and this is used for most Latin based languages, and as you can see, MySQL reserves a maximum of 1 byte per character. So in this particular case, if you change the character set for this column, or this table, or this database, we can reduce the number of bytes MySQL will reserve on disk. So, can reduce this to 10 million bytes. Now let me show you how to change the character set. You can do it visually or using SQL. So first I'm going to show you the visual way. Here in the navigator panel, we can right click a database and go to schema inspector. On the first tab you can see the default character set for this database is UTF-8, and here's the default collation. 
Again, you really don't have to worry about changing the collation, just stick to the default. And over here you can also see your database size that is roughly about 64 kilobytes. Now unfortunately we cannot change the character set at the database level visually, we'll have to use sql. But we can change the character set at the table or column level. So, let's open one of these tables in the design mode. Here we have a varchar column, let's select that. Right below we have these drop down lists for selecting the character set and collation. Also, on the top here to the right, there is a chevron, unfortunately it's not visible in my recording window, when you click that, you can see the character set and collation for this table. 
Most of the time you want to set the character set at the database level for consistency, because you either support international languages or you don't. So let's see how we can change the character set at the database level using sql. There are two ways. If you're creating a database, you can set the character set and collation at the time of creating a database or after creating it. So we can type create database, give our database a name like db name, and right here we can type character set, let's say latin 1. We can also change the character set for an existing database, we simply have to replace create with alter. We can also change the character set at a table level, so when creating a table, 
let's say table 1, here we list our columns and at the end we type character set. Or if you have an existing table, we can type alter table 1 and then we change the character set. We can also set the character set for a particular column, so back to our main script, here when creating the customers table, let's say we want to set the character set for the first name column. Right after we specify the data type, we set character set to latin 1, and then we add all the column attributes and constraints.














Storage Engines:

 

 

 

going to finish this section by a quick overview of storage engines. In MySQL we have several storage engines and these storage engines determine how the data is stored and what features are available to us. So if you type show engines we can see all storage engines supported by the current version of MySQL and don't worry about this list here, the two most commonly used storage engines are MyISAM and InnoDB. MyISAM is an older storage engine, it used to be popular prior to version 5.5. But going forward, InnoDB is the superior storage engine, it supports features like transactions, all these things we have talked about so far, these are part of InnoDB. MyISAM does not support these features. So you really don't want to use MyISAM. 
But there are situations where you're working with a database built with an older version of MySQL and you may want to upgrade that database to use so we can add foreign keys. Foreign keys are really important for maintaining referential integrity. Earlier I told you that when we add a relationship between two tables, we cannot add invalid values in our foreign key columns. So that is the benefit of foreign keys. Now let me show you how to change the storage engine. We set the storage engine at a table level. So in the same database we can use multiple storage engines. For example, here I've got the customers table open, here on the top we have this drop down list, for selecting the storage engine. 
As you can see, InnoDB is the default storage engine and we really don't want to change this to anything else. But if this table was built with an older version of MySQL, perhaps here we would have MyISAM, we could simply change it to InnoDB right here. But we can also do the same in SQL. So, back to our query window, we can type alter table customers engine equals InnoDB. So this is how we change the storage engine for a table. Just remember that changing the storage engine of a table can be an expensive operation because mysql has to rebuild the table. During this time, your table is not going to be accessible. So don't do this in production unless you have a scheduled maintenance. 
So that's all about storage engines that you need to know and that brings us to the end of this section. I hope you learned a lot and I will see you in the next section.

























Indexing for High Performance:

 

In this section we're going to look at indexing for high performance. Indexes are extremely important in large databases and high traffic websites because they can improve the performance of our queries dramatically. In this section you're going to learn all about indexes, how they work, and how we can create them to speed up our queries. This is a very important topic that every developer and database administrator must learn and understand. Now before we get started, I want you to download and execute the script I've attached to this lecture. With this script, we're going to populate our customers table with a thousand new records so we can see the impact of indexes on our queries. Alright, now let's get started.







Indexes:

 

 

 

 

 

 

 

 

Indexes are basically data structures that database engines use to quickly find data. As an analogy, think of a telephone directory. Using a telephone directory, we can quickly find someone's phone number because contacts are sorted by their last and first names. This way we don't have to go through every contact in the directory. Database management systems use indexes to find data in a similar way. Let's say we want to find customers located in California. Without an index, MySQL has to scan every record in the customers table. This is not a big deal in a small table with a few hundred or thousand records, but as our tables grow larger, the cost of this query is going to increase dramatically. We can speed up this query by creating an index on the state column, and this is like creating a directory of customers sorted by their state. 
In this directory, or more accurately, this index, we only have the state of our customers and references to the records in the customers table. So MySQL can quickly find the corresponding customers using this index and then it will read those records from the table. This is way faster than scanning or reading every single record in the customer's table. In a lot of cases, indexes are small enough that they can fit into memory. That's why it's much faster to use them to find data. Because reading data from the memory is always faster than reading it from the disk. So indexes help us find data quickly. but they come with a cost. First of all, they increase the size of our databases because they have to be permanently stored next to our tables. 
Also, every time we add, update, or delete a record, MySQL has to update the corresponding indexes and this will impact the performance of our write operations. For these reasons, we should reserve indexes for performance critical queries. One of the common mistakes that a lot of developers make is that they add indexes at the time of designing their tables. You don't create indexes based on your tables, you create them based on your queries, because the whole point of using an index is to speed up a slow query. Adding an index based on the design of a table is like solving a problem that doesn't exist. So don't blindly add indexes on your tables, because this will increase the size of your database and slow down your writes. 
Now internally indexes are often stored as binary trees, but in this course I'm going to present them as tables because it's easier to visualize and understand them. In case you're not familiar with binary trees, they're basically one of the fundamental data structures that computer science students learn at school. You don't really need to understand how binary trees work to work with database indexes. So for simplicity, think of indexes as tables as I've presented in this lecture. Now let's see how we can create an index.




Creating Indexes:

 

 

 

 

 

Exercise:

 

Solution:

 

 

following the example from the last lecture, let's write a query to get the customers located in California. So select, for now let's only pick the customer id column, don't use a star, we'll talk about this later. So customer id from the customers table, where state equals California. When we execute this, obviously we see these numbers here. Beautiful. Now let me show you how MySQL actually executes this query. So we can prefix this with the explain keyword, and now when we run this, instead of seeing this actual result, we're going to see something else. Take a look. So we have these columns here, like select type, table, partitions, type, and so on. Now don't worry about all these columns, you're going to learn about them as we go through this section. 
The two columns that you need to pay attention to are type and rows. When we see all under type, that means mysql is going to do a full table scan. which means it's going to read or scan every single record in this table. Here in the rows column you can see the number of records that were scanned. In this case we have 1010 because that's the number of records we have in the customers table. Take a look. So, select count of everything from the customers table. There you go. So, back to this query. Because currently we don't have an index on this state column, In order to find the customers located in California, mysql has to scan every single record in this table. 
And this can get very slow as our customers table grows large. What if we have a million records here? This query is going to take several seconds or minutes. This is where we use an index. So we put an index on the state column to speed up this query. Let me show you. So we type out create index, we give our index a name, Quite often we prefix the name by idx or ix. Then we add an underline and here we specify the name of the column that we're going to put an index on. In this case, state. As a best practice, always give meaningful names to your indexes. I've seen people creating indexes like index 1, index 2, what does this represent? 
I have no idea. So always use meaningful names. So here we create an index called idx state. on customers table, and inside this parenthesis we type out the name of the columns, we want to put an index on, in this case, state. So, let's execute this line, beautiful, now let's execute the first statement one more time, take a look. In the type column we no longer have all, which means we don't have a full table scan, and in the rows column we see 112, so we reduce the number of records that MySQL has to read, from 1010 to 112. This is far faster. Now look under the possible keys. These are various indexes that MySQL might consider for executing this query. It is possible that we might have multiple indexes, so MySQL picks the one that has the best performance. 
So here we have the possible keys or indexes, and in the key column we can see the actual index or key that was used. So this is how an index can speed up our query. Now it's time for an exercise. Write a query to find customers with more than 1000 points. Use the explain statement to see how many records MySQL is going to scan to produce the result, then create an index on this column and compare the result. You will see my solution next. Alright, so first let's select customer id from the customers table where points is greater than 1000. Now we're going to use the explain keyword to see how mysql executes this query. So as you can see we have a full table scanned and the number of records that mysql is going to read is 1010. 
So let's go ahead and create an index on the points column so we can quickly find customers with more than 1000 points. Create index idx underline points on customers table and in parenthesis we type out points. let's execute this line, beautiful, now we're going to explain this query one more time, this time we have range instead of all, which means we're looking for a range of records, under possible keys we can see the index that we just created, obviously we can see that mysql picked this index, and here are the number of records that mysql had to read. So we reduced the number of records from 1000 to 500. Next I'm going to show you how to view indexes on a table.



Viewing Indexes:
 

 

 

 

 

 

 

Alright, now to view the indexes on a table, we type show indexes in, and here we type the name of our table, customers. Take a look. So here we have three indexes, the first one is the primary key, this is also called the clustered index, so whenever we add a primary key to a table, MySQL automatically creates an index, so we can quickly look up records by their id. Here you can see that this index is placed on the customer id column, Collation represents how data is sorted in the index a means ascending. We also have B which means descending Cardinality represents an estimated number of unique values in the index. So the cardinality of this primary key index is 1,000 and 10 because we have 1,000 and 10 unique values in this column But take into account that this number is an estimate not an actual value to get a more accurate value. 
We use the analyze table statement. So we type analyze table customers, and this will regenerate the statistics for this table. So, let's execute this, alright, now let's look at the indexes in this table one more time, so now we should have more accurate values. So one more time here we have three indexes, the first one is the primary key, which is also called the clustered index, so every table can have a maximum of one clustered index. Here we have two other indexes, these are referred to as secondary indexes. Now technically whenever we create a secondary index, mysql automatically includes the id or the primary key column in the secondary index. For example, here we have a secondary index on the points column, but inside this index we have two values in each entry. 
We have the points as well as the id for each customer. We don't see the id here, but internally it's stored in the index. Now look at the type of these indexes. All these indexes are btree which is short for binary tree. That is why earlier I told you that in MySQL most of our indexes are stored as binary trees, but in this course I represent them visually as tables because they're easier to understand and reason about. Now let's look at the indexes in the orders table. So show indexes in orders. This table has four indexes, the first one is the primary key, and these three other indexes are the secondary indexes that are placed on our foreign key columns. So whenever we create a relationship between two tables, MySQL automatically creates an index on the foreign keys so we can quickly join our tables. 
Alright, so this is how we can see the indexes in a given table, but we can also find them in the navigator panel. For example, in our SQL store database look at the customers table, here we have a folder for the indexes, and if you click on an index You can see various attributes about that index, for example, this index is a binary tree, it's not unique because we can have multiple customers in the same state. It's visible, which means it's enabled, and it's placed on the state column. Next we're going to talk about indexing string columns.














Prefix Indexes:
So you have learned how to create and view indexes. Now if the column you want to create an index on is a string column like a char, var char, text, or blob, our index may consume a lot of disk space and it won't perform well. Smaller indexes are better because they can fit in memory and this makes our searches faster. So when indexing string columns, we don't want to include the entire column in the index, we only want to include the first few characters or the prefix of the column so our index will be smaller. Let me show you. Let's say you want to create an index on the last name column in the customers table. So create index idx underline last name on customers on the last name column. 
Now because the last name column is a string column here in parenthesis we can specify the number of characters we want to include in the index. This is optional for char and varchar columns, but it's compulsory for text and blob columns. So here let's say we want to include only the first 20 characters in the index. Now we have a prefix index. You may be wondering why I chose 20 here, is it a magic number or a best practice? Not really. To find the optimal number we have to look at our data. We want to include enough characters that can uniquely identify each customer. For example, if we include only one character, we'll have a lot of customers whose last names start with a or b or c, this is not a good index, 
because it doesn't allow mysql to quickly find a customer by their last name. The index may return 100,000 customers whose last names start with a. Then mysql has to go through all these 100,000 customers to find someone with a given last name. So let me show you how to find the optimal prefix length. First, let's get the number of records in this table. So select count of everything from the customers table. We have 1010 records. Now let's try a few different prefix lengths and see how many unique values we get. For example, let's get the first character of our customers last names. So we type left of last name, and we only want to get one character. Now this will return a lot of duplicate values like aaa, bbb, and so on. 
So we apply the distinct keyword to see how many unique values we get. Take a look. So we have 25 unique values. Our goal here should be to maximize the number of unique values in our index. So let's try a few different lengths. I'm going to put this on a new line so we can compare them side by side. Let's put from here as well. Now, let's duplicate this line and try a different prefix. Let's say the first 5 characters. With this we get 966 unique values. This is pretty good since we have 1010 records in this table. what if we include the first 10 characters? So 10, alright, we see a very small improvement, so we only have 30 more unique values compared to prefix length of 5, so we are including twice as many characters, but we see a very small improvement. 
So in this case, 5 is the optimal prefix length. By including only the first 5 characters, we can uniquely identify most of the last names in this table. Next I'm going to talk about a very special and powerful type of index called a full text index.

Full-text Indexes:

 

 

 
 

 

 

 

 

 

MySQL and many other database management systems, we have a special kind of index called a full text index. We use these indexes to build fast and flexible search engines in our applications. Let me show you. first. I want you to download the script. I've attached to this lecture. With this script, we're going to create a new database called sequel blog. Let's say we're going to build a blog website and we're gonna give our users the ability to search for blog posts. So, let's run the script. Alright, now, back in the navigator panel, refresh, so here's our new database, sql blog, in this database we have only a single table called posts, let's take a look here, so we have four columns, post id, title, body, and date published. 
Now let's say the user searches for react, redox on our blog. React is a very popular javascript library for building frontend applications, Redux is a library that is quite often used with react applications. So let's say someone lands on our blog and searches for react Redux. How can we find the posts that are about react Redux? Well, here's one way. We can select everything From the posts table. And by the way, here we have to use our new database, sequel blog. So we select everything from the posts table where title is like react Redux. or body is like react redux. So with this like operator, we can find any posts that have this search phrase in their title or body. Now to refresh your memory, this percent sign here represents any number of characters. 
So we can have any number of characters before or after this search phrase. Now, there are a few issues with this query. The first issue is that currently we don't have an index on these columns. So as our posts table grows large, this query is going to get slower and slower. In the last lecture you learned about prefix indexes for indexing string columns, so we can add a prefix index here, but this index will only include the first few characters of the title or the body columns. What if this search phrase is after the column prefix? Our index is not going to include our search phrase, so MySQL has to do a full table scan. And as you know, that can get really slow as our table grows large. 
The other issue with this query is that it only returns the posts that have these exact two words in this sequence. So it won't return the posts that have either react or redux in them or posts that have these two words but in the reverse order. That's not how search engines work. If you go on Google and search for something, Google doesn't necessarily return documents that have this exact combination or this exact search phrase in them. will return any documents that have these two keywords in them in any order and they may not even be next to each other. They may be separated by other words. So this query is not really helpful for building search engines. This is where use full text indexes. 
With these indexes we can implement a fast and powerful search engine in our applications. These indexes work very differently from regular indexes. They include the entire string columns so they don't store just a prefix. They ignore any stop words like in, on, the, whatever, and they basically store a list of words, and for each word, they store a list of rows or documents that these words appear in. Let's see them in action. So, we're going to create a full text index called idx title body on the posts table, and in this index we're going to include two columns. So let me zoom out a little bit, alright. The first column is title, and the second column is body. That is why I added both these column names in the name of the index. 
Alright, now let's execute this line, beautiful. Let's rewrite our query, so select everything from the post table, where, here instead of the like operator, we're going to use two built in functions to work with full text indexes. First we call the match function, and here we pass the name of the columns that you want to search on. so title and body. These are the columns that we included in our full text index, so if our index has three columns, we have to include all these three columns here, otherwise MySQL is going to complain. So first we call the match function, then we call the against function, and here we pass our search phrase, so react redux. Now this will return any posts that have one or both these keywords in their title or body, 
These words can be in any order and they may be separated by one or more words. Take a look. So here's one post that has the word redux in its title, we can see here we don't have the word react. The next three posts have the word react in their title. Now let's take this to the next level. One of the beauties of full text searches is that they include a relevance score. So based on a number of factors, MySQL calculates a relevance use score for each row that contains the search phrase. The relevance use score is a floating point number between 0 to 1. 0 means no relevance. So let's display the relevance score in the result. So after the asterisk I'm going to add this expression here. 
So let's copy this and paste it here. Take a look. Now we have this new column, this is our relevance score column So you can see that the first post has the relevancy score of 0.9, then we have 0.1, once again 0.1 and 0.09. So the result is sorted by relevancy score in descending order. This is very powerful, just like search engines, just like Google. Now, these full text searches have two modes. One is the natural language mode, which is the default mode, and that's what we're using here. The other is the Boolean mode. And with this mode, we can include or exclude certain words just like how we use Google. Let me show you. So here, after our search phrase, we type in boolean mode. 
Now we can exclude redux by prefixing it with a minus, so we're telling MySQL that we're looking for rows that have react, but not redux. Take a look. The first post that was about redux is no longer in the search result. We can also include a word as a requirement, for example, if we add plus form, that means every row in the result must have the word form in either the title or the body. Take a look. So now we only get one row in the result, and as you can see here we have the word form and react, they are not in the order that we specified here, and this is the beauty of full text searches. We can also search for an exact phrase, for example, here we can add double quotes, and search for handling a form. 
Now this returns any posts that has this exact phrase and its title or body. So full text indexes are very powerful, use them if you want to build a search engine in your applications, especially if you want to search on long string columns like the body of a newspaper article or blog post, or the description of a product. Otherwise, for shorter string columns like name and address, use prefix indexes. Next we're going to look at composite indexes.





















Composite Indexes:

 

 

 

 

 

 

 

 
 

and let's make sure we're going to look at composite indexes in MySQL. So let's go back to our SQL store database, and look at the indexes in the customers table. So show indexes in customers. So here we have one primary or clustered index and three secondary indexes. Now let's say we want to look for customers located in California who have more than a thousand points. So let's write that query, select, customer id, from the customers table, where state equals California, and points is greater than 1000. Now let's use the explain statement and see how MySQL executes this query. So here we have two possible keys or indexes, one is the index on the state column, the other is the index on the points column. 
But as you can see, out of the two, MySQL picked the one on the state column, So no matter how many indexes we have, mysql will pick a maximum of one index. Now look at the number of rows that are scanned here. 100 and 12. So using this index we can narrow down our search to customers located in California. When mysql executes this query, it uses our state index to quickly find customers located in California. But then it has to go through all these customers and check their points. This part of the query requires a table scan, because we don't have the number of points for each customer in our state index. Now here's where things get tricky. What if we have 10 million customers in California? 
Our index definitely helps speeding up this query, but it only does half of the job. It only allows us to quickly find customers in California. The second part of this query involves a table scan. And because we are reading data from the disk, this will get slow as our customers table grows large. This is where composite index has come to the rescue. With the composite index we can index multiple columns. So here we can create a composite index on the state and points columns, and with this index we can quickly find customers located in any given states with any number of points. Let me show you. So, let's create a new index called idx, underline state, underline points, on customers table, and our columns are state and points. 
Let me zoom out a little bit, alright, that's better. So here we have a composite index on these two columns, you might be asking if the order matters, it actually does, and we're going to talk about that in the next lecture. For now let's just go ahead and create this index, now let's explain this query one more time, and see how many rows are scanned to satisfy this query. 58, previously we had 112. So this composite index is doing a better job at optimizing our query. Also, if you look at the possible keys column, you can see we have three candidates here, the index on the state column, the index on the points column, and our composite index. Out of the three, MySQL realized that this composite index does a better job at optimizing this query. 
So in reality, most of the time we should use composite indexes, because a query can have multiple filters. Also, later I will show you that indexes can help us sort data faster, so if you have multiple columns in an index, we can also speed up sorting of our data. One of the common mistakes that a lot of beginners make is they create a separate index on each column. As you saw in this lecture, these indexes only do half of the job. They don't help us get the optimum performance. Also, they take a lot of space, and every time you modify your data in your tables, these indexes have to be updated. The more indexes you have, the slower your write operations are going to be. 
Also, as I told you before, MySQL automatically includes the primary key of the table in each secondary index. So these single column indexes are going to waste a lot of space, and that's why it's better to use composite indexes. Now, how many columns should you include in your indexes? In MySQL, an index can have a maximum of 16 columns, and generally speaking, I would say that's a pretty high number. You don't want to hit that. I would say somewhere around 4 to 6 columns performs well, but don't take this as a hard and fast rule or as a best practice, you should always experiment based on your queries and the amount of data you have. So now let's drop these two indexes on the state and points columns. 
That's very easy. We type drop index idx underline state on customers table. Let's execute this, beautiful. Also, let's drop the other index, Now let's look at the indexes in the customers table, so currently we have one index on the last name column and a composite index on these two columns. Next we're going to talk about the order of columns in a composite index.

























Order of Columns in Composite Indexes:

In the last lecture you learned how to create composite indexes. In this lecture we're going to talk about the order of columns in a composite index. So here we have two basic rules. The first rule says that we should order our columns such that the columns that are used more frequently come first. And this makes perfect sense. If we have five queries and all or most of these queries look up customers by state, it makes sense to put the state column first because this can help narrow down our searches. The second rule says that we should put the columns with a higher cardinality first. Cardinality represents the number of unique values in the index. For example, in our primary key, the cardinality is 1010, so we have 1010 unique values in this column. 
Now, think of a column like gender. What is the cardinality or the number of unique values in this column? It's 2. We either have 0 or 1, right? Now, if our table has a million records, and we assume an even distribution of genders. We could say that half of them are males and the other half are females. So, in our composite index, if we put the gender column first, this column can narrow down our searches from 1 million to about half a million customers, right? Now, what if we put the state column first? In our customers table we have 48 unique states. So, if we have 1 million records in this table, and again assume and even distribution of customers across different states we're going to have 1 million divided by 48 that is roughly about 20 000 customers in each state so if you put the state column first this can narrow down our searches to fewer records so as a basic rule of thumb it's better to put the columns with a higher cardinality first but don't take this as a hard and fast rule this is just a starting point you should always take your query 
and your data into account. Let's look at a few examples. Let's say we want to get customers located in California, whose last names start with a. Which column should come first in our index? Well, let's look at the cardinality of these two columns. So, we're going to count how many unique values we have in each of these columns. Select count of distinct of state, as well as count of distinct of last name from the customers table. Take a look. So the cardinality of the state column is 48, and the cardinality of the last name column is 996. So according to our second rule, if we ignore our queries, this column is a better candidate to come first, because it can break down our table into smaller segments. 
But as I'm going to show you in this lecture, this cardinality rule is not always the best practice, you should always take your queries into account. Let me show you. So first I'm going to create a composite index on the last name and state columns. So create index, we're going to call it last name, underline state on customers, and here are our columns. Alright. Now let's use the explain keyword and see how MySQL executes this query. So out of these indexes, it decided to use our new composite index on last name and state columns, look at the number of rows that MySQL scanned, that is 40. So, if you put the last name column first, in order to satisfy this query, MySQL has to go through each last name that starts with a, in that segment it has to find the customers located in California. 
Now we could have hundreds of thousands of people or millions of people whose last name starts with a. So mysql has to go through each entry and then find customers located in California. That looks inefficient to me. But what if we reverse the order of these columns? If we put the state first, mysql can quickly go to the segment for California, and in that segment it can quickly select the customers whose last names start with 8. Because these last names are sorted alphabetically. So in my opinion, this second index will probably perform better. But let's investigate this. So, remember this number. 40. Now let's create another index but with the opposite order. So I'm going to call this state underline last name, and then I'm going to change the order of these columns. 
Alright, now let's execute this query one more time, this time mysql decided to use our new composite index, and with this only 7 rows are scanned. So we reduce the number from 40 to 7. Now, these are just some numbers based on the constant values we have used in this query. What if we search for customers in New York or Virginia or any other state? Let's take a look. So I'm going to change this query and find customers located in New York. Alright, once again, mysql use our composite index that starts with the state column, and here we have only two rows. Now, even though this is the optimal index for this query, we can force mysql to use a different index. So just after our from clause and before the where clause, we type use index and in parenthesis we type out the name of that index. 
That is idx, last name, state. So with the former index, mysql has to scan 40 rows as opposed to 2 rows. So here's what I want you to take away. Our second rule, the rule about cardinality suggests that the last name column should come first because it has a higher cardinality. But as I told you before, we should always look at our queries and see how MySQL would execute them using different indexes. In this query, because we have an equality sign on the state column, this column is more restrictive. In contrast, the filter on the last name column is more open because here we're dealing with a range. So for this particular query, it's more efficient to put the state column first, so we can quickly go to a particular state and then find customers whose last names start with a given character. 
Now, what if we search for a range of states? So, let's change this query, and look at the customers in any states that start with a. Now we have two ranges, one is the state, the other is the last name, so let's see what index performs better. First we're going to execute this query with this index, So, with this index, mysql had to scan 40 records. Now let's use the other index. State, last name. With this other index, mysql had to scan 51 records. So for this particular query, the other index performed better than the one that started with the last name column. But wait a second, let's be realistic here. It's more realistic to have a query find customers in a given state like California, as opposed to customers in any states that start with A or B or C, right? 
So this example is not realistic. So we don't have to worry about optimizing this query. We only want to add indexes to optimize performance critical queries. Not all queries in the world. So back to our previous query, where we search for customers in California, for this particular query, this index that starts with the state column is a better index. So I'm going to drop the other index. Drop index, idx, last name, state. Alright. Now let's look at another example. What if we remove the state filter? So we only want to look up customers by their last name. For this query, this index is not efficient, because MySQL has to go through each state, and then check the last name of customers. So for this particular query, if this is a performance critical query, we're going to create a separate index that starts with the last name column. 
Currently we don't have any other filters here, so we can have a single column index on the last name column. In the future, as we analyze more queries, we might extend that index and add more columns. So to wrap up, start with our basic guidelines. Put the columns that are used more frequently first. look at the cardinality of your columns, it's better to put columns with a higher cardinality first, but always take your queries into account. Try to understand how MySQL would execute your query with different indexes. You're not going to be able to come up with one compound index that is going to speed up all your queries. As your system grows, you might need several indexes on columns in different orders.








When indexes are ignored:

 

 

 

 

 

 

 

 

 

 

 

There are situations where you have an index, but you still experience performance problems. Let's look at one of the common scenarios. So, I'm going to select the customer id column from the customers table, where state equals California, or points is greater than 1000. So in all the previous examples, we used the and operator, but here we are using the or operator. Now, let's explain this query and see what we get. So, just like before, here are the possible indexes, and you can see mysql has used an index to satisfy this query, but look at the number of rows, that's 1010. It looks like we have a full table scan, but actually we don't. Take a look at the value and the type column, that's index, which means we have a full index scan. 
This is faster than a table scan because it doesn't involve reading every record from the disk. Having said that, we still have to scan 1010 records. So how can we optimize this query further? This is one of those situations where you have to rewrite your query to utilize your indexes in the best possible way. In this case, we're going to chop up this query into two smaller queries. First we're going to select all the customers located in the state of California, then we're going to union that with another query that picks customers who have more than 1000 points. So, let's break this up into two smaller queries, here's the first one, then we union this with another similar query, but with a different word clause. 
Like this. So, this index that we have satisfies the first part of this query, because with this index, we can quickly find customers located in California. But this index is not an ideal index for searching customers by their points, because points is the second column in this index. So if you use this index to satisfy this query, mysql has to go through every state and then pick customers who have more than a thousand points. So, to speed up the second part of this query, we're going to create a separate index on the points column. So, on the top, create index idx underline points, on customers, on the points column. Alright, now let's see what happens when we explain this query. Alright, now in this table we have three records, the first two have an identifier, one represents the first select, two represents the second select. 
For the first select, which is our primary select, here are the possible keys, and as you can see the composite key on the state and points column is picked, so with this index, you have to scan 112 records. Now, for the second select, once again we have possible keys, one of them is our composite index, and the other is the index that we just created on the points column. As you can see, mysql picked the last index because this performs better on the second part of this query. So with this index, now we have to scan 528 records. So if you add these two numbers together, we get 640 rows, which is a significant improvement compared to the previous query where we used the or operator. 
Previously we had to scan records. Now you have to scan 640 records. Let's look at another example. I'm going to select the customer id column from the customers table where points plus 10 is greater than 2010. Let's explain this query and see what we get. So once again we have an index scan, look at the number of records, that is 1010. So we have a full index scan index scan, even though we have an index on the points column, mysql had to read every entry in our index to satisfy this query. Now here we have only a thousand records, that's not a big deal, but if we had a million records, even scanning every entry in an index can be slow. So what is the reason we have a full index scan here? 
That's because of this expression. So whenever we use a column in an expression, mysql is not able to utilize our index in the best possible way. So, To solve this problem, I'm going to isolate this column and rewrite this expression like this. Where points is greater than 2000. So this produces the exact same result, but now when we explain this query, we see something radically different. Look at the number of rows, it's only 3. This is a huge improvement compared to the previous query. So if you want MySQL to utilize your indexes, you should always isolate your columns. Next I'm going to talk about using indexes for sorting.


Using Indexes for Sorting:

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 

 

 

 

 

 

So far we have only used indexes for filtering data. But we can also use indexes for sorting data. Let me show you. So here are the indexes in the customers table. We have our primary key, this secondary index on the last name column, and one composite index on the state and points columns. In the previous videos I created a couple more indexes, but I dropped them to clean things up. Now, let's write a query and sort our customers by their state. So, select Once again, we're only going to pick up the customer id column, I'll talk about this in the next lecture. So, let's select this from the customers table, and order by state. Now earlier I told you that, when you add an index on a column, MySQL grabs all the values in that column, sorts them, and stores them in the index. 
So this composite index that we have here only has these customers sorted by their state. Let's take a look. So, I'm going to explain this query, as you can see, we have an index scan, to the right side you can see the key that is used, now the weird thing here is that we don't see this key under possible keys column, honestly I'm not entirely sure why this happens, but what matters is that this index is selected to sort customers by their state. So here we have 1010 records, so mysql is scanning this entire index reading entries in order. And in the extra column you can see it's using this index. Okay? Now let's see what happens if we sort a different column that is not in our index. 
Let's say first name. The type is changed to all, which means we have a full table scan, and in the extra column you can see using file sort. Now this file sort doesn't have anything to do with files, it's just the name of the algorithm that MySQL uses to sort data in a table. What you need to know is that file sort is an expensive operation. So generally speaking, don't sort data unless you really have to, and then see if you can design an index so mysql doesn't have to perform the sort operation. Now let me show you something interesting. Here we can use the show status statement to look at the server variables. Take a look. So there's so many variables here, these are the variables used by mysql server. 
Here we have a variable called last query cost returns the cost of the last query. So we can filter that using the like operator, last query cost. So the cost of the last query was just over 1000. Now let's see what happens when we sort by a column that is in our index. So state, and let's look at the cost of this query, that is just over 100. So you can see that the file sort operation is very expensive, it's almost 10 times more expensive than getting data from an index. So if possible, it's a good idea to design your indexes so they can be used both for filtering and sorting data. But remember, this doesn't always look simple like what I showed you in this lecture. 
There are some complications depending on your query, on your where clause, on your order by clause. Depending on the columns you have here and the order, MySQL may decide not to use your index for sorting data. The basic rule of thumb is that these columns that you have in the order by clause should be in the same order as the columns in the index. So here we can sort by state and points, and once again we have an index scan, but if you add a column in the middle, let's say first name, obviously this column is not in our index, so now we get a full table scan. Another situation is where you're sorting in different directions. For example, let's sort by state and points, and look at the cost of this query, that is about 100. 
Now, if we sort by points in descending order, we still see the index, however, when we look at the cost of this query, we see 1,112. Here's the reason, let's explain this query one more time, always look in the extra column. Here we have using index and using file sort, and that means part of this query is satisfied using the index, the other part is satisfied using the file sort operation. Because the composite index that we have on these two columns is sorted by the state and then points in ascending order. So mysql cannot utilize that index to satisfy this query because we're sorting in different directions. Now what if you're sorting by state in descending order and also points in descending order. 
Take a look. In this case, we have a backward index scan, not a file sort operation. Let's look at the cost of this query. This is exactly like sorting by state and points in ascending order. So here's the basic rule of thumb, if you have an index on two columns like a and b, we can sort by a, we can sort by a and b, we can sort by the same columns in descending order, but we cannot mix the directions. Also, we cannot put a column in the middle, you saw this earlier, this results in a full table scan. Now let's see what happens if we sort by the second column of an index. So, back to our query, I'm going to sort by the points column. 
So we have an index again, so far so good, but let's take a look at the extra column. Using index, using file sort. So once again, this is going to be an expensive query. We can validate this by looking at the cost, that is about 1000. Here's the reason, in our current index, our customers are sorted by their state, and within each state, they're sorted by their points. So mysql cannot rely on the order of entries in this index to sort customers by their points. Having said that, there is an exception to this rule. We can go to a particular segment or a particular state and then sort customers by their points. So if we have a where clause here, where state equals let's say California, with this mysql is not going to do a file sort operation because it's going to go to this state and as you know in this state all customers are already sorted by their points. 
So there is no need to do a file sort operation. Let's take a look. So we explain this query, now, under extra we have using where, using index, we don't have using file sort, and we can look at the cost of this query, that is 11. So this query is far cheaper because we have narrowed down our search to one particular state. Okay? So, if you have a composite index on these two columns, these are three ways that MySQL can use to sort our data. So I'm going to delete the last one.











Covering Indexes:
 

 

 

 

In all the queries we have written so far, I've only picked the customer id column. What is the reason? That's what I'm going to answer in this video. So here we have a simple query, select customer id from customers, order by state. Let's explain this query and see what we get. So here we have an index scan, and if you look at the extra column, you can see that MySQL is satisfying this query purely using our index. Now let's see what happens if we select all columns. We get a full table scan, and as you know this can be very expensive. So here's the reason, the composite index that we put on the state and points columns contains three pieces of information about each customer. 
Their id, their state, and their points. Just to refresh your memory, earlier I told you that whenever you create a secondary index, mysql automatically includes the primary key in your secondary index. So that's why our index contains the customer id, state, and points. and points. So if we pick any of these columns here, like customer id and state, mysql can satisfy our query entirely using our index. This is called a covering index. An index that covers everything that a query needs. So using this index, mysql can execute our query without touching the table. And this is the fastest performance we can get. So when designing your indexes, first look at your where clause. look at the columns that are most frequently there. Include those in your index, with this you can narrow down the searches. 
Then look at the columns in the order by clause. See if you can include these columns in your index. And finally look at the columns used in the select clause. If you include these columns as well, then you will get a covering index, so MySQL can use your index to satisfy your query.
















Index Maintenance:
 

 

So indexes can dramatically improve the performance of our queries. But too much of a good thing can be a bad thing. So as you work with indexes, you need to watch for duplicate and redundant indexes. Duplicate indexes are indexes on the same set of columns in the same order. Like ABC and ABC. The problem is that MySQL doesn't stop you from creating these duplicate indexes. It will maintain each duplicate index separately. Sometimes you can create duplicate indexes without being aware of it. This often happens when someone creates an index without looking at the existing indexes. So as a best practice, always check the existing indexes before creating a new one. Redundant indexes are a little bit different. If you have an index on two columns like A and B, and then create another index on column A, that is considered redundant. 
Because the former index can also optimize the queries that work with column A. However, if you create an index on columns B and A, or just column B, that is not redundant, because these indexes satisfy different queries. Again, redundant indexes appear when someone creates a new index without looking at the existing indexes. So always, always, always, before creating a new index, look at the existing indexes and see if there is an index that you can extend. So index maintenance is very important, make sure to drop, duplicate, redundant, as well as unused indexes.






















Securing Databases:

Throughout this course, we have been using MySQL on our own computer. And for this very reason, we didn't have to worry about security in terms of who can access our data and how much access they should have. However, in a real world scenario, you typically have a database somewhere on a server, and if you don't take security seriously, people can access and misuse your data. So in this section, we're going to talk about user accounts and privileges for securing databases. Are you ready? Let's get started.




















Creating a User:

 

 

 

 

 

 

 

 

So far we've been connecting to our database server using the root user. This is the same user account that we created at the time of installing MySQL early on in the course. Now, when it comes to using MySQL in a production environment, we need to create additional user accounts and give them specific privileges. For example, let's say you're building a web or a desktop application. Your application needs to access data in a MySQL database. So you need to create a user account for your application and give it permission to read and write data to your application's database, but nothing more. So this user account should not be able to change the structure of your database. It shouldn't be able to create new tables or drop existing ones, because this can totally mess up with everything. 
As another example, let's say someone new joins your organization as a database administrator. You need to create an account for this person so they can manage one or more databases or the entire MySQL server. So first let me show you how to create a new user account, and then we'll talk about assigning permissions or privileges. To create a new user, we use the create user statement, we give our user a name like John, and then we can optionally restrict where the user can connect from. So here we can type an at sign, and then we can type the IP address of a computer, like 127.0.0.1, this is the IP address of our own computer. So this means this user can only connect from the same computer where we have installed MySQL. 
If they try to connect from a different computer, MySQL is going to decline the connection. This is very useful in cloud environments, so typically you have a web server and a database server. On your database server, when creating a new user account for your application, you want to make sure that that user account can only connect from the web server. So this is where you specify the IP address of your web server. Okay? here we can also specify a host name, like localhost, which again represents the current computer where we have installed mysql, we can also specify a domain name, like code with mosh.com, now this user can connect from any computers in this domain, but they won't be able to connect from the subdomains of code with mosh.com, to provide that we need to add a wildcard here, so we add percent dot, this represents any subdomains, right? 
Now you can see here we have an error, because we have to put this entire domain in quotes, either single or double quotes. So with this, john can connect from any computers in this domain or any of its subdomains. Now for simplicity, I'm going to drop this, which means john can connect from anywhere. There are no restrictions. Next we need to set the password for this user. So we type identified by, and here we supply the password. Let's say 1234. Now this is purely for simplicity, but do not ever, ever, ever, ever use this password, always use a strong password, the longer the better. So let's go ahead and create this user, beautiful. Next I'm going to show you how to view the users on your server.



















Viewing Users:

 

 

 

let's see the list of users in our mysql server. There are basically two ways to do this. We have this database called MySQL. In this database we have a table called user. So we can select everything from this table. Take a look. So host represents where the user can connect from. So we created this john user without specifying a host. And as you can see, the host for this user is set to this percent, which is a wildcard character, just like when we use the like operator. So it means anywhere. John can connect from any computers, there are no restrictions. We also have these three user accounts that are used internally by MySQL, and finally we have root. This is the user account that we created when installing MySQL. 
Now note that all these accounts, their host is localhost. So if I want to log in as the root, I have to be on this computer. I cannot connect remotely and log in as the root user. Okay? Now here we have several columns that determine the permissions for each user, don't worry about this now, we're going to talk about this later. So this is one way to get the list of users. We can also see our users in the navigator panel. So, on the left side, open the administration tab, here under management we have users and privileges. So once again, we can see the same user accounts over here. Next I'm going to talk about dropping users.



Dropping Users:

 

 

As people leave your organization, you need to drop their user account so they can no longer access your MySQL server. This is pretty easy. So I'm going to create a new user, Bob, who can connect from code with mosh.com, and is identified by this password. Let's create this user, okay, now let's say Bob left the organization, we come back here and write drop user Bob, we should specify the host as well, so at code with mosh.com, As simple as that. This is how we can drop a user account. So as a best practice, always drop the user accounts that are no longer used in your organization. Next I'm going to talk about changing passwords.





Changing Passwords:

 

 

 

forget their passwords. So as a database admin, you may be asked to change someone's password. Or maybe your own password. This is pretty easy, there are basically two ways to do this. We can use the set password statement, so set password for john, we set this to a new password. Simple as that. Now if you want to change your own password, you drop the for clause, and this sets the password of the currently logged in user. Whether it's the root user or someone else. The other way to change the password is is through the navigator panel. So, let's go back to the administration panel here, open up the users and privileges window, so here's John, over here we can change the password, we can also expire the password, and this will force this user to change their password next time they log in. 
Just remember, whenever you change the password here, you need to click on the apply button that is on the bottom right corner of the screen, currently it's not visible, it's over here. So this is all about user accounts. Next we're going to talk about privileges.



















Granting Privileges:

 

 

 

 

 

 

 

 

 

 

Once you create a user account, you should assign it some privileges. So in this lecture I'm going to walk you through the two common scenarios. The first scenario is where we have a web or a desktop application, and we want to allow this application to read and write data in a database, but nothing more. We don't want this application to be able to create a new table or modify existing tables, that's something that only an admin should be able to do. So the second scenario is for our admins. Let's say someone new joins our organization, and you want to give them administrative privileges over one or more databases or perhaps the entire MySQL server. So let's start with the first scenario. For this demo, let's imagine we have an application called moon, and this application needs to read or write data in the SQL store database. 
So first we need to create a user account for this application, we call it moon underline app, this clearly specifies that this user account is for an application, not a human, So we're going to create this user account and give it a password, 1, 2, 3, 4, once again I want to emphasize that you should always, always, always use strong passwords. So we create this user account, beautiful, now we use the grant statement to give this user a few privileges. We want this user to be able to select, insert, update, and delete data, as well as execute stored procedures. These are the typical privileges we want to give to a user account for an application, okay? So, here are our privileges, next we use the on clause to specify the database, we can type sql store dot star, and this means all tables in the sql store database, we can also designate a particular table, let's say the customer table, and with this, our user account will only be able to select, insert, update, and delete data in the customers table, nowhere else, okay? 
Not very common, but it's doable. So I'm going to revert this back to the start. Finally we use the two clause to specify the user account. In this case moon app, now if this user account has a host or an IP address or a domain name, we should also specify that here. So let's go ahead and give this user access, beautiful. Now I'm going to connect to our server using this user account. So back to the homepage, let's create a new connection, let's give this connection a name like moon app connection, I'm going to set the username to moon on the night app, and the password is going to be 1234, let's test the connection, successful, beautiful, okay, now let's connect with this user account, so here we can use the sql store database and select everything, 
from the customers table, there you go, beautiful, but if I use a different database like sql blog, mysql gives me an error, access denied for user mona app, so I don't have access to any other databases, okay? Now, back to our query window, so we covered the scenario for a web or a desktop application, now let's look at the second scenario, so earlier we created a user account called john, let's say john is going to be an admin, So once again we use the grant statement to give this user certain privileges. These privileges are going to be more than reading and writing data, we want this user account to be able to create tables, create triggers, modify existing tables, so if you search for mysql privileges, on this page, mysql reference manual, you can see all the privileges supported in mysql. 
So, look at this table, for example, we have create routine, which allows someone to create stored procedure or function. We have so many privileges here and can read about them on your own. But what I'm going to talk about in this lecture is all. This is the highest level of privilege we can give to someone. So typically for admins, we want to give them all privileges. So back to a query window, I'm going to grant all on, and here we can specify a database like sequel store. So now this user will have the highest level of privileges over all tables in this database. but we can also give them access to all databases on our server. So, we can change this to star dot star. 
This means all tables in all databases. Okay? And finally, we type to john. So these are the two common scenarios that we covered in this lecture. Next I'm going to show you how to view the privileges for a given user.













Viewing Privileges:

 

 

 

 

There are times you want to see the permissions or privileges assigned to a user account. There are basically two ways to do this. We can use this through the navigator panel or using SQL. So here we can type show grants for let's say John, and this returns all the grants or all the privileges for this user account. As you can see, John can select, insert, update, and delete data, as well as a bunch of other things like shutting down the server, creating backups, and so on. Now if we drop the for clause, we can see the permissions for the current user. So currently I've logged in as the root, as you can see root has the highest level of privileges, more than any other admins. 
Now we can also find this information in the navigator panel, so back to our users and privileges window, let's select John, here under the administrative roles, you can see the roles and privileges assigned to this user, and under schema privileges you can see permissions for various databases. Now because John is an admin, we don't have anything specific here because he can access all databases. But let's take a look at the moon app. On this app you can see this account is only able to access the sql store database, and here are the privileges assigned to this user for this database. Now if you want to make any changes here, simply select this item, make any necessary changes and then click apply. Next I'm going to show you how to revoke privileges.


















Revoking Privileges:

 

 

Once you create a user and give it some privileges, you may realize you made a mistake and you want to revoke one or more privileges. Or maybe you assign someone more privileges than they deserve and they end up abusing those privileges. So in this lecture I'm going to show you how to revoke privileges. It's very easy, it's very similar to granting privileges. So as an example, let's grant the create view privilege on sql store database to our moon app account. earlier i told you that this account should only be able to read and write data as well as execute stored procedures. So it shouldn't be able to create views. Now, let's execute this all right so we made a mistake, now we want to revoke this privilege. 
So we simply replace grant with revoke and to with from. So revoke, create view on this database from this user account. As simple as that. So take security seriously and do not grant more privileges to a user than necessary. Always grant the minimum required by user account. Otherwise you're opening so many security holes in your system. And that brings us to the end of this section. I hope you learned a lot and thank you for watching.



