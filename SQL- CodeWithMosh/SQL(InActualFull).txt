

code with mosh sql:
===================

Let's start with a quick overview of Databases, what they are and how we use them. A database is a collection of data stored in a format that can easily be accessed. In order to manage our Databases, we use a software application called Database Management System or DBMS. We connect to a DBMS and give it instructions for querying or modifying data. The DBMS will execute our instructions and send results back. 

Now, we have several database management systems out there, and these are classified into two categories. 
Relational and non-relational, also called NoSQL. In Relational Databases, we store data in tables that are linked to each other using relationships. That's why we call these databases Relational Databases. Each table stores data about a specific type of object, like customer, product, order, and so on. 
SQL is the language that we use to work with these Relational Database Management Systems. It looks like this. 

SELECT *
FROM products
WHERE category = 'food'
ORDER BY price


We use SQL to query or modify our data. In this course, you're going to learn everything about this powerful language. Now, there are many different Relational database management systems out there. Some of the most popular ones are MySQL, SQL Server by Microsoft, and Oracle. But of course, there are plenty more. Each Database management system has a different flavor of SQL, But all these implementations are very similar and are based on the standard SQL specification. So most of the SQL code that you will learn in this course will work with any Database Management system. In this course, we'll be using MySQL, which is the most popular open source Database in the world. 

Alright, Now, What about Non-relational databases? In Non-relational databases, we don't have tables or relationships. These databases are very different from Relational databases, but that's a topic for an entirely different course. What you need to know is that Non-relational Database Management Systems don't understand SQL. They have their own query language. So we use SQL to work with Relational Database Management Systems. 

Now, before we jump in and install MySQL, let me clarify something quickly. As you talk to different people, you will hear two different pronunciations of SQL, SQL or Sequel. What is the correct way? Well, it depends on who you ask. And of course, everybody thinks their way of pronouncing this word is the right way. But here's a little history about this language. 
SQL was originally developed at IBM in the 70s, and back then it was initially called SeQuEL, short for Structured English Query Language. But they changed the acronym to SQL because Sequel was the trademark of an airplane company. So to this date, there's been an argument about what is the right way to pronounce this language. Generally speaking, people in non-English speaking countries call it SQL. I'm used to calling it SQL because it's shorter and sweeter than SQL. But if you prefer to call it SQL, that's totally fine with me. I'm not going to get mad at you. So that's the history behind this language. But what about MySQL as a software product? Developers of this product prefer to call it MySQL rather than MySQL, but they don't mind if we call it MySQL. 
In this course, I'll be teaching you SQL with MySQL.
 
 
 
 
What is SQL:
------------

🚀 Introduction to Databases:
A database is a structured collection of data that allows for easy access, management, and modification. To interact with databases, we use Database Management Systems (DBMS), which handle storing, retrieving, updating, and deleting data efficiently.




📌 Types of Database Management Systems:
1. Relational Databases (SQL-Based)
✔ Data is stored in tables that are linked using relationships. 
✔ Each table represents a specific entity (e.g., customers, orders, products). 
✔ SQL (Structured Query Language) is used to query and modify data. 
✔ Examples of Relational Database Management Systems (RDBMS):
MySQL (Open-source, widely used)
Microsoft SQL Server
PostgreSQL
Oracle Database
SQLite

📌 Example SQL Query to Retrieve Data:
sql
SELECT * 
FROM products 
WHERE category = 'food' 
ORDER BY price;

🚀 Effect: ✔ Retrieves all food products, ordered by price.




2. Non-Relational Databases (NoSQL)
✔ Data is stored in flexible formats such as key-value pairs, documents, graphs, or columns. 
✔ Does not use SQL—each system has its own query language. 
✔ Ideal for handling large, unstructured, or rapidly changing data. 
✔ Examples of NoSQL Databases:
MongoDB (Document-based)
Redis (Key-value store)
Cassandra (Column-based)
Neo4j (Graph-based)

🚀 Effect: ✔ NoSQL databases offer flexibility, making them suitable for big data, real-time analytics, and large-scale applications.




📌 Understanding SQL vs NoSQL
Feature	SQL         (Relational)	                     NoSQL (Non-Relational)
Data Structure	    Tables (rows & columns)	             Flexible (JSON, key-value, graphs)
Relationships	    Uses Foreign Keys	                 No predefined relationships
Scalability	        Vertical (powerful server)	         Horizontal (distributed servers)
Query Language	    SQL	                                 NoSQL-specific syntax
Examples	        MySQL, PostgreSQL, SQL Server	     MongoDB, Redis, Cassandra

🚀 Effect: ✔ SQL is structured, best for transactions; NoSQL is flexible, ideal for handling large-scale dynamic data.





📌 History & Pronunciation of SQL
✔ Originally called "SeQuEL" (Structured English Query Language). 
✔ The name was changed to SQL after legal issues with an airplane company. 
✔ Pronounced both "SQL" and "Sequel"—preferences vary globally.

🚀 Effect: ✔ Both pronunciations are widely accepted, though MySQL developers prefer "MySQL" over "MySequel."




📌 Why MySQL?
✔ MySQL is the most popular open-source database. 
✔ Used by Facebook, Twitter, YouTube, and countless websites. 
✔ Lightweight, fast, and reliable for handling structured data.

🚀 Effect: ✔ In this course, we'll use MySQL to learn SQL and database management.




📌 Visual Representation of Database Structure
Relational Database Example (SQL)

┌──────────┬───────────┬───────────────┐
│ Customer │ Product   │ Order         │
├──────────┼───────────┼───────────────┤
│ ID       │ ID        │ ID            │
│ Name     │ Name      │ Customer_ID   │
│ Email    │ Category  │ Product_ID    │
│ Phone    │ Price     │ Quantity      │
└──────────┴───────────┴───────────────┘
🚀 Effect: ✔ Each table stores specific information, linked together using Foreign Keys.




📌 Summary
✔ Databases store and manage structured/unstructured data. 
✔ RDBMS (SQL) uses tables & relationships; NoSQL offers flexible storage formats. 
✔ SQL is widely used; NoSQL is best for scalability & flexibility. 
✔ MySQL is the most popular open-source RDBMS, ideal for learning SQL. 
✔ Both "SQL" and "Sequel" are acceptable pronunciations. 














🚀 Installing MySQL on Mac & Windows:
-------------------------------------
This guide provides step-by-step instructions for installing MySQL on both Mac and Windows, setting up MySQL Workbench, and creating a connection to the MySQL database server.

📌 Installing MySQL on Mac
1. Download MySQL
✔ Open your browser and go to MySQL Downloads. 
✔ Scroll down and click on MySQL Community Edition (free version). 
✔ Click MySQL Community Server → Select MacOS DMG Archive. 
✔ Click on "No thanks, just start my download" to download the file.



2. Install MySQL
✔ Open the downloaded .dmg file. 
✔ Double-click the package and follow the installation wizard:
Accept the license agreement.
Enter your Mac password (system login password).
Set a password for the MySQL root user. ✔ Click Finish, and MySQL is now installed.



3. Install MySQL Workbench
✔ Go to MySQL Community Edition → Find MySQL Workbench. 
✔ Download the MacOS DMG Archive version. 
✔ Open the .dmg file and drag MySQL Workbench into Applications.

🚀 Effect: ✔ You now have MySQL and MySQL Workbench installed!




📌 Setting Up MySQL Workbench on Mac:
1. Open MySQL Workbench
✔ Press Command + Space → Search MySQL Workbench → Open it. 
✔ If prompted, click "Open" to confirm security settings.



2. Create a Connection
✔ If a default connection is available, use it. 
✔ Otherwise, click on the + (plus) icon to create a new connection.

✔ Fill in the following details:
Connection Name: Local Instance
Method: TCP/IP
Host: 127.0.0.1 (Local Machine)
Port: 3306 (Default MySQL Port)
Username: root

✔ Click "Store in Keychain" → Enter the root password set during installation. 
✔ Click Test Connection → Should show "Successful Connection".

🚀 Effect: ✔ MySQL Workbench is now connected to your database server.




📌 Installing MySQL on Windows
1. Download MySQL
✔ Open MySQL Downloads → Select MySQL Community Edition. 
✔ Click MySQL Community Server → Download MySQL Installer for Windows. 
✔ Click on "No thanks, just start my download" to download the installer.



2. Install MySQL
✔ Open the MySQL Installer file. 
✔ Select Developer Default Setup and click Next. 
✔ Follow the installation wizard and click Next:
If prompted, ignore the Python 3.7 warning (not required for MySQL). 
✔ Click Execute → Wait for installation (5-10 minutes). 
✔ Click Next until prompted to set a password for the root user. 
✔ Enter a secure password and proceed. 
✔ Click Finish, and MySQL is installed!




3. Install MySQL Workbench
✔ After installing MySQL Server, MySQL Workbench should be installed automatically. 
✔ Open MySQL Workbench → Create a new connection (similar to Mac setup):
Connection Name: Local Instance
Host: 127.0.0.1
Port: 3306
Username: root
✔ Store the root password, test the connection, and click OK.

🚀 Effect: ✔ You have now successfully installed MySQL on Windows.

📌 Exploring MySQL Workbench
✔ The navigator panel (left) lists all databases. 
✔ The query editor (middle) is where we write SQL queries. 
✔ The right panel contains snippets and SQL history.

🚀 Effect: ✔ You can now start writing SQL queries and managing databases!




📌 Summary
✔ Installed MySQL on Mac & Windows. 
✔ Set up MySQL Workbench to connect to the database server. 
✔ Created a local connection to MySQL. 
✔ Next steps: Creating databases and executing SQL queries!
















🚀 Creating Databases in MySQL Workbench:
-----------------------------------------
In this guide, we will: 
✔ Set up databases using MySQL Workbench. 
✔ Understand MySQL Workbench's interface and navigation. 
✔ Execute SQL scripts to create multiple databases. 
✔ Explore tables, views, relationships, and stored procedures.



📌 Understanding MySQL Workbench Interface
1. Interface Overview:
✔ Toolbar (Top): Buttons for writing SQL, creating databases/tables. 
✔ Navigator Panel (Left):
Administration Tab: Server management (start/stop, import/export).
Schemas Tab: Shows available databases. ✔ Query Editor (Middle): Where we write SQL queries. ✔ Context Help & Snippets Panel (Right): Provides SQL references.


2. Cleaning Up the Interface:
✔ Hide right-side snippets panel and bottom output panel for clarity.
🚀 Effect: ✔ A clean workspace for writing SQL queries efficiently.

📌 Executing the Database Setup Script
1. Download the SQL Script
✔ Locate and open create-databases.sql in MySQL Workbench.

2. Running the Script
✔ Click the yellow thunder icon to execute the SQL code. 
✔ If a single command needs execution, highlight it before clicking the thunder icon. 
✔ Verify execution in the output window.

3. Refreshing the Database View
✔ Click Refresh in the Schemas tab to see the newly created databases.
🚀 Effect: ✔ All databases are created successfully!

📌 Understanding Relational Databases
A relational database stores information in multiple related tables using Foreign Key relationships.

Example Database Structure (sql_store)
┌──────────┬──────────┬───────────────┐
│Customers │ Orders   │ Products      │
├──────────┼──────────┼───────────────┤
│ ID       │ ID       │ ID            │
│ Name     │ Customer │ Name          │
│ Phone    │ OrderDate│ Price         │
│ Address  │ Status   │ Stock         │
└──────────┴──────────┴───────────────┘
🚀 Effect: ✔ Data is stored across multiple related tables, ensuring efficient storage.




📌 Exploring Tables & Relationships:
1. Viewing Customer Data
✔ Open sql_store > Customers and click table lightning icon to see records. 
✔ Example Customer Data:
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ Name      │ Phone Number  │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John Doe  │ 123-456-7890  │ New York  │
│ 2          │ Alice     │ 987-654-3210  │ London    │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Each row represents a customer, storing all relevant details.


2. Understanding Foreign Key Relationships
✔ Open Orders table—notice CustomerID as a Foreign Key:

┌─────────┬───────────┬──────────────┐
│ OrderID │ CustomerID│ Order Date   │
├─────────┼───────────┼──────────────┤
│ 101     │ 1         │ 2025-04-01   │
│ 102     │ 2         │ 2025-04-05   │
└─────────┴───────────┴──────────────┘
🚀 Effect: ✔ Orders are linked to customers using Foreign Keys, ensuring data integrity.




📌 Benefits of Relational Databases:
✔ Avoids redundant data (Customer details stored once, referenced in Orders). 
✔ Prevents inconsistencies (Updating customer details in one place). 
✔ Efficient queries (Retrieve customer orders efficiently using JOIN).

🚀 Effect: ✔ Ensures data accuracy, consistency, and optimized storage.



📌 Summary
✔ Installed MySQL on Mac & Windows. 
✔ Set up MySQL Workbench and executed SQL scripts. 
✔ Created databases with multiple relational tables. 
✔ Explored data structure, relationships, and foreign keys. 
✔ Next steps: Running SQL queries to retrieve data efficiently!










🚀 Course Overview: What You'll Learn in SQL:
---------------------------------------------
This course is designed to teach you everything you need to know about SQL, covering essential database operations, advanced querying techniques, and performance optimization.

📌 Course Breakdown:
1. SQL Fundamentals
✔ Learn how to retrieve, insert, update, and delete data from a database. 
✔ Understand SQL syntax and structure applicable to any database management system (MySQL, PostgreSQL, SQL Server, Oracle).
🚀 Effect: ✔ These skills allow you to work with any relational database, making you a versatile SQL professional.


2. Summarizing & Reporting Data
✔ Aggregate functions for data analysis (SUM, AVG, COUNT). 
✔ Learn to write complex queries using subqueries for deeper insights. 
✔ Work with dates, numbers, and textual data using built-in SQL functions.
🚀 Effect: ✔ Master data summarization, enabling report generation and business analysis.


3. Optimizing Queries Using Views & Stored Procedures
✔ Views: Create reusable virtual tables to simplify complex queries. 
✔ Stored Procedures & Functions: Store and reuse SQL queries to increase productivity.
🚀 Effect: ✔ Avoid repetitive queries, enhancing efficiency in database operations.


4. Advanced Topics: Triggers, Events & Transactions
✔ Triggers: Automate actions based on database changes (e.g., logging updates). 
✔ Scheduled Events: Perform automated tasks at specific times. 
✔ Transactions & Concurrency: Manage database updates safely to prevent inconsistencies.
🚀 Effect: ✔ Implement real-world database automation and consistency mechanisms.


5. Database Design
✔ Learn how to design scalable databases. 
✔ Follow a systematic approach for creating optimized database structures.
🚀 Effect: ✔ Develop efficient, high-performance databases used in real-world applications.


6. Indexing for High Performance
✔ Understand how indexes work. 
✔ Learn to speed up queries when handling millions or billions of records.
🚀 Effect: ✔ Optimize database performance by reducing query execution time.


7. Securing Databases
✔ User accounts & privileges: Control access to sensitive data. 
✔ Prevent unauthorized modifications and secure database transactions.
🚀 Effect: ✔ Protect databases from misuse and ensure data integrity.


📌 Course Benefits
✔ Master SQL for job interviews and real-world projects. 
✔ Gain transferable database management skills across multiple platforms. 
✔ Build high-performance databases and optimize data processing. ✔ Ensure security and reliability in large-scale applications.

🚀 Next steps: Start learning SQL and practice each concept with hands-on exercises!











Retrieving Data From a Single Table: 
------------------------------------

The SELECT Statement: 
---------------------
🚀 Understanding the SELECT Statement in SQL:
In this tutorial, we will: 
✔ Learn how to retrieve data from a single table using SQL's SELECT statement.
✔ Understand how to filter (WHERE clause) and sort (ORDER BY clause) data. 
✔ Explore SQL syntax rules and best practices.

📌 1. Selecting a Database for Querying
Before executing SQL queries, we must select the database we want to query.

📌 Syntax:

USE sql_store;

🚀 Effect: ✔ The sql_store database is now the active database for our queries.




📌 2. Retrieving All Data From a Table:

📌 Syntax to retrieve all records from customers table:

SELECT * 
FROM customers;

🚀 Effect: ✔ Fetches all columns and rows from the customers table.

📌 Table Structure Example (customers):
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John      │ Doe           │ NY, USA   │
│ 2          │ Alice     │ Johnson       │ London, UK│
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Returns all customers stored in the database.




📌 3. Filtering Data Using the WHERE Clause

📌 Retrieve a specific customer by ID:

SELECT * 
FROM customers
WHERE customer_id = 1;

🚀 Effect: ✔ Returns only the customer whose customer_id = 1.

📌 Example Output:
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 1          │ John      │ Doe           │ NY, USA   │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ Filters only relevant data instead of retrieving everything.




📌 4. Sorting Data Using the ORDER BY Clause
📌 Sort customers by first name:

SELECT * 
FROM customers
ORDER BY first_name;

🚀 Effect: ✔ Customers are sorted alphabetically based on the first_name column.

📌 Example Output (Sorted by First Name):
┌────────────┬───────────┬───────────────┬───────────┐
│ CustomerID │ FirstName │ LastName      │ Address   │
├────────────┼───────────┼───────────────┼───────────┤
│ 3          │ Alice     │ Johnson       │ London, UK│
│ 1          │ John      │ Doe           │ NY, USA   │
└────────────┴───────────┴───────────────┴───────────┘
🚀 Effect: ✔ The result is ordered based on first names.


📌 Sorting in Descending Order:

SELECT * FROM customers ORDER BY first_name DESC;

🚀 Effect: ✔ Sorts results in reverse (Z-A) order.




📌 5. Commenting Out SQL Code (--):
✔ Use -- to disable a line of SQL code without deleting it.

📌 Example (Commenting Out WHERE Clause):

SELECT * 
FROM customers
-- WHERE customer_id = 1
ORDER BY first_name;

🚀 Effect: ✔ The query executes without filtering, showing all customers. ✔ Useful for temporary testing/debugging.




📌 6. Selecting Custom Values (Without a Table):
📌 Retrieving static values:

SELECT 1, 2;

🚀 Effect: ✔ Returns two columns named 1 and 2, each containing static values.

📌 Example Output:
┌───┬───┐
│ 1 │ 2 │
├───┼───┤
│ 1 │ 2 │
└───┴───┘

🚀 Effect: ✔ Used for testing query execution without fetching from a table.




📌 7. SQL Syntax Rules & Best Practices:
✔ SQL is not case-sensitive, but use uppercase for keywords (SELECT, WHERE). 
✔ Terminate statements with a semicolon (;) for clarity. 
✔ Place each clause on a new line to improve readability:

SELECT * 
FROM customers
WHERE customer_id = 1
ORDER BY first_name;

🚀 Effect: ✔ Clear and structured queries for easier debugging.




📌 8. Understanding Clause Order in SQL
✔ The order of SQL clauses must follow a strict sequence:

SELECT → FROM → WHERE → ORDER BY

🚀 Effect: ✔ Ensures queries are properly structured to avoid errors.

📌 Example of Incorrect Clause Order (Throws Syntax Error):

sql
FROM customers 
SELECT *;

🚀 Effect: ✔ This will fail because SELECT must come before FROM.





Queries used in this lesson: 
Use sql_store;

SELECT * 
FROM customers;


SELECT * 
FROM customers
WHERE customer_id = 1;

SELECT * 
FROM customers
-- WHERE customer_id = 1
ORDER BY first_name;


SELECT 1, 2
-- FROM customers
-- WHERE customer_id = 1
-- ORDER BY first_name;


SELECT * FROM customers WHERE customer_id = 1 ORDER BY first_name;




📌 Summary
✔ SELECT retrieves data from a database table. 
✔ WHERE filters records based on conditions. 
✔ ORDER BY sorts results alphabetically or numerically. 
✔ SQL queries must follow a specific order (SELECT → FROM → WHERE → ORDER BY). 
✔ Next steps: Exploring the SELECT clause in more detail.

🚀 Master these SQL basics to retrieve, filter, and sort data effectively!














The SELECT Clause: 
------------------

🚀 Understanding the SELECT Clause in SQL
The SELECT clause is one of the most fundamental parts of SQL, used for retrieving data from a table. This tutorial explores how to use it efficiently, apply arithmetic operations, use aliases, and remove duplicate values.

📌 1. Retrieving Specific Columns vs. All Columns:
✔ The simplest way to retrieve all data from a table is using an asterisk (*):

SELECT * 
FROM customers;
🚀 Effect: ✔ Returns all columns in the customers table.

📌 Retrieving Specific Columns ✔ Instead of fetching all data, we can select only the necessary columns:
SELECT first_name, last_name 
FROM customers;
🚀 Effect: ✔ Displays only the first_name and last_name columns, reducing load on the database.

📌 Changing Column Order ✔ Columns can be retrieved in any order:
SELECT last_name, first_name 
FROM customers;
🚀 Effect: ✔ The order of columns in the output matches the order of selection.




📌 2. Using Arithmetic Expressions in Queries:
✔ SQL allows performing mathematical operations directly in queries.
📌 Example: Modifying Points Based on Customer Shopping
SELECT last_name, first_name, points + 10 
FROM customers;
🚀 Effect: ✔ Adds 10 to each customer's points, useful for calculating discounts.

📌 Complex Arithmetic Expression ✔ SQL supports multiple operators (+, -, *, /, %):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100
FROM customers;

🚀 Effect: ✔ Multiplies points by 10, then adds 100 for a new discount calculation.




📌 3. Understanding Operator Precedence in SQL
✔ Just like in math, multiplication (*) and division (/) are processed before addition (+) and subtraction (-).

📌 Example Without Parentheses:
SELECT 
    last_name,
    first_name, 
    points + 10 * 100
FROM customers;

🚀 Effect: ✔ First multiplies 10 * 100, then adds the result to points. ✔ If this is not what we want, use parentheses.

📌 Example With Parentheses (Changing the Order)

SELECT 
    last_name,
    first_name, 
    (points + 10) * 100 AS discount_factor
FROM customers;

🚀 Effect: ✔ First adds 10 to points, then multiplies the result by 100.

📌 Visualization of Operator Precedence:
Without Parentheses:   points + (10 * 100)
With Parentheses:     (points + 10) * 100
🚀 Effect: ✔ Parentheses ensure clarity and correct execution of calculations.




📌 4. Using Aliases (AS) to Rename Columns
✔ Column names in SQL output are based on expressions used in queries. ✔ We can make names more readable using AS.

📌 Assigning a Custom Name (Alias):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100 AS discount_factor
FROM customers;

🚀 Effect: ✔ Renames the calculated column for better readability.

📌 Adding Spaces in Aliases (Using Quotes):
SELECT 
    last_name,
    first_name, 
    points * 10 + 100 AS 'Discount Factor'
FROM customers;

🚀 Effect: ✔ If column names require spaces, use single or double quotes.




📌 5. Removing Duplicate Values Using DISTINCT
✔ The DISTINCT keyword removes duplicate entries from the result set.

📌 Example: Get Unique States from customers Table
SELECT DISTINCT state 
FROM customers;
🚀 Effect: ✔ Retrieves only unique states, eliminating duplicate entries.

📌 Why Use DISTINCT? ✔ Prevents redundancy when analyzing categorical data (e.g., unique cities, job titles).




📌 6. SQL Exercise: Product Price Calculation
🚀 Task: 
✔ Retrieve product names and prices. 
✔ Apply a 10% price increase. 
✔ Use an alias (new_price) for better clarity.

📌 Expected Query Solution:
SELECT name, unit_price, unit_price * 1.1 AS new_price 
FROM products;
🚀 Effect: ✔ The result includes:

┌───────────┬───────────┬───────────┐
│ Name      │ UnitPrice │ NewPrice  │
├───────────┼───────────┼───────────┤
│ Lettuce   │ 3.35      │ 3.69      │
│ Broccoli  │ 4.53      │ 4.98      │
└───────────┴───────────┴───────────┘
✔ New price is calculated using unit_price * 1.1.






Queries used in this lesson: 

SELECT first_name, last_name 
FROM customers;


SELECT last_name, first_name 
FROM customers;

SELECT last_name, first_name, points 
FROM customers;

SELECT last_name, first_name, points + 10 
FROM customers;

SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100
FROM customers;

SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100 AS discount_factor
FROM customers;


SELECT 
	last_name,
	first_name, 
	points + 10,
	points * 10 + 100 AS 'discount factor'
FROM customers;


SELECT DISTINCT state
FROM customers;


Exercise: 
-- Return all the products
-- name
-- unit price
-- new price (unit price * 1.1)


SELECT name, unit_price, unit_price * 1.1 AS new_price FROM products;





📌 Summary
✔ SELECT retrieves specific columns or all columns (*). 
✔ Arithmetic expressions allow calculations within queries. 
✔ Operator precedence determines the order of execution—use parentheses for clarity. 
✔ Aliases (AS) rename columns, improving readability. 
✔ DISTINCT removes duplicate values from results. 
✔ SQL syntax must follow structured ordering (SELECT → FROM → WHERE → ORDER BY).









The WHERE Clause: 
-----------------
🚀 Understanding the WHERE Clause in SQL:
The WHERE clause in SQL allows us to filter data based on conditions, ensuring we retrieve only relevant records. This tutorial covers comparison operators, filtering string, numeric, and date values, and an exercise to solidify understanding.

📌 1. Using the WHERE Clause to Filter Data:
Retrieve Customers With Points Greater Than 3000

SELECT * 
FROM Customers
WHERE points > 3000;

🚀 Effect: ✔ Filters records, returning only customers who have more than 3000 points.

📌 Example Output:
┌────────────┬───────────┬───────────┬─────────────┐
│ CustomerID │ Name      │ State     │ Points      │
├────────────┼───────────┼───────────┼─────────────┤
│ 5          │ Clemmie   │ TX        │ 3675        │
│ 6          │ Elka      │ IL        │ 3073        │
└────────────┴───────────┴───────────┴─────────────┘
✔ The query execution engine checks each customer, evaluates the condition, and returns matching records.




📌 2. Understanding Comparison Operators:
SQL provides several comparison operators for filtering data:

>, >=, <, <=, =, !=, <>

📌 Examples Using Comparison Operators 
✔ Retrieve customers born after January 1st, 1990:

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01';

✔ Retrieve customers from Virginia (VA):

SELECT * 
FROM Customers
WHERE state = 'VA';

✔ Retrieve customers NOT from Virginia (VA):

SELECT * 
FROM Customers
WHERE state != 'VA';

✔ Alternative syntax for NOT EQUAL (<>):

SELECT * 
FROM Customers
WHERE state <> 'VA';

🚀 Effect: ✔ All comparison operators work with numbers, text, and dates.




📌 3. Working With String Filtering
✔ Strings in SQL must be enclosed in quotes ('single' or "double"). 
✔ SQL is not case-sensitive, so both queries below return the same result:

SELECT * 
FROM Customers
WHERE state = 'VA';

SELECT * 
FROM Customers
WHERE state = 'va';

🚀 Effect: ✔ Retrieves all customers located in Virginia, regardless of uppercase/lowercase.




📌 4. Filtering Data Using Date Values
✔ SQL stores dates in the format YYYY-MM-DD. ✔ We can compare dates using comparison operators.

📌 Example Query: Customers Born After 1990:

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01';

🚀 Effect: ✔ Retrieves only customers born after January 1, 1990.

📌 Example Output
┌────────────┬───────────┬───────────┬─────────────┐
│ CustomerID │ Name      │ BirthDate │ Points      │
├────────────┼───────────┼───────────┼─────────────┤
│ 6          │ Elka      │ 1991-09-04│ 3073        │
│ 8          │ Thacher   │ 1993-07-17│ 205         │
│ 9          │ Romola    │ 1992-05-23│ 1486        │
└────────────┴───────────┴───────────┴─────────────┘
✔ Even though dates are not strings, we must enclose them in quotes ('YYYY-MM-DD') in SQL queries.




📌 5. Exercise: Retrieving Orders Placed in the Current Year
🚀 Task: ✔ Retrieve all orders placed in 2019 using the order_date column.

📌 Expected Query Solution:
SELECT * 
FROM orders
WHERE order_date >= '2019-01-01';
🚀 Effect: ✔ Returns all orders placed on or after January 1st, 2019.

📌 Example Output:
┌─────────┬───────────┬───────────────┬───────────┐
│ OrderID │ CustomerID│ OrderDate     │ Status    │
├─────────┼───────────┼───────────────┼───────────┤
│ 1       │ 6         │ 2019-01-30    │ Processed │
└─────────┴───────────┴───────────────┴───────────┘
✔ Currently, only one order matches the filter.

📌 Future Consideration 
✔ Since we manually set 2019, next year the query won't be accurate. 
✔ Later in the course, we will explore dynamic queries to get the current year automatically.





Queries used in this lesson: 

SELECT *
FROM Customers
WHERE points > 3000;


>, >=, <, <=, =, !=, <>


SELECT *
FROM Customers
WHERE state = 'VA';

SELECT *
FROM Customers
WHERE state = 'va';

SELECT *
FROM Customers
WHERE state != 'va';

SELECT *
FROM Customers
WHERE state <> 'va';

SELECT *
FROM Customers
WHERE birth_date > '1990-01-01';


Exercise:

-- Get the orders placed this year

SELECT *
FROM orders
WHERE order_date >= '2019-01-01';






📌 Summary:
✔ WHERE filters data based on conditions. 
✔ Comparison operators (>, <, >=, <=, =, !=, <>) allow precise data filtering. 
✔ Strings must be enclosed in quotes ('VA', 'New York'). 
✔ Dates follow the format YYYY-MM-DD and must be enclosed in quotes. 
✔ SQL is case-insensitive for string comparisons (VA = va). 
✔ Next steps: Learning how to combine multiple conditions using logical operators (AND, OR).











The AND, OR and NOT Operators:
------------------------------
Combining Conditions in SQL Using AND, OR, and NOT Operators:
In this tutorial, we will learn how to filter data using multiple conditions, understand operator precedence, and apply logical operators (AND, OR, NOT) in SQL queries.

📌 1. Using AND to Combine Conditions
The AND operator returns rows where all specified conditions are true.

📌 Example: Get Customers Born After 1990 & With More Than 1000 Points

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' AND points > 1000;

🚀 Effect: ✔ Retrieves only customers who satisfy both conditions.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ 1991-09-04│ 3675      │
│ 6         │ Elka      │ 1992-05-23│ 3073      │
└───────────┴───────────┴───────────┴───────────┘
✔ This query only returns customers who satisfy both conditions.




📌 2. Using OR for Flexible Filtering:
The OR operator returns rows where at least one condition is true.

📌 Example: Get Customers Born After 1990 OR With More Than 1000 Points

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000;

🚀 Effect: ✔ Expands the result set, returning customers who satisfy at least one condition.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 1986-04-13│  947      │ ❌ Older than 1990, Less than 1000 points
│ 5         │ Clemmie   │ 1991-09-04│ 3675      │ ✅ Born after 1990, More than 1000 points
│ 6         │ Elka      │ 1992-05-23│ 3073      │ ✅ Born after 1990, More than 1000 points
└───────────┴───────────┴───────────┴───────────┘
✔ Customers are retrieved if at least one condition matches.




📌 3. Combining AND & OR With Parentheses:
When combining multiple logical operators, order matters — use parentheses to control execution.

📌 Example: Customers Born After 1990 OR (Have 1000+ Points & Live in Virginia)

SELECT * 
FROM Customers
WHERE birth_date > '1990-01-01' OR 
      (points > 1000 AND state = 'VA');

🚀 Effect: ✔ Customers who were born after 1990 OR who live in Virginia AND have over 1000 points.

📌 Understanding Precedence 
✔ AND is evaluated first, then OR. 
✔ Parentheses override default precedence and group conditions.


📌 Correct Precedence Order:
1. (points > 1000 AND state = 'VA') → Evaluated first
2. birth_date > '1990-01-01' → Evaluated after OR condition
🚀 Effect: ✔ Ensures logical grouping and correct evaluation.




📌 4. Using NOT to Negate Conditions:
The NOT operator reverses a condition, excluding matching rows.

📌 Example: Get Customers NOT Born After 1990 OR Who Don't Have More Than 1000 Points

SELECT * 
FROM Customers
WHERE NOT (birth_date > '1990-01-01' OR points > 1000);

🚀 Effect: ✔ Retrieves customers born before 1990 & with 1000 or fewer points.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 1986-04-13│  947      │ ❌ Born Before 1990, Less than 1000 points
│ 4         │ Ambur     │ 1974-04-14│  457      │ ❌ Born Before 1990, Less than 1000 points
│ 10        │ Levy      │ 1969-10-13│  796      │ ❌ Born Before 1990, Less than 1000 points
└───────────┴───────────┴───────────┴───────────┘
✔ All results do not match the original condition.


📌 Simplifying NOT Expressions: 
✔ Instead of using NOT, we rewrite the condition using inverse operators:

SELECT * 
FROM Customers
WHERE birth_date <= '1990-01-01' AND points <= 1000;

🚀 Effect: ✔ Cleaner, easier-to-read query with same logical meaning.





📌 5. Exercise: Filtering Order Items
🚀 Task: ✔ Retrieve order items from order #6 where the total price (quantity × unit price) is greater than 30.

📌 Expected Query Solution

SELECT * 
FROM order_items
WHERE order_id = 6 AND unit_price * quantity > 30;
🚀 Effect: ✔ Retrieves only order items where total price exceeds $30.

📌 Understanding Condition: 
✔ We calculate total price using unit_price * quantity. 
✔ The result is filtered to exclude values ≤ 30.

📌 Example Output:
┌─────────┬───────────┬───────────────┬───────────┐
│ OrderID │ ProductID │ Quantity      │ UnitPrice │
├─────────┼───────────┼───────────────┼───────────┤
│ 6       │ 1         │  4            │  8.65     │ ✅ $34.60 (Matches Condition)
└─────────┴───────────┴───────────────┴───────────┘
✔ Only one product matches the criteria.






Queries used in this lesson: 
SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' AND points > 1000;


SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000;


SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR points > 1000 AND state = 'VA';


Order of precedence in Arithmetic Operations:
()
*/
+-

SELECT *
FROM Customers
WHERE birth_date > '1990-01-01' OR 
	 (points > 1000 AND state = 'VA');
	 
	 
SELECT *
FROM Customers
WHERE NOT (birth_date > '1990-01-01' OR points > 1000);	 

Simplifying the NOT like this: 
SELECT *
FROM Customers
WHERE (birth_date <= '1990-01-01' AND points <= 1000);	



Exercise: 
-- From the order_items table, get the items
--  for order #6
--  where the total price is greater than 30


SELECT *
FROM order_items
WHERE order_id = 6 AND unit_price  * quantity > 30; 





📌 Summary
✔ AND ensures both conditions must be true. 
✔ OR ensures at least one condition must be true. 
✔ Operator precedence (AND before OR) affects execution—use parentheses for clarity. 
✔ NOT reverses a condition to exclude matching rows. 
✔ Next steps: Learning how to filter data using IN, BETWEEN, and LIKE conditions.











The IN Operator:
----------------
🚀 Using the IN Operator in SQL:
The IN operator allows us to simplify multiple OR conditions, making SQL queries more concise and readable.


📌 1. Understanding the Need for the IN Operator:
Using OR for Filtering Multiple Values
📌 Example: Retrieve Customers Located in Virginia, Georgia, or Florida

SELECT * 
FROM Customers
WHERE state = 'VA' OR state = 'GA' OR state = 'FL';

🚀 Effect: ✔ Checks each row individually, leading to a long and repetitive query.

📌 Incorrect Syntax Attempt (What Doesn’t Work)

SELECT * 
FROM Customers
WHERE state = 'VA' OR 'GA' OR 'FL';  -- ❌ Incorrect syntax

🚀 Why Doesn't This Work? 
✔ SQL requires explicit conditions for each comparison. 
✔ Strings cannot be combined with boolean expressions.




📌 2. Simplifying with the IN Operator
Using IN for Cleaner Filtering

SELECT * 
FROM Customers
WHERE state IN ('VA', 'GA', 'FL');

🚀 Effect: ✔ Retrieves customers from Virginia, Georgia, or Florida. ✔ Shorter and easier to understand compared to using multiple OR conditions.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ VA        │
│ 2         │ Alice     │ GA        │
│ 5         │ Clemmie   │ FL        │
└───────────┴───────────┴───────────┘
🚀 Effect: ✔ Efficient data retrieval, avoiding redundant OR conditions.




📌 3. Using NOT IN to Exclude Values
📌 Retrieve Customers NOT in Virginia, Georgia, or Florida

SELECT * 
FROM Customers
WHERE state NOT IN ('VA', 'GA', 'FL');

🚀 Effect: ✔ Retrieves customers outside of these states (e.g., Texas, Colorado).

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ State     │
├───────────┼───────────┼───────────┤
│ 3         │ Elka      │ TX        │
│ 4         │ Ambur     │ CO        │
└───────────┴───────────┴───────────┘
🚀 Effect: ✔ Filters out unwanted values efficiently.




📌 4. Exercise: Filtering Products Based on Quantity in Stock
🚀 Task: ✔ Retrieve products where quantity_in_stock is 49, 38, or 72.

📌 Expected Query Solution
SELECT * 
FROM products
WHERE quantity_in_stock IN (49, 38, 72);

🚀 Effect: ✔ Filters only products matching the specified stock quantities.

📌 Example Output:
┌───────────┬───────────┬───────────────┐
│ ProductID │ Name      │ QuantityStock │
├───────────┼───────────┼───────────────┤
│ 2         │ Bacon     │ 49            │
│ 3         │ Lettuce   │ 38            │
└───────────┴───────────┴───────────────┘
✔ Since no product has quantity_in_stock = 72, only two records match.









Queries used in this lesson: 
SELECT *
FROM Customers
WHERE state = 'VA' OR state = 'GA' OR state = 'FL';

SELECT *
FROM Customers
WHERE state = 'VA' OR 'GA' OR 'FL';

SELECT *
FROM Customers
WHERE state IN ('VA', 'GA', 'FL');

SELECT *
FROM Customers
WHERE state NOT IN ('VA', 'GA', 'FL');


Exercise: 

-- Return products with 
--     quantity in stock equal to 49, 38, 72


SELECT * 
FROM products
WHERE quantity_in_stock IN (49, 38, 72);





📌 Summary
✔ IN replaces multiple OR conditions, making queries cleaner. 
✔ NOT IN excludes specific values, filtering out unwanted data. 
✔ SQL requires explicit comparisons (OR for multiple conditions vs IN for lists). 
✔ Next steps: Learning BETWEEN for range filtering.











The BETWEEN Operator: 
---------------------

🚀 Understanding the BETWEEN Operator in SQL:
The BETWEEN operator simplifies range-based filtering, making SQL queries more efficient and readable.

📌 1. Filtering Data Using BETWEEN:
Using Comparison Operators to Retrieve Customers With Points Between 1000 and 3000

SELECT * 
FROM customers
WHERE points >= 1000 AND points <= 3000;

🚀 Effect: ✔ Retrieves customers whose points fall within the range of 1000 to 3000.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Points    │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 3         │ Freddi    │ 2967      │ CO        │
│ 6         │ Elka      │ 3073      │ IL        │
└───────────┴───────────┴───────────┴───────────┘
✔ The query execution engine evaluates each row, returning matching records.




📌 2. Simplifying Queries Using the BETWEEN Operator
✔ Instead of using multiple comparison operators (>=, <=), BETWEEN provides a cleaner syntax.

📌 Equivalent Query Using BETWEEN:

SELECT * 
FROM customers
WHERE points BETWEEN 1000 AND 3000;

🚀 Effect: ✔ The result is identical to using >= and <=, but the query is shorter and more readable.

📌 Understanding BETWEEN Behavior 

✔ BETWEEN includes boundary values, meaning:

BETWEEN 1000 AND 3000 → Equivalent to ≥ 1000 AND ≤ 3000
🚀 Effect: ✔ Both the lower (1000) and upper (3000) limits are included.





📌 3. Using BETWEEN With Date Values
✔ The BETWEEN operator works with both numbers and dates.

📌 Example: Retrieve Customers Born Between 1990 and 2000:

SELECT * 
FROM customers
WHERE birth_date BETWEEN '1990-01-01' AND '2000-01-01';

🚀 Effect: ✔ Retrieves customers born in the date range, including January 1, 1990 and January 1, 2000.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ BirthDate │ Points    │
├───────────┼───────────┼───────────┼───────────┤
│ 6         │ Elka      │ 1991-09-04│ 3073      │
│ 8         │ Thacher   │ 1993-07-17│ 205       │
│ 9         │ Romola    │ 1992-05-23│ 1486      │
└───────────┴───────────┴───────────┴───────────┘
✔ Since dates are not strings, they still need to be enclosed in quotes ('YYYY-MM-DD').

📌 Breaking Down SQL Date Formatting

'YYYY-MM-DD' → Standard SQL Date Format
'1990-01-01' → January 1, 1990
'2000-01-01' → January 1, 2000

🚀 Effect: ✔ BETWEEN handles date filtering efficiently, avoiding multiple conditions.




Queries used in this lesson: 
SELECT  * 
FROM customers
WHERE points >= 1000 AND points <= 3000;

SELECT  * 
FROM customers
WHERE points BETWEEN 1000 AND 3000;


Exercise:

--Return customers born 
			between 1/1/1990 and 1/1/2000
			
			
SELECT *
FROM customers
WHERE birth_date BETWEEN '1990-01-01' AND '2000-01-01'; 




📌 Summary
✔ BETWEEN simplifies range filtering, replacing multiple comparison operators (>=, <=). 
✔ Works with both numbers and dates, ensuring clean queries. 
✔ BETWEEN is inclusive, meaning both lower and upper values are included. 
✔ SQL date format follows 'YYYY-MM-DD', ensuring consistency. 
✔ Next steps: Learning how to filter textual data using the LIKE operator.












The LIKE Operator:
------------------
🚀 Understanding the LIKE Operator in SQL:
The LIKE operator allows us to filter textual data based on patterns, enabling flexible searching in SQL queries.

📌 1. Using LIKE for Pattern Matching
Example: Retrieve Customers Whose Last Name Starts With "B":

SELECT * 
FROM customers
WHERE last_name LIKE 'b%';

🚀 Effect: ✔ Returns customers whose last name begins with "B", regardless of the number of following characters. ✔ Not case-sensitive—"B" matches both uppercase and lowercase.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ LastName  │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ Barbara   │ Banks     │ VA        │
│ 3         │ Freddi    │ Boagey    │ CO        │
│ 5         │ Clemmie   │ Betchley  │ FL        │
└───────────┴───────────┴───────────┴───────────┘
🚀 Effect: ✔ Matches all last names beginning with "B".




📌 2. Using Wildcards for Flexible Searching:
Wildcard Characters:
Wildcard	Function
%	        Matches any number of characters (including none)
_	        Matches exactly one character

📌 Example Queries: 
✔ Retrieve last names that start with "Brush":
SELECT * 
FROM customers
WHERE last_name LIKE 'brush%';

✔ Retrieve last names that contain "B" anywhere:
SELECT * 
FROM customers
WHERE last_name LIKE '%b%';

✔ Retrieve last names ending with "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '%y';
🚀 Effect: ✔ % ensures matches can be anywhere in the string.




📌 3. Using _ (Underscore) for Exact Character Matching

✔ Match last names that are exactly two characters long, ending with "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '_y';
🚀 Effect: ✔ Matches one-character last names followed by "Y" (if any exist).

✔ Match last names with exactly five characters before "Y":
SELECT * 
FROM customers
WHERE last_name LIKE '_____y';
🚀 Effect: ✔ Retrieves last names with exactly six characters, ending with "Y".

✔ Match last names starting with "B" and having exactly four more characters before "Y":
SELECT * 
FROM customers
WHERE last_name LIKE 'b____y';
🚀 Effect: ✔ Returns specific patterns with strict character matching.




📌 4. Using LIKE With NOT for Excluding Patterns:
✔ Retrieve customers whose phone numbers DO NOT end with "9":

SELECT * 
FROM customers
WHERE phone NOT LIKE '%9';
🚀 Effect: ✔ Matches all phone numbers except those ending in "9".




📌 5. Exercise: Filtering Customers Based on Address & Phone Number
🚀 Task: 
✔ Retrieve customers whose addresses contain "Trail" or "Avenue". 
✔ Retrieve customers whose phone numbers end with "9".

📌 Expected Query Solution

SELECT * 
FROM customers
WHERE address LIKE '%trail%' OR
      address LIKE '%avenue%';
🚀 Effect: ✔ Filters addresses containing "Trail" or "Avenue", regardless of location.

📌 Example Output:                  
┌───────────┬───────────┬───────────────────────┬──────────────┐
│ CustomerID│ Name      │ Address               │ Phone        │
├───────────┼───────────┼───────────────────────┼──────────────┤
│ 2         │ Ines      │ 14187 Commercial Trail│ 804-427-9456 │
│ 9         │ Romola    │ 3520 Ohio Trail       │ 559-181-3744 │
│ 10        │ Levy      │ 68 Lawn Avenue        │ 404-246-3370 │
└───────────┴───────────┴───────────────────────┴──────────────┘
🚀 Effect: ✔ Matches all relevant addresses.

📌 Query to Retrieve Phone Numbers Ending With "9"

SELECT * 
FROM customers
WHERE phone LIKE '%9';
🚀 Effect: ✔ Filters customers whose phone numbers end with "9".






Queries used in this discussion:
SELECT * 
FROM customers
WHERE last_name LIKE 'b%';

SELECT * 
FROM customers
WHERE last_name LIKE 'brush%';

SELECT * 
FROM customers
WHERE last_name LIKE '%b%';

SELECT * 
FROM customers
WHERE last_name LIKE '%y';

SELECT * 
FROM customers
WHERE last_name LIKE '_y';

SELECT * 
FROM customers
WHERE last_name LIKE '_____y';

SELECT * 
FROM customers
WHERE last_name LIKE 'b____y';


Exercise: 
-- Get the customers whose 
-- 	  addresses contain TRAIL or AVENUE
--    phone numbers end with 9

Solution: 
SELECT * 
FROM customers
WHERE address LIKE '%trail%' OR
	  address LIKE '%avenue%';
	  

SELECT * 
FROM customers
WHERE phone LIKE '%9';

SELECT * 
FROM customers
WHERE phone NOT LIKE '%9';
	  




📌 Summary
✔ LIKE filters string patterns using % and _. 
✔ % matches any number of characters, while _ matches exactly one character. 
✔ NOT LIKE excludes specific patterns from results. 
✔ SQL is case-insensitive, making searches flexible. 
✔ Next steps: Learning how to filter data efficiently using REGEXP for advanced text matching.
















The REGEXP Operator: 
--------------------

🚀 Using the REGEXP Operator in SQL:
The REGEXP operator allows for advanced text pattern matching in SQL, making searches more flexible and powerful than the LIKE operator.

📌 1. Understanding Basic REGEXP Usage:
Using LIKE vs. REGEXP
📌 Using LIKE to Find Customers With "Field" in Last Name

SELECT * 
FROM customers
WHERE last_name LIKE '%field%';

📌 Using REGEXP for the Same Query

SELECT * 
FROM customers
WHERE last_name REGEXP 'field';

🚀 Effect: ✔ The results are identical, but REGEXP allows more advanced pattern matching.




📌 2. Special Characters in REGEXP
Caret (^): Matches the Beginning of a String
✔ Find customers whose last name starts with "Field":

SELECT * 
FROM customers
WHERE last_name REGEXP '^field';

🚀 Effect: ✔ Retrieves records only where "Field" appears at the beginning.

Dollar Sign ($): Matches the End of a String
✔ Find customers whose last name ends with "Field":

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$';
🚀 Effect: ✔ Matches records where "Field" appears at the end.

Pipe (|): OR Condition for Multiple Patterns
✔ Find customers whose last name contains "Field", "Mac", or "Rose":

SELECT * 
FROM customers
WHERE last_name REGEXP 'field|mac|rose';
🚀 Effect: ✔ Retrieves records matching any of the given patterns.

Combining Special Characters
✔ Find customers whose last name starts with "Field" OR contains "Mac" OR "Rose":

SELECT * 
FROM customers
WHERE last_name REGEXP '^field|mac|rose';
🚀 Effect: ✔ Ensures "Field" must be at the beginning, while "Mac" or "Rose" can be anywhere.




📌 3. Using Square Brackets [ ] for Character Matching
✔ Find customers whose last name contains "E", preceded by G, I, or M:

SELECT * 
FROM customers
WHERE last_name REGEXP '[gim]e';
🚀 Effect: ✔ Ensures "E" is preceded by either "G", "I", or "M".

✔ Find customers whose last name contains "E", followed by F, M, or Q:

SELECT * 
FROM customers
WHERE last_name REGEXP 'e[fmq]';
🚀 Effect: ✔ Ensures "E" is followed by "F", "M", or "Q".




📌 4. Using Ranges in Character Matching
✔ Find customers whose last name contains "E", preceded by any letter from A to H:

SELECT * 
FROM customers
WHERE last_name REGEXP '[a-h]e';
🚀 Effect: ✔ Searches for a last name containing "E", preceded by letters A-H.




📌 5. Exercise: Using REGEXP for Advanced Searches
🚀 Task: ✔ Retrieve customers based on the following conditions: 
1.First names should be Elka or Ambur. 
2.Last names should end with "EY" or "ON". 
3.Last names should start with "MY" or contain "SE". 
4.Last names should contain "B" followed by "R" or "U".

📌 Expected Query Solutions:

SELECT * 
FROM customers
WHERE first_name REGEXP 'elka|ambur';
🚀 Effect: ✔ Matches Elka and Ambur.


SELECT * 
FROM customers
WHERE last_name REGEXP 'ey$|on$';
🚀 Effect: ✔ Retrieves last names ending with "EY" or "ON".


SELECT * 
FROM customers
WHERE last_name REGEXP '^my|se';
🚀 Effect: ✔ Retrieves last names starting with "MY" or containing "SE".


SELECT * 
FROM customers
WHERE last_name REGEXP 'b[ru]';
🚀 Effect: ✔ Ensures "B" is followed by "R" or "U".

✔ Alternative query using OR condition:


SELECT * 
FROM customers
WHERE last_name REGEXP 'br|bu';
🚀 Effect: ✔ Matches exact phrases "BR" or "BU" following "B".





Queries in this lesson: 

SELECT * 
FROM customers
WHERE last_name REGEXP 'field'

SELECT * 
FROM customers
WHERE last_name REGEXP '^field'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field|mac|rose'

SELECT * 
FROM customers
WHERE last_name REGEXP 'field$|mac|rose'

SELECT * 
FROM customers
WHERE last_name REGEXP '[gim]e'

SELECT * 
FROM customers
WHERE last_name REGEXP '[a-h]e';


Exercise: 

-- Get the customers whose
-- 	 first names are ELKA or AMBUR
--   last names end with EY or ON
--   last names start with MY or contains SE
--   last names contain B followed by R or U


Solution: 

SELECT * 
FROM customers
WHERE first_name REGEXP 'elka|ambur';


SELECT * 
FROM customers
WHERE first_name REGEXP 'ey$|on$';

SELECT * 
FROM customers
WHERE first_name REGEXP '^my|se';


SELECT * 
FROM customers
WHERE first_name REGEXP 'b[ru]';

SELECT * 
FROM customers
WHERE first_name REGEXP 'br|bu';





📌 Summary
✔ REGEXP allows flexible pattern matching beyond LIKE. 
✔ Special characters (^, $, |, [ ]) enhance text filtering precision. 
✔ Ranges ([a-h]) provide a powerful way to search multiple characters efficiently. 
✔ SQL regular expressions simplify complex searches, making queries concise. 
✔ Next steps: Learning how to handle NULL values and missing data in SQL queries.











The IS NULL Operator: 
---------------------
🚀 Understanding the IS NULL Operator in SQL:
The IS NULL operator is used to identify missing values in a database, allowing us to filter records where certain attributes are absent.

📌 1. Identifying NULL Values in a Table:
✔ NULL represents missing or unknown data. 
✔ If a column contains NULL, it means no value has been assigned.

📌 Example: Retrieve Customers Without a Phone Number

SELECT * 
FROM customers
WHERE phone IS NULL;

🚀 Effect: ✔ Filters customers who do not have a phone number.

📌 Example Output
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Phone     │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ NULL      │ TX        │
└───────────┴───────────┴───────────┴───────────┘
✔ Customer 5 has no phone number.

📌 Real-World Use Case ✔ If a customer has missing contact details, businesses can send an email prompting them to update their information.




📌 2. Excluding NULL Values Using IS NOT NULL
✔ The IS NOT NULL operator retrieves only rows where values exist.

📌 Example: Retrieve Customers Who Have a Phone Number

SELECT * 
FROM customers
WHERE phone IS NOT NULL;
🚀 Effect: ✔ Filters customers who have valid phone numbers.

📌 Example Output
┌───────────┬───────────┬───────────────┬────────┐
│ CustomerID│ Name      │ Phone         │ State  │
├───────────┼───────────┼───────────────┼────────┤
│ 1         │ Barbara   │ 781-932-9754  │ VA     │
│ 2         │ Ines      │ 804-427-9456  │ GA     │
│ 3         │ Freddi    │ 719-724-7869  │ CO     │
└───────────┴───────────┴───────────────┴────────┘
✔ Only customers with phone numbers are included.





📌 3. Exercise: Retrieve Orders That Are Not Shipped
🚀 Task: ✔ Retrieve orders that have not been shipped (missing shipper details).

📌 Expected Query Solution:

SELECT * 
FROM orders
WHERE shipper_id IS NULL;
🚀 Effect: ✔ Filters orders that have NOT been assigned to a shipping provider.

📌 Example Output:
┌───────────┬───────────┬────────────┬───────────┐
│ OrderID   │ CustomerID│ ShippedDate│ ShipperID │
├───────────┼───────────┼────────────┼───────────┤
│ 1         │ 6         │ NULL       │ NULL      │
│ 3         │ 8         │ NULL       │ NULL      │
│ 4         │ 2         │ NULL       │ NULL      │
│ 6         │ 10        │ NULL       │ NULL      │
│ 8         │ 5         │ NULL       │ NULL      │
└───────────┴───────────┴────────────┴───────────┘
✔ Only unshipped orders are retrieved.

📌 Alternative Query Using shipped_date Instead

SELECT * 
FROM orders
WHERE shipped_date IS NULL;
🚀 Effect: ✔ Retrieves orders without a shipping date, indicating they haven’t been processed yet.

📌 Real-World Use Case ✔ E-commerce platforms frequently use this query to track pending shipments.




Queries used in this discussion: 

SELECT * 
FROM customers
WHERE phone IS NULL;


SELECT * 
FROM customers
WHERE phone IS NOT NULL;


Exercise: 

-- Get the orders that are not shipped 

SELECT * 
FROM orders
WHERE shipper_id IS NULL;




📌 Summary
✔ NULL represents missing values in a table. 
✔ IS NULL retrieves missing values, while IS NOT NULL excludes them. 
✔ Businesses use NULL filtering to track missing customer details and pending orders. 
✔ Next steps: Learning how to handle duplicate records and optimize data integrity using DISTINCT.








The ORDER BY Clause:
--------------------

🚀 Understanding the ORDER BY Clause in SQL:
The ORDER BY clause in SQL allows us to sort query results based on one or more columns in ascending or descending order.

📌 1. Default Sorting Behavior
✔ By default, MySQL orders query results based on the primary key column (typically id). 
✔ When we select all customers, they appear sorted by customer_id:

SELECT * 
FROM customers;

📌 Example Output:
┌───────────┬───────────┬───────────────┐
│ CustomerID│ Name      │ State         │
├───────────┼───────────┼───────────────┤
│ 1         │ Barbara   │ VA            │
│ 2         │ Ines      │ GA            │
│ 3         │ Freddi    │ CO            │
└───────────┴───────────┴───────────────┘
✔ The sorting is based on customer_id, as indicated by the primary key.




📌 2. Sorting Data Using ORDER BY
✔ We can change the sorting order using the ORDER BY clause.

📌 Example: Sorting Customers by First Name

SELECT * 
FROM customers 
ORDER BY first_name;
🚀 Effect: ✔ Customers are sorted alphabetically by first name in ascending order.

📌 Sorting in Descending Order ✔ To reverse the order, use DESC:

sql
SELECT * 
FROM customers 
ORDER BY first_name DESC;
🚀 Effect: ✔ Customers are sorted in reverse alphabetical order (Z-A).




📌 3. Sorting By Multiple Columns
✔ We can sort by multiple attributes, ensuring nested ordering.

📌 Example: First Sort By State, Then By First Name

SELECT * 
FROM customers 
ORDER BY state, first_name;
🚀 Effect: ✔ Customers are sorted alphabetically by state, and then by first name within each state.

📌 Mixing ASC & DESC for Multi-Level Sorting ✔ First sort by state in descending order, then by first name in ascending order:

SELECT * 
FROM customers 
ORDER BY state DESC, first_name ASC;
🚀 Effect: ✔ Data appears in reverse alphabetical order by state, but names remain in ascending order within each state.




📌 4. Ordering Data by Non-Selected Columns
✔ Unlike some database systems, MySQL allows sorting by columns not included in the SELECT clause.

📌 Example: Selecting Only Names, But Sorting By Birth Date

SELECT first_name, last_name 
FROM customers 
ORDER BY birth_date;

🚀 Effect: ✔ Only first_name and last_name are shown, but data is sorted by birth_date.




📌 5. Sorting Using Aliases
✔ We can sort by expressions or aliases.

📌 Example: Sorting By an Alias (points)

SELECT first_name, last_name, 10 AS points 
FROM customers 
ORDER BY points, first_name;

🚀 Effect: ✔ Even though points is not a real column, MySQL still allows sorting by its alias.




📌 6. Avoiding Sorting By Column Positions
✔ Some tutorials suggest sorting by column positions (ORDER BY 1, 2), but this is unreliable.

📌 Example: Sorting By Column Positions (Avoid This)

SELECT first_name, last_name, 10 AS points 
FROM customers 
ORDER BY 1, 2;

🚀 Why Avoid This? 
✔ If a new column is added before first_name, sorting behavior changes unexpectedly. 
✔ Always sort by column names instead.




📌 7. Exercise: Sorting Order Items By Total Price
🚀 Task: ✔ Retrieve items for order #2, sorted by total price (quantity × unit_price) in descending order.

📌 Expected Query Solution

SELECT *, quantity * unit_price AS total_price 
FROM order_items 
WHERE order_id = 2 
ORDER BY total_price DESC;

🚀 Effect: ✔ Sorts items in order #2 by their total price, highest first.

📌 Example Output
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ TotalPrice│
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ 1         │  2        │ 18.20     │ ✅ Highest Total Price
│ 2         │ 4         │  4        │  6.64     │
│ 2         │ 6         │  2        │  5.88     │ ✅ Lowest Total Price
└───────────┴───────────┴───────────┴───────────┘
✔ Orders are correctly sorted by total price.


📌 Alternative Query Using Alias for Sorting

SELECT *, quantity * unit_price AS total_price 
FROM order_items 
WHERE order_id = 2 
ORDER BY total_price DESC;

🚀 Effect: ✔ Avoids redundancy by using total_price alias instead of recalculating.






Queries used in this discussion: 

SELECT *
FROM customers 
ORDER BY first_name; 

SELECT *
FROM customers 
ORDER BY first_name DESC; 

SELECT *
FROM customers 
ORDER BY state, first_name; 

SELECT *
FROM customers 
ORDER BY state DESC, first_name DESC; 


valid query: 
SELECT first_name, last_name
FROM customers 
ORDER BY birth_date; 


SELECT first_name, last_name, 10 AS points
FROM customers 
ORDER BY points, first_name; 


Avoid: 
SELECT first_name, last_name, 10 AS points
FROM customers 
ORDER BY 1, 2; 


Exercise: 
SELECT *, quantity * unit_price AS total_price
FROM order_items
WHERE order_id = 2
ORDER BY total_price DESC





📌 Summary
✔ ORDER BY sorts query results in ascending (ASC) or descending (DESC) order. ✔ Sorting can be applied to multiple columns, allowing nested ordering. ✔ MySQL allows sorting by columns not included in SELECT. ✔ Sorting by column positions (ORDER BY 1, 2) is risky—use explicit column names. ✔ SQL supports ordering by expressions and aliases (ORDER BY total_price). ✔ Next steps: Learning how to limit query results using LIMIT for pagination and optimization.


















The LIMIT Clause: 
-----------------
🚀 Understanding the LIMIT Clause in SQL:
The LIMIT clause allows us to control the number of records returned in a SQL query. It is especially useful for pagination and retrieving top results.

📌 1. Limiting Query Results
By default, when we execute a query like:

SELECT * 
FROM customers;
🚀 Effect: ✔ It retrieves all records in the customers table. ✔ If the table contains 10 customers, the result will show all 10.

📌 Using LIMIT to Return Only the First 3 Customers:

SELECT * 
FROM customers
LIMIT 3;
🚀 Effect: ✔ Retrieves only the first 3 rows from the table.

📌 If LIMIT Exceeds Available Records:

SELECT * 
FROM customers
LIMIT 300;
🚀 Effect: ✔ Since there are only 10 customers, this query will return all 10 records. ✔ LIMIT will never exceed available data.




📌 2. Using LIMIT With OFFSET for Pagination
✔ The LIMIT clause allows us to skip records using OFFSET, ensuring efficient pagination.

📌 Example: Displaying Customers in Pages of 3

Page 1 → Customers 1, 2, 3
Page 2 → Customers 4, 5, 6
Page 3 → Customers 7, 8, 9

📌 Retrieving Customers for Page 3

SELECT * 
FROM customers
LIMIT 6, 3;
🚀 Effect: ✔ Skips the first 6 records and retrieves the next 3 customers.

✔ Alternative Syntax Using OFFSET

SELECT * 
FROM customers
LIMIT 3 OFFSET 6;
🚀 Effect: ✔ Ensures data is retrieved efficiently, helping websites paginate content properly.




📌 3. Exercise: Retrieving the Top 3 Loyal Customers
🚀 Task: ✔ Retrieve the top 3 customers with the highest points.

📌 Expected Query Solution:

SELECT * 
FROM customers
ORDER BY points DESC
LIMIT 3;
🚀 Effect: ✔ Customers are first sorted by points in descending order (DESC). ✔ Then, only the top 3 records are retrieved.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ CustomerID│ Name      │ Points    │ State     │
├───────────┼───────────┼───────────┼───────────┤
│ 5         │ Clemmie   │ 3675      │ TX        │ ✅ Highest Loyalty
│ 6         │ Elka      │ 3073      │ IL        │
│ 3         │ Freddi    │ 2967      │ CO        │ ✅ Third Highest Loyalty
└───────────┴───────────┴───────────┴───────────┘
✔ The most loyal customers appear first.

📌 Important SQL Clause Order ✔ The LIMIT clause must always come at the end of a query.

SELECT → FROM → WHERE → ORDER BY → LIMIT
✔ Changing this order causes errors.





Queries used in this discussion: 

SELECT * 
FROM customers
LIMIT 3


SELECT * 
FROM customers
LIMIT 300 -- produces all the rows 


-- page 1: 1 - 3
-- page 2: 4 - 6
-- page 3: 7 - 9

SELECT * 
FROM customers
LIMIT 6, 3

SELECT * 
FROM customers
LIMIT 6 OFFSET 3;


Exercise: 
--Get the top three loyal customers

Solution: 
SELECT * 
FROM customers
ORDER BY points DESC
LIMIT 3;



📌 Summary
✔ LIMIT controls the number of records returned. 
✔ LIMIT with OFFSET enables pagination, helping display data in pages. 
✔ Sorting must happen before limiting records, ensuring accurate results. 
✔ SQL follows strict query structure (SELECT → FROM → WHERE → ORDER BY → LIMIT). 










Retrieving Data From Multiple Tables: 
-------------------------------------


Inner Joins:
------------
🚀 Understanding INNER JOINS in SQL:
In real-world applications, data is spread across multiple tables, and JOIN operations allow us to retrieve related data efficiently. This tutorial covers INNER JOINS, their syntax, usage, and best practices.

📌 1. Why Do We Need Joins?
✔ Tables are structured to avoid redundancy and store related data separately. 
✔ For example:
The orders table stores order details, but not customer information.
The customers table stores customer details, but not order details.

📌 Example: Orders Table:
┌───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │
├───────────┼───────────┼───────────┤
│ 1         │ 3         │ 2025-05-17│
│ 2         │ 7         │ 2025-05-16│
└───────────┴───────────┴───────────┘
✔ The customer_id column links orders to customers.

📌 Example: Customers Table:
┌───────────┬───────────┬───────────┬─────────────────┐
│ CustomerID│ FirstName │ LastName  │ Email           │
├───────────┼───────────┼───────────┼─────────────────┤
│ 3         │ Alex      │ Smith     │ alex@email.com  │
│ 7         │ Maria     │ Johnson   │ maria@email.com │
└───────────┴───────────┴───────────┴─────────────────┘
✔ To retrieve an order with customer details, we join both tables.




📌 2. Using INNER JOIN to Merge Data:
✔ INNER JOIN matches records between two tables based on a common key (e.g., customer_id).

📌 Retrieve Orders Along With Customer Names:

SELECT order_id, first_name, last_name
FROM orders
JOIN customers 
ON orders.customer_id = customers.customer_id;

🚀 Effect: ✔ Merges both tables, ensuring only matching records appear.

📌 Example Output
┌───────────┬───────────┬───────────┐
│ OrderID   │ FirstName │ LastName  │
├───────────┼───────────┼───────────┤
│ 1         │ Alex      │ Smith     │
│ 2         │ Maria     │ Johnson   │
└───────────┴───────────┴───────────┘
✔ Now we see customer names instead of just IDs.




📌 3. Handling Column Name Ambiguity:
✔ If both tables contain a column with the same name (customer_id), MySQL requires explicit table prefixes.

📌 Example Query That Causes an Error:

SELECT order_id, customer_id, first_name, last_name
FROM orders
JOIN customers 
ON customer_id = customer_id;  -- ❌ Ambiguous!

🚀 Effect: ✔ This throws an error—MySQL doesn't know which customer_id to use.

📌 Correct Query Using Table Prefixes

SELECT order_id, orders.customer_id, first_name, last_name
FROM orders
JOIN customers 
ON orders.customer_id = customers.customer_id;

🚀 Effect: ✔ Explicit table names resolve ambiguity, making the query valid.




📌 4. Using Table Aliases for Simplicity
✔ To avoid repetition, use short aliases for tables.

📌 Assigning Aliases (o for orders, c for customers)

SELECT order_id, o.customer_id, first_name, last_name
FROM orders o
JOIN customers c
ON o.customer_id = c.customer_id;

🚀 Effect: ✔ Query remains clear, but avoids redundant table names.




📌 5. Exercise: Joining Order Items with Products
🚀 Task: ✔ Retrieve product details for each order item from order_items and products.

📌 Expected Query Solution:

SELECT order_id, oi.product_id, quantity, oi.unit_price
FROM order_items oi
JOIN products p 
ON oi.product_id = p.product_id;

🚀 Effect: ✔ Displays product details alongside order quantities.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 10        │  3        │  4.99     │
│ 1         │ 22        │  2        │  8.25     │
│ 2         │ 10        │  5        │  4.99     │
└───────────┴───────────┴───────────┴───────────┘
✔ The product_id is retrieved along with quantity and unit price.




📌 6. Understanding Price Data Storage:
✔ The unit_price column exists in both order_items and products tables.

📌 Why Does unit_price Exist Twice? 
✔ Products Table (products.unit_price) → Stores current price. 
✔ Order Items Table (order_items.unit_price) → Stores historical price at time of order.

🚀 Effect: ✔ Ensures accurate historical pricing, allowing proper sales calculations.






Queries in this discussion: 

SELECT *
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	

SELECT order_id, customer_id, first_name, last_name
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	
SELECT order_id, orders.customer_id, first_name, last_name
FROM orders
JOIN customers 
	ON orders.customer_id = customers.customer_id;
	
	
SELECT order_id, o.customer_id, first_name, last_name
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;	
	
	
Exercise:

SELECT order_id, oi. product_id, quantity, oi.unit_price
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id






📌 Summary:
✔ INNER JOIN merges records from multiple tables, linking related data. 
✔ Ambiguous columns require explicit table prefixes (orders.customer_id). 
✔ Aliases (o, c) simplify queries, making them easier to read. 
✔ Product pricing is stored both historically (order_items) and currently (products). 
✔ Next steps: Learning how to use OUTER JOINS to retrieve unmatched data from related tables.










Joining Across Databases: 
-------------------------

🚀 Joining Across Databases in SQL:
In real-world applications, developers and database administrators often work with multiple databases. This tutorial demonstrates how to join tables across different databases, ensuring proper data integration.

📌 1. Why Join Tables Across Databases?
✔ Large applications may store data in separate databases for organization and security. 
✔ Sometimes, identical tables exist in multiple databases, but queries require combining them.

📌 Example Scenario: 
✔ The sql_store database contains customer orders (order_items). 
✔ The sql_inventory database contains product details (products). 
✔ We need to retrieve order items from sql_store, along with product details from sql_inventory.




📌 2. Writing Queries to Join Tables Across Databases
✔ When a table exists in another database, it must be prefixed with the database name.

📌 Joining order_items (from sql_store) With products (from sql_inventory):

SELECT * 
FROM order_items oi
JOIN sql_inventory.products p 
ON oi.product_id = p.product_id;
🚀 Effect: ✔ Joins order items from sql_store with product details from sql_inventory.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬─────────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │ ProductName │
├───────────┼───────────┼───────────┼───────────┼─────────────┤
│ 1         │ 10        │  3        │  4.99     │ Foam Plate  │
│ 2         │ 22        │  2        │  8.25     │ Bacon       │
└───────────┴───────────┴───────────┴───────────┴─────────────┘
✔ Ensures data from both databases is integrated.




📌 3. Selecting a Different Database for Querying
✔ The current database determines which tables need prefixing. ✔ The USE statement sets the active database.

📌 Changing the Active Database to sql_inventory:

USE sql_inventory;
🚀 Effect: ✔ Sets sql_inventory as the current database, affecting queries.

📌 Joining order_items (From sql_store) When sql_inventory Is Active:
SELECT * 
FROM sql_store.order_items oi
JOIN products p 
ON oi.product_id = p.product_id;
🚀 Effect: ✔ Since sql_inventory is active, only order_items needs database prefixing.




Queries in this discussion: 

SELECT *
FROM order_items oi
JOIN sql_inventory.products p
	ON oi.product_id = p.product_id;
	
	
	
USE sql_inventory;
	
SELECT *
FROM sql_store.order_items oi
JOIN products p
	ON oi.product_id = p.product_id;	



📌 Key Takeaways
✔ Tables from other databases must be prefixed with the database name (sql_inventory.products). 
✔ If the table exists in the current database, no prefix is required. 
✔ Changing the active database (USE database_name;) alters query requirements. 
✔ Next steps: Exploring different types of joins (LEFT, RIGHT, FULL OUTER) for handling unmatched records.

🚀 Use cross-database joins to retrieve data seamlessly across systems!












Self Joins:
-----------
🚀 Understanding Self Joins in SQL:
A self-join occurs when a table is joined with itself, often used to compare rows within the same table.

📌 1. Why Use Self Joins?
✔ Some tables reference themselves, such as hierarchical structures. 
✔ In the sql_hr database, employees report to other employees, making a self-referencing relationship.

📌 Example: Employees Table:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Job Title │ Salary    │ ReportsTo │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 37270     │ John      │ CEO       │ 120000    │ NULL      │
│ 33391     │ Sarah     │ Manager   │ 75000     │ 37270     │
│ 37851     │ Alex      │ Engineer  │ 65000     │ 33391     │
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ The ReportsTo column references EmployeeID within the same table.




📌 2. Performing a Self Join:
✔ To retrieve employees along with their managers, we join the employees table with itself.

📌 Joining Employees With Their Managers:

USE sql_hr;

SELECT * 
FROM employees e
JOIN employees m 
ON e.reports_to = m.employee_id;
🚀 Effect: ✔ Links each employee with their manager, forming a hierarchical structure.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Job Title │ Salary    │ ReportsTo │ Manager   │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ 33391     │ Sarah     │ Manager   │ 75000     │ 37270     │ John      │
│ 37851     │ Alex      │ Engineer  │ 65000     │ 33391     │ Sarah     │
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Each row shows an employee and their manager.




📌 3. Selecting Specific Columns for Clarity
✔ Instead of selecting all columns, we focus on employee name & manager name.

📌 Query Selecting Only Employee & Manager Names:

SELECT 
    e.employee_id,
    e.first_name,
    m.first_name AS manager
FROM employees e
JOIN employees m 
ON e.reports_to = m.employee_id;
🚀 Effect: ✔ Improves readability by focusing on essential columns.

📌 Example Output:
┌───────────┬───────────┬───────────┐
│ EmployeeID│ FirstName │ Manager   │
├───────────┼───────────┼───────────┤
│ 33391     │ Sarah     │ John      │
│ 37851     │ Alex      │ Sarah     │
└───────────┴───────────┴───────────┘
✔ The Manager column is renamed for clarity.




Queries in this discussion:

USE sql_hr;


SELECT *
FROM employees e
JOIN employees m
 ON e.reports_to = m.employee_id;


SELECT 
	e.employee_id,
	e.first_name,
	m.first_name AS manager
FROM employees e
JOIN employees m
	ON e.reports_to = m.employee_id;  




📌 Key Takeaways:
✔ Self-joins allow referencing rows within the same table, commonly used for hierarchical structures. 
✔ Aliases (e, m) simplify the query, making it easier to read. 
✔ Explicit table prefixes are required, as all columns belong to the same table. 
✔ Next steps: Learning how to join multiple tables together for complex queries.

🚀 Use self joins to retrieve hierarchical relationships efficiently!










Joining Multiple Tables:
------------------------

🚀 Joining Multiple Tables in SQL:
In SQL, joining multiple tables allows us to combine related data from different sources into a single query result. This tutorial covers joining three tables, its practical use, and an exercise to reinforce learning.

📌 1. Understanding Multi-Table Joins
✔ The orders table contains order details but does not store customer or status names. 
✔ The customers table contains customer details. 
✔ The order_statuses table contains order status names.

📌 Example: Orders Table:
┌───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ Status    │
├───────────┼───────────┼───────────┤
│ 1         │ 6         │ 1         │
│ 2         │ 3         │ 2         │
└───────────┴───────────┴───────────┘
✔ The status column stores an order status ID, not a name.

📌 Example: Order Statuses Table:
┌───────────────┬───────────┐
│ OrderStatusID │ Name      │
├───────────────┼───────────┤
│ 1             │ Processed │
│ 2             │ Shipped   │
└───────────────┴───────────┘
✔ This table provides readable status names.





📌 2. Writing a Multi-Table Join Query
📌 Retrieving Orders With Customer Names and Status:

USE sql_store;

SELECT 
    o.order_id, 
    o.order_date,
    c.first_name, 
    c.last_name,
    os.name AS status
FROM orders o
JOIN customers c 
    ON o.customer_id = c.customer_id
JOIN order_statuses os 
    ON o.status = os.order_status_id;
🚀 Effect: ✔ Retrieves order details along with customer names and order statuses.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ OrderDate │ FirstName │ LastName  │ Status    │
├───────────┼───────────┼───────────┼───────────┼───────────┤
│ 1         │ 2025-05-17│ Alex      │ Smith     │ Processed │
│ 2         │ 2025-05-16│ Maria     │ Johnson   │ Shipped   │
└───────────┴───────────┴───────────┴───────────┴───────────┘
✔ Orders now display full customer names and status names.




📌 3. How Multi-Table Joins Work
✔ SQL executes joins sequentially, first linking orders → customers, then orders → order_statuses. 
✔ Queries can join multiple tables in a single statement using additional JOIN clauses. 
✔ Aliases (o, c, os) simplify queries for better readability.

📌 Query Breakdown:
JOIN customers connects orders with customers, matching customer IDs.
JOIN order_statuses connects orders with statuses, mapping the status ID.





📌 4. Exercise: Joining Payments With Clients and Payment Methods:
🚀 Task: ✔ Retrieve payment details along with client names and payment methods.

📌 Expected Query Solution:

SELECT 
    p.date, 
    p.invoice_id,
    p.amount, 
    c.name,
    pm.name
FROM payments p
JOIN clients c 
    ON p.client_id = c.client_id
JOIN payment_methods pm 
    ON p.payment_method = pm.payment_method_id;
	
🚀 Effect: ✔ Displays detailed payment information.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬───────────────┐
│ Date      │ InvoiceID │ Amount    │ Client    │ Method        │
├───────────┼───────────┼───────────┼───────────┼───────────────┤
│ 2025-05-01│ 112       │ 250.00    │ Vinte     │ Credit Card   │
│ 2025-04-30│ 113       │ 175.50    │ MyWorks   │ Wire Transfer │
└───────────┴───────────┴───────────┴───────────┴───────────────┘
✔ Clients and payment methods are clearly displayed.





Queries in this discussion: 

USE sql_store; 


SELECT 
	o.order_id, 
	o.order_date,
	c.first_name, 
	c.last_name,
	os.name AS status
FROM order o
JOIN customers c
	ON o.customer_id = c.customer_id
JOIN order_statuses os
	ON o.status = os.order_status_id;



Exercise: 

SELECT 
	p.date, 
	p.invoice_id,
	p.amount, 
	c.name,
	pm.name
FROM payments p
JOIN clients c
	ON p.client_id = c.client_id
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id;




📌 Summary
✔ Joining multiple tables allows for complex data retrieval. 
✔ Aliases (o, c, os) reduce redundancy. 
✔ SQL executes joins sequentially, ensuring efficient data mapping. 
✔ Next steps: Learning different join types (LEFT, RIGHT, FULL OUTER) for handling unmatched records.














Compound Join Conditions:
-------------------------

🚀 Understanding Compound Join Conditions in SQL:
While many tables use a single column to uniquely identify rows (customer_id in customers), some require multiple columns for uniqueness. This tutorial covers composite primary keys and joining tables using multiple conditions.

📌 1. Identifying Composite Keys in Tables:
✔ Some tables cannot use a single column for unique identification. 
✔ Example: order_items table contains repeated values in order_id and product_id.

📌 Example: order_items Table:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ ProductID │ Quantity  │ UnitPrice │
├───────────┼───────────┼───────────┼───────────┤
│ 2         │ 1         │  2        │  9.10     │
│ 2         │ 4         │  4        │  1.66     │
│ 2         │ 6         │  2        │  2.94     │
│ 6         │ 1         │  4        │  8.65     │
└───────────┴───────────┴───────────┴───────────┘
✔ Neither order_id nor product_id alone can uniquely identify records. 
✔ The combination of order_id and product_id creates a unique identifier.

📌 Understanding Composite Primary Keys 
✔ The primary key (PK) is a combination of multiple columns (order_id & product_id). 
✔ This ensures each order item is uniquely tracked.




📌 2. Joining Tables With a Composite Key:
✔ When joining a table with a composite key, both key columns must be included in the join condition.

📌 Example: Joining order_items With order_item_notes:

SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	ON oi.order_id = oin.order_id 
	AND oi.product_id = oin.product_id;
🚀 Effect: ✔ Matches order items with their corresponding notes, ensuring precise record association.

📌 Example Output:
┌───────────┬───────────┬───────────┬───────────┬────────────┐
│ OrderID   │ ProductID │ Quantity  │ NoteID    │ Note       │
├───────────┼───────────┼───────────┼───────────┼────────────┤
│ 2         │ 1         │  2        │ 1         │ First note │
│ 2         │ 1         │  2        │ 2         │ Second note│
└───────────┴───────────┴───────────┴───────────┴────────────┘
✔ Each order item is correctly linked with its notes.




Queries in this discussion:

SELECT *
FROM order_items oi
JOIN order_item_notes oin
	ON oi.order_id = oin.order_id
	AND oi.product_id = oin.product_id




📌 Key Takeaways
✔ Some tables require composite keys (multiple columns) for unique identification. 
✔ Joining tables with composite keys requires multiple conditions (ON order_id AND product_id). 
✔ Ensures precise data retrieval and accurate joins. 












Implicit Join Syntax:
---------------------

🚀 Understanding Implicit Join Syntax in SQL:
MySQL allows two methods for joining tables: 
Explicit Join Syntax (Recommended ✅) 
Implicit Join Syntax (Not Recommended ⚠️)



📌 1. Explicit vs. Implicit Joins:
✔ Explicit joins use the JOIN keyword, ensuring clarity and structure. 
✔ Implicit joins place multiple tables in the FROM clause and define join conditions in WHERE.

📌 Explicit Join (Recommended):

SELECT * 
FROM orders o
JOIN customers c 
ON o.customer_id = c.customer_id;

🚀 Effect: ✔ Directly links orders with customers, ensuring structured queries.

📌 Implicit Join (Not Recommended):
SELECT * 
FROM orders o, customers c 
WHERE o.customer_id = c.customer_id;

🚀 Effect: ✔ Produces the same result, but poses risks if the WHERE clause is omitted.




📌 2. Risks of Implicit Join Syntax:
✔ If the WHERE clause is mistakenly omitted, MySQL performs a CROSS JOIN, multiplying data unexpectedly.

📌 Example of Missing WHERE Clause (Cross Join):

SELECT * 
FROM orders o, customers c;  -- ⚠️ No Join Condition!

🚀 Effect: 
✔ Every order combines with every customer, creating unexpected results. 
✔ If the orders table contains 10 records and customers contains 10 records, the result produces 100 rows instead of 10.

📌 Example Output of a Cross Join:
┌───────────┬───────────┬───────────┬───────────┐
│ OrderID   │ CustomerID│ OrderDate │ Customer  │
├───────────┼───────────┼───────────┼───────────┤
│ 1         │ 1         │ 2025-05-17│ Alice     │
│ 1         │ 2         │ 2025-05-17│ Bob       │
│ 1         │ 3         │ 2025-05-17│ Charlie   │
│ 2         │ 1         │ 2025-05-16│ Alice     │
│ 2         │ 2         │ 2025-05-16│ Bob       │
│ 2         │ 3         │ 2025-05-16│ Charlie   │
└───────────┴───────────┴───────────┴───────────┘
✔ Orders incorrectly combine with all customers, leading to data inconsistency.




📌 3. Why Explicit Joins Are Safer
✔ Explicit syntax forces the join condition, preventing unintended CROSS JOINS. 
✔ If the join condition is missing, MySQL throws an error instead of generating incorrect results.

📌 Explicit Join Preventing Cross Join:

SELECT * 
FROM orders o
JOIN customers c;  -- ❌ ERROR (Join condition required)

🚀 Effect: ✔ Ensures correctness by enforcing required conditions.





Queries in this discussion: 

SELECT *
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;
	
	
--Implicit Join Syntax
SELECT *
FROM orders o, customers c
WHERE o.customer_id = c.customer_id;




📌 Summary
✔ Explicit joins (JOIN ON) ensure structured queries and prevent errors. 
✔ Implicit joins (FROM table1, table2 WHERE) allow mistakes if the WHERE condition is forgotten. 
✔ Avoid implicit joins to prevent accidental cross joins. 












Outer Joins: 
------------
🚀 Understanding Outer Joins in SQL:
SQL joins allow us to combine data from multiple tables. So far, we've explored inner joins, which return only matching records between tables. However, outer joins retrieve all records from one table, even if there is no match in the other.

📌 1. Difference Between Inner and Outer Joins
✔ Inner Join: Returns only records that match in both tables. 
✔ Outer Join: Returns all records from one table, even if there is no match in the second table.

📌 Inner Join Example:
SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ Only customers who have placed orders are retrieved.

📌 Example Output (Inner Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 2         │ Ines      │ 4         │
│ 2         │ Ines      │ 7         │
│ 5         │ Clemmie   │ 12        │
└───────────┴───────────┴───────────┘
✔ Customers without orders are missing.




📌 2. Using LEFT JOIN to Retrieve All Customers
✔ LEFT JOIN returns all records from the left table, even if no match exists in the right table.

📌 Retrieve All Customers, Including Those Without Orders:

SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
LEFT JOIN orders o 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;
🚀 Effect: ✔ All customers appear in the result, whether or not they have orders.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ ✅ Has orders
│ 2         │ Ines      │ 7         │ ✅ Has orders
│ 3         │ Freddi    │ NULL      │ ❌ No orders
└───────────┴───────────┴───────────┘
✔ Customers without orders display NULL values for order_id.





📌 3. Using RIGHT JOIN to Retrieve All Orders
✔ RIGHT JOIN returns all records from the right table, ensuring all orders appear, even if no matching customer exists.

📌 Retrieve All Orders, Including Those Without Customers:

SELECT c.customer_id, c.first_name, o.order_id
FROM orders o
RIGHT JOIN customers c 
ON c.customer_id = o.customer_id
ORDER BY c.customer_id;

🚀 Effect: ✔ All orders appear, even if no customer exists.

📌 Example Output (Right Join)

┌───────────┬───────────┬───────────┐
│ CustomerID│ FirstName │ OrderID   │
├───────────┼───────────┼───────────┤
│ 1         │ John      │ NULL      │ ❌ No orders
│ 2         │ Ines      │ 4         │ ✅ Has orders
│ 2         │ Ines      │ 7         │ ✅ Has orders
│ NULL      │ NULL      │ 10        │ ❌ No matching customer
└───────────┴───────────┴───────────┘
✔ Orders without customers display NULL values for customer_id.

📌 Understanding Table Order ✔ LEFT JOIN → Ensures all customers appear. ✔ RIGHT JOIN → Ensures all orders appear. ✔ Swapping tables affects results.




📌 4. Exercise: Retrieve Products, Including Those Never Ordered
🚀 Task: ✔ Retrieve all products, even those never ordered.

📌 Expected Query Solution:

SELECT p.product_id, p.name, oi.quantity 
FROM products p
LEFT JOIN order_items oi 
ON p.product_id = oi.product_id;

🚀 Effect: ✔ All products appear, even if not ordered.

📌 Example Output (Left Join):
┌───────────┬───────────┬───────────┐
│ ProductID │ Name      │ Quantity  │
├───────────┼───────────┼───────────┤
│ 1         │ Laptop    │ 5         │ ✅ Ordered
│ 2         │ Mouse     │ 12        │ ✅ Ordered
│ 3         │ Keyboard  │ NULL      │ ❌ Never ordered
└───────────┴───────────┴───────────┘
✔ Products with no orders display NULL values in quantity.





Queries used in this discussion: 

SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
JOIN orders o
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM orders o
RIGHT JOIN customers c
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id;	


Exercise:

SELECT 
	p.product_id, 
	p.name, 
	oi.quantity
FROM products p
LEFT JOIN order_items oi
	ON p.product_id = oi.product_id;






📌 Summary
✔ INNER JOIN → Only matching records from both tables. 
✔ LEFT JOIN → All records from left table, even if no match in right. 
✔ RIGHT JOIN → All records from right table, even if no match in left. 
✔ OUTER keyword is optional (LEFT JOIN = LEFT OUTER JOIN). 













Outer Joins Between Multiple Tables: 
------------------------------------


Queries in this discussion: 

SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
JOIN shippers sh
	ON o.shipper_id = sh.shipper_id
ORDER BY c.customer_id;	



SELECT 
	c.customer_id,
	c.first_name,
	o.order_id,
	sh.name AS shipper 
FROM customers c
LEFT JOIN orders o
	ON c.customer_id = o.customer_id
LEFT JOIN shippers sh
	ON o.shipper_id = sh.shipper_id
ORDER BY c.customer_id;	




Exercise: 

SELECT
	o.order_id, 
	o.order_date, 
	c.first_name AS customer, 
	sh.name AS shipper, 
	os.name AS status
FROM orders o
JOIN customers c 
	ON o.customer_id = c.customer_id 
LEFT JOIN shippers sh 
	ON o.shipper_id = sh.shipper_id
JOIN order_statuses os 
	ON o.status = os.order_status_id
	
	
	
	
	







Self Outer Joins:
-----------------

Queries used in this discussion: 

USE sql_hr;

SELECT 
	e.employee_id,
	e.first_name, 
	m.first_name AS manager
FROM employees e
JOIN employees m 
	ON e.reports_to = m.employee_id;
	

SELECT 
	e.employee_id,
	e.first_name, 
	m.first_name AS manager
FROM employees e
LEFT JOIN employees m 
	ON e.reports_to = m.employee_id;













The USING Clause:
-----------------

Queries used in this discussion: 

SELECT 
	o.order_id, 
	c.first_name
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id;
	
	
SELECT 
	o.order_id, 
	c.first_name,
	sh.name AS shipper
FROM orders o
JOIN customers c
	USING (customer_id)
LEFT JOIN shippers sh
	USING (shipper_id);
	
		
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	ON oi.order_id = oin.order_id 
	AND oi.product_id = oin.product_id;
	
	
SELECT * 
FROM order_items oi
JOIN order_item_notes oin 
	USING (order_id, product_id);
	
	
	
Exercise: 

SELECT 
	p.date, 
	c.name AS client,
	p.amount, 
	pm.name AS payment_method
FROM payments p
JOIN clients c USING (client_id)
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
Natural Joins:
--------------

Queries in this discussion: 

SELECT 
	o.order_id,
	c.first_name
FROM orders o
NATURAL JOIN customers c















Cross Joins: 
------------


Queries used in this discussion: 

SELECT 
	c.first_name AS customer, 
	p.name AS product
FROM customers c
CROSS JOIN products p
ORDER BY c.first_name; 


--Implicit syntax
SELECT 
	c.first_name AS customer, 
	p.name AS product
FROM customers c, products p
ORDER BY c.first_name; 



Exercise: 

-- Do a cross join between shippers and products
-- 		using the implicit syntax
-- 		and then using the explicit syntax 


SELECT 
	sh.name AS shipper, 
	p.name AS product 
FROM shippers sh, products p
ORDER BY sh.name 


SELECT 
	sh.name AS shipper, 
	p.name AS product 
FROM shippers sh
CROSS JOIN products p
ORDER BY sh.name 






















Unions: 
-------

Queries used in this discussion: 

SELECT 
	order_id,
	order_date,
	'Active' AS status, 
FROM orders
WHERE order_date >= '2019-01-01'
UNION
SELECT 
	order_id,
	order_date,
	'Archived' AS status, 
FROM orders
WHERE order_date < '2019-01-01';



SELECT first_name
FROM customers
UNION 
SELECT name 
FROM shippers 




SELECT first_name, last_name   --Error
FROM customers
UNION 
SELECT name 
FROM shippers 



SELECT name 
FROM shippers 
UNION 
SELECT first_name
FROM customers


Exercise: 

SELECT 
	customer_id, 
	first_name,
	points, 
	'Bronze' AS type
FROM customers 
WHERE points < 2000
UNION 
SELECT 
	customer_id, 
	first_name,
	points, 
	'Silver' AS type
FROM customers 
WHERE points BETWEEN 2000 AND 3000
UNION 
SELECT 
	customer_id, 
	first_name,
	points, 
	'Gold' AS type
FROM customers 
WHERE points > 3000
ORDER BY first_name














Inserting, Updating and Deleting Data:
--------------------------------------

Column Attributes: 
------------------

Queries used in this discussion: 











Inserting a Row: 
----------------

Queries used in this discussion: 

INSERT INTO customers
VALUES (
	DEFAULT, 
	'John', 
	'Smith',
	'1990-01-01',
	NULL, 
	'address',
	'city', 
	'CA',
	DEFAULT)
	
	
INSERT INTO customers(    -- we can optionally supply the list of columns and we can provide values according to this
	first_name, 
	last_name, 
	birth_date,
	address,
	city, 
	state)
VALUES ( 
	'John', 
	'Smith',
	'1990-01-01',
	'address',
	'city', 
	'CA')
	
	
	
	
	
	
	
	
	
	
	
	
Inserting Multiple Rows:
------------------------

Queries used in this discussion: 

INSERT INTO shippers (name)
VALUES ('shipper1'),
	   ('shipper2'),
	   ('shipper3');
	   
	   
Exercise: 

-- Insert three rows in the products table

INSERT INTO products (name, quantity_in_stock, unit_price)
VALUES ('Product1', 10, 1.95),
	   ('Product2', 11, 1.95),
	   ('Product3', 12, 1.95);
	   
	   
	   
	   
	   
	   



Inserting Hierarchial Rows:
---------------------------


Queries used in this discussion: 

INSERT INTO orders (customer_id, order_date, status)
VALUES (1, '2019-01-02', 1);


INSERT INTO order_items
VALUES 
	(LAST_INSERT_ID(), 1, 1, 2.95)
	(LAST_INSERT_ID(), 2, 1, 3.95);
	
	
	
	
	
	
	
	
	
	
	
	

Creating a Copy of a Table: 
---------------------------

Queries used in this discussion: 


CREATE TABLE orders_archived AS 
SELECT * FROM orders


INSERT INTO orders_archived    --example of using a select statement as a sub query in an insert statement
SELECT * 
FROM orders
WHERE order_date < '2019-01-01';



Exercise: 

USE sql_invoicing; 

CREATE TABLE invoices_archived AS
SELECT 
	i.invoice_id, 
	i.number,
	c.name AS client,
	i.invoice_total, 
	i.payment_total, 
	i.invoice_date,
	i.payment_date,
	i.due_date
FROM invoices i
JOIN clients c
	USING (client_id)
WHERE payment_date IS NOT NULL; 











Updating a Single Row: 
----------------------

Queries used in this discussion: 


UPDATE invoices 
SET payment_total = 10, payment_date = '2019-03-01'
WHERE invoice_id = 1;


UPDATE invoices 
SET payment_total = DEFAULT, payment_date = NULL
WHERE invoice_id = 1;


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE invoice_id = 3;










Updating Multiple Rows: 
-----------------------


Queries used in this discussion: 

UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id = 3;


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id IN (3, 4);


Exercise: 

-- Write a SQL statement to 
-- 	   give any customers born before 1990
--     50 extra points 


USE sql_store;

UPDATE customers 
SET points = points + 50 
WHERE birth_date < '1990-01-01';










Using Subqueries in updates:
----------------------------


Queries used in this discussion: 

UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id = 
		(SELECT client_id
		FROM clients
		WHERE name = 'Myworks');

-- the sub query is a select statement and is within another SQL statement


UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE client_id IN 
		(SELECT client_id
		FROM clients
		WHERE state IN ('CA', 'NY'));
		
		
		
UPDATE invoices 
SET 
	payment_total = invoice_total * 0.5, 
	payment_date = due_date
WHERE payment_date IS NULL
	
	
-- So, as a best practice before executing your update statement, run your query to see what records you're going to update
-- So, you don't accidentally update the records that shouldn't be updated. 



Exercise: 

UPDATE orders
SET comments = 'Gold Customer'
WHERE customer_id IN 
		(SELECT customer_id
		FROM customers 
		WHERE points > 3000);
		
		
		
		
		
		
		
		







Deleting Rows:
--------------

Queries used in this discussion: 

DELETE FROM invoices  
WHERE invoice_id =1; 

-- without where statement, will delete all the records from the particular table


DELETE FROM invoices  
WHERE client_id = (
        SELECT * 
		FROM clients
		WHERE name = 'Myworks');
		
		
		
		
		









Restoring the Databases: 
------------------------

Queries used in this discussion: 














Summarizing Data:
-----------------

Aggregate Functions:
--------------------


Queries and other notes in this discussion: 

-- MAX()
-- MIN()
-- AVG()
-- SUM()
-- COUNT()


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total) AS total,
	COUNT(invoice_total) AS number_of_invoices,
	COUNT(payment_date) AS count_of_payments,
	COUNT(*) AS total_records
FROM invoices; 

SELECT 
	MAX(payment_date) AS highest
FROM invoices;	


-- SUM(invoice_total * 1.1 ) AS total,


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total * 1.1) AS total,
	COUNT(*) AS total_records
FROM invoices
WHERE invoice_date > '2019-07-01';


SELECT 
	MAX(invoice_total) AS highest, 
	MIN(invoice_total) AS lowest, 
	AVG(invoice_total) AS average,
	SUM(invoice_total * 1.1) AS total,
	COUNT(DISTINCT client_id) AS total_records
FROM invoices
WHERE invoice_date > '2019-07-01';




Exercise:

SELECT 
	'First half of 2019' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-01-01' AND '2019-06-30'
UNION 
SELECT 
	'Second half of 2019' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-07-01' AND '2019-12-31'
UNION 
SELECT 
	'Total' AS date_range, 
	SUM(invoice_total) AS total_sales, 
	SUM(payment_total) AS total_payments, 
	SUM(invoice_total - payment_total) AS what_we_expect
FROM invoices 
WHERE invoice_date 
	BETWEEN '2019-01-01' AND '2019-12-31';
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
The GROUP BY Clause:
--------------------

Queries used in this discussion: 

SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
ORDER BY DESC



SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
WHERE invoice_date >= '2019-07-01'
GROUP BY client_id
ORDER BY DESC;




SELECT 
	state,
	city
	SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients USING (client_id)
GROUP BY state, city;


Exercise: 

SELECT 
	date,
	pm.name AS payment_method,
	SUM(amount) AS total_payments
FROM payments p
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
GROUP BY date, payment_method 
ORDER BY date;














The HAVING Clause:
------------------

Queries used in this discussion: 

SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id



SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
-- WHERE total_sales > 500      -- not possible 
GROUP BY client_id


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
HAVING total_sales > 500 


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
	COUNT(*) AS number_of_invoices
FROM invoices
GROUP BY client_id
HAVING total_sales > 500 AND number_of_invoices > 5


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
	COUNT(*) AS number_of_invoices
FROM invoices
GROUP BY client_id
HAVING payment_date   -- wrong


Exercise: 

-- Get the customers
-- 		located in Virginia
--		who have spent more than $100


USE sql_store; 

SELECT 
	c.customer_id,
	c.first_name,
	c.last_name,
	SUM(oi.quantity * oi.unit_price) AS total_sales  
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE state = 'VA'
GROUP BY 
	c.customer_id,
	c.first_name,
	c.last_name
HAVING total_sales > 100;














The ROLLUP Operator:
--------------------

Queries used in this discussion: 


SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id WITH ROLLUP;


SELECT 
	state,
	city
	SUM(invoice_total) AS total_sales
FROM invoices i
JOIN clients c USING (client_id)
GROUP BY state, city WITH ROLLUP;



Exercise: 

SELECT 
	pm.name AS payment_method,
	SUM(amount) AS total
FROM payments p
JOIN payment_methods pm
	ON p.payment_method = pm.payment_method_id
GROUP BY pm.name WITH ROLLUP;   -- when we use the rollup operator, we cannot use the column alias in the group by clause, we need to provide actual column name
















Writing Complex Query:
----------------------


Introduction: 
-------------



Subqueries:
-----------

Queries used in this discussion: 
--------------------------------

-- Find products that are more
-- expensive than Lettuce(id = 3)


SELECT * 
FROM products
WHERE unit_price > (
		SELECT unit_price
		FROM products 
		WHERE product_id = 3
)


Exercise:

--  In sql_hr database:
-- 		Find employees whose earn more than average


SELECT *
FROM employees
WHERE salary > (
		SELECT AVG(salary)
		FROM employees
)










The IN Operator:
----------------

Queries used in this discussion: 


-- Find the products that have never been ordered

USE sql_store;

SELECT *
FROM products 
WHERE product_id NOT IN (
		SELECT DISTINCT product_id
		FROM order_items
)


Exercise: 

-- Find clients without invoices

USE sql_invoicing; 

SELECT *
FROM clients
WHERE client_id NOT IN (
	SELECT DISTINCT client_id
	FROM invoices
)












Subqueries vs Joins:
--------------------


Queries used in this discussion: 


SELECT *
FROM clients
WHERE client_id NOT IN (
	SELECT DISTINCT client_id
	FROM invoices
)



SELECT *
FROM clients
LEFT JOIN invoices USING (client_id)
WHERE invoice_id IS NULL




Exercise: 
--  Find customers who have ordered lettuce (id = 3)
-- 		Select customer_id, first_name, last_name 


USE sql_store;


SELECT customer_id, first_name, last_name  
FROM customers 
WHERE cutomer_id IN (
	SELECT o.customer_id
	FROM order_items oi
	JOIN orders o USING (order_id)
	WHERE product_id = 3
)


SELECT DISTINCT customer_id, first_name, last_name 
FROM customers c
JOIN orders o USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE oi.product_id = 3













The ALL Keyword:
----------------


-- Select invoices larger than all invoices of client 3

USE sql_invoicing;

SELECT *
FROM invoices 
WHERE invoice_total > (
	SELECT MAX(invoice_total)
	FROM invoices
	WHERE client_id = 3
)



SELECT *
FROM invoices 
WHERE invoice_total > ALL(
	SELECT invoice_total
	FROM invoices
	WHERE client_id = 3
)


The above subquery will be tecnically returned as:
SELECT *
FROM invoices 
WHERE invoice_total > ALL(150, 130, 167,...)













The ANY Keyword:
----------------


Queries used in this discussion:  



SELECT *
FROM invoices 
WHERE invoice_total > ANY(      --   you can also use 'SOME' 
	SELECT invoice_total
	FROM invoices
	WHERE client_id = 3
)




-- SELECT clients with at least two invoices 


SELECT *
FROM clients
WHERE client_id IN (
	SELECT client_id
	FROM invoices 
	GROUP BY client_id
	HAVING COUNT(*) >= 2
)


SELECT *
FROM clients
WHERE client_id = ANY(
	SELECT client_id
	FROM invoices 
	GROUP BY client_id
	HAVING COUNT(*) >= 2
)














Correlated Subqueries:
----------------------


Queries used in this discussion:

-- Select employees whose salary is 
-- above the average in their office 


USE sql_hr; 

-- for each employee 
-- 		calculate the avg salary for employee.office
--  	return the employee if salary > avg



SELECT *
FROM employees e
WHERE salary > (
	SELECT AVG(salary)
	FROM employees
	WHERE office_id = e.office_id
)


Exercise: 

-- Get invoices that are larger than the 
-- Client's average invoice amount


USE sql_invoicing; 


SELECT *
FROM invoices i
WHERE invoice_total > (
	SELECT AVG(invoice_total)
	FROM invoices 
	WHERE client_id = i.client_id
)

















The EXISTS Opertor:
-------------------


Queries used in this discussion:

-- Select clients that have an invoice 

SELECT * 
FROM clients 
WHERE client_id IN ( 
		SELECT DISTINCT client_id
		FROM invoices
)


SELECT * 
FROM clients c
WHERE  EXISTS ( 
	SELECT client_id
	FROM invoices
	WHERE client_id = c.client_id   -- more efficient if the IN operator returns a larger dataset 
)



Exercise: 

-- Find the products that have never been ordered 

USE sql_store; 


SELECT * 
FROM products 
WHERE product_id NOT IN (
	SELECT product_id 
	FROM order_items
)


SELECT * 
FROM products p
WHERE NOT EXISTS (
	SELECT product_id 
	FROM order_items
	WHERE product_id = p.product_id 
)
















Subqueries in the SELECT Clause:
--------------------------------


Queries used in this discussion:

SELECT 
	invoice_id, 
	invoice_total, 
	(SELECT AVG(invoice_total)
		FROM invoices) AS invoice_average
	invoice_total - (SELECT invoice_average) AS difference 
FROM invoices 



Exercise:

SELECT 
	client_id, 
	name,
	(SELECT SUM(invoice_total)
		FROM invoices
		WHERE client_id = c.client_id) AS total_sales 
	(SELECT AVG(invoice_total) FROM invoices) AS average 
	(SELECT total_sales - average) AS difference 
FROM clients c












Subqueries in the FROM clause:
------------------------------


SELECT *
FROM (
	SELECT 
		client_id, 
		name,
		(SELECT SUM(invoice_total)
			FROM invoices
			WHERE client_id = c.client_id) AS total_sales 
		(SELECT AVG(invoice_total) FROM invoices) AS average 
		(SELECT total_sales - average) AS difference 
	FROM clients c
) AS sales_summary



SELECT *
FROM (
	SELECT 
		client_id, 
		name,
		(SELECT SUM(invoice_total)
			FROM invoices
			WHERE client_id = c.client_id) AS total_sales 
		(SELECT AVG(invoice_total) FROM invoices) AS average 
		(SELECT total_sales - average) AS difference 
	FROM clients c
) AS sales_summary
WHERE total_sales IS NOT NULL 
















Essential MySQl Functions:
--------------------------


Numeric Functions:
------------------

ROUND(5.73) -- 6
ROUND(5.73, 1) -- 5.7
ROUND(5.7345, 2) -- 5.73
TRUNCATE(5.7345, 2) -- 5.73
CEILING(5.7) -- 6
FLOOR(5.2) -- 5
ABS(5.2) -- 5.2
ABS(-5.2) -- 5.2
RAND() 

Go to browser --> mysql numeric functions  --> https://dev.mysql.com/doc/refman/8.4/en/numeric-functions.html








String Functions: 
-----------------

LENGTH()
UPPER()
LOWER()
LTRIM()
RTRIM()
TRIM()
LEFT('Kindergarten', 3)
RIGHT('Kindergarten', 4)
SUBSTRING('Kindergarten', 3, 5)
LOCATE('n', 'Kindergarten')
REPLACE('Kindergarten', 'garten', 'garden')
CONCAT('first', 'last')


SELECT CONCAT(first_name, ' ', last_name) AS full_name 
FROM customers 


mysql string functions -->  https://dev.mysql.com/doc/refman/8.4/en/string-functions.html















Date Functions in MySQL:
------------------------

Queries and other notes in this discussion:

NOW(), CURDATE(),  CURTIME()
YEAR(NOW())
MONTH(NOW())
HOUR(NOW())
MINUTE(NOW())
SECOND(NOW())
DAYNAME(NOW())
MONTHNAME(NOW())

SELECT EXTRACT(DAY FROM NOW())
SELECT EXTRACT(YEAR FROM NOW())


Exercise:
SELECT * 
FROM orders
WHERE order_date >= '2019-01-01';

Solution:
SELECT * 
FROM orders
WHERE YEAR(order_date) =  YEAR(NOW());
















Formatting Dates and Times: 
---------------------------


Queries and other notes used in this discussion:
DATE_FORMAT(NOW(), '%y') -- 19
DATE_FORMAT(NOW(), '%Y') -- 2019


DATE_FORMAT(NOW(), '%m %y') -- 03 2019
DATE_FORMAT(NOW(), '%M %Y') -- March 2019 

DATE_FORMAT(NOW(), '%M %d %y') -- March 11 2019


search for mysql date format string --> https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html

TIME_FORMAT(NOW(), '%H:%i %p')










Calculating Dates and Times:
-----------------------------

Queries and other notes used in this discussion: 

SELECT DATE_ADD(NOW(), INTERVAL 1 DAY);
SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);
SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);
SELECT DATE_SUB(NOW(), INTERVAL 1 YEAR);
SELECT DATEDIFF('2019-01-05', '2019-01-01');
SELECT DATEDIFF('2019-01-05 09:00', '2019-01-01 17:00'); --only returns difference in days, even if we include time values

SELECT TIME_TO_SEC('09:00')
SELECT TIME_TO_SEC('09:02') - TIME_TO_SEC('09:00') -- 120 










The IFNULL and COALESCE Functions: 
----------------------------------

Queries and other notes used in this discussion:

SELECT 
	order_id, 
	IF_NULL(shipper_id, 'Not assigned') AS shipper
FROM orders;


SELECT 
	order_id
	COALESCE(shipper_id, comments, 'Not assigned')
FROM orders;


Exercise:
SELECT 
	CONCAT(first_name, ' ', last_name) AS customer, 
	COALESCE(phone, 'Unknown') AS phone
FROM customers;











The IF Function:
----------------

Queries and other notes in this discussion: 

IF(expression, first, second)


SELECT
	order_id, 
	order_date, 
	IF(
		YEAR(order_date) = YEAR(NOW()),
	    'Active', 
		'Archived') AS category
FROM orders



Exercise: 
SELECT 
	product_id, 
	name, 
	COUNT(*) AS orders,
	IF (COUNT(*) > 1, 'Many times', 'Once') AS frequency
FROM products
JOIN order_items USING (product_id)
GROUP BY product_id, name;












The CASE Operator:
------------------

Queries and other notes in this discussion: 



SELECT 
	order_id
	CASE 
		WHEN YEAR(order_date) = YEAR(NOW()) THEN 'Active'
		WHEN YEAR(order_date) = YEAR(NOW()) - 1  THEN 'Last Year'
		WHEN YEAR(order_date) < YEAR(NOW()) - 1  THEN 'Archived'
		ELSE 'Future'
	END AS category
FROM orders;



Exercise: 

SELECT 
	CONCAT(first_name, ' ', last_name) AS customer, 
	points, 
	CASE
		WHEN points > 3000 THEN 'Gold'
		WHEN points >=  2000 THEN 'Silver'
		ELSE 'Bronze' 
	END AS category
FROM customers; 
















Views:
------

Creating Views:
---------------

Queries used in this discussion: 

USE sql_invoicing; 

CREATE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name; 



SELECT * 
FROM sales_by_client 
ORDER BY total_sales DESC;


SELECT * 
FROM sales_by_client 
WHERE total_sales > 500;


SELECT * 
FROM sales_by_client 
JOIN clients USING (client_id);



Exercise: 

-- Create a view to see the balance 
-- for each client 
--
-- client_balance 

-- client_id
-- name
-- balance 


CREATE VIEW clients_balance AS 
SELECT 
	c.client_id,
	c.name, 
	SUM(invoice_total - payment_total) AS balance
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;












Altering or Dropping Views:
---------------------------


Queries used in this discussion: 

DROP VIEW sales_by_client; 


CREATE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;


CREATE OR REPLACE VIEW sales_by_client AS
SELECT 
	c.client_id, 
	c.name, 
	SUM(invoice_total) AS total_sales
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id, name;
















Updatable Views:
----------------

Queries and other notes in this discussion: 

-- DISTINCT
-- Aggregate Functions (MIN, MAX, SUM,..) 
-- GROUP BY/ HAVING
-- UNION 


CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
	invoice_id, 
	number, 
	client_id, 
	invoice_total, 
	payment_total, 
	invoice_total - payment_total AS balance, 
	invoice_date, 
	due_date, 
	payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0; 



DELETE FROM invoices_with_balance
WHERE invoice_id = 1;


UPDATE invoices_with_balance
SET due_date = DATE_ADD(due_date, INTERVAL 2 DAY)
WHERE invoice_id = 2; 













The WITH OPTION CHECK Clause: 
-----------------------------

Queries used in this discussion: 

UPDATE invoices_with_balance
SET payment_total = invoice_total 
WHERE invoice_id = 2; 



CREATE OR REPLACE VIEW invoices_with_balance AS
SELECT 
	invoice_id, 
	number, 
	client_id, 
	invoice_total, 
	payment_total, 
	invoice_total - payment_total AS balance, 
	invoice_date, 
	due_date, 
	payment_date
FROM invoices 
WHERE (invoice_total - payment_total) > 0
WITH CHECK OPTION; 












Other Benefits Of Views:
------------------------

Simplify Queries
Reduce the impact of changes
Restrict access to the data 














Stored Procedures:
------------------

Queries and other notes used in this discussion:

Store and organize SQL
Faster execution
Data security











Creating a Stored Procedure:
----------------------------

Queries and other notes used in this discussion:


CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients;
END 



DELIMITER $$
CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients;
END$$ 

DELIMITER ;


CALL get_clients()


Exercise: 
-- create a stored procedure called 
--  get_invoices_with_balance
--  to return all the invoices with a balance > 0


SELECT *
FROM invoices 
WHERE invoice_total - payment_total > 0  


DELIMITER $$
CREATE PROCEDURE get_invoices_with_balance()
BEGIN 
	SELECT * 
	FROM invoices_with_balance
	WHERE balance > 0;  
END$$

DELIMITER ; 













Creating Procedures Using MySQLWorkbench:
-----------------------------------------

Queries and other notes used in this discussion:


Stored Procedures --> Create Stored Procedure 


CREATE PROCEDURE `get_payments` ()
BEGIN 
	SELECT * FROM payments; 
END 




MySQL generates these SQL statements: 

USE `sql_invoicing`;
DROP procedure IF EXISTS `get_payments`;

DELIMITER $$
USE `sql_invoicing`$$
CREATE PROCEDURE `get_payments` ()
BEGIN
	SELECT * FROM payments; 
END$$

DELIMITER ;















Dropping Stored Procedures:
---------------------------

Queries and other notes used in this discussion:

DROP PROCEDURE get_clients

DROP PROCEDURE IF EXISTS get_clients;

DELIMITER $$
CREATE PROCEDURE get_clients()
BEGIN 
	SELECT * FROM clients; 
END$$

DELIMITER ; 











Parameters:
----------

Queries and other notes in this discussion:


DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	SELECT * FROM clients c
	WHERE c.state = state; 
END $$

DELIMITER ;



CALL get_clients_by_state('CA')


Exercise: 

-- Write a stored procedure to return invoices 
-- for a given client 
--
-- get_invoices_by_client 


DROP PROCEDURE IF EXISTS get_invoices_by_client();

DELIMITER$$
CREATE PROCEDURE get_invoices_by_client
(
	client_id INT 
)
BEGIN 
	SELECT * FROM invoices i
	WHERE i.client_id = client_id; 
END $$

DELIMITER ;




















Parameter With Default Value:
-----------------------------

Queries and other notes in this discussion:


DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	IF state IS NULL THEN 
		SET state = 'CA';
	END IF; 
	
	SELECT * FROM clients c
	WHERE c.state = state; 
END $$

DELIMITER ;

CALL get_clients_by_state(NULL)


-- if you want to display all clients of all states 

DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	IF state IS NULL THEN 
		SELECT * FROM clients; 
	ELSE
		SELECT * FROM clients c
		WHERE c.state = state; 
	END IF; 

END $$

DELIMITER ;

CALL get_clients_by_state(NULL)



DROP PROCEDURE IF EXISTS get_clients_by_state();

DELIMITER$$
CREATE PROCEDURE get_clients_by_state
(
	state CHAR(2) 
)
BEGIN 
	SELECT * FROM clients c
	WHERE C.state = IFNULL(state, c.state);   -- if it is null, c.state = c.state, this condition is always true, returns all the rows

END $$

DELIMITER ;

CALL get_clients_by_state(NULL)



EXERCISE: 

-- Write a stored procedure called get_payments
-- with two parameters
--
-- client_id => INT
-- payment_method_id => TINYINT



DROP PROCEDURE IF EXISTS get_payments();

DELIMITER$$
CREATE PROCEDURE get_payments
(
	client_id INT,
	payment_method_id TINYINT
)
BEGIN 
	SELECT *
	FROM payments p
	WHERE 
		p.client_id = IFNULL(client_id, p.client_id) AND 
		p.payment_method  = IFNULL(payment_method_id, p.payment_method_id);

END $$

DELIMITER ;

CALL get_payments(NULL, NULL)

CALL get_payments(5, NULL)

CALL get_payments(NULL, 2)












Parameter Validation:
---------------------

Queries and other notes in this discussion:


USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER$$
CREATE PROCEDURE make_payment
(
	invoice_id INT,
	payment_amount DECIMAL(9,2),
	payment_date DATE
)
BEGIN 
	UPDATE invoices i
	SET 
		i.payment_total = payment_amount,
		i.payment_date = payment_date
	WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;

CALL make_payment(2, 100, '2019-01-01')




USE sql_invoicing;
DROP PROCEDURE IF EXISTS make_payment;

DELIMITER$$
CREATE PROCEDURE make_payment
(
	invoice_id INT,
	payment_amount DECIMAL(9,2),
	payment_date DATE
)
BEGIN 
	IF payment_amount <=  0 THEN 
		SIGNAL SQLSTATE '22003' SET MESSAGE_TEXT = 'Invalid payment amount';
	END IF; 
	
	UPDATE invoices i
	SET 
		i.payment_total = payment_amount,
		i.payment_date = payment_date
	WHERE i.invoice_id = invoice_id;
END $$

DELIMITER ;

CALL make_payment(2, -100, '2019-01-01')



search for sqlstate errors 















Output Parameters: 
------------------


Queries and other notes in this discussion:


DELIMITER$$
CREATE PROCEDURE get_unpaid_invoices_for_client
(
	client_id INT
	OUT invoices_count INT
	OUT invoices_total DECIMAL(9,2)
)
BEGIN 
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total 
	FROM invoices i
	WHERE i.client_id = client_id AND payment_total = 0; 
	
END$$

DELIMITER ;


CALL get_unpaid_invoices_for_client(3); 


set @invoices_count = 0;
set @invoices_total = 0; 

CALL get_unpaid_invoices_for_client(3, @invoices_count, @invoices_total); 

select @invoices_count, @invoices_total;











Variables:
----------

Queries and other notes in this discussion:

-- user or session variables
SET @invoices_count = 0

-- Local variable

CREATE PROCEDURE get_risk_factor()
BEGIN 
-- risk_factor = invoices_total / invoices_count * 5
	DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
	DECLARE invoices_total DECIMAL(9, 2); 
	DECLARE invoices_count INT; 
	
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total
	FROM invoices; 
	
	SET risk_factor = invoices_total / invoices_count * 5; 

	SELECT risk_factor;
END 











Functions:
----------

Queries and other notes in this discussion:

CREATE FUNCTION function_name(param1 datatype, param2 datatype) 
RETURNS return_datatype
DETERMINISTIC   -- Other attributes are READS SQL DATA, MODIFIES SQL DATA 
BEGIN
    -- Function logic here
    RETURN value;
END;


CREATE FUNCTION get_rist_factor_for_client(client_id INT) 
RETURNS INTEGER
READS SQL DATA 
BEGIN
	DECLARE risk_factor DECIMAL(9, 2) DEFAULT 0;
	DECLARE invoices_total DECIMAL(9, 2); 
	DECLARE invoices_count INT; 
	
	SELECT COUNT(*), SUM(invoice_total)
	INTO invoices_count, invoices_total
	FROM invoices i 
	WHERE i.client_id = client_id;
	
	SET risk_factor = invoices_total / invoices_count * 5; 
    RETURN IFNULL(risk_factor, 0);
END;




SELECT 
	client_id, 
	name, 
	get_rist_factor_for_client(client_id) AS risk_factor
FROM clients; 


DROP FUNCTION IF EXISTS get_rist_factor_for_client; 













Other Conventions:
------------------

Queries and other notes in this discussion:

'fn_', 'proc_', 'procGetRiskFactor', 'getRiskFactor', 'get_risk_factor'

DELIMITER $$
DELIMITER //











Triggers and Events:
--------------------


Triggers:
---------

Queries and other notes in this discussion:

A block of SQL code that automatically gets executed before or after an insert, update or delete statement. 

DELIMITER $$

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;
	
	
	
INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2019-01-01', 10, 1);



Exercise: 

-- Create a trigger that gets fired when we 
-- delete a payment. 	



DELIMITER $$

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;


DELETE 
FROM payments 
WHERE payment_id = 10; 










Viewing Triggers:
-----------------

Queries and other notes in this discussion:

SHOW TRIGGERS 

SHOW TRIGGERS LIKE 'payments%'

--table_after_insert    










Dropping Triggers:
------------------

Queries and other notes in this discussion:

DROP TRIGGER IF EXISTS payments_after_insert; 




DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 
END $$

DELIMITER ;




DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
END $$

DELIMITER ;













Using Triggers for Auditing:
----------------------------


USE sql_invoicing; 

CREATE TABLE payments_audit
(
	client_id 		INT 			NOT NULL, 
    date 			DATE 			NOT NULL,
    amount 			DECIMAL(9, 2) 	NOT NULL,
    action_type 	VARCHAR(50) 	NOT NULL,
    action_date 	DATETIME 		NOT NULL
)


DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_insert; 

CREATE TRIGGER payments_after_insert 
	AFTER INSERT ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total + NEW.amount 
	WHERE invoice_id = NEW.invoice_id; 

	INSERT INTO payments_audit 
	VALUES (NEW.client_id, NEW.date, NEW.amount, 'Insert', NOW());
END $$

DELIMITER ;




DELIMITER $$

DROP TRIGGER IF EXISTS payments_after_delete;

CREATE TRIGGER payments_after_delete 
	AFTER DELETE ON payments 
	FOR EACH ROW 
BEGIN
	UPDATE invoices  
	SET payment_total = payment_total - OLD.amount 
	WHERE invoice_id = OLD.invoice_id; 
	
	INSERT INTO payments_audit 
	VALUES (OLD.client_id, OLD.date, OLD.amount, 'Delete', NOW());
END $$

DELIMITER ;


INSERT INTO payments 
VALUES (DEFAULT, 5, 3, '2019-01-01', 10, 1); 



DELETE 
FROM payments 
WHERE payment_id = 11; 

















Events:
-------

Queries and other notes in this discussion:


A task (or block of SQL code) that gets executed according to a schedule

SHOW VARIABLES LIKE 'event%'; 


event_scheduler -- set it to 'ON'

SET GLOBAL event_scheduler = ON; 




DELIMITER $$

CREATE EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
	-- AT '2019-05-01'
	EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
	DELETE FROM payments_audit
	WHERE  action_date < NOW() - INTERVAL 1 YEAR;   -- or DATEADD(NOW(), INTERVAL -1 YEAR) or DATESUB(NOW(), INTERVAL 1 YEAR)
END $$

DELIMITER ;

















Viewing, Dropping and Altering Events:
--------------------------------------

Queries and other notes in this discussion:

SHOW EVENTS; 


SHOW EVENTS LIKE 'yearly%';

DROP EVENT IF EXISTS yearly_delete_stale_audit_rows;



DELIMITER $$

ALTER EVENT yearly_delete_stale_audit_rows 
ON SCHEDULE 
	-- AT '2019-05-01'
	EVERY 1 YEAR STARTS '2019-01-01' ENDS '2029-01-01'
DO BEGIN
	DELETE FROM payments_audit
	WHERE  action_date < NOW() - INTERVAL 1 YEAR;   -- or DATEADD(NOW(), INTERVAL -1 YEAR) or DATESUB(NOW(), INTERVAL 1 YEAR)
END $$

DELIMITER ;  



ALTER EVENT yearly_delete_stale_audit_rows DISABLE; 

ALTER EVENT yearly_delete_stale_audit_rows ENABLE; 




















Transactions and Concurrency:
-----------------------------


Transactions:
-------------

Queries and other notes in this discussion:


A group of SQL statements that represent a single unit of work 


properties of Transactions:(ACID)

Atomicity 
Consistency
Isolation 
Durability













Creating Transactions:
-----------------------

Queries and other notes in this discussion:


USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (Last_INSERT_ID(), 1, 1, 1);

COMMIT; 




USE sql_store;

START TRANSACTION; 

INSERT INTO orders (customer_id, order_date, status)
VALUES(1, '2019-01-01', 1);

INSERT INTO order_items
VALUES (Last_INSERT_ID(), 1, 1, 1);

ROLLBACK;


difference between commit and rollback 


SHOW VARIABLES LIKE 'autocommit';  -- autocommit variable which is set to 'ON' 














Concurrency and Locking:
------------------------


Queries and other notes in this discussion:


connection 1:

USE sql_store;
START TRANSACTION; 
UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;
COMMIT; 


connection 2: 

USE sql_store;
START TRANSACTION; 
UPDATE customers
SET points = points + 10 
WHERE customer_id = 1;
COMMIT; 














Concurrency Problems: 
---------------------


Queries and other notes in this discussion:

Some common concurrency problems:
Lost Updates 
Dirty Reads 
Non-repeating Reads 
Phantom Reads 















Transaction Isolation Levels:
-----------------------------

Queries and other notes in this discussion:


SHOW VARIABLES LIKE 'transaction_isolation'; 

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;








READ UNCOMMITTED Isolation Level: 
---------------------------------

Queries and other notes in this discussion:

connection 1:

USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT points 
FROM customers 
WHERE customer_id = 1; -- reads the uncommitted data which is points = 20


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
COMMIT; 


USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
ROLLBACK;   -- say if we rolls back for some reason, and connection 1 has read it as points as 20 which is not true now 











READ COMMITTED Isolation Level: 
-------------------------------

Queries and other notes in this discussion:

connection 1:

USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT points 
FROM customers 
WHERE customer_id = 1; -- reads only the committed data 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 20
WHERE customer_id = 1; 
COMMIT; 



connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT points FROM customers WHERE customer_id = 1; -- reads 20
SELECT points FROM customers WHERE customer_id = 1; -- reads 30 after we updated the points and committed in connection 2
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 30
WHERE customer_id = 1; 
COMMIT; 


















REPEATABLE READ Isolation Level:
--------------------------------

Queries and other notes in this discussion:


connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT points FROM customers WHERE customer_id = 1; -- reads 30
SELECT points FROM customers WHERE customer_id = 1; -- reads 30, because our reads are repeatable and consistent 
COMMIT; 



connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET points = 40
WHERE customer_id = 1; 
COMMIT; 



problem with phantom reads:
connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM customers WHERE state = 'VA';  -- we won't get to see the customer_id 1
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET state = 'VA'
WHERE customer_id = 1; 
COMMIT; 

















SERIALIZABLE Isolation Level:
-----------------------------

Queries and other notes in this discussion:


connection 1:
USE sql_store; 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM customers WHERE state = 'VA';  -- this transaction should be waiting for the transaction to finish and then reads customers along with customer_id 3 
COMMIT; 


connection 2:
USE sql_store; 
START TRANSACTION;
UPDATE customers 
SET state = 'VA'
WHERE customer_id = 3; 
COMMIT; 















Deadlocks:
----------

Queries and other notes in this discussion:


Session 1:
USE sql_store; 
START TRANSACTION; 
UPDATE customers SET state = 'VA' WHERE customer_id = 1; 
UPDATE orders SET status = 1 WHERE order_id = 1; 
COMMIT; 



Session 2:
USE sql_store; 
START TRANSACTION; 
UPDATE orders SET status = 1 WHERE order_id = 1; 
UPDATE customers SET state = 'VA' WHERE customer_id = 1; 
COMMIT; 














Data Types:
-----------

In MySQL we have several categories of data types. We have String types, Numeric types, Date and Time types, Blob Types for storing binary data, and Spatial Types storing geometric or geographical values. Over the next few lectures, we're going to explore various data types in each category. So, let's get started.




String Types:
-------------

Queries and other notes in this discussion:

CHAR(x) -- fixed length
VARCHAR(x) -- max: 65, 535 characters (~64KB)

VARCHAR(50) for short strings 
VARCHAR(255) for medium-length strings 

MEDIUMTEXT: max: 16MB
LONGTEXT: max: 4GB

TINYTEXT: max: 255 bytes 
TEXT: max: 64KB


Bytes: 
English = 1 byte, 
European, Middle-eastern = 2 bytes
Asian = 3 bytes 











Integer Types:
--------------

Queries and other notes in this discussion:

TINYINT 1b   [-128, 127]
UNSIGNED TINYINT [0, 255]
SMALLINT 2b [-32K, 32K]
MEDIUMINT 3b [-8M, 8M]
INT 4b [-2B, 2B]
BIGINT  8b [-9Z, 9Z]

search for mysql integer types 


Zerofill --> INT(4) => 0001


Use the smallest data type that suits your needs. 













Fixed-point and Floating-point Types:
-------------------------------------

Queries and other notes in this discussion:

DECIMAL(p, s)     DECIMAL(9, 2) => 1234567.89
DEC
NUMERIC
FIXED 

FLOAT  4b
DOUBLE  8b













Boolean Types:
---------------

Queries and other notes in this discussion:

BOOL 

BOOLEAN 

UPDATE posts
SET is_published = 1 










Enum and Set Types:
-------------------

ENUM('small', 'medium', 'large')
SET(...)









Date and Time Types:
--------------------

DATE
TIME
DATETIME  8b
TIMESTAMP 4b (up to 2038)
YEAR

















Blob Types: 
-----------


TINYBLOB      255b
BLOB          65KB
MEDIUM BLOB   16MB
LONGBLOB      4GB


Problems with storing files in database: 

Increased database size
Slower backups
Performance problems 
More code to read/write images









JSON Type:
----------


Queries and other notes in this discussion:

Lightweight format for storing and transferring data over the internet

json
{
 "key" : value
}



UPDATE products 
SET properties = '
{
	"dimensions" : [1, 2, 3],
	"weight": 10
	"manufacturer": { "name" : "sony"}
}
'
WHERE product_id = 1;


in MySQL:
UPDATE products 
SET properties = JSON_OBJECT(
	'weight', 10, 
	'dimensions', JSON_ARRAY(1, 2, 3),
	'manufacturer, JSON_OBJECT('name', 'sony')
)
WHERE product_id = 1;



SELECT product_id, JSON_EXTRACT(properties, '$.weight') AS weight
FROM products
WHERE product_id = 1; 

SELECT product_id, properties -> '$.weight' AS weight  -- '->' column pass operator
FROM products
WHERE product_id = 1; 


SELECT product_id, properties -> '$.dimensions[0]'
FROM products
WHERE product_id = 1; 

SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE product_id = 1; 


SELECT product_id, properties ->> '$.manufacturer.name'
FROM products
WHERE properties ->> '$.manufacturer.name' = 'sony';




UPDATE products 
SET properties = JSON_SET(
	properties,
	'$.weight', 20
	'$.age', 10
)
WHERE product_id = 1;



UPDATE products 
SET properties = JSON_REMOVE(
	properties,
	'$.age'
)
WHERE product_id = 1;
















Designing Databases:

So far we've been writing our queries against existing databases. But as a software engineer or database administrator, there are times when you will need to design a new database from scratch or add new tables to an existing database. And that's what you're going to learn in this section. I'm going to walk you through a simple step-by-step process to design well-structured databases. Remember, a well-designed database requires a bit of planning at the beginning and it may take a bit of time, but it plays a critical role in the success of your applications. If your database is designed properly, you can easily extend it to support new business requirements, you can easily query to extract useful information and your queries will execute quickly. A poorly designed database requires a lot of maintenance and the cost of maintaining it increases over time to the extent that it will eventually prevent you from supporting new business requirements. 
In one of the companies that I worked at, we had a poorly designed database and believe it or not, some of our stored procedures were almost a thousand lines of code because the structure of the database was overly complex. So extracting data was really difficult. Also, some of our queries took several minutes to execute. So in this section, I'm going to walk you through a systematic approach to design well-structured databases. Are you ready? Let's get started.




Data Modelling:
---------------

Queries and other notes in this discussion:

Understand the requirements 
Build a Conceptual Model 
Build a Logical Model 
Build a Physical Model 











Conceptual Models:
------------------

Queries and other notes in this discussion:

Conceptual Model: Represents the entities and their relationships 

Entity Relationship, UML - visually expressing the concepts 

conceptual model - identifying the entities or things or concepts in the business and their relationships with each other. A conceptual model is just a visual representation of these concepts that you use to communicate with the stakeholders so you know you're both on the same page.











Logical Models:
---------------

logical model is independent of database technologies


















Physical Models:
----------------


















Primary Keys:
-------------















Foreign Keys:
-------------

parent or the primary key table, child or the foreign key table 



















Foreign Key Constraints:
------------------------


















Normalization: 
--------------




















1NF-First Normal Form:
----------------------
















Link Tables:
------------









2NF-Second Normal Form:
-----------------------





3NF-Third Normal Form:
----------------------






My Pragmatic Advice:
--------------------





Don't Model the Universe:
-------------------------







Forward Engineering a Model:
----------------------------








Synchronizing a Model with a Database:
--------------------------------------







Reverse Engineering a Database:
-------------------------------








Project: Flight Booking System
------------------------------


Flight Booking System.pdf:
Los Angeles, CA -> San Francisco, CA
San Francisco, CA -> Los Angeles, CA
Fri Apr 05 2019 -> Sun Apr 07 2019
2 Tickets


Airline Confirmation Numbers
Alaska Airline: TAEGKX


Passengers and Ticket Numbers:
John Smith
Ticket Number: 0177200658

Jennifer Smith
Ticket Number: 0178410326





Fri Apr 05
Los Angeles -> San Francisco
LAX -> SFO
08:20 AM - 09:35 AM
Alaska Airlines Flight 1490
1h 15m, 236 miles

Depart: Los Angeles Intl Airport (LAX)
Arrive: San Francisco Intl Airport (SFO)

Economy Class


Sun Apr 07
San Francisco -> Los Angeles
SFO -> LAX
02:00 PM - 03:15 PM
Alaska Airlines Flight 1473
1h 15m, 236 miles

Depart: San Francisco Intl Airport (SFO)
Arrive: Los Angeles Intl Airport (LAX)

Economy Class




Price Summary:
Traveler 1: $357.60
Traveler 2: $357.60
Total:      $756.20













Solution - Conceptual Model:
----------------------------











Solution - Logical Model:
-------------------------










Project - Video Rental Application:
-----------------------------------


Vidly - Requirements:
We’re going to build a desktop application called Vidly. This application will be used at a video rental store. We need different levels of permissions for different users.
The store manager should be able to add/update/delete the list of movies. They will be in charge of setting the stock for each movie as well as the daily rental rate. Cashiers should have a read-only view of the list of movies. They should be able to manage the list of customers and the movies they rent. 

At check out, a customer brings one or more movies. The cashier looks up a customer by their phone number. If the customer is a first-time customer, the cashier asks their full name, email and phone number, and then registers them in the system. The cashier then scans the movies the customer has brought to check out and records them in the system. Each movie has a 10 digit barcode printed on the cover.


When the customer returns to the store, they’ll bring the movies they rented. If a movie is lost, the customer should be charged 5 times the daily rental rate of the movie. The cashier should mark the movie as lost and this will reduce the stock. There is no need to keep track of the lost movies. All we need to know is the the number of movies in stock and how much the customer was charged.


For other movies, the customer should be charged based on the number of days and the daily rental rate.

We issue discount coupons from time to time. The customer can bring a coupon when returning the movies.

It is possible that a customer returns the movies they’ve rented in multiple visits.

We need to be able to track the
- top movies
- top customers
- revenue per day, month and year







Solution - Conceptual Model:
----------------------------











Solution - Logical Model:
-------------------------











Creating and Dropping Databases:
--------------------------------


Queries and other notes in this discussion:

CREATE DATABASE sql_store2; 

CREATE DATABASE IF NOT EXISTS sql_store2; 

DROP DATABASE IF EXISTS sql_store2; 












Creating Tables:
----------------

Queries and other notes in this discussion: 

CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS customers; 
CREATE TABLE customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);


or 


CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);














Altering Tables:
----------------

Queries and other notes in this discussion: 

ALTER TABLE customers 
	ADD last_name VARCHAR(50) NOT NULL AFTER first_name, -- if you have space in between `first name`
	ADD city  VARHCAR(50) NOT NULL, 
	MODIFY COLUMN first_name VARCHAR(255) DEFAULT '', 
	DROP points;












Creating Relationships:
-----------------------

Queries and other notes in this discussion:

CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS customers;
CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders
(
	order_id INT PRIMARY KEY, 
	customer_id INT NOT NULL,
	FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);



CREATE DATABASE IF NOT EXISTS sql_store2; 
USE sql_store2;
DROP TABLE IF EXISTS orders;   -- Since customers table is having relationship with orders table, we are moving the statement before dropping customers table
DROP TABLE IF EXISTS customers;

CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE orders
(
	order_id INT PRIMARY KEY, 
	customer_id INT NOT NULL,
	FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);
















Altering Primary and Foreign Key Constraints:
---------------------------------------------


Queries and other notes in this discussion: 


ALTER TABLE orders
	ADD PRIMARY KEY (order_id), 
	DROP PRIMARY KEY, 
	DROP FOREIGN KEY fk_orders_customers,
	ADD FOREIGN KEY fk_orders_customers (customer_id)
		REFERENCES customers (customer_id)
		ON UPDATE CASCADE
		ON DELETE NO ACTION
);













Character Sets and Collations:
------------------------------

Queries and other notes in this discussion: 

SHOW CHARSET 


CHAR(10) -> 10 x 3 = 30 x 1000000 = 30M



CREATE DATABASE db_name 
	CHARACTER SET latin1;


ALTER DATABASE db_name 
	CHARACTER SET latin1;
	
	
CREATE TABLE table1
(
)
CHARACTER SET latin1;


ALTER TABLE table1
CHARACTER SET latin1; 


CREATE TABLE IF NOT EXISTS customers
(
	customer_id INT PRIMARY KEY AUTO_INCREMENT, 
	first_name VARCHAR(50) CHARACTER SET latin1 NOT NULL,
	points INT NOT NULL DEFAULT 0,
	email VARCHAR(255) NOT NULL UNIQUE
);
















Storage Engines:
----------------

Queries and other notes in this discussion: 

SHOW ENGINES

-- most commonly used storage engines are MyISAM and InnoDB


ALTER TABLE customers
ENGINE = InnoDB 








Indexing for High Performance:
------------------------------

In this section we're going to look at indexing for high performance. Indexes are extremely important in large databases and high traffic websites because they can improve the performance of our queries dramatically. In this section you're going to learn all about indexes, how they work, and how we can create them to speed up our queries. This is a very important topic that every developer and database administrator must learn and understand. Now before we get started, I want you to download and execute the script I've attached to this lecture. With this script, we're going to populate our customers table with a thousand new records so we can see the impact of indexes on our queries. Alright, now let's get started.


use sql_store; 
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Ashlin', 'Bickerdyke', '1970-12-09', '79 Holmberg Parkway', 'Saint Louis', 'MO', 1278);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Mordecai', 'Barltrop', '1970-08-06', '59322 Northridge Street', 'Long Beach', 'CA', 838);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Karoline', 'Gookey', '1975-09-15', '180 Walton Pass', 'New York City', 'NY', 24);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Shelba', 'Pedden', '1956-10-28', '50 Troy Drive', 'Minneapolis', 'MN', 1937);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Leighton', 'Beeble', '1982-02-16', '2562 Northview Circle', 'Cleveland', 'OH', 1824);
insert into customers (first_name, last_name, birth_date, address, city, state, points) values ('Almeria', 'Biddlestone', '1985-04-17', '41 Sunfield Junction', 'Los Angeles', 'CA', 790);
.
.
.

and so on 

















Indexes: 
--------










Creating Indexes:
-----------------

Queries and other notes in this discussion:


SELECT customer_id FROM customers WHERE state = 'CA';
EXPLAIN SELECT customer_id FROM customers WHERE state = 'CA';


CREATE INDEX idx_state ON customers (state);


Exercise: 

-- Write a query to find customers with more than 1000 points 

EXPLAIN SELECT customer_id FROM customers WHERE points > 1000;

CREATE INDEX idx_points ON customers (points);











Viewing Indexes:
----------------

Queries and other notes in this discussion:

SHOW INDEXES IN customers; 

Clustered Index -- having primary key as index 
Secondary Indexes 


ANALYZE TABLE customers; 








Prefix Indexes:
---------------

Queries and other notes in this discussion: 

CREATE INDEX idx_lastname ON customers (last_name(20));


To find the optimal prefix length:

SELECT COUNT(*) FROM customers; 

SELECT COUNT(DISTINCT LEFT(last_name, 1)) FROM customers; 



SELECT 
	COUNT(DISTINCT LEFT(last_name, 1)) 
	COUNT(DISTINCT LEFT(last_name, 5))
	COUNT(DISTINCT LEFT(last_name, 10)) 
FROM customers;
	
	
	
	
	
	
	
	
	
	
	


Full-text Indexes:
------------------	

Queries and other notes in this discussion: 


create-db-blog.sql:

DROP DATABASE IF EXISTS sql_blog;
CREATE DATABASE sql_blog;

USE sql_blog;

CREATE TABLE `posts`
(
  `post_id` int
(11) NOT NULL AUTO_INCREMENT,
  `title` varchar
(255) NOT NULL,
  `body` text NOT NULL,
  `date_published` datetime DEFAULT NULL,
  PRIMARY KEY
(`post_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;


INSERT INTO posts
  (title, body, date_published)
VALUES
  ('Handling a Form in React', 'Web applications often need to send data from browser to the backend server. Certainly, the most used way of doing so is through a HTML form, by using text inputs, radio buttons, checkboxes, selects and so on. This remains true in React. Are you looking how to handle forms in React? If so, this article is a great fit for you. Have a good read.', '2019-01-01'),
  ('What JavaScript Framework You Should Learn to Get a Job in 2019?', 'Are you wondering what JavaScript framework or library you should use to land a job in 2019? In this post, I am going to go over a comparison of the most popular JavaScript frameworks that are available today. By the end of this post, you will be ready to pick the right framework to help you land a front-end developer job in 2019.', '2019-03-02'),
  ('Building an Accessible React Modal Component', 'Modal is an overlay on the web-page, but has some standards to follow. WAI-ARIA Authoring Practices are the standards set by W3C. This lets bots and screen-readers know that it is a modal. It is not within the regular flow of the page. We’ll create an awesome react modal using React components.', '2019-01-15'),
  ('Redux Vs. Mobx – What Should I Pick For My Web App?', 'State management is a hard problem to solve in large applications. Redux and Mobx are both external libraries that are popularly used to solve state management problems.', '2019-02-20'),
  ('Stateful and Stateless Components in React', 'Today, we’re going to review what stateful and stateless components are in React, how you can tell the difference, and the complex process of deciding whether to make components stateful or not.', '2019-03-29');





'react redux' -->
USE sql_blog;
SELECT *
FROM posts
WHERE title LIKE '%react redux%' OR
		body LIKE '%react redux%';
		
		
		
CREATE FULLTEXT INDEX idx_title_body ON posts (title, body);


SELECT *
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');


SELECT *, MATCH(title, body) AGAINST('react redux')  -- relevance score  
FROM posts
WHERE MATCH(title, body) AGAINST('react redux');


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux' IN BOOLEAN MODE);


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('react -redux +form' IN BOOLEAN MODE);


SELECT *, MATCH(title, body) AGAINST('react redux')  
FROM posts
WHERE MATCH(title, body) AGAINST('"handling a form"' IN BOOLEAN MODE);


















Composite Indexes: 
------------------

Queries and other notes in this discussion: 


USE sql_store; 

SHOW INDEXES IN customers; 

EXPLAIN select customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;


CREATE INDEX idx_state_points ON customers (state, points);

EXPLAIN select customer_id FROM customers 
WHERE state = 'CA' AND points > 1000;


DROP INDEX idx_state ON customers; 
DROP INDEX idx_points ON customers; 







Order of Columns in Composite Indexes:
--------------------------------------


Queries and other notes in this discussion: 

order of columns: 
put the most frequently used columns first 
put the columns with a higher cardinality first 

cardinality represents the number of unique values in the index.


SELECT 
	COUNT(DISTINCT state),
	COUNT(DISTINCT last_name)
FROM customers; 


CREATE INDEX idx_lastname_state ON customers (last_name, state);


EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%';  -- 40 rows scanned

CREATE INDEX idx_state_lastname ON customers (state, last_name);


EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'CA' AND last_name LIKE 'A%'; -- 7 rows scanned 


EXPLAIN SELECT customer_id 
FROM customers
WHERE state = 'NY' AND last_name LIKE 'A%';


EXPLAIN SELECT customer_id 
FROM customers
USE INDEX (idx_lastname_state)
WHERE state = 'NY' AND last_name LIKE 'A%';



